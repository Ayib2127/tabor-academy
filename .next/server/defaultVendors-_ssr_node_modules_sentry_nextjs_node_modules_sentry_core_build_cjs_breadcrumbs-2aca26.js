exports.id="defaultVendors-_ssr_node_modules_sentry_nextjs_node_modules_sentry_core_build_cjs_breadcrumbs-2aca26",exports.ids=["defaultVendors-_ssr_node_modules_sentry_nextjs_node_modules_sentry_core_build_cjs_breadcrumbs-2aca26"],exports.modules={"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/api.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst dsn = __webpack_require__(/*! ./utils-hoist/dsn.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/dsn.js\");\n\nconst SENTRY_API_VERSION = '7';\n\n/** Returns the prefix to construct Sentry ingestion API endpoints. */\nfunction getBaseApiEndpoint(dsn) {\n  const protocol = dsn.protocol ? `${dsn.protocol}:` : '';\n  const port = dsn.port ? `:${dsn.port}` : '';\n  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ''}/api/`;\n}\n\n/** Returns the ingest API endpoint for target. */\nfunction _getIngestEndpoint(dsn) {\n  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;\n}\n\n/** Returns a URL-encoded string with auth config suitable for a query string. */\nfunction _encodedAuth(dsn, sdkInfo) {\n  const params = {\n    sentry_version: SENTRY_API_VERSION,\n  };\n\n  if (dsn.publicKey) {\n    // We send only the minimum set of required information. See\n    // https://github.com/getsentry/sentry-javascript/issues/2572.\n    params.sentry_key = dsn.publicKey;\n  }\n\n  if (sdkInfo) {\n    params.sentry_client = `${sdkInfo.name}/${sdkInfo.version}`;\n  }\n\n  return new URLSearchParams(params).toString();\n}\n\n/**\n * Returns the envelope endpoint URL with auth in the query string.\n *\n * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.\n */\nfunction getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel, sdkInfo) {\n  return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;\n}\n\n/** Returns the url to the report dialog endpoint. */\nfunction getReportDialogEndpoint(dsnLike, dialogOptions) {\n  const dsn$1 = dsn.makeDsn(dsnLike);\n  if (!dsn$1) {\n    return '';\n  }\n\n  const endpoint = `${getBaseApiEndpoint(dsn$1)}embed/error-page/`;\n\n  let encodedOptions = `dsn=${dsn.dsnToString(dsn$1)}`;\n  for (const key in dialogOptions) {\n    if (key === 'dsn') {\n      continue;\n    }\n\n    if (key === 'onClose') {\n      continue;\n    }\n\n    if (key === 'user') {\n      const user = dialogOptions.user;\n      if (!user) {\n        continue;\n      }\n      if (user.name) {\n        encodedOptions += `&name=${encodeURIComponent(user.name)}`;\n      }\n      if (user.email) {\n        encodedOptions += `&email=${encodeURIComponent(user.email)}`;\n      }\n    } else {\n      encodedOptions += `&${encodeURIComponent(key)}=${encodeURIComponent(dialogOptions[key] )}`;\n    }\n  }\n\n  return `${endpoint}?${encodedOptions}`;\n}\n\nexports.getEnvelopeEndpointWithUrlEncodedAuth = getEnvelopeEndpointWithUrlEncodedAuth;\nexports.getReportDialogEndpoint = getReportDialogEndpoint;\n//# sourceMappingURL=api.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLFlBQVksbUJBQU8sQ0FBQyx3SEFBc0I7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRCw4QkFBOEIsU0FBUztBQUN2QyxZQUFZLFNBQVMsSUFBSSxTQUFTLEVBQUUsS0FBSyxFQUFFLGVBQWUsU0FBUyxPQUFPO0FBQzFFOztBQUVBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QixFQUFFLGNBQWM7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLGFBQWEsR0FBRyxnQkFBZ0I7QUFDOUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCLEdBQUcsMkJBQTJCO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsMEJBQTBCOztBQUVoRCw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOEJBQThCO0FBQ2pFO0FBQ0E7QUFDQSxvQ0FBb0MsK0JBQStCO0FBQ25FO0FBQ0EsTUFBTTtBQUNOLDRCQUE0Qix3QkFBd0IsR0FBRyx3Q0FBd0M7QUFDL0Y7QUFDQTs7QUFFQSxZQUFZLFNBQVMsR0FBRyxlQUFlO0FBQ3ZDOztBQUVBLDZDQUE2QztBQUM3QywrQkFBK0I7QUFDL0IiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxhcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGRzbiA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvZHNuLmpzJyk7XG5cbmNvbnN0IFNFTlRSWV9BUElfVkVSU0lPTiA9ICc3JztcblxuLyoqIFJldHVybnMgdGhlIHByZWZpeCB0byBjb25zdHJ1Y3QgU2VudHJ5IGluZ2VzdGlvbiBBUEkgZW5kcG9pbnRzLiAqL1xuZnVuY3Rpb24gZ2V0QmFzZUFwaUVuZHBvaW50KGRzbikge1xuICBjb25zdCBwcm90b2NvbCA9IGRzbi5wcm90b2NvbCA/IGAke2Rzbi5wcm90b2NvbH06YCA6ICcnO1xuICBjb25zdCBwb3J0ID0gZHNuLnBvcnQgPyBgOiR7ZHNuLnBvcnR9YCA6ICcnO1xuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2Rzbi5ob3N0fSR7cG9ydH0ke2Rzbi5wYXRoID8gYC8ke2Rzbi5wYXRofWAgOiAnJ30vYXBpL2A7XG59XG5cbi8qKiBSZXR1cm5zIHRoZSBpbmdlc3QgQVBJIGVuZHBvaW50IGZvciB0YXJnZXQuICovXG5mdW5jdGlvbiBfZ2V0SW5nZXN0RW5kcG9pbnQoZHNuKSB7XG4gIHJldHVybiBgJHtnZXRCYXNlQXBpRW5kcG9pbnQoZHNuKX0ke2Rzbi5wcm9qZWN0SWR9L2VudmVsb3BlL2A7XG59XG5cbi8qKiBSZXR1cm5zIGEgVVJMLWVuY29kZWQgc3RyaW5nIHdpdGggYXV0aCBjb25maWcgc3VpdGFibGUgZm9yIGEgcXVlcnkgc3RyaW5nLiAqL1xuZnVuY3Rpb24gX2VuY29kZWRBdXRoKGRzbiwgc2RrSW5mbykge1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgc2VudHJ5X3ZlcnNpb246IFNFTlRSWV9BUElfVkVSU0lPTixcbiAgfTtcblxuICBpZiAoZHNuLnB1YmxpY0tleSkge1xuICAgIC8vIFdlIHNlbmQgb25seSB0aGUgbWluaW11bSBzZXQgb2YgcmVxdWlyZWQgaW5mb3JtYXRpb24uIFNlZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzI1NzIuXG4gICAgcGFyYW1zLnNlbnRyeV9rZXkgPSBkc24ucHVibGljS2V5O1xuICB9XG5cbiAgaWYgKHNka0luZm8pIHtcbiAgICBwYXJhbXMuc2VudHJ5X2NsaWVudCA9IGAke3Nka0luZm8ubmFtZX0vJHtzZGtJbmZvLnZlcnNpb259YDtcbiAgfVxuXG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbnZlbG9wZSBlbmRwb2ludCBVUkwgd2l0aCBhdXRoIGluIHRoZSBxdWVyeSBzdHJpbmcuXG4gKlxuICogU2VuZGluZyBhdXRoIGFzIHBhcnQgb2YgdGhlIHF1ZXJ5IHN0cmluZyBhbmQgbm90IGFzIGN1c3RvbSBIVFRQIGhlYWRlcnMgYXZvaWRzIENPUlMgcHJlZmxpZ2h0IHJlcXVlc3RzLlxuICovXG5mdW5jdGlvbiBnZXRFbnZlbG9wZUVuZHBvaW50V2l0aFVybEVuY29kZWRBdXRoKGRzbiwgdHVubmVsLCBzZGtJbmZvKSB7XG4gIHJldHVybiB0dW5uZWwgPyB0dW5uZWwgOiBgJHtfZ2V0SW5nZXN0RW5kcG9pbnQoZHNuKX0/JHtfZW5jb2RlZEF1dGgoZHNuLCBzZGtJbmZvKX1gO1xufVxuXG4vKiogUmV0dXJucyB0aGUgdXJsIHRvIHRoZSByZXBvcnQgZGlhbG9nIGVuZHBvaW50LiAqL1xuZnVuY3Rpb24gZ2V0UmVwb3J0RGlhbG9nRW5kcG9pbnQoZHNuTGlrZSwgZGlhbG9nT3B0aW9ucykge1xuICBjb25zdCBkc24kMSA9IGRzbi5tYWtlRHNuKGRzbkxpa2UpO1xuICBpZiAoIWRzbiQxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgY29uc3QgZW5kcG9pbnQgPSBgJHtnZXRCYXNlQXBpRW5kcG9pbnQoZHNuJDEpfWVtYmVkL2Vycm9yLXBhZ2UvYDtcblxuICBsZXQgZW5jb2RlZE9wdGlvbnMgPSBgZHNuPSR7ZHNuLmRzblRvU3RyaW5nKGRzbiQxKX1gO1xuICBmb3IgKGNvbnN0IGtleSBpbiBkaWFsb2dPcHRpb25zKSB7XG4gICAgaWYgKGtleSA9PT0gJ2RzbicpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdvbkNsb3NlJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3VzZXInKSB7XG4gICAgICBjb25zdCB1c2VyID0gZGlhbG9nT3B0aW9ucy51c2VyO1xuICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHVzZXIubmFtZSkge1xuICAgICAgICBlbmNvZGVkT3B0aW9ucyArPSBgJm5hbWU9JHtlbmNvZGVVUklDb21wb25lbnQodXNlci5uYW1lKX1gO1xuICAgICAgfVxuICAgICAgaWYgKHVzZXIuZW1haWwpIHtcbiAgICAgICAgZW5jb2RlZE9wdGlvbnMgKz0gYCZlbWFpbD0ke2VuY29kZVVSSUNvbXBvbmVudCh1c2VyLmVtYWlsKX1gO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGVkT3B0aW9ucyArPSBgJiR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KGRpYWxvZ09wdGlvbnNba2V5XSApfWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGAke2VuZHBvaW50fT8ke2VuY29kZWRPcHRpb25zfWA7XG59XG5cbmV4cG9ydHMuZ2V0RW52ZWxvcGVFbmRwb2ludFdpdGhVcmxFbmNvZGVkQXV0aCA9IGdldEVudmVsb3BlRW5kcG9pbnRXaXRoVXJsRW5jb2RlZEF1dGg7XG5leHBvcnRzLmdldFJlcG9ydERpYWxvZ0VuZHBvaW50ID0gZ2V0UmVwb3J0RGlhbG9nRW5kcG9pbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/api.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/asyncContext/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst carrier = __webpack_require__(/*! ../carrier.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/carrier.js");\nconst stackStrategy = __webpack_require__(/*! ./stackStrategy.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/asyncContext/stackStrategy.js");\n\n/**\n * @private Private API with no semver guarantees!\n *\n * Sets the global async context strategy\n */\nfunction setAsyncContextStrategy(strategy) {\n  // Get main carrier (global for every environment)\n  const registry = carrier.getMainCarrier();\n  const sentry = carrier.getSentryCarrier(registry);\n  sentry.acs = strategy;\n}\n\n/**\n * Get the current async context strategy.\n * If none has been setup, the default will be used.\n */\nfunction getAsyncContextStrategy(carrier$1) {\n  const sentry = carrier.getSentryCarrier(carrier$1);\n\n  if (sentry.acs) {\n    return sentry.acs;\n  }\n\n  // Otherwise, use the default one (stack)\n  return stackStrategy.getStackAsyncContextStrategy();\n}\n\nexports.getAsyncContextStrategy = getAsyncContextStrategy;\nexports.setAsyncContextStrategy = setAsyncContextStrategy;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvYXN5bmNDb250ZXh0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLGdCQUFnQixtQkFBTyxDQUFDLHlHQUFlO0FBQ3ZDLHNCQUFzQixtQkFBTyxDQUFDLGlJQUFvQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcYXN5bmNDb250ZXh0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgY2FycmllciA9IHJlcXVpcmUoJy4uL2NhcnJpZXIuanMnKTtcbmNvbnN0IHN0YWNrU3RyYXRlZ3kgPSByZXF1aXJlKCcuL3N0YWNrU3RyYXRlZ3kuanMnKTtcblxuLyoqXG4gKiBAcHJpdmF0ZSBQcml2YXRlIEFQSSB3aXRoIG5vIHNlbXZlciBndWFyYW50ZWVzIVxuICpcbiAqIFNldHMgdGhlIGdsb2JhbCBhc3luYyBjb250ZXh0IHN0cmF0ZWd5XG4gKi9cbmZ1bmN0aW9uIHNldEFzeW5jQ29udGV4dFN0cmF0ZWd5KHN0cmF0ZWd5KSB7XG4gIC8vIEdldCBtYWluIGNhcnJpZXIgKGdsb2JhbCBmb3IgZXZlcnkgZW52aXJvbm1lbnQpXG4gIGNvbnN0IHJlZ2lzdHJ5ID0gY2Fycmllci5nZXRNYWluQ2FycmllcigpO1xuICBjb25zdCBzZW50cnkgPSBjYXJyaWVyLmdldFNlbnRyeUNhcnJpZXIocmVnaXN0cnkpO1xuICBzZW50cnkuYWNzID0gc3RyYXRlZ3k7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGFzeW5jIGNvbnRleHQgc3RyYXRlZ3kuXG4gKiBJZiBub25lIGhhcyBiZWVuIHNldHVwLCB0aGUgZGVmYXVsdCB3aWxsIGJlIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGdldEFzeW5jQ29udGV4dFN0cmF0ZWd5KGNhcnJpZXIkMSkge1xuICBjb25zdCBzZW50cnkgPSBjYXJyaWVyLmdldFNlbnRyeUNhcnJpZXIoY2FycmllciQxKTtcblxuICBpZiAoc2VudHJ5LmFjcykge1xuICAgIHJldHVybiBzZW50cnkuYWNzO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgb25lIChzdGFjaylcbiAgcmV0dXJuIHN0YWNrU3RyYXRlZ3kuZ2V0U3RhY2tBc3luY0NvbnRleHRTdHJhdGVneSgpO1xufVxuXG5leHBvcnRzLmdldEFzeW5jQ29udGV4dFN0cmF0ZWd5ID0gZ2V0QXN5bmNDb250ZXh0U3RyYXRlZ3k7XG5leHBvcnRzLnNldEFzeW5jQ29udGV4dFN0cmF0ZWd5ID0gc2V0QXN5bmNDb250ZXh0U3RyYXRlZ3k7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/asyncContext/index.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/asyncContext/stackStrategy.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst defaultScopes = __webpack_require__(/*! ../defaultScopes.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/defaultScopes.js");\nconst scope = __webpack_require__(/*! ../scope.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/scope.js");\nconst is = __webpack_require__(/*! ../utils-hoist/is.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/is.js");\nconst carrier = __webpack_require__(/*! ../carrier.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/carrier.js");\n\n/**\n * This is an object that holds a stack of scopes.\n */\nclass AsyncContextStack {\n\n   constructor(scope$1, isolationScope) {\n    let assignedScope;\n    if (!scope$1) {\n      assignedScope = new scope.Scope();\n    } else {\n      assignedScope = scope$1;\n    }\n\n    let assignedIsolationScope;\n    if (!isolationScope) {\n      assignedIsolationScope = new scope.Scope();\n    } else {\n      assignedIsolationScope = isolationScope;\n    }\n\n    // scope stack for domains or the process\n    this._stack = [{ scope: assignedScope }];\n    this._isolationScope = assignedIsolationScope;\n  }\n\n  /**\n   * Fork a scope for the stack.\n   */\n   withScope(callback) {\n    const scope = this._pushScope();\n\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback(scope);\n    } catch (e) {\n      this._popScope();\n      throw e;\n    }\n\n    if (is.isThenable(maybePromiseResult)) {\n      // @ts-expect-error - isThenable returns the wrong type\n      return maybePromiseResult.then(\n        res => {\n          this._popScope();\n          return res;\n        },\n        e => {\n          this._popScope();\n          throw e;\n        },\n      );\n    }\n\n    this._popScope();\n    return maybePromiseResult;\n  }\n\n  /**\n   * Get the client of the stack.\n   */\n   getClient() {\n    return this.getStackTop().client ;\n  }\n\n  /**\n   * Returns the scope of the top stack.\n   */\n   getScope() {\n    return this.getStackTop().scope;\n  }\n\n  /**\n   * Get the isolation scope for the stack.\n   */\n   getIsolationScope() {\n    return this._isolationScope;\n  }\n\n  /**\n   * Returns the topmost scope layer in the order domain > local > process.\n   */\n   getStackTop() {\n    return this._stack[this._stack.length - 1] ;\n  }\n\n  /**\n   * Push a scope to the stack.\n   */\n   _pushScope() {\n    // We want to clone the content of prev scope\n    const scope = this.getScope().clone();\n    this._stack.push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * Pop a scope from the stack.\n   */\n   _popScope() {\n    if (this._stack.length <= 1) return false;\n    return !!this._stack.pop();\n  }\n}\n\n/**\n * Get the global async context stack.\n * This will be removed during the v8 cycle and is only here to make migration easier.\n */\nfunction getAsyncContextStack() {\n  const registry = carrier.getMainCarrier();\n  const sentry = carrier.getSentryCarrier(registry);\n\n  return (sentry.stack = sentry.stack || new AsyncContextStack(defaultScopes.getDefaultCurrentScope(), defaultScopes.getDefaultIsolationScope()));\n}\n\nfunction withScope(callback) {\n  return getAsyncContextStack().withScope(callback);\n}\n\nfunction withSetScope(scope, callback) {\n  const stack = getAsyncContextStack() ;\n  return stack.withScope(() => {\n    stack.getStackTop().scope = scope;\n    return callback(scope);\n  });\n}\n\nfunction withIsolationScope(callback) {\n  return getAsyncContextStack().withScope(() => {\n    return callback(getAsyncContextStack().getIsolationScope());\n  });\n}\n\n/**\n * Get the stack-based async context strategy.\n */\nfunction getStackAsyncContextStrategy() {\n  return {\n    withIsolationScope,\n    withScope,\n    withSetScope,\n    withSetIsolationScope: (_isolationScope, callback) => {\n      return withIsolationScope(callback);\n    },\n    getCurrentScope: () => getAsyncContextStack().getScope(),\n    getIsolationScope: () => getAsyncContextStack().getIsolationScope(),\n  };\n}\n\nexports.AsyncContextStack = AsyncContextStack;\nexports.getStackAsyncContextStrategy = getStackAsyncContextStrategy;\n//# sourceMappingURL=stackStrategy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvYXN5bmNDb250ZXh0L3N0YWNrU3RyYXRlZ3kuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsc0JBQXNCLG1CQUFPLENBQUMscUhBQXFCO0FBQ25ELGNBQWMsbUJBQU8sQ0FBQyxxR0FBYTtBQUNuQyxXQUFXLG1CQUFPLENBQUMsdUhBQXNCO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLHlHQUFlOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QixvQ0FBb0M7QUFDcEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxhc3luY0NvbnRleHRcXHN0YWNrU3RyYXRlZ3kuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGRlZmF1bHRTY29wZXMgPSByZXF1aXJlKCcuLi9kZWZhdWx0U2NvcGVzLmpzJyk7XG5jb25zdCBzY29wZSA9IHJlcXVpcmUoJy4uL3Njb3BlLmpzJyk7XG5jb25zdCBpcyA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2lzLmpzJyk7XG5jb25zdCBjYXJyaWVyID0gcmVxdWlyZSgnLi4vY2Fycmllci5qcycpO1xuXG4vKipcbiAqIFRoaXMgaXMgYW4gb2JqZWN0IHRoYXQgaG9sZHMgYSBzdGFjayBvZiBzY29wZXMuXG4gKi9cbmNsYXNzIEFzeW5jQ29udGV4dFN0YWNrIHtcblxuICAgY29uc3RydWN0b3Ioc2NvcGUkMSwgaXNvbGF0aW9uU2NvcGUpIHtcbiAgICBsZXQgYXNzaWduZWRTY29wZTtcbiAgICBpZiAoIXNjb3BlJDEpIHtcbiAgICAgIGFzc2lnbmVkU2NvcGUgPSBuZXcgc2NvcGUuU2NvcGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduZWRTY29wZSA9IHNjb3BlJDE7XG4gICAgfVxuXG4gICAgbGV0IGFzc2lnbmVkSXNvbGF0aW9uU2NvcGU7XG4gICAgaWYgKCFpc29sYXRpb25TY29wZSkge1xuICAgICAgYXNzaWduZWRJc29sYXRpb25TY29wZSA9IG5ldyBzY29wZS5TY29wZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25lZElzb2xhdGlvblNjb3BlID0gaXNvbGF0aW9uU2NvcGU7XG4gICAgfVxuXG4gICAgLy8gc2NvcGUgc3RhY2sgZm9yIGRvbWFpbnMgb3IgdGhlIHByb2Nlc3NcbiAgICB0aGlzLl9zdGFjayA9IFt7IHNjb3BlOiBhc3NpZ25lZFNjb3BlIH1dO1xuICAgIHRoaXMuX2lzb2xhdGlvblNjb3BlID0gYXNzaWduZWRJc29sYXRpb25TY29wZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JrIGEgc2NvcGUgZm9yIHRoZSBzdGFjay5cbiAgICovXG4gICB3aXRoU2NvcGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuX3B1c2hTY29wZSgpO1xuXG4gICAgbGV0IG1heWJlUHJvbWlzZVJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgbWF5YmVQcm9taXNlUmVzdWx0ID0gY2FsbGJhY2soc2NvcGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuX3BvcFNjb3BlKCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChpcy5pc1RoZW5hYmxlKG1heWJlUHJvbWlzZVJlc3VsdCkpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc1RoZW5hYmxlIHJldHVybnMgdGhlIHdyb25nIHR5cGVcbiAgICAgIHJldHVybiBtYXliZVByb21pc2VSZXN1bHQudGhlbihcbiAgICAgICAgcmVzID0+IHtcbiAgICAgICAgICB0aGlzLl9wb3BTY29wZSgpO1xuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGUgPT4ge1xuICAgICAgICAgIHRoaXMuX3BvcFNjb3BlKCk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fcG9wU2NvcGUoKTtcbiAgICByZXR1cm4gbWF5YmVQcm9taXNlUmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY2xpZW50IG9mIHRoZSBzdGFjay5cbiAgICovXG4gICBnZXRDbGllbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2tUb3AoKS5jbGllbnQgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjb3BlIG9mIHRoZSB0b3Agc3RhY2suXG4gICAqL1xuICAgZ2V0U2NvcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2tUb3AoKS5zY29wZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGlzb2xhdGlvbiBzY29wZSBmb3IgdGhlIHN0YWNrLlxuICAgKi9cbiAgIGdldElzb2xhdGlvblNjb3BlKCkge1xuICAgIHJldHVybiB0aGlzLl9pc29sYXRpb25TY29wZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3Btb3N0IHNjb3BlIGxheWVyIGluIHRoZSBvcmRlciBkb21haW4gPiBsb2NhbCA+IHByb2Nlc3MuXG4gICAqL1xuICAgZ2V0U3RhY2tUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrW3RoaXMuX3N0YWNrLmxlbmd0aCAtIDFdIDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIGEgc2NvcGUgdG8gdGhlIHN0YWNrLlxuICAgKi9cbiAgIF9wdXNoU2NvcGUoKSB7XG4gICAgLy8gV2Ugd2FudCB0byBjbG9uZSB0aGUgY29udGVudCBvZiBwcmV2IHNjb3BlXG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLmdldFNjb3BlKCkuY2xvbmUoKTtcbiAgICB0aGlzLl9zdGFjay5wdXNoKHtcbiAgICAgIGNsaWVudDogdGhpcy5nZXRDbGllbnQoKSxcbiAgICAgIHNjb3BlLFxuICAgIH0pO1xuICAgIHJldHVybiBzY29wZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3AgYSBzY29wZSBmcm9tIHRoZSBzdGFjay5cbiAgICovXG4gICBfcG9wU2NvcGUoKSB7XG4gICAgaWYgKHRoaXMuX3N0YWNrLmxlbmd0aCA8PSAxKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICEhdGhpcy5fc3RhY2sucG9wKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIGdsb2JhbCBhc3luYyBjb250ZXh0IHN0YWNrLlxuICogVGhpcyB3aWxsIGJlIHJlbW92ZWQgZHVyaW5nIHRoZSB2OCBjeWNsZSBhbmQgaXMgb25seSBoZXJlIHRvIG1ha2UgbWlncmF0aW9uIGVhc2llci5cbiAqL1xuZnVuY3Rpb24gZ2V0QXN5bmNDb250ZXh0U3RhY2soKSB7XG4gIGNvbnN0IHJlZ2lzdHJ5ID0gY2Fycmllci5nZXRNYWluQ2FycmllcigpO1xuICBjb25zdCBzZW50cnkgPSBjYXJyaWVyLmdldFNlbnRyeUNhcnJpZXIocmVnaXN0cnkpO1xuXG4gIHJldHVybiAoc2VudHJ5LnN0YWNrID0gc2VudHJ5LnN0YWNrIHx8IG5ldyBBc3luY0NvbnRleHRTdGFjayhkZWZhdWx0U2NvcGVzLmdldERlZmF1bHRDdXJyZW50U2NvcGUoKSwgZGVmYXVsdFNjb3Blcy5nZXREZWZhdWx0SXNvbGF0aW9uU2NvcGUoKSkpO1xufVxuXG5mdW5jdGlvbiB3aXRoU2NvcGUoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGdldEFzeW5jQ29udGV4dFN0YWNrKCkud2l0aFNjb3BlKGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gd2l0aFNldFNjb3BlKHNjb3BlLCBjYWxsYmFjaykge1xuICBjb25zdCBzdGFjayA9IGdldEFzeW5jQ29udGV4dFN0YWNrKCkgO1xuICByZXR1cm4gc3RhY2sud2l0aFNjb3BlKCgpID0+IHtcbiAgICBzdGFjay5nZXRTdGFja1RvcCgpLnNjb3BlID0gc2NvcGU7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHNjb3BlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhJc29sYXRpb25TY29wZShjYWxsYmFjaykge1xuICByZXR1cm4gZ2V0QXN5bmNDb250ZXh0U3RhY2soKS53aXRoU2NvcGUoKCkgPT4ge1xuICAgIHJldHVybiBjYWxsYmFjayhnZXRBc3luY0NvbnRleHRTdGFjaygpLmdldElzb2xhdGlvblNjb3BlKCkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHN0YWNrLWJhc2VkIGFzeW5jIGNvbnRleHQgc3RyYXRlZ3kuXG4gKi9cbmZ1bmN0aW9uIGdldFN0YWNrQXN5bmNDb250ZXh0U3RyYXRlZ3koKSB7XG4gIHJldHVybiB7XG4gICAgd2l0aElzb2xhdGlvblNjb3BlLFxuICAgIHdpdGhTY29wZSxcbiAgICB3aXRoU2V0U2NvcGUsXG4gICAgd2l0aFNldElzb2xhdGlvblNjb3BlOiAoX2lzb2xhdGlvblNjb3BlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgcmV0dXJuIHdpdGhJc29sYXRpb25TY29wZShjYWxsYmFjayk7XG4gICAgfSxcbiAgICBnZXRDdXJyZW50U2NvcGU6ICgpID0+IGdldEFzeW5jQ29udGV4dFN0YWNrKCkuZ2V0U2NvcGUoKSxcbiAgICBnZXRJc29sYXRpb25TY29wZTogKCkgPT4gZ2V0QXN5bmNDb250ZXh0U3RhY2soKS5nZXRJc29sYXRpb25TY29wZSgpLFxuICB9O1xufVxuXG5leHBvcnRzLkFzeW5jQ29udGV4dFN0YWNrID0gQXN5bmNDb250ZXh0U3RhY2s7XG5leHBvcnRzLmdldFN0YWNrQXN5bmNDb250ZXh0U3RyYXRlZ3kgPSBnZXRTdGFja0FzeW5jQ29udGV4dFN0cmF0ZWd5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhY2tTdHJhdGVneS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/asyncContext/stackStrategy.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/breadcrumbs.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js");\nconst time = __webpack_require__(/*! ./utils-hoist/time.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/time.js");\n\n/**\n * Default maximum number of breadcrumbs added to an event. Can be overwritten\n * with {@link Options.maxBreadcrumbs}.\n */\nconst DEFAULT_BREADCRUMBS = 100;\n\n/**\n * Records a new breadcrumb which will be attached to future events.\n *\n * Breadcrumbs will be added to subsequent events to provide more context on\n * user\'s actions prior to an error or crash.\n */\nfunction addBreadcrumb(breadcrumb, hint) {\n  const client = currentScopes.getClient();\n  const isolationScope = currentScopes.getIsolationScope();\n\n  if (!client) return;\n\n  const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions();\n\n  if (maxBreadcrumbs <= 0) return;\n\n  const timestamp = time.dateTimestampInSeconds();\n  const mergedBreadcrumb = { timestamp, ...breadcrumb };\n  const finalBreadcrumb = beforeBreadcrumb\n    ? (logger.consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) )\n    : mergedBreadcrumb;\n\n  if (finalBreadcrumb === null) return;\n\n  if (client.emit) {\n    client.emit(\'beforeAddBreadcrumb\', finalBreadcrumb, hint);\n  }\n\n  isolationScope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);\n}\n\nexports.addBreadcrumb = addBreadcrumb;\n//# sourceMappingURL=breadcrumbs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvYnJlYWRjcnVtYnMuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsc0JBQXNCLG1CQUFPLENBQUMsb0hBQW9CO0FBQ2xELGVBQWUsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLDBIQUF1Qjs7QUFFNUM7QUFDQTtBQUNBLFNBQVMsNkJBQTZCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsZ0VBQWdFOztBQUUxRTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcYnJlYWRjcnVtYnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuL2N1cnJlbnRTY29wZXMuanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCB0aW1lID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC90aW1lLmpzJyk7XG5cbi8qKlxuICogRGVmYXVsdCBtYXhpbXVtIG51bWJlciBvZiBicmVhZGNydW1icyBhZGRlZCB0byBhbiBldmVudC4gQ2FuIGJlIG92ZXJ3cml0dGVuXG4gKiB3aXRoIHtAbGluayBPcHRpb25zLm1heEJyZWFkY3J1bWJzfS5cbiAqL1xuY29uc3QgREVGQVVMVF9CUkVBRENSVU1CUyA9IDEwMDtcblxuLyoqXG4gKiBSZWNvcmRzIGEgbmV3IGJyZWFkY3J1bWIgd2hpY2ggd2lsbCBiZSBhdHRhY2hlZCB0byBmdXR1cmUgZXZlbnRzLlxuICpcbiAqIEJyZWFkY3J1bWJzIHdpbGwgYmUgYWRkZWQgdG8gc3Vic2VxdWVudCBldmVudHMgdG8gcHJvdmlkZSBtb3JlIGNvbnRleHQgb25cbiAqIHVzZXIncyBhY3Rpb25zIHByaW9yIHRvIGFuIGVycm9yIG9yIGNyYXNoLlxuICovXG5mdW5jdGlvbiBhZGRCcmVhZGNydW1iKGJyZWFkY3J1bWIsIGhpbnQpIHtcbiAgY29uc3QgY2xpZW50ID0gY3VycmVudFNjb3Blcy5nZXRDbGllbnQoKTtcbiAgY29uc3QgaXNvbGF0aW9uU2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldElzb2xhdGlvblNjb3BlKCk7XG5cbiAgaWYgKCFjbGllbnQpIHJldHVybjtcblxuICBjb25zdCB7IGJlZm9yZUJyZWFkY3J1bWIgPSBudWxsLCBtYXhCcmVhZGNydW1icyA9IERFRkFVTFRfQlJFQURDUlVNQlMgfSA9IGNsaWVudC5nZXRPcHRpb25zKCk7XG5cbiAgaWYgKG1heEJyZWFkY3J1bWJzIDw9IDApIHJldHVybjtcblxuICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lLmRhdGVUaW1lc3RhbXBJblNlY29uZHMoKTtcbiAgY29uc3QgbWVyZ2VkQnJlYWRjcnVtYiA9IHsgdGltZXN0YW1wLCAuLi5icmVhZGNydW1iIH07XG4gIGNvbnN0IGZpbmFsQnJlYWRjcnVtYiA9IGJlZm9yZUJyZWFkY3J1bWJcbiAgICA/IChsb2dnZXIuY29uc29sZVNhbmRib3goKCkgPT4gYmVmb3JlQnJlYWRjcnVtYihtZXJnZWRCcmVhZGNydW1iLCBoaW50KSkgKVxuICAgIDogbWVyZ2VkQnJlYWRjcnVtYjtcblxuICBpZiAoZmluYWxCcmVhZGNydW1iID09PSBudWxsKSByZXR1cm47XG5cbiAgaWYgKGNsaWVudC5lbWl0KSB7XG4gICAgY2xpZW50LmVtaXQoJ2JlZm9yZUFkZEJyZWFkY3J1bWInLCBmaW5hbEJyZWFkY3J1bWIsIGhpbnQpO1xuICB9XG5cbiAgaXNvbGF0aW9uU2NvcGUuYWRkQnJlYWRjcnVtYihmaW5hbEJyZWFkY3J1bWIsIG1heEJyZWFkY3J1bWJzKTtcbn1cblxuZXhwb3J0cy5hZGRCcmVhZGNydW1iID0gYWRkQnJlYWRjcnVtYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyZWFkY3J1bWJzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/breadcrumbs.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/carrier.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst version = __webpack_require__(/*! ./utils-hoist/version.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/version.js");\nconst worldwide = __webpack_require__(/*! ./utils-hoist/worldwide.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js");\n\n/**\n * An object that contains globally accessible properties and maintains a scope stack.\n * @hidden\n */\n\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/\nfunction getMainCarrier() {\n  // This ensures a Sentry carrier exists\n  getSentryCarrier(worldwide.GLOBAL_OBJ);\n  return worldwide.GLOBAL_OBJ;\n}\n\n/** Will either get the existing sentry carrier, or create a new one. */\nfunction getSentryCarrier(carrier) {\n  const __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});\n\n  // For now: First SDK that sets the .version property wins\n  __SENTRY__.version = __SENTRY__.version || version.SDK_VERSION;\n\n  // Intentionally populating and returning the version of "this" SDK instance\n  // rather than what\'s set in .version so that "this" SDK always gets its carrier\n  return (__SENTRY__[version.SDK_VERSION] = __SENTRY__[version.SDK_VERSION] || {});\n}\n\n/**\n * Returns a global singleton contained in the global `__SENTRY__[]` object.\n *\n * If the singleton doesn\'t already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn\'t already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `GLOBAL_OBJ`\'s return value\n * @returns the singleton\n */\nfunction getGlobalSingleton(\n  name,\n  creator,\n  obj = worldwide.GLOBAL_OBJ,\n) {\n  const __SENTRY__ = (obj.__SENTRY__ = obj.__SENTRY__ || {});\n  const carrier = (__SENTRY__[version.SDK_VERSION] = __SENTRY__[version.SDK_VERSION] || {});\n  // Note: We do not want to set `carrier.version` here, as this may be called before any `init` is called, e.g. for the default scopes\n  return carrier[name] || (carrier[name] = creator());\n}\n\nexports.getGlobalSingleton = getGlobalSingleton;\nexports.getMainCarrier = getMainCarrier;\nexports.getSentryCarrier = getSentryCarrier;\n//# sourceMappingURL=carrier.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvY2Fycmllci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxnQkFBZ0IsbUJBQU8sQ0FBQyxnSUFBMEI7QUFDbEQsa0JBQWtCLG1CQUFPLENBQUMsb0lBQTRCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxjYXJyaWVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCB2ZXJzaW9uID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC92ZXJzaW9uLmpzJyk7XG5jb25zdCB3b3JsZHdpZGUgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3dvcmxkd2lkZS5qcycpO1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGdsb2JhbGx5IGFjY2Vzc2libGUgcHJvcGVydGllcyBhbmQgbWFpbnRhaW5zIGEgc2NvcGUgc3RhY2suXG4gKiBAaGlkZGVuXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnbG9iYWwgc2hpbSByZWdpc3RyeS5cbiAqXG4gKiBGSVhNRTogVGhpcyBmdW5jdGlvbiBpcyBwcm9ibGVtYXRpYywgYmVjYXVzZSBkZXNwaXRlIGFsd2F5cyByZXR1cm5pbmcgYSB2YWxpZCBDYXJyaWVyLFxuICogaXQgaGFzIGFuIG9wdGlvbmFsIGBfX1NFTlRSWV9fYCBwcm9wZXJ0eSwgd2hpY2ggdGhlbiBpbiB0dXJuIHJlcXVpcmVzIHVzIHRvIGFsd2F5cyBwZXJmb3JtIGFuIHVubmVjZXNzYXJ5IGNoZWNrXG4gKiBhdCB0aGUgY2FsbC1zaXRlLiBXZSBhbHdheXMgYWNjZXNzIHRoZSBjYXJyaWVyIHRocm91Z2ggdGhpcyBmdW5jdGlvbiwgc28gd2UgY2FuIGd1YXJhbnRlZSB0aGF0IGBfX1NFTlRSWV9fYCBpcyB0aGVyZS5cbiAqKi9cbmZ1bmN0aW9uIGdldE1haW5DYXJyaWVyKCkge1xuICAvLyBUaGlzIGVuc3VyZXMgYSBTZW50cnkgY2FycmllciBleGlzdHNcbiAgZ2V0U2VudHJ5Q2Fycmllcih3b3JsZHdpZGUuR0xPQkFMX09CSik7XG4gIHJldHVybiB3b3JsZHdpZGUuR0xPQkFMX09CSjtcbn1cblxuLyoqIFdpbGwgZWl0aGVyIGdldCB0aGUgZXhpc3Rpbmcgc2VudHJ5IGNhcnJpZXIsIG9yIGNyZWF0ZSBhIG5ldyBvbmUuICovXG5mdW5jdGlvbiBnZXRTZW50cnlDYXJyaWVyKGNhcnJpZXIpIHtcbiAgY29uc3QgX19TRU5UUllfXyA9IChjYXJyaWVyLl9fU0VOVFJZX18gPSBjYXJyaWVyLl9fU0VOVFJZX18gfHwge30pO1xuXG4gIC8vIEZvciBub3c6IEZpcnN0IFNESyB0aGF0IHNldHMgdGhlIC52ZXJzaW9uIHByb3BlcnR5IHdpbnNcbiAgX19TRU5UUllfXy52ZXJzaW9uID0gX19TRU5UUllfXy52ZXJzaW9uIHx8IHZlcnNpb24uU0RLX1ZFUlNJT047XG5cbiAgLy8gSW50ZW50aW9uYWxseSBwb3B1bGF0aW5nIGFuZCByZXR1cm5pbmcgdGhlIHZlcnNpb24gb2YgXCJ0aGlzXCIgU0RLIGluc3RhbmNlXG4gIC8vIHJhdGhlciB0aGFuIHdoYXQncyBzZXQgaW4gLnZlcnNpb24gc28gdGhhdCBcInRoaXNcIiBTREsgYWx3YXlzIGdldHMgaXRzIGNhcnJpZXJcbiAgcmV0dXJuIChfX1NFTlRSWV9fW3ZlcnNpb24uU0RLX1ZFUlNJT05dID0gX19TRU5UUllfX1t2ZXJzaW9uLlNES19WRVJTSU9OXSB8fCB7fSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGdsb2JhbCBzaW5nbGV0b24gY29udGFpbmVkIGluIHRoZSBnbG9iYWwgYF9fU0VOVFJZX19bXWAgb2JqZWN0LlxuICpcbiAqIElmIHRoZSBzaW5nbGV0b24gZG9lc24ndCBhbHJlYWR5IGV4aXN0IGluIGBfX1NFTlRSWV9fYCwgaXQgd2lsbCBiZSBjcmVhdGVkIHVzaW5nIHRoZSBnaXZlbiBmYWN0b3J5XG4gKiBmdW5jdGlvbiBhbmQgYWRkZWQgdG8gdGhlIGBfX1NFTlRSWV9fYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIG5hbWUgbmFtZSBvZiB0aGUgZ2xvYmFsIHNpbmdsZXRvbiBvbiBfX1NFTlRSWV9fXG4gKiBAcGFyYW0gY3JlYXRvciBjcmVhdG9yIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBzaW5nbGV0b24gaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0IG9uIGBfX1NFTlRSWV9fYFxuICogQHBhcmFtIG9iaiAoT3B0aW9uYWwpIFRoZSBnbG9iYWwgb2JqZWN0IG9uIHdoaWNoIHRvIGxvb2sgZm9yIGBfX1NFTlRSWV9fYCwgaWYgbm90IGBHTE9CQUxfT0JKYCdzIHJldHVybiB2YWx1ZVxuICogQHJldHVybnMgdGhlIHNpbmdsZXRvblxuICovXG5mdW5jdGlvbiBnZXRHbG9iYWxTaW5nbGV0b24oXG4gIG5hbWUsXG4gIGNyZWF0b3IsXG4gIG9iaiA9IHdvcmxkd2lkZS5HTE9CQUxfT0JKLFxuKSB7XG4gIGNvbnN0IF9fU0VOVFJZX18gPSAob2JqLl9fU0VOVFJZX18gPSBvYmouX19TRU5UUllfXyB8fCB7fSk7XG4gIGNvbnN0IGNhcnJpZXIgPSAoX19TRU5UUllfX1t2ZXJzaW9uLlNES19WRVJTSU9OXSA9IF9fU0VOVFJZX19bdmVyc2lvbi5TREtfVkVSU0lPTl0gfHwge30pO1xuICAvLyBOb3RlOiBXZSBkbyBub3Qgd2FudCB0byBzZXQgYGNhcnJpZXIudmVyc2lvbmAgaGVyZSwgYXMgdGhpcyBtYXkgYmUgY2FsbGVkIGJlZm9yZSBhbnkgYGluaXRgIGlzIGNhbGxlZCwgZS5nLiBmb3IgdGhlIGRlZmF1bHQgc2NvcGVzXG4gIHJldHVybiBjYXJyaWVyW25hbWVdIHx8IChjYXJyaWVyW25hbWVdID0gY3JlYXRvcigpKTtcbn1cblxuZXhwb3J0cy5nZXRHbG9iYWxTaW5nbGV0b24gPSBnZXRHbG9iYWxTaW5nbGV0b247XG5leHBvcnRzLmdldE1haW5DYXJyaWVyID0gZ2V0TWFpbkNhcnJpZXI7XG5leHBvcnRzLmdldFNlbnRyeUNhcnJpZXIgPSBnZXRTZW50cnlDYXJyaWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2Fycmllci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/carrier.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/checkin.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst dsn = __webpack_require__(/*! ./utils-hoist/dsn.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/dsn.js\");\nconst envelope = __webpack_require__(/*! ./utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\n\n/**\n * Create envelope from check in item.\n */\nfunction createCheckInEnvelope(\n  checkIn,\n  dynamicSamplingContext,\n  metadata,\n  tunnel,\n  dsn$1,\n) {\n  const headers = {\n    sent_at: new Date().toISOString(),\n  };\n\n  if (metadata?.sdk) {\n    headers.sdk = {\n      name: metadata.sdk.name,\n      version: metadata.sdk.version,\n    };\n  }\n\n  if (!!tunnel && !!dsn$1) {\n    headers.dsn = dsn.dsnToString(dsn$1);\n  }\n\n  if (dynamicSamplingContext) {\n    headers.trace = dynamicSamplingContext ;\n  }\n\n  const item = createCheckInEnvelopeItem(checkIn);\n  return envelope.createEnvelope(headers, [item]);\n}\n\nfunction createCheckInEnvelopeItem(checkIn) {\n  const checkInHeaders = {\n    type: 'check_in',\n  };\n  return [checkInHeaders, checkIn];\n}\n\nexports.createCheckInEnvelope = createCheckInEnvelope;\n//# sourceMappingURL=checkin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvY2hlY2tpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxZQUFZLG1CQUFPLENBQUMsd0hBQXNCO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLGtJQUEyQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxjaGVja2luLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBkc24gPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2Rzbi5qcycpO1xuY29uc3QgZW52ZWxvcGUgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2VudmVsb3BlLmpzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGVudmVsb3BlIGZyb20gY2hlY2sgaW4gaXRlbS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hlY2tJbkVudmVsb3BlKFxuICBjaGVja0luLFxuICBkeW5hbWljU2FtcGxpbmdDb250ZXh0LFxuICBtZXRhZGF0YSxcbiAgdHVubmVsLFxuICBkc24kMSxcbikge1xuICBjb25zdCBoZWFkZXJzID0ge1xuICAgIHNlbnRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgfTtcblxuICBpZiAobWV0YWRhdGE/LnNkaykge1xuICAgIGhlYWRlcnMuc2RrID0ge1xuICAgICAgbmFtZTogbWV0YWRhdGEuc2RrLm5hbWUsXG4gICAgICB2ZXJzaW9uOiBtZXRhZGF0YS5zZGsudmVyc2lvbixcbiAgICB9O1xuICB9XG5cbiAgaWYgKCEhdHVubmVsICYmICEhZHNuJDEpIHtcbiAgICBoZWFkZXJzLmRzbiA9IGRzbi5kc25Ub1N0cmluZyhkc24kMSk7XG4gIH1cblxuICBpZiAoZHluYW1pY1NhbXBsaW5nQ29udGV4dCkge1xuICAgIGhlYWRlcnMudHJhY2UgPSBkeW5hbWljU2FtcGxpbmdDb250ZXh0IDtcbiAgfVxuXG4gIGNvbnN0IGl0ZW0gPSBjcmVhdGVDaGVja0luRW52ZWxvcGVJdGVtKGNoZWNrSW4pO1xuICByZXR1cm4gZW52ZWxvcGUuY3JlYXRlRW52ZWxvcGUoaGVhZGVycywgW2l0ZW1dKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2hlY2tJbkVudmVsb3BlSXRlbShjaGVja0luKSB7XG4gIGNvbnN0IGNoZWNrSW5IZWFkZXJzID0ge1xuICAgIHR5cGU6ICdjaGVja19pbicsXG4gIH07XG4gIHJldHVybiBbY2hlY2tJbkhlYWRlcnMsIGNoZWNrSW5dO1xufVxuXG5leHBvcnRzLmNyZWF0ZUNoZWNrSW5FbnZlbG9wZSA9IGNyZWF0ZUNoZWNrSW5FbnZlbG9wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNraW4uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/checkin.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/client.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst api = __webpack_require__(/*! ./api.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/api.js\");\nconst constants = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/constants.js\");\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst envelope = __webpack_require__(/*! ./envelope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/envelope.js\");\nconst integration = __webpack_require__(/*! ./integration.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\");\nconst session = __webpack_require__(/*! ./session.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/session.js\");\nconst dynamicSamplingContext = __webpack_require__(/*! ./tracing/dynamicSamplingContext.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js\");\nconst eventUtils = __webpack_require__(/*! ./utils/eventUtils.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/eventUtils.js\");\nconst merge = __webpack_require__(/*! ./utils/merge.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/merge.js\");\nconst parseSampleRate = __webpack_require__(/*! ./utils/parseSampleRate.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/parseSampleRate.js\");\nconst prepareEvent = __webpack_require__(/*! ./utils/prepareEvent.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/prepareEvent.js\");\nconst spanUtils = __webpack_require__(/*! ./utils/spanUtils.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanUtils.js\");\nconst transactionEvent = __webpack_require__(/*! ./utils/transactionEvent.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/transactionEvent.js\");\nconst clientreport = __webpack_require__(/*! ./utils-hoist/clientreport.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/clientreport.js\");\nconst dsn = __webpack_require__(/*! ./utils-hoist/dsn.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/dsn.js\");\nconst envelope$1 = __webpack_require__(/*! ./utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\nconst is = __webpack_require__(/*! ./utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst misc = __webpack_require__(/*! ./utils-hoist/misc.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js\");\nconst syncpromise = __webpack_require__(/*! ./utils-hoist/syncpromise.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/syncpromise.js\");\n\n/* eslint-disable max-lines */\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\nconst MISSING_RELEASE_FOR_SESSION_ERROR = 'Discarded session because of missing or non-string release';\n\nconst INTERNAL_ERROR_SYMBOL = Symbol.for('SentryInternalError');\nconst DO_NOT_SEND_EVENT_SYMBOL = Symbol.for('SentryDoNotSendEventError');\n\nfunction _makeInternalError(message) {\n  return {\n    message,\n    [INTERNAL_ERROR_SYMBOL]: true,\n  };\n}\n\nfunction _makeDoNotSendEventError(message) {\n  return {\n    message,\n    [DO_NOT_SEND_EVENT_SYMBOL]: true,\n  };\n}\n\nfunction _isInternalError(error) {\n  return !!error && typeof error === 'object' && INTERNAL_ERROR_SYMBOL in error;\n}\n\nfunction _isDoNotSendEventError(error) {\n  return !!error && typeof error === 'object' && DO_NOT_SEND_EVENT_SYMBOL in error;\n}\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link Client._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends Client<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nclass Client {\n  /** Options passed to the SDK. */\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n\n  /** Array of set up integrations. */\n\n  /** Number of calls being processed */\n\n  /** Holds flushable  */\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n   constructor(options) {\n    this._options = options;\n    this._integrations = {};\n    this._numProcessing = 0;\n    this._outcomes = {};\n    this._hooks = {};\n    this._eventProcessors = [];\n\n    if (options.dsn) {\n      this._dsn = dsn.makeDsn(options.dsn);\n    } else {\n      debugBuild.DEBUG_BUILD && logger.logger.warn('No DSN provided, client will not send events.');\n    }\n\n    if (this._dsn) {\n      const url = api.getEnvelopeEndpointWithUrlEncodedAuth(\n        this._dsn,\n        options.tunnel,\n        options._metadata ? options._metadata.sdk : undefined,\n      );\n      this._transport = options.transport({\n        tunnel: this._options.tunnel,\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url,\n      });\n    }\n  }\n\n  /**\n   * Captures an exception event and sends it to Sentry.\n   *\n   * Unlike `captureException` exported from every SDK, this method requires that you pass it the current scope.\n   */\n   captureException(exception, hint, scope) {\n    const eventId = misc.uuid4();\n\n    // ensure we haven't captured this very object before\n    if (misc.checkOrSetAlreadyCaught(exception)) {\n      debugBuild.DEBUG_BUILD && logger.logger.log(ALREADY_SEEN_ERROR);\n      return eventId;\n    }\n\n    const hintWithEventId = {\n      event_id: eventId,\n      ...hint,\n    };\n\n    this._process(\n      this.eventFromException(exception, hintWithEventId).then(event =>\n        this._captureEvent(event, hintWithEventId, scope),\n      ),\n    );\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a message event and sends it to Sentry.\n   *\n   * Unlike `captureMessage` exported from every SDK, this method requires that you pass it the current scope.\n   */\n   captureMessage(\n    message,\n    level,\n    hint,\n    currentScope,\n  ) {\n    const hintWithEventId = {\n      event_id: misc.uuid4(),\n      ...hint,\n    };\n\n    const eventMessage = is.isParameterizedString(message) ? message : String(message);\n\n    const promisedEvent = is.isPrimitive(message)\n      ? this.eventFromMessage(eventMessage, level, hintWithEventId)\n      : this.eventFromException(message, hintWithEventId);\n\n    this._process(promisedEvent.then(event => this._captureEvent(event, hintWithEventId, currentScope)));\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a manually created event and sends it to Sentry.\n   *\n   * Unlike `captureEvent` exported from every SDK, this method requires that you pass it the current scope.\n   */\n   captureEvent(event, hint, currentScope) {\n    const eventId = misc.uuid4();\n\n    // ensure we haven't captured this very object before\n    if (hint?.originalException && misc.checkOrSetAlreadyCaught(hint.originalException)) {\n      debugBuild.DEBUG_BUILD && logger.logger.log(ALREADY_SEEN_ERROR);\n      return eventId;\n    }\n\n    const hintWithEventId = {\n      event_id: eventId,\n      ...hint,\n    };\n\n    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n    const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;\n    const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;\n\n    this._process(\n      this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope, capturedSpanIsolationScope),\n    );\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a session.\n   */\n   captureSession(session$1) {\n    this.sendSession(session$1);\n    // After sending, we set init false to indicate it's not the first occurrence\n    session.updateSession(session$1, { init: false });\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry. This method is not available on all clients.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   * @param scope An optional scope containing event metadata.\n   * @returns A string representing the id of the check in.\n   */\n\n  /**\n   * Get the current Dsn.\n   */\n   getDsn() {\n    return this._dsn;\n  }\n\n  /**\n   * Get the current options.\n   */\n   getOptions() {\n    return this._options;\n  }\n\n  /**\n   * Get the SDK metadata.\n   * @see SdkMetadata\n   */\n   getSdkMetadata() {\n    return this._options._metadata;\n  }\n\n  /**\n   * Returns the transport that is used by the client.\n   * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.\n   */\n   getTransport() {\n    return this._transport;\n  }\n\n  /**\n   * Wait for all events to be sent or the timeout to expire, whichever comes first.\n   *\n   * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will\n   *   cause the client to wait until all events are sent before resolving the promise.\n   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are\n   * still events in the queue when the timeout is reached.\n   */\n   flush(timeout) {\n    const transport = this._transport;\n    if (transport) {\n      this.emit('flush');\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return syncpromise.resolvedSyncPromise(true);\n    }\n  }\n\n  /**\n   * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.\n   *\n   * @param {number} timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause\n   *   the client to wait until all events are sent before disabling itself.\n   * @returns {Promise<boolean>} A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if\n   * it doesn't.\n   */\n   close(timeout) {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      this.emit('close');\n      return result;\n    });\n  }\n\n  /**\n   * Get all installed event processors.\n   */\n   getEventProcessors() {\n    return this._eventProcessors;\n  }\n\n  /**\n   * Adds an event processor that applies to any event processed by this client.\n   */\n   addEventProcessor(eventProcessor) {\n    this._eventProcessors.push(eventProcessor);\n  }\n\n  /**\n   * Initialize this client.\n   * Call this after the client was set on a scope.\n   */\n   init() {\n    if (\n      this._isEnabled() ||\n      // Force integrations to be setup even if no DSN was set when we have\n      // Spotlight enabled. This is particularly important for browser as we\n      // don't support the `spotlight` option there and rely on the users\n      // adding the `spotlightBrowserIntegration()` to their integrations which\n      // wouldn't get initialized with the check below when there's no DSN set.\n      this._options.integrations.some(({ name }) => name.startsWith('Spotlight'))\n    ) {\n      this._setupIntegrations();\n    }\n  }\n\n  /**\n   * Gets an installed integration by its name.\n   *\n   * @returns {Integration|undefined} The installed integration or `undefined` if no integration with that `name` was installed.\n   */\n   getIntegrationByName(integrationName) {\n    return this._integrations[integrationName] ;\n  }\n\n  /**\n   * Add an integration to the client.\n   * This can be used to e.g. lazy load integrations.\n   * In most cases, this should not be necessary,\n   * and you're better off just passing the integrations via `integrations: []` at initialization time.\n   * However, if you find the need to conditionally load & add an integration, you can use `addIntegration` to do so.\n   */\n   addIntegration(integration$1) {\n    const isAlreadyInstalled = this._integrations[integration$1.name];\n\n    // This hook takes care of only installing if not already installed\n    integration.setupIntegration(this, integration$1, this._integrations);\n    // Here we need to check manually to make sure to not run this multiple times\n    if (!isAlreadyInstalled) {\n      integration.afterSetupIntegrations(this, [integration$1]);\n    }\n  }\n\n  /**\n   * Send a fully prepared event to Sentry.\n   */\n   sendEvent(event, hint = {}) {\n    this.emit('beforeSendEvent', event, hint);\n\n    let env = envelope.createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n\n    for (const attachment of hint.attachments || []) {\n      env = envelope$1.addItemToEnvelope(env, envelope$1.createAttachmentEnvelopeItem(attachment));\n    }\n\n    const promise = this.sendEnvelope(env);\n    if (promise) {\n      promise.then(sendResponse => this.emit('afterSendEvent', event, sendResponse), null);\n    }\n  }\n\n  /**\n   * Send a session or session aggregrates to Sentry.\n   */\n   sendSession(session) {\n    // Backfill release and environment on session\n    const { release: clientReleaseOption, environment: clientEnvironmentOption = constants.DEFAULT_ENVIRONMENT } = this._options;\n    if ('aggregates' in session) {\n      const sessionAttrs = session.attrs || {};\n      if (!sessionAttrs.release && !clientReleaseOption) {\n        debugBuild.DEBUG_BUILD && logger.logger.warn(MISSING_RELEASE_FOR_SESSION_ERROR);\n        return;\n      }\n      sessionAttrs.release = sessionAttrs.release || clientReleaseOption;\n      sessionAttrs.environment = sessionAttrs.environment || clientEnvironmentOption;\n      session.attrs = sessionAttrs;\n    } else {\n      if (!session.release && !clientReleaseOption) {\n        debugBuild.DEBUG_BUILD && logger.logger.warn(MISSING_RELEASE_FOR_SESSION_ERROR);\n        return;\n      }\n      session.release = session.release || clientReleaseOption;\n      session.environment = session.environment || clientEnvironmentOption;\n    }\n\n    this.emit('beforeSendSession', session);\n\n    const env = envelope.createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(env);\n  }\n\n  /**\n   * Record on the client that an event got dropped (ie, an event that will not be sent to Sentry).\n   */\n   recordDroppedEvent(reason, category, count = 1) {\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session, replay_event) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      debugBuild.DEBUG_BUILD && logger.logger.log(`Recording outcome: \"${key}\"${count > 1 ? ` (${count} times)` : ''}`);\n      this._outcomes[key] = (this._outcomes[key] || 0) + count;\n    }\n  }\n\n  /* eslint-disable @typescript-eslint/unified-signatures */\n  /**\n   * Register a callback for whenever a span is started.\n   * Receives the span as argument.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n\n  /**\n   * Register a hook on this client.\n   */\n   on(hook, callback) {\n    const hooks = (this._hooks[hook] = this._hooks[hook] || []);\n\n    // @ts-expect-error We assume the types are correct\n    hooks.push(callback);\n\n    // This function returns a callback execution handler that, when invoked,\n    // deregisters a callback. This is crucial for managing instances where callbacks\n    // need to be unregistered to prevent self-referencing in callback closures,\n    // ensuring proper garbage collection.\n    return () => {\n      // @ts-expect-error We assume the types are correct\n      const cbIndex = hooks.indexOf(callback);\n      if (cbIndex > -1) {\n        hooks.splice(cbIndex, 1);\n      }\n    };\n  }\n\n  /** Fire a hook whenever a span starts. */\n\n  /**\n   * Emit a hook that was previously registered via `on()`.\n   */\n   emit(hook, ...rest) {\n    const callbacks = this._hooks[hook];\n    if (callbacks) {\n      callbacks.forEach(callback => callback(...rest));\n    }\n  }\n\n  /**\n   * Send an envelope to Sentry.\n   */\n   sendEnvelope(envelope) {\n    this.emit('beforeEnvelope', envelope);\n\n    if (this._isEnabled() && this._transport) {\n      return this._transport.send(envelope).then(null, reason => {\n        debugBuild.DEBUG_BUILD && logger.logger.error('Error while sending envelope:', reason);\n        return reason;\n      });\n    }\n\n    debugBuild.DEBUG_BUILD && logger.logger.error('Transport disabled');\n\n    return syncpromise.resolvedSyncPromise({});\n  }\n\n  /* eslint-enable @typescript-eslint/unified-signatures */\n\n  /** Setup integrations for this client. */\n   _setupIntegrations() {\n    const { integrations } = this._options;\n    this._integrations = integration.setupIntegrations(this, integrations);\n    integration.afterSetupIntegrations(this, integrations);\n  }\n\n  /** Updates existing session based on the provided event */\n   _updateSessionFromEvent(session$1, event) {\n    let crashed = event.level === 'fatal';\n    let errored = false;\n    const exceptions = event.exception?.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism?.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session$1.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session$1.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      session.updateSession(session$1, {\n        ...(crashed && { status: 'crashed' }),\n        errors: session$1.errors || Number(errored || crashed),\n      });\n      this.captureSession(session$1);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n   _isClientDoneProcessing(timeout) {\n    return new syncpromise.SyncPromise(resolve => {\n      let ticked = 0;\n      const tick = 1;\n\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a transport is present. */\n   _isEnabled() {\n    return this.getOptions().enabled !== false && this._transport !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param currentScope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n   _prepareEvent(\n    event,\n    hint,\n    currentScope,\n    isolationScope,\n  ) {\n    const options = this.getOptions();\n    const integrations = Object.keys(this._integrations);\n    if (!hint.integrations && integrations?.length) {\n      hint.integrations = integrations;\n    }\n\n    this.emit('preprocessEvent', event, hint);\n\n    if (!event.type) {\n      isolationScope.setLastEventId(event.event_id || hint.event_id);\n    }\n\n    return prepareEvent.prepareEvent(options, event, hint, currentScope, this, isolationScope).then(evt => {\n      if (evt === null) {\n        return evt;\n      }\n\n      this.emit('postprocessEvent', evt, hint);\n\n      evt.contexts = {\n        trace: currentScopes.getTraceContextFromScope(currentScope),\n        ...evt.contexts,\n      };\n\n      const dynamicSamplingContext$1 = dynamicSamplingContext.getDynamicSamplingContextFromScope(this, currentScope);\n\n      evt.sdkProcessingMetadata = {\n        dynamicSamplingContext: dynamicSamplingContext$1,\n        ...evt.sdkProcessingMetadata,\n      };\n\n      return evt;\n    });\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n   _captureEvent(\n    event,\n    hint = {},\n    currentScope = currentScopes.getCurrentScope(),\n    isolationScope = currentScopes.getIsolationScope(),\n  ) {\n    if (debugBuild.DEBUG_BUILD && isErrorEvent(event)) {\n      logger.logger.log(`Captured error event \\`${eventUtils.getPossibleEventMessages(event)[0] || '<unknown>'}\\``);\n    }\n\n    return this._processEvent(event, hint, currentScope, isolationScope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        if (debugBuild.DEBUG_BUILD) {\n          if (_isDoNotSendEventError(reason)) {\n            logger.logger.log(reason.message);\n          } else if (_isInternalError(reason)) {\n            logger.logger.warn(reason.message);\n          } else {\n            logger.logger.warn(reason);\n          }\n        }\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param currentScope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n   _processEvent(\n    event,\n    hint,\n    currentScope,\n    isolationScope,\n  ) {\n    const options = this.getOptions();\n    const { sampleRate } = options;\n\n    const isTransaction = isTransactionEvent(event);\n    const isError = isErrorEvent(event);\n    const eventType = event.type || 'error';\n    const beforeSendLabel = `before send for type \\`${eventType}\\``;\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    const parsedSampleRate = typeof sampleRate === 'undefined' ? undefined : parseSampleRate.parseSampleRate(sampleRate);\n    if (isError && typeof parsedSampleRate === 'number' && Math.random() > parsedSampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error');\n      return syncpromise.rejectedSyncPromise(\n        _makeDoNotSendEventError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n        ),\n      );\n    }\n\n    const dataCategory = (eventType === 'replay_event' ? 'replay' : eventType) ;\n\n    return this._prepareEvent(event, hint, currentScope, isolationScope)\n      .then(prepared => {\n        if (prepared === null) {\n          this.recordDroppedEvent('event_processor', dataCategory);\n          throw _makeDoNotSendEventError('An event processor returned `null`, will not send event.');\n        }\n\n        const isInternalException = hint.data && (hint.data ).__sentry__ === true;\n        if (isInternalException) {\n          return prepared;\n        }\n\n        const result = processBeforeSend(this, options, prepared, hint);\n        return _validateBeforeSendResult(result, beforeSendLabel);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent('before_send', dataCategory);\n          if (isTransaction) {\n            const spans = event.spans || [];\n            // the transaction itself counts as one span, plus all the child spans that are added\n            const spanCount = 1 + spans.length;\n            this.recordDroppedEvent('before_send', 'span', spanCount);\n          }\n          throw _makeDoNotSendEventError(`${beforeSendLabel} returned \\`null\\`, will not send event.`);\n        }\n\n        const session = currentScope.getSession() || isolationScope.getSession();\n        if (isError && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        if (isTransaction) {\n          const spanCountBefore = processedEvent.sdkProcessingMetadata?.spanCountBeforeProcessing || 0;\n          const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;\n\n          const droppedSpanCount = spanCountBefore - spanCountAfter;\n          if (droppedSpanCount > 0) {\n            this.recordDroppedEvent('before_send', 'span', droppedSpanCount);\n          }\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        const transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          const source = 'custom';\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source,\n          };\n        }\n\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (_isDoNotSendEventError(reason) || _isInternalError(reason)) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason,\n        });\n        throw _makeInternalError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n   _process(promise) {\n    this._numProcessing++;\n    void promise.then(\n      value => {\n        this._numProcessing--;\n        return value;\n      },\n      reason => {\n        this._numProcessing--;\n        return reason;\n      },\n    );\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n   _clearOutcomes() {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.entries(outcomes).map(([key, quantity]) => {\n      const [reason, category] = key.split(':') ;\n      return {\n        reason,\n        category,\n        quantity,\n      };\n    });\n  }\n\n  /**\n   * Sends client reports as an envelope.\n   */\n   _flushOutcomes() {\n    debugBuild.DEBUG_BUILD && logger.logger.log('Flushing outcomes...');\n\n    const outcomes = this._clearOutcomes();\n\n    if (outcomes.length === 0) {\n      debugBuild.DEBUG_BUILD && logger.logger.log('No outcomes to send');\n      return;\n    }\n\n    // This is really the only place where we want to check for a DSN and only send outcomes then\n    if (!this._dsn) {\n      debugBuild.DEBUG_BUILD && logger.logger.log('No dsn provided, will not send outcomes');\n      return;\n    }\n\n    debugBuild.DEBUG_BUILD && logger.logger.log('Sending outcomes:', outcomes);\n\n    const envelope = clientreport.createClientReportEnvelope(outcomes, this._options.tunnel && dsn.dsnToString(this._dsn));\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(envelope);\n  }\n\n  /**\n   * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n   */\n\n}\n\n/**\n * @deprecated Use `Client` instead. This alias may be removed in a future major version.\n */\n// TODO(v10): Remove\n\n/**\n * @deprecated Use `Client` instead. This alias may be removed in a future major version.\n */\n// TODO(v10): Remove\nconst BaseClient = Client;\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(\n  beforeSendResult,\n  beforeSendLabel,\n) {\n  const invalidValueError = `${beforeSendLabel} must return \\`null\\` or a valid event.`;\n  if (is.isThenable(beforeSendResult)) {\n    return beforeSendResult.then(\n      event => {\n        if (!is.isPlainObject(event) && event !== null) {\n          throw _makeInternalError(invalidValueError);\n        }\n        return event;\n      },\n      e => {\n        throw _makeInternalError(`${beforeSendLabel} rejected with ${e}`);\n      },\n    );\n  } else if (!is.isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw _makeInternalError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\n/**\n * Process the matching `beforeSendXXX` callback.\n */\nfunction processBeforeSend(\n  client,\n  options,\n  event,\n  hint,\n) {\n  const { beforeSend, beforeSendTransaction, beforeSendSpan } = options;\n  let processedEvent = event;\n\n  if (isErrorEvent(processedEvent) && beforeSend) {\n    return beforeSend(processedEvent, hint);\n  }\n\n  if (isTransactionEvent(processedEvent)) {\n    if (beforeSendSpan) {\n      // process root span\n      const processedRootSpanJson = beforeSendSpan(transactionEvent.convertTransactionEventToSpanJson(processedEvent));\n      if (!processedRootSpanJson) {\n        spanUtils.showSpanDropWarning();\n      } else {\n        // update event with processed root span values\n        processedEvent = merge.merge(event, transactionEvent.convertSpanJsonToTransactionEvent(processedRootSpanJson));\n      }\n\n      // process child spans\n      if (processedEvent.spans) {\n        const processedSpans = [];\n        for (const span of processedEvent.spans) {\n          const processedSpan = beforeSendSpan(span);\n          if (!processedSpan) {\n            spanUtils.showSpanDropWarning();\n            processedSpans.push(span);\n          } else {\n            processedSpans.push(processedSpan);\n          }\n        }\n        processedEvent.spans = processedSpans;\n      }\n    }\n\n    if (beforeSendTransaction) {\n      if (processedEvent.spans) {\n        // We store the # of spans before processing in SDK metadata,\n        // so we can compare it afterwards to determine how many spans were dropped\n        const spanCountBefore = processedEvent.spans.length;\n        processedEvent.sdkProcessingMetadata = {\n          ...event.sdkProcessingMetadata,\n          spanCountBeforeProcessing: spanCountBefore,\n        };\n      }\n      return beforeSendTransaction(processedEvent , hint);\n    }\n  }\n\n  return processedEvent;\n}\n\nfunction isErrorEvent(event) {\n  return event.type === undefined;\n}\n\nfunction isTransactionEvent(event) {\n  return event.type === 'transaction';\n}\n\n/** Extract trace information from scope */\nfunction _getTraceInfoFromScope(\n  client,\n  scope,\n) {\n  if (!scope) {\n    return [undefined, undefined];\n  }\n\n  return currentScopes.withScope(scope, () => {\n    const span = spanUtils.getActiveSpan();\n    const traceContext = span ? spanUtils.spanToTraceContext(span) : currentScopes.getTraceContextFromScope(scope);\n    const dynamicSamplingContext$1 = span\n      ? dynamicSamplingContext.getDynamicSamplingContextFromSpan(span)\n      : dynamicSamplingContext.getDynamicSamplingContextFromScope(client, scope);\n    return [dynamicSamplingContext$1, traceContext];\n  });\n}\n\nexports.BaseClient = BaseClient;\nexports.Client = Client;\nexports._getTraceInfoFromScope = _getTraceInfoFromScope;\n//# sourceMappingURL=client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLFlBQVksbUJBQU8sQ0FBQyxnR0FBVTtBQUM5QixrQkFBa0IsbUJBQU8sQ0FBQyw0R0FBZ0I7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMsb0hBQW9CO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLGdIQUFrQjtBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQywwR0FBZTtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyxnSEFBa0I7QUFDOUMsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQWM7QUFDdEMsK0JBQStCLG1CQUFPLENBQUMsc0pBQXFDO0FBQzVFLG1CQUFtQixtQkFBTyxDQUFDLDBIQUF1QjtBQUNsRCxjQUFjLG1CQUFPLENBQUMsZ0hBQWtCO0FBQ3hDLHdCQUF3QixtQkFBTyxDQUFDLG9JQUE0QjtBQUM1RCxxQkFBcUIsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsd0hBQXNCO0FBQ2hELHlCQUF5QixtQkFBTyxDQUFDLHNJQUE2QjtBQUM5RCxxQkFBcUIsbUJBQU8sQ0FBQywwSUFBK0I7QUFDNUQsWUFBWSxtQkFBTyxDQUFDLHdIQUFzQjtBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQyxrSUFBMkI7QUFDdEQsV0FBVyxtQkFBTyxDQUFDLHNIQUFxQjtBQUN4QyxlQUFlLG1CQUFPLENBQUMsOEhBQXlCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQywwSEFBdUI7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMsd0lBQThCOztBQUUxRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekIsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMEJBQTBCO0FBQzlCO0FBQ0EsSUFBSSwyQkFBMkI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUUsbUJBQW1CO0FBQzVGO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsTUFBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFHQUFxRztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPLEdBQUcsU0FBUztBQUN4Qyx5RUFBeUUsSUFBSSxHQUFHLGlCQUFpQixPQUFPLGFBQWE7QUFDckg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUEsNkNBQTZDO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw2REFBNkQ7QUFDL0c7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTs7QUFFekI7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsV0FBVztBQUN6RztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0lBQXdJLE9BQU87QUFDL0k7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0NBQW9DLGlCQUFpQixnQkFBZ0IsRUFBRTtBQUN2RSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBb0Q7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxjbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGFwaSA9IHJlcXVpcmUoJy4vYXBpLmpzJyk7XG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy5qcycpO1xuY29uc3QgY3VycmVudFNjb3BlcyA9IHJlcXVpcmUoJy4vY3VycmVudFNjb3Blcy5qcycpO1xuY29uc3QgZGVidWdCdWlsZCA9IHJlcXVpcmUoJy4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IGVudmVsb3BlID0gcmVxdWlyZSgnLi9lbnZlbG9wZS5qcycpO1xuY29uc3QgaW50ZWdyYXRpb24gPSByZXF1aXJlKCcuL2ludGVncmF0aW9uLmpzJyk7XG5jb25zdCBzZXNzaW9uID0gcmVxdWlyZSgnLi9zZXNzaW9uLmpzJyk7XG5jb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gcmVxdWlyZSgnLi90cmFjaW5nL2R5bmFtaWNTYW1wbGluZ0NvbnRleHQuanMnKTtcbmNvbnN0IGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50VXRpbHMuanMnKTtcbmNvbnN0IG1lcmdlID0gcmVxdWlyZSgnLi91dGlscy9tZXJnZS5qcycpO1xuY29uc3QgcGFyc2VTYW1wbGVSYXRlID0gcmVxdWlyZSgnLi91dGlscy9wYXJzZVNhbXBsZVJhdGUuanMnKTtcbmNvbnN0IHByZXBhcmVFdmVudCA9IHJlcXVpcmUoJy4vdXRpbHMvcHJlcGFyZUV2ZW50LmpzJyk7XG5jb25zdCBzcGFuVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3NwYW5VdGlscy5qcycpO1xuY29uc3QgdHJhbnNhY3Rpb25FdmVudCA9IHJlcXVpcmUoJy4vdXRpbHMvdHJhbnNhY3Rpb25FdmVudC5qcycpO1xuY29uc3QgY2xpZW50cmVwb3J0ID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9jbGllbnRyZXBvcnQuanMnKTtcbmNvbnN0IGRzbiA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvZHNuLmpzJyk7XG5jb25zdCBlbnZlbG9wZSQxID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9lbnZlbG9wZS5qcycpO1xuY29uc3QgaXMgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2lzLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuY29uc3QgbWlzYyA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvbWlzYy5qcycpO1xuY29uc3Qgc3luY3Byb21pc2UgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3N5bmNwcm9taXNlLmpzJyk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1saW5lcyAqL1xuXG5jb25zdCBBTFJFQURZX1NFRU5fRVJST1IgPSBcIk5vdCBjYXB0dXJpbmcgZXhjZXB0aW9uIGJlY2F1c2UgaXQncyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQuXCI7XG5jb25zdCBNSVNTSU5HX1JFTEVBU0VfRk9SX1NFU1NJT05fRVJST1IgPSAnRGlzY2FyZGVkIHNlc3Npb24gYmVjYXVzZSBvZiBtaXNzaW5nIG9yIG5vbi1zdHJpbmcgcmVsZWFzZSc7XG5cbmNvbnN0IElOVEVSTkFMX0VSUk9SX1NZTUJPTCA9IFN5bWJvbC5mb3IoJ1NlbnRyeUludGVybmFsRXJyb3InKTtcbmNvbnN0IERPX05PVF9TRU5EX0VWRU5UX1NZTUJPTCA9IFN5bWJvbC5mb3IoJ1NlbnRyeURvTm90U2VuZEV2ZW50RXJyb3InKTtcblxuZnVuY3Rpb24gX21ha2VJbnRlcm5hbEVycm9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlLFxuICAgIFtJTlRFUk5BTF9FUlJPUl9TWU1CT0xdOiB0cnVlLFxuICB9O1xufVxuXG5mdW5jdGlvbiBfbWFrZURvTm90U2VuZEV2ZW50RXJyb3IobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2UsXG4gICAgW0RPX05PVF9TRU5EX0VWRU5UX1NZTUJPTF06IHRydWUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIF9pc0ludGVybmFsRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuICEhZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBJTlRFUk5BTF9FUlJPUl9TWU1CT0wgaW4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIF9pc0RvTm90U2VuZEV2ZW50RXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuICEhZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBET19OT1RfU0VORF9FVkVOVF9TWU1CT0wgaW4gZXJyb3I7XG59XG5cbi8qKlxuICogQmFzZSBpbXBsZW1lbnRhdGlvbiBmb3IgYWxsIEphdmFTY3JpcHQgU0RLIGNsaWVudHMuXG4gKlxuICogQ2FsbCB0aGUgY29uc3RydWN0b3Igd2l0aCB0aGUgY29ycmVzcG9uZGluZyBvcHRpb25zXG4gKiBzcGVjaWZpYyB0byB0aGUgY2xpZW50IHN1YmNsYXNzLiBUbyBhY2Nlc3MgdGhlc2Ugb3B0aW9ucyBsYXRlciwgdXNlXG4gKiB7QGxpbmsgQ2xpZW50LmdldE9wdGlvbnN9LlxuICpcbiAqIElmIGEgRHNuIGlzIHNwZWNpZmllZCBpbiB0aGUgb3B0aW9ucywgaXQgd2lsbCBiZSBwYXJzZWQgYW5kIHN0b3JlZC4gVXNlXG4gKiB7QGxpbmsgQ2xpZW50LmdldERzbn0gdG8gcmV0cmlldmUgdGhlIERzbiBhdCBhbnkgbW9tZW50LiBJbiBjYXNlIHRoZSBEc24gaXNcbiAqIGludmFsaWQsIHRoZSBjb25zdHJ1Y3RvciB3aWxsIHRocm93IGEge0BsaW5rIFNlbnRyeUV4Y2VwdGlvbn0uIE5vdGUgdGhhdFxuICogd2l0aG91dCBhIHZhbGlkIERzbiwgdGhlIFNESyB3aWxsIG5vdCBzZW5kIGFueSBldmVudHMgdG8gU2VudHJ5LlxuICpcbiAqIEJlZm9yZSBzZW5kaW5nIGFuIGV2ZW50LCBpdCBpcyBwYXNzZWQgdGhyb3VnaFxuICoge0BsaW5rIENsaWVudC5fcHJlcGFyZUV2ZW50fSB0byBhZGQgU0RLIGluZm9ybWF0aW9uIGFuZCBzY29wZSBkYXRhXG4gKiAoYnJlYWRjcnVtYnMgYW5kIGNvbnRleHQpLiBUbyBhZGQgbW9yZSBjdXN0b20gaW5mb3JtYXRpb24sIG92ZXJyaWRlIHRoaXNcbiAqIG1ldGhvZCBhbmQgZXh0ZW5kIHRoZSByZXN1bHRpbmcgcHJlcGFyZWQgZXZlbnQuXG4gKlxuICogVG8gaXNzdWUgYXV0b21hdGljYWxseSBjcmVhdGVkIGV2ZW50cyAoZS5nLiB2aWEgaW5zdHJ1bWVudGF0aW9uKSwgdXNlXG4gKiB7QGxpbmsgQ2xpZW50LmNhcHR1cmVFdmVudH0uIEl0IHdpbGwgcHJlcGFyZSB0aGUgZXZlbnQgYW5kIHBhc3MgaXQgdGhyb3VnaFxuICogdGhlIGNhbGxiYWNrIGxpZmVjeWNsZS4gVG8gaXNzdWUgYXV0by1icmVhZGNydW1icywgdXNlXG4gKiB7QGxpbmsgQ2xpZW50LmFkZEJyZWFkY3J1bWJ9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBjbGFzcyBOb2RlQ2xpZW50IGV4dGVuZHMgQ2xpZW50PE5vZGVPcHRpb25zPiB7XG4gKiAgIHB1YmxpYyBjb25zdHJ1Y3RvcihvcHRpb25zOiBOb2RlT3B0aW9ucykge1xuICogICAgIHN1cGVyKG9wdGlvbnMpO1xuICogICB9XG4gKlxuICogICAvLyAuLi5cbiAqIH1cbiAqL1xuY2xhc3MgQ2xpZW50IHtcbiAgLyoqIE9wdGlvbnMgcGFzc2VkIHRvIHRoZSBTREsuICovXG5cbiAgLyoqIFRoZSBjbGllbnQgRHNuLCBpZiBzcGVjaWZpZWQgaW4gb3B0aW9ucy4gV2l0aG91dCB0aGlzIERzbiwgdGhlIFNESyB3aWxsIGJlIGRpc2FibGVkLiAqL1xuXG4gIC8qKiBBcnJheSBvZiBzZXQgdXAgaW50ZWdyYXRpb25zLiAqL1xuXG4gIC8qKiBOdW1iZXIgb2YgY2FsbHMgYmVpbmcgcHJvY2Vzc2VkICovXG5cbiAgLyoqIEhvbGRzIGZsdXNoYWJsZSAgKi9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGlzIGNsaWVudCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIGNsaWVudC5cbiAgICovXG4gICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5faW50ZWdyYXRpb25zID0ge307XG4gICAgdGhpcy5fbnVtUHJvY2Vzc2luZyA9IDA7XG4gICAgdGhpcy5fb3V0Y29tZXMgPSB7fTtcbiAgICB0aGlzLl9ob29rcyA9IHt9O1xuICAgIHRoaXMuX2V2ZW50UHJvY2Vzc29ycyA9IFtdO1xuXG4gICAgaWYgKG9wdGlvbnMuZHNuKSB7XG4gICAgICB0aGlzLl9kc24gPSBkc24ubWFrZURzbihvcHRpb25zLmRzbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdObyBEU04gcHJvdmlkZWQsIGNsaWVudCB3aWxsIG5vdCBzZW5kIGV2ZW50cy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZHNuKSB7XG4gICAgICBjb25zdCB1cmwgPSBhcGkuZ2V0RW52ZWxvcGVFbmRwb2ludFdpdGhVcmxFbmNvZGVkQXV0aChcbiAgICAgICAgdGhpcy5fZHNuLFxuICAgICAgICBvcHRpb25zLnR1bm5lbCxcbiAgICAgICAgb3B0aW9ucy5fbWV0YWRhdGEgPyBvcHRpb25zLl9tZXRhZGF0YS5zZGsgOiB1bmRlZmluZWQsXG4gICAgICApO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gb3B0aW9ucy50cmFuc3BvcnQoe1xuICAgICAgICB0dW5uZWw6IHRoaXMuX29wdGlvbnMudHVubmVsLFxuICAgICAgICByZWNvcmREcm9wcGVkRXZlbnQ6IHRoaXMucmVjb3JkRHJvcHBlZEV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgIC4uLm9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyxcbiAgICAgICAgdXJsLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmVzIGFuIGV4Y2VwdGlvbiBldmVudCBhbmQgc2VuZHMgaXQgdG8gU2VudHJ5LlxuICAgKlxuICAgKiBVbmxpa2UgYGNhcHR1cmVFeGNlcHRpb25gIGV4cG9ydGVkIGZyb20gZXZlcnkgU0RLLCB0aGlzIG1ldGhvZCByZXF1aXJlcyB0aGF0IHlvdSBwYXNzIGl0IHRoZSBjdXJyZW50IHNjb3BlLlxuICAgKi9cbiAgIGNhcHR1cmVFeGNlcHRpb24oZXhjZXB0aW9uLCBoaW50LCBzY29wZSkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBtaXNjLnV1aWQ0KCk7XG5cbiAgICAvLyBlbnN1cmUgd2UgaGF2ZW4ndCBjYXB0dXJlZCB0aGlzIHZlcnkgb2JqZWN0IGJlZm9yZVxuICAgIGlmIChtaXNjLmNoZWNrT3JTZXRBbHJlYWR5Q2F1Z2h0KGV4Y2VwdGlvbikpIHtcbiAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci5sb2coQUxSRUFEWV9TRUVOX0VSUk9SKTtcbiAgICAgIHJldHVybiBldmVudElkO1xuICAgIH1cblxuICAgIGNvbnN0IGhpbnRXaXRoRXZlbnRJZCA9IHtcbiAgICAgIGV2ZW50X2lkOiBldmVudElkLFxuICAgICAgLi4uaGludCxcbiAgICB9O1xuXG4gICAgdGhpcy5fcHJvY2VzcyhcbiAgICAgIHRoaXMuZXZlbnRGcm9tRXhjZXB0aW9uKGV4Y2VwdGlvbiwgaGludFdpdGhFdmVudElkKS50aGVuKGV2ZW50ID0+XG4gICAgICAgIHRoaXMuX2NhcHR1cmVFdmVudChldmVudCwgaGludFdpdGhFdmVudElkLCBzY29wZSksXG4gICAgICApLFxuICAgICk7XG5cbiAgICByZXR1cm4gaGludFdpdGhFdmVudElkLmV2ZW50X2lkO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmVzIGEgbWVzc2FnZSBldmVudCBhbmQgc2VuZHMgaXQgdG8gU2VudHJ5LlxuICAgKlxuICAgKiBVbmxpa2UgYGNhcHR1cmVNZXNzYWdlYCBleHBvcnRlZCBmcm9tIGV2ZXJ5IFNESywgdGhpcyBtZXRob2QgcmVxdWlyZXMgdGhhdCB5b3UgcGFzcyBpdCB0aGUgY3VycmVudCBzY29wZS5cbiAgICovXG4gICBjYXB0dXJlTWVzc2FnZShcbiAgICBtZXNzYWdlLFxuICAgIGxldmVsLFxuICAgIGhpbnQsXG4gICAgY3VycmVudFNjb3BlLFxuICApIHtcbiAgICBjb25zdCBoaW50V2l0aEV2ZW50SWQgPSB7XG4gICAgICBldmVudF9pZDogbWlzYy51dWlkNCgpLFxuICAgICAgLi4uaGludCxcbiAgICB9O1xuXG4gICAgY29uc3QgZXZlbnRNZXNzYWdlID0gaXMuaXNQYXJhbWV0ZXJpemVkU3RyaW5nKG1lc3NhZ2UpID8gbWVzc2FnZSA6IFN0cmluZyhtZXNzYWdlKTtcblxuICAgIGNvbnN0IHByb21pc2VkRXZlbnQgPSBpcy5pc1ByaW1pdGl2ZShtZXNzYWdlKVxuICAgICAgPyB0aGlzLmV2ZW50RnJvbU1lc3NhZ2UoZXZlbnRNZXNzYWdlLCBsZXZlbCwgaGludFdpdGhFdmVudElkKVxuICAgICAgOiB0aGlzLmV2ZW50RnJvbUV4Y2VwdGlvbihtZXNzYWdlLCBoaW50V2l0aEV2ZW50SWQpO1xuXG4gICAgdGhpcy5fcHJvY2Vzcyhwcm9taXNlZEV2ZW50LnRoZW4oZXZlbnQgPT4gdGhpcy5fY2FwdHVyZUV2ZW50KGV2ZW50LCBoaW50V2l0aEV2ZW50SWQsIGN1cnJlbnRTY29wZSkpKTtcblxuICAgIHJldHVybiBoaW50V2l0aEV2ZW50SWQuZXZlbnRfaWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FwdHVyZXMgYSBtYW51YWxseSBjcmVhdGVkIGV2ZW50IGFuZCBzZW5kcyBpdCB0byBTZW50cnkuXG4gICAqXG4gICAqIFVubGlrZSBgY2FwdHVyZUV2ZW50YCBleHBvcnRlZCBmcm9tIGV2ZXJ5IFNESywgdGhpcyBtZXRob2QgcmVxdWlyZXMgdGhhdCB5b3UgcGFzcyBpdCB0aGUgY3VycmVudCBzY29wZS5cbiAgICovXG4gICBjYXB0dXJlRXZlbnQoZXZlbnQsIGhpbnQsIGN1cnJlbnRTY29wZSkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBtaXNjLnV1aWQ0KCk7XG5cbiAgICAvLyBlbnN1cmUgd2UgaGF2ZW4ndCBjYXB0dXJlZCB0aGlzIHZlcnkgb2JqZWN0IGJlZm9yZVxuICAgIGlmIChoaW50Py5vcmlnaW5hbEV4Y2VwdGlvbiAmJiBtaXNjLmNoZWNrT3JTZXRBbHJlYWR5Q2F1Z2h0KGhpbnQub3JpZ2luYWxFeGNlcHRpb24pKSB7XG4gICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIubG9nKEFMUkVBRFlfU0VFTl9FUlJPUik7XG4gICAgICByZXR1cm4gZXZlbnRJZDtcbiAgICB9XG5cbiAgICBjb25zdCBoaW50V2l0aEV2ZW50SWQgPSB7XG4gICAgICBldmVudF9pZDogZXZlbnRJZCxcbiAgICAgIC4uLmhpbnQsXG4gICAgfTtcblxuICAgIGNvbnN0IHNka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IGV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSB8fCB7fTtcbiAgICBjb25zdCBjYXB0dXJlZFNwYW5TY29wZSA9IHNka1Byb2Nlc3NpbmdNZXRhZGF0YS5jYXB0dXJlZFNwYW5TY29wZTtcbiAgICBjb25zdCBjYXB0dXJlZFNwYW5Jc29sYXRpb25TY29wZSA9IHNka1Byb2Nlc3NpbmdNZXRhZGF0YS5jYXB0dXJlZFNwYW5Jc29sYXRpb25TY29wZTtcblxuICAgIHRoaXMuX3Byb2Nlc3MoXG4gICAgICB0aGlzLl9jYXB0dXJlRXZlbnQoZXZlbnQsIGhpbnRXaXRoRXZlbnRJZCwgY2FwdHVyZWRTcGFuU2NvcGUgfHwgY3VycmVudFNjb3BlLCBjYXB0dXJlZFNwYW5Jc29sYXRpb25TY29wZSksXG4gICAgKTtcblxuICAgIHJldHVybiBoaW50V2l0aEV2ZW50SWQuZXZlbnRfaWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FwdHVyZXMgYSBzZXNzaW9uLlxuICAgKi9cbiAgIGNhcHR1cmVTZXNzaW9uKHNlc3Npb24kMSkge1xuICAgIHRoaXMuc2VuZFNlc3Npb24oc2Vzc2lvbiQxKTtcbiAgICAvLyBBZnRlciBzZW5kaW5nLCB3ZSBzZXQgaW5pdCBmYWxzZSB0byBpbmRpY2F0ZSBpdCdzIG5vdCB0aGUgZmlyc3Qgb2NjdXJyZW5jZVxuICAgIHNlc3Npb24udXBkYXRlU2Vzc2lvbihzZXNzaW9uJDEsIHsgaW5pdDogZmFsc2UgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY3JvbiBtb25pdG9yIGNoZWNrIGluIGFuZCBzZW5kIGl0IHRvIFNlbnRyeS4gVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSBvbiBhbGwgY2xpZW50cy5cbiAgICpcbiAgICogQHBhcmFtIGNoZWNrSW4gQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgY2hlY2sgaW4uXG4gICAqIEBwYXJhbSB1cHNlcnRNb25pdG9yQ29uZmlnIEFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIG1vbml0b3IgY29uZmlnLiBVc2UgdGhpcyBpZiB5b3Ugd2FudFxuICAgKiB0byBjcmVhdGUgYSBtb25pdG9yIGF1dG9tYXRpY2FsbHkgd2hlbiBzZW5kaW5nIGEgY2hlY2sgaW4uXG4gICAqIEBwYXJhbSBzY29wZSBBbiBvcHRpb25hbCBzY29wZSBjb250YWluaW5nIGV2ZW50IG1ldGFkYXRhLlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGlkIG9mIHRoZSBjaGVjayBpbi5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBEc24uXG4gICAqL1xuICAgZ2V0RHNuKCkge1xuICAgIHJldHVybiB0aGlzLl9kc247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gICAqL1xuICAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFNESyBtZXRhZGF0YS5cbiAgICogQHNlZSBTZGtNZXRhZGF0YVxuICAgKi9cbiAgIGdldFNka01ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLl9tZXRhZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0cmFuc3BvcnQgdGhhdCBpcyB1c2VkIGJ5IHRoZSBjbGllbnQuXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIHRyYW5zcG9ydCBnZXRzIGxhenkgaW5pdGlhbGl6ZWQgc28gaXQgd2lsbCBvbmx5IGJlIHRoZXJlIG9uY2UgdGhlIGZpcnN0IGV2ZW50IGhhcyBiZWVuIHNlbnQuXG4gICAqL1xuICAgZ2V0VHJhbnNwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQ7XG4gIH1cblxuICAvKipcbiAgICogV2FpdCBmb3IgYWxsIGV2ZW50cyB0byBiZSBzZW50IG9yIHRoZSB0aW1lb3V0IHRvIGV4cGlyZSwgd2hpY2hldmVyIGNvbWVzIGZpcnN0LlxuICAgKlxuICAgKiBAcGFyYW0gdGltZW91dCBNYXhpbXVtIHRpbWUgaW4gbXMgdGhlIGNsaWVudCBzaG91bGQgd2FpdCBmb3IgZXZlbnRzIHRvIGJlIGZsdXNoZWQuIE9taXR0aW5nIHRoaXMgcGFyYW1ldGVyIHdpbGxcbiAgICogICBjYXVzZSB0aGUgY2xpZW50IHRvIHdhaXQgdW50aWwgYWxsIGV2ZW50cyBhcmUgc2VudCBiZWZvcmUgcmVzb2x2aW5nIHRoZSBwcm9taXNlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2l0aCBgdHJ1ZWAgaWYgYWxsIGV2ZW50cyBhcmUgc2VudCBiZWZvcmUgdGhlIHRpbWVvdXQsIG9yIGBmYWxzZWAgaWYgdGhlcmUgYXJlXG4gICAqIHN0aWxsIGV2ZW50cyBpbiB0aGUgcXVldWUgd2hlbiB0aGUgdGltZW91dCBpcyByZWFjaGVkLlxuICAgKi9cbiAgIGZsdXNoKHRpbWVvdXQpIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQ7XG4gICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICAgICAgcmV0dXJuIHRoaXMuX2lzQ2xpZW50RG9uZVByb2Nlc3NpbmcodGltZW91dCkudGhlbihjbGllbnRGaW5pc2hlZCA9PiB7XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQuZmx1c2godGltZW91dCkudGhlbih0cmFuc3BvcnRGbHVzaGVkID0+IGNsaWVudEZpbmlzaGVkICYmIHRyYW5zcG9ydEZsdXNoZWQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzeW5jcHJvbWlzZS5yZXNvbHZlZFN5bmNQcm9taXNlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCB0aGUgZXZlbnQgcXVldWUgYW5kIHNldCB0aGUgY2xpZW50IHRvIGBlbmFibGVkID0gZmFsc2VgLiBTZWUge0BsaW5rIENsaWVudC5mbHVzaH0uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IE1heGltdW0gdGltZSBpbiBtcyB0aGUgY2xpZW50IHNob3VsZCB3YWl0IGJlZm9yZSBzaHV0dGluZyBkb3duLiBPbWl0dGluZyB0aGlzIHBhcmFtZXRlciB3aWxsIGNhdXNlXG4gICAqICAgdGhlIGNsaWVudCB0byB3YWl0IHVudGlsIGFsbCBldmVudHMgYXJlIHNlbnQgYmVmb3JlIGRpc2FibGluZyBpdHNlbGYuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBBIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gYHRydWVgIGlmIHRoZSBmbHVzaCBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5IGJlZm9yZSB0aGUgdGltZW91dCwgb3IgYGZhbHNlYCBpZlxuICAgKiBpdCBkb2Vzbid0LlxuICAgKi9cbiAgIGNsb3NlKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gdGhpcy5mbHVzaCh0aW1lb3V0KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICB0aGlzLmdldE9wdGlvbnMoKS5lbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgaW5zdGFsbGVkIGV2ZW50IHByb2Nlc3NvcnMuXG4gICAqL1xuICAgZ2V0RXZlbnRQcm9jZXNzb3JzKCkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudFByb2Nlc3NvcnM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBldmVudCBwcm9jZXNzb3IgdGhhdCBhcHBsaWVzIHRvIGFueSBldmVudCBwcm9jZXNzZWQgYnkgdGhpcyBjbGllbnQuXG4gICAqL1xuICAgYWRkRXZlbnRQcm9jZXNzb3IoZXZlbnRQcm9jZXNzb3IpIHtcbiAgICB0aGlzLl9ldmVudFByb2Nlc3NvcnMucHVzaChldmVudFByb2Nlc3Nvcik7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGlzIGNsaWVudC5cbiAgICogQ2FsbCB0aGlzIGFmdGVyIHRoZSBjbGllbnQgd2FzIHNldCBvbiBhIHNjb3BlLlxuICAgKi9cbiAgIGluaXQoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5faXNFbmFibGVkKCkgfHxcbiAgICAgIC8vIEZvcmNlIGludGVncmF0aW9ucyB0byBiZSBzZXR1cCBldmVuIGlmIG5vIERTTiB3YXMgc2V0IHdoZW4gd2UgaGF2ZVxuICAgICAgLy8gU3BvdGxpZ2h0IGVuYWJsZWQuIFRoaXMgaXMgcGFydGljdWxhcmx5IGltcG9ydGFudCBmb3IgYnJvd3NlciBhcyB3ZVxuICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCB0aGUgYHNwb3RsaWdodGAgb3B0aW9uIHRoZXJlIGFuZCByZWx5IG9uIHRoZSB1c2Vyc1xuICAgICAgLy8gYWRkaW5nIHRoZSBgc3BvdGxpZ2h0QnJvd3NlckludGVncmF0aW9uKClgIHRvIHRoZWlyIGludGVncmF0aW9ucyB3aGljaFxuICAgICAgLy8gd291bGRuJ3QgZ2V0IGluaXRpYWxpemVkIHdpdGggdGhlIGNoZWNrIGJlbG93IHdoZW4gdGhlcmUncyBubyBEU04gc2V0LlxuICAgICAgdGhpcy5fb3B0aW9ucy5pbnRlZ3JhdGlvbnMuc29tZSgoeyBuYW1lIH0pID0+IG5hbWUuc3RhcnRzV2l0aCgnU3BvdGxpZ2h0JykpXG4gICAgKSB7XG4gICAgICB0aGlzLl9zZXR1cEludGVncmF0aW9ucygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGluc3RhbGxlZCBpbnRlZ3JhdGlvbiBieSBpdHMgbmFtZS5cbiAgICpcbiAgICogQHJldHVybnMge0ludGVncmF0aW9ufHVuZGVmaW5lZH0gVGhlIGluc3RhbGxlZCBpbnRlZ3JhdGlvbiBvciBgdW5kZWZpbmVkYCBpZiBubyBpbnRlZ3JhdGlvbiB3aXRoIHRoYXQgYG5hbWVgIHdhcyBpbnN0YWxsZWQuXG4gICAqL1xuICAgZ2V0SW50ZWdyYXRpb25CeU5hbWUoaW50ZWdyYXRpb25OYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVncmF0aW9uc1tpbnRlZ3JhdGlvbk5hbWVdIDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gaW50ZWdyYXRpb24gdG8gdGhlIGNsaWVudC5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBlLmcuIGxhenkgbG9hZCBpbnRlZ3JhdGlvbnMuXG4gICAqIEluIG1vc3QgY2FzZXMsIHRoaXMgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnksXG4gICAqIGFuZCB5b3UncmUgYmV0dGVyIG9mZiBqdXN0IHBhc3NpbmcgdGhlIGludGVncmF0aW9ucyB2aWEgYGludGVncmF0aW9uczogW11gIGF0IGluaXRpYWxpemF0aW9uIHRpbWUuXG4gICAqIEhvd2V2ZXIsIGlmIHlvdSBmaW5kIHRoZSBuZWVkIHRvIGNvbmRpdGlvbmFsbHkgbG9hZCAmIGFkZCBhbiBpbnRlZ3JhdGlvbiwgeW91IGNhbiB1c2UgYGFkZEludGVncmF0aW9uYCB0byBkbyBzby5cbiAgICovXG4gICBhZGRJbnRlZ3JhdGlvbihpbnRlZ3JhdGlvbiQxKSB7XG4gICAgY29uc3QgaXNBbHJlYWR5SW5zdGFsbGVkID0gdGhpcy5faW50ZWdyYXRpb25zW2ludGVncmF0aW9uJDEubmFtZV07XG5cbiAgICAvLyBUaGlzIGhvb2sgdGFrZXMgY2FyZSBvZiBvbmx5IGluc3RhbGxpbmcgaWYgbm90IGFscmVhZHkgaW5zdGFsbGVkXG4gICAgaW50ZWdyYXRpb24uc2V0dXBJbnRlZ3JhdGlvbih0aGlzLCBpbnRlZ3JhdGlvbiQxLCB0aGlzLl9pbnRlZ3JhdGlvbnMpO1xuICAgIC8vIEhlcmUgd2UgbmVlZCB0byBjaGVjayBtYW51YWxseSB0byBtYWtlIHN1cmUgdG8gbm90IHJ1biB0aGlzIG11bHRpcGxlIHRpbWVzXG4gICAgaWYgKCFpc0FscmVhZHlJbnN0YWxsZWQpIHtcbiAgICAgIGludGVncmF0aW9uLmFmdGVyU2V0dXBJbnRlZ3JhdGlvbnModGhpcywgW2ludGVncmF0aW9uJDFdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGZ1bGx5IHByZXBhcmVkIGV2ZW50IHRvIFNlbnRyeS5cbiAgICovXG4gICBzZW5kRXZlbnQoZXZlbnQsIGhpbnQgPSB7fSkge1xuICAgIHRoaXMuZW1pdCgnYmVmb3JlU2VuZEV2ZW50JywgZXZlbnQsIGhpbnQpO1xuXG4gICAgbGV0IGVudiA9IGVudmVsb3BlLmNyZWF0ZUV2ZW50RW52ZWxvcGUoZXZlbnQsIHRoaXMuX2RzbiwgdGhpcy5fb3B0aW9ucy5fbWV0YWRhdGEsIHRoaXMuX29wdGlvbnMudHVubmVsKTtcblxuICAgIGZvciAoY29uc3QgYXR0YWNobWVudCBvZiBoaW50LmF0dGFjaG1lbnRzIHx8IFtdKSB7XG4gICAgICBlbnYgPSBlbnZlbG9wZSQxLmFkZEl0ZW1Ub0VudmVsb3BlKGVudiwgZW52ZWxvcGUkMS5jcmVhdGVBdHRhY2htZW50RW52ZWxvcGVJdGVtKGF0dGFjaG1lbnQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5zZW5kRW52ZWxvcGUoZW52KTtcbiAgICBpZiAocHJvbWlzZSkge1xuICAgICAgcHJvbWlzZS50aGVuKHNlbmRSZXNwb25zZSA9PiB0aGlzLmVtaXQoJ2FmdGVyU2VuZEV2ZW50JywgZXZlbnQsIHNlbmRSZXNwb25zZSksIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgc2Vzc2lvbiBvciBzZXNzaW9uIGFnZ3JlZ3JhdGVzIHRvIFNlbnRyeS5cbiAgICovXG4gICBzZW5kU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgLy8gQmFja2ZpbGwgcmVsZWFzZSBhbmQgZW52aXJvbm1lbnQgb24gc2Vzc2lvblxuICAgIGNvbnN0IHsgcmVsZWFzZTogY2xpZW50UmVsZWFzZU9wdGlvbiwgZW52aXJvbm1lbnQ6IGNsaWVudEVudmlyb25tZW50T3B0aW9uID0gY29uc3RhbnRzLkRFRkFVTFRfRU5WSVJPTk1FTlQgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgaWYgKCdhZ2dyZWdhdGVzJyBpbiBzZXNzaW9uKSB7XG4gICAgICBjb25zdCBzZXNzaW9uQXR0cnMgPSBzZXNzaW9uLmF0dHJzIHx8IHt9O1xuICAgICAgaWYgKCFzZXNzaW9uQXR0cnMucmVsZWFzZSAmJiAhY2xpZW50UmVsZWFzZU9wdGlvbikge1xuICAgICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybihNSVNTSU5HX1JFTEVBU0VfRk9SX1NFU1NJT05fRVJST1IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXNzaW9uQXR0cnMucmVsZWFzZSA9IHNlc3Npb25BdHRycy5yZWxlYXNlIHx8IGNsaWVudFJlbGVhc2VPcHRpb247XG4gICAgICBzZXNzaW9uQXR0cnMuZW52aXJvbm1lbnQgPSBzZXNzaW9uQXR0cnMuZW52aXJvbm1lbnQgfHwgY2xpZW50RW52aXJvbm1lbnRPcHRpb247XG4gICAgICBzZXNzaW9uLmF0dHJzID0gc2Vzc2lvbkF0dHJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXNlc3Npb24ucmVsZWFzZSAmJiAhY2xpZW50UmVsZWFzZU9wdGlvbikge1xuICAgICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybihNSVNTSU5HX1JFTEVBU0VfRk9SX1NFU1NJT05fRVJST1IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXNzaW9uLnJlbGVhc2UgPSBzZXNzaW9uLnJlbGVhc2UgfHwgY2xpZW50UmVsZWFzZU9wdGlvbjtcbiAgICAgIHNlc3Npb24uZW52aXJvbm1lbnQgPSBzZXNzaW9uLmVudmlyb25tZW50IHx8IGNsaWVudEVudmlyb25tZW50T3B0aW9uO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnYmVmb3JlU2VuZFNlc3Npb24nLCBzZXNzaW9uKTtcblxuICAgIGNvbnN0IGVudiA9IGVudmVsb3BlLmNyZWF0ZVNlc3Npb25FbnZlbG9wZShzZXNzaW9uLCB0aGlzLl9kc24sIHRoaXMuX29wdGlvbnMuX21ldGFkYXRhLCB0aGlzLl9vcHRpb25zLnR1bm5lbCk7XG5cbiAgICAvLyBzZW5kRW52ZWxvcGUgc2hvdWxkIG5vdCB0aHJvd1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICB0aGlzLnNlbmRFbnZlbG9wZShlbnYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29yZCBvbiB0aGUgY2xpZW50IHRoYXQgYW4gZXZlbnQgZ290IGRyb3BwZWQgKGllLCBhbiBldmVudCB0aGF0IHdpbGwgbm90IGJlIHNlbnQgdG8gU2VudHJ5KS5cbiAgICovXG4gICByZWNvcmREcm9wcGVkRXZlbnQocmVhc29uLCBjYXRlZ29yeSwgY291bnQgPSAxKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VuZENsaWVudFJlcG9ydHMpIHtcbiAgICAgIC8vIFdlIHdhbnQgdG8gdHJhY2sgZWFjaCBjYXRlZ29yeSAoZXJyb3IsIHRyYW5zYWN0aW9uLCBzZXNzaW9uLCByZXBsYXlfZXZlbnQpIHNlcGFyYXRlbHlcbiAgICAgIC8vIGJ1dCBzdGlsbCBrZWVwIHRoZSBkaXN0aW5jdGlvbiBiZXR3ZWVuIGRpZmZlcmVudCB0eXBlIG9mIG91dGNvbWVzLlxuICAgICAgLy8gV2UgY291bGQgdXNlIG5lc3RlZCBtYXBzLCBidXQgaXQncyBtdWNoIGVhc2llciB0byByZWFkIGFuZCB0eXBlIHRoaXMgd2F5LlxuICAgICAgLy8gQSBjb3JyZWN0IHR5cGUgZm9yIG1hcC1iYXNlZCBpbXBsZW1lbnRhdGlvbiBpZiB3ZSB3YW50IHRvIGdvIHRoYXQgcm91dGVcbiAgICAgIC8vIHdvdWxkIGJlIGBQYXJ0aWFsPFJlY29yZDxTZW50cnlSZXF1ZXN0VHlwZSwgUGFydGlhbDxSZWNvcmQ8T3V0Y29tZSwgbnVtYmVyPj4+PmBcbiAgICAgIC8vIFdpdGggdHlwZXNjcmlwdCA0LjEgd2UgY291bGQgZXZlbiB1c2UgdGVtcGxhdGUgbGl0ZXJhbCB0eXBlc1xuICAgICAgY29uc3Qga2V5ID0gYCR7cmVhc29ufToke2NhdGVnb3J5fWA7XG4gICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIubG9nKGBSZWNvcmRpbmcgb3V0Y29tZTogXCIke2tleX1cIiR7Y291bnQgPiAxID8gYCAoJHtjb3VudH0gdGltZXMpYCA6ICcnfWApO1xuICAgICAgdGhpcy5fb3V0Y29tZXNba2V5XSA9ICh0aGlzLl9vdXRjb21lc1trZXldIHx8IDApICsgY291bnQ7XG4gICAgfVxuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3VuaWZpZWQtc2lnbmF0dXJlcyAqL1xuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmb3Igd2hlbmV2ZXIgYSBzcGFuIGlzIHN0YXJ0ZWQuXG4gICAqIFJlY2VpdmVzIHRoZSBzcGFuIGFzIGFyZ3VtZW50LlxuICAgKiBAcmV0dXJucyB7KCkgPT4gdm9pZH0gQSBmdW5jdGlvbiB0aGF0LCB3aGVuIGV4ZWN1dGVkLCByZW1vdmVzIHRoZSByZWdpc3RlcmVkIGNhbGxiYWNrLlxuICAgKi9cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBob29rIG9uIHRoaXMgY2xpZW50LlxuICAgKi9cbiAgIG9uKGhvb2ssIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaG9va3MgPSAodGhpcy5faG9va3NbaG9va10gPSB0aGlzLl9ob29rc1tob29rXSB8fCBbXSk7XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGFzc3VtZSB0aGUgdHlwZXMgYXJlIGNvcnJlY3RcbiAgICBob29rcy5wdXNoKGNhbGxiYWNrKTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGNhbGxiYWNrIGV4ZWN1dGlvbiBoYW5kbGVyIHRoYXQsIHdoZW4gaW52b2tlZCxcbiAgICAvLyBkZXJlZ2lzdGVycyBhIGNhbGxiYWNrLiBUaGlzIGlzIGNydWNpYWwgZm9yIG1hbmFnaW5nIGluc3RhbmNlcyB3aGVyZSBjYWxsYmFja3NcbiAgICAvLyBuZWVkIHRvIGJlIHVucmVnaXN0ZXJlZCB0byBwcmV2ZW50IHNlbGYtcmVmZXJlbmNpbmcgaW4gY2FsbGJhY2sgY2xvc3VyZXMsXG4gICAgLy8gZW5zdXJpbmcgcHJvcGVyIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBXZSBhc3N1bWUgdGhlIHR5cGVzIGFyZSBjb3JyZWN0XG4gICAgICBjb25zdCBjYkluZGV4ID0gaG9va3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICBpZiAoY2JJbmRleCA+IC0xKSB7XG4gICAgICAgIGhvb2tzLnNwbGljZShjYkluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqIEZpcmUgYSBob29rIHdoZW5ldmVyIGEgc3BhbiBzdGFydHMuICovXG5cbiAgLyoqXG4gICAqIEVtaXQgYSBob29rIHRoYXQgd2FzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB2aWEgYG9uKClgLlxuICAgKi9cbiAgIGVtaXQoaG9vaywgLi4ucmVzdCkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuX2hvb2tzW2hvb2tdO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKC4uLnJlc3QpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhbiBlbnZlbG9wZSB0byBTZW50cnkuXG4gICAqL1xuICAgc2VuZEVudmVsb3BlKGVudmVsb3BlKSB7XG4gICAgdGhpcy5lbWl0KCdiZWZvcmVFbnZlbG9wZScsIGVudmVsb3BlKTtcblxuICAgIGlmICh0aGlzLl9pc0VuYWJsZWQoKSAmJiB0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc2VuZChlbnZlbG9wZSkudGhlbihudWxsLCByZWFzb24gPT4ge1xuICAgICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIuZXJyb3IoJ0Vycm9yIHdoaWxlIHNlbmRpbmcgZW52ZWxvcGU6JywgcmVhc29uKTtcbiAgICAgICAgcmV0dXJuIHJlYXNvbjtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci5lcnJvcignVHJhbnNwb3J0IGRpc2FibGVkJyk7XG5cbiAgICByZXR1cm4gc3luY3Byb21pc2UucmVzb2x2ZWRTeW5jUHJvbWlzZSh7fSk7XG4gIH1cblxuICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC91bmlmaWVkLXNpZ25hdHVyZXMgKi9cblxuICAvKiogU2V0dXAgaW50ZWdyYXRpb25zIGZvciB0aGlzIGNsaWVudC4gKi9cbiAgIF9zZXR1cEludGVncmF0aW9ucygpIHtcbiAgICBjb25zdCB7IGludGVncmF0aW9ucyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICB0aGlzLl9pbnRlZ3JhdGlvbnMgPSBpbnRlZ3JhdGlvbi5zZXR1cEludGVncmF0aW9ucyh0aGlzLCBpbnRlZ3JhdGlvbnMpO1xuICAgIGludGVncmF0aW9uLmFmdGVyU2V0dXBJbnRlZ3JhdGlvbnModGhpcywgaW50ZWdyYXRpb25zKTtcbiAgfVxuXG4gIC8qKiBVcGRhdGVzIGV4aXN0aW5nIHNlc3Npb24gYmFzZWQgb24gdGhlIHByb3ZpZGVkIGV2ZW50ICovXG4gICBfdXBkYXRlU2Vzc2lvbkZyb21FdmVudChzZXNzaW9uJDEsIGV2ZW50KSB7XG4gICAgbGV0IGNyYXNoZWQgPSBldmVudC5sZXZlbCA9PT0gJ2ZhdGFsJztcbiAgICBsZXQgZXJyb3JlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGV4Y2VwdGlvbnMgPSBldmVudC5leGNlcHRpb24/LnZhbHVlcztcblxuICAgIGlmIChleGNlcHRpb25zKSB7XG4gICAgICBlcnJvcmVkID0gdHJ1ZTtcblxuICAgICAgZm9yIChjb25zdCBleCBvZiBleGNlcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1lY2hhbmlzbSA9IGV4Lm1lY2hhbmlzbTtcbiAgICAgICAgaWYgKG1lY2hhbmlzbT8uaGFuZGxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjcmFzaGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEEgc2Vzc2lvbiBpcyB1cGRhdGVkIGFuZCB0aGF0IHNlc3Npb24gdXBkYXRlIGlzIHNlbnQgaW4gb25seSBvbmUgb2YgdGhlIHR3byBmb2xsb3dpbmcgc2NlbmFyaW9zOlxuICAgIC8vIDEuIFNlc3Npb24gd2l0aCBub24gdGVybWluYWwgc3RhdHVzIGFuZCAwIGVycm9ycyArIGFuIGVycm9yIG9jY3VycmVkIC0+IFdpbGwgc2V0IGVycm9yIGNvdW50IHRvIDEgYW5kIHNlbmQgdXBkYXRlXG4gICAgLy8gMi4gU2Vzc2lvbiB3aXRoIG5vbiB0ZXJtaW5hbCBzdGF0dXMgYW5kIDEgZXJyb3IgKyBhIGNyYXNoIG9jY3VycmVkIC0+IFdpbGwgc2V0IHN0YXR1cyBjcmFzaGVkIGFuZCBzZW5kIHVwZGF0ZVxuICAgIGNvbnN0IHNlc3Npb25Ob25UZXJtaW5hbCA9IHNlc3Npb24kMS5zdGF0dXMgPT09ICdvayc7XG4gICAgY29uc3Qgc2hvdWxkVXBkYXRlQW5kU2VuZCA9IChzZXNzaW9uTm9uVGVybWluYWwgJiYgc2Vzc2lvbiQxLmVycm9ycyA9PT0gMCkgfHwgKHNlc3Npb25Ob25UZXJtaW5hbCAmJiBjcmFzaGVkKTtcblxuICAgIGlmIChzaG91bGRVcGRhdGVBbmRTZW5kKSB7XG4gICAgICBzZXNzaW9uLnVwZGF0ZVNlc3Npb24oc2Vzc2lvbiQxLCB7XG4gICAgICAgIC4uLihjcmFzaGVkICYmIHsgc3RhdHVzOiAnY3Jhc2hlZCcgfSksXG4gICAgICAgIGVycm9yczogc2Vzc2lvbiQxLmVycm9ycyB8fCBOdW1iZXIoZXJyb3JlZCB8fCBjcmFzaGVkKSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jYXB0dXJlU2Vzc2lvbihzZXNzaW9uJDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIGNsaWVudCBpcyBmaW5pc2hlZCBwcm9jZXNzaW5nLiBSZXR1cm5zIGEgcHJvbWlzZSBiZWNhdXNlIGl0IHdpbGwgd2FpdCBgdGltZW91dGAgbXMgYmVmb3JlIHNheWluZ1xuICAgKiBcIm5vXCIgKHJlc29sdmluZyB0byBgZmFsc2VgKSBpbiBvcmRlciB0byBnaXZlIHRoZSBjbGllbnQgYSBjaGFuY2UgdG8gcG90ZW50aWFsbHkgZmluaXNoIGZpcnN0LlxuICAgKlxuICAgKiBAcGFyYW0gdGltZW91dCBUaGUgdGltZSwgaW4gbXMsIGFmdGVyIHdoaWNoIHRvIHJlc29sdmUgdG8gYGZhbHNlYCBpZiB0aGUgY2xpZW50IGlzIHN0aWxsIGJ1c3kuIFBhc3NpbmcgYDBgIChvciBub3RcbiAgICogcGFzc2luZyBhbnl0aGluZykgd2lsbCBtYWtlIHRoZSBwcm9taXNlIHdhaXQgYXMgbG9uZyBhcyBpdCB0YWtlcyBmb3IgcHJvY2Vzc2luZyB0byBmaW5pc2ggYmVmb3JlIHJlc29sdmluZyB0b1xuICAgKiBgdHJ1ZWAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB3aGljaCB3aWxsIHJlc29sdmUgdG8gYHRydWVgIGlmIHByb2Nlc3NpbmcgaXMgYWxyZWFkeSBkb25lIG9yIGZpbmlzaGVzIGJlZm9yZSB0aGUgdGltZW91dCwgYW5kXG4gICAqIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAqL1xuICAgX2lzQ2xpZW50RG9uZVByb2Nlc3NpbmcodGltZW91dCkge1xuICAgIHJldHVybiBuZXcgc3luY3Byb21pc2UuU3luY1Byb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgdGlja2VkID0gMDtcbiAgICAgIGNvbnN0IHRpY2sgPSAxO1xuXG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX251bVByb2Nlc3NpbmcgPT0gMCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlja2VkICs9IHRpY2s7XG4gICAgICAgICAgaWYgKHRpbWVvdXQgJiYgdGlja2VkID49IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aWNrKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBTREsgaXMgZW5hYmxlZCBhbmQgYSB0cmFuc3BvcnQgaXMgcHJlc2VudC4gKi9cbiAgIF9pc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucygpLmVuYWJsZWQgIT09IGZhbHNlICYmIHRoaXMuX3RyYW5zcG9ydCAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY29tbW9uIGluZm9ybWF0aW9uIHRvIGV2ZW50cy5cbiAgICpcbiAgICogVGhlIGluZm9ybWF0aW9uIGluY2x1ZGVzIHJlbGVhc2UgYW5kIGVudmlyb25tZW50IGZyb20gYG9wdGlvbnNgLFxuICAgKiBicmVhZGNydW1icyBhbmQgY29udGV4dCAoZXh0cmEsIHRhZ3MgYW5kIHVzZXIpIGZyb20gdGhlIHNjb3BlLlxuICAgKlxuICAgKiBJbmZvcm1hdGlvbiB0aGF0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgZXZlbnQgaXMgbmV2ZXIgb3ZlcndyaXR0ZW4uIEZvclxuICAgKiBuZXN0ZWQgb2JqZWN0cywgc3VjaCBhcyB0aGUgY29udGV4dCwga2V5cyBhcmUgbWVyZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50LlxuICAgKiBAcGFyYW0gaGludCBNYXkgY29udGFpbiBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBleGNlcHRpb24uXG4gICAqIEBwYXJhbSBjdXJyZW50U2NvcGUgQSBzY29wZSBjb250YWluaW5nIGV2ZW50IG1ldGFkYXRhLlxuICAgKiBAcmV0dXJucyBBIG5ldyBldmVudCB3aXRoIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqL1xuICAgX3ByZXBhcmVFdmVudChcbiAgICBldmVudCxcbiAgICBoaW50LFxuICAgIGN1cnJlbnRTY29wZSxcbiAgICBpc29sYXRpb25TY29wZSxcbiAgKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIGNvbnN0IGludGVncmF0aW9ucyA9IE9iamVjdC5rZXlzKHRoaXMuX2ludGVncmF0aW9ucyk7XG4gICAgaWYgKCFoaW50LmludGVncmF0aW9ucyAmJiBpbnRlZ3JhdGlvbnM/Lmxlbmd0aCkge1xuICAgICAgaGludC5pbnRlZ3JhdGlvbnMgPSBpbnRlZ3JhdGlvbnM7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdwcmVwcm9jZXNzRXZlbnQnLCBldmVudCwgaGludCk7XG5cbiAgICBpZiAoIWV2ZW50LnR5cGUpIHtcbiAgICAgIGlzb2xhdGlvblNjb3BlLnNldExhc3RFdmVudElkKGV2ZW50LmV2ZW50X2lkIHx8IGhpbnQuZXZlbnRfaWQpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVwYXJlRXZlbnQucHJlcGFyZUV2ZW50KG9wdGlvbnMsIGV2ZW50LCBoaW50LCBjdXJyZW50U2NvcGUsIHRoaXMsIGlzb2xhdGlvblNjb3BlKS50aGVuKGV2dCA9PiB7XG4gICAgICBpZiAoZXZ0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBldnQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdCgncG9zdHByb2Nlc3NFdmVudCcsIGV2dCwgaGludCk7XG5cbiAgICAgIGV2dC5jb250ZXh0cyA9IHtcbiAgICAgICAgdHJhY2U6IGN1cnJlbnRTY29wZXMuZ2V0VHJhY2VDb250ZXh0RnJvbVNjb3BlKGN1cnJlbnRTY29wZSksXG4gICAgICAgIC4uLmV2dC5jb250ZXh0cyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQkMSA9IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TY29wZSh0aGlzLCBjdXJyZW50U2NvcGUpO1xuXG4gICAgICBldnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0ge1xuICAgICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0OiBkeW5hbWljU2FtcGxpbmdDb250ZXh0JDEsXG4gICAgICAgIC4uLmV2dC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEsXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZXZ0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyB0aGUgZXZlbnQgYW5kIGxvZ3MgYW4gZXJyb3IgaW4gY2FzZSBvZiByZWplY3Rpb25cbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwYXJhbSBoaW50XG4gICAqIEBwYXJhbSBzY29wZVxuICAgKi9cbiAgIF9jYXB0dXJlRXZlbnQoXG4gICAgZXZlbnQsXG4gICAgaGludCA9IHt9LFxuICAgIGN1cnJlbnRTY29wZSA9IGN1cnJlbnRTY29wZXMuZ2V0Q3VycmVudFNjb3BlKCksXG4gICAgaXNvbGF0aW9uU2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldElzb2xhdGlvblNjb3BlKCksXG4gICkge1xuICAgIGlmIChkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGlzRXJyb3JFdmVudChldmVudCkpIHtcbiAgICAgIGxvZ2dlci5sb2dnZXIubG9nKGBDYXB0dXJlZCBlcnJvciBldmVudCBcXGAke2V2ZW50VXRpbHMuZ2V0UG9zc2libGVFdmVudE1lc3NhZ2VzKGV2ZW50KVswXSB8fCAnPHVua25vd24+J31cXGBgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc0V2ZW50KGV2ZW50LCBoaW50LCBjdXJyZW50U2NvcGUsIGlzb2xhdGlvblNjb3BlKS50aGVuKFxuICAgICAgZmluYWxFdmVudCA9PiB7XG4gICAgICAgIHJldHVybiBmaW5hbEV2ZW50LmV2ZW50X2lkO1xuICAgICAgfSxcbiAgICAgIHJlYXNvbiA9PiB7XG4gICAgICAgIGlmIChkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEKSB7XG4gICAgICAgICAgaWYgKF9pc0RvTm90U2VuZEV2ZW50RXJyb3IocmVhc29uKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZ2dlci5sb2cocmVhc29uLm1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX2lzSW50ZXJuYWxFcnJvcihyZWFzb24pKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nZ2VyLndhcm4ocmVhc29uLm1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nZ2VyLndhcm4ocmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYW4gZXZlbnQgKGVpdGhlciBlcnJvciBvciBtZXNzYWdlKSBhbmQgc2VuZHMgaXQgdG8gU2VudHJ5LlxuICAgKlxuICAgKiBUaGlzIGFsc28gYWRkcyBicmVhZGNydW1icyBhbmQgY29udGV4dCBpbmZvcm1hdGlvbiB0byB0aGUgZXZlbnQuIEhvd2V2ZXIsXG4gICAqIHBsYXRmb3JtIHNwZWNpZmljIG1ldGEgZGF0YSAoc3VjaCBhcyB0aGUgVXNlcidzIElQIGFkZHJlc3MpIG11c3QgYmUgYWRkZWRcbiAgICogYnkgdGhlIFNESyBpbXBsZW1lbnRvci5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBzZW5kIHRvIFNlbnRyeS5cbiAgICogQHBhcmFtIGhpbnQgTWF5IGNvbnRhaW4gYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uLlxuICAgKiBAcGFyYW0gY3VycmVudFNjb3BlIEEgc2NvcGUgY29udGFpbmluZyBldmVudCBtZXRhZGF0YS5cbiAgICogQHJldHVybnMgQSBTeW5jUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGV2ZW50IG9yIHJlamVjdHMgaW4gY2FzZSBldmVudCB3YXMvd2lsbCBub3QgYmUgc2VuZC5cbiAgICovXG4gICBfcHJvY2Vzc0V2ZW50KFxuICAgIGV2ZW50LFxuICAgIGhpbnQsXG4gICAgY3VycmVudFNjb3BlLFxuICAgIGlzb2xhdGlvblNjb3BlLFxuICApIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgY29uc3QgeyBzYW1wbGVSYXRlIH0gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgaXNUcmFuc2FjdGlvbiA9IGlzVHJhbnNhY3Rpb25FdmVudChldmVudCk7XG4gICAgY29uc3QgaXNFcnJvciA9IGlzRXJyb3JFdmVudChldmVudCk7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gZXZlbnQudHlwZSB8fCAnZXJyb3InO1xuICAgIGNvbnN0IGJlZm9yZVNlbmRMYWJlbCA9IGBiZWZvcmUgc2VuZCBmb3IgdHlwZSBcXGAke2V2ZW50VHlwZX1cXGBgO1xuXG4gICAgLy8gMS4wID09PSAxMDAlIGV2ZW50cyBhcmUgc2VudFxuICAgIC8vIDAuMCA9PT0gMCUgZXZlbnRzIGFyZSBzZW50XG4gICAgLy8gU2FtcGxpbmcgZm9yIHRyYW5zYWN0aW9uIGhhcHBlbnMgc29tZXdoZXJlIGVsc2VcbiAgICBjb25zdCBwYXJzZWRTYW1wbGVSYXRlID0gdHlwZW9mIHNhbXBsZVJhdGUgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogcGFyc2VTYW1wbGVSYXRlLnBhcnNlU2FtcGxlUmF0ZShzYW1wbGVSYXRlKTtcbiAgICBpZiAoaXNFcnJvciAmJiB0eXBlb2YgcGFyc2VkU2FtcGxlUmF0ZSA9PT0gJ251bWJlcicgJiYgTWF0aC5yYW5kb20oKSA+IHBhcnNlZFNhbXBsZVJhdGUpIHtcbiAgICAgIHRoaXMucmVjb3JkRHJvcHBlZEV2ZW50KCdzYW1wbGVfcmF0ZScsICdlcnJvcicpO1xuICAgICAgcmV0dXJuIHN5bmNwcm9taXNlLnJlamVjdGVkU3luY1Byb21pc2UoXG4gICAgICAgIF9tYWtlRG9Ob3RTZW5kRXZlbnRFcnJvcihcbiAgICAgICAgICBgRGlzY2FyZGluZyBldmVudCBiZWNhdXNlIGl0J3Mgbm90IGluY2x1ZGVkIGluIHRoZSByYW5kb20gc2FtcGxlIChzYW1wbGluZyByYXRlID0gJHtzYW1wbGVSYXRlfSlgLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhQ2F0ZWdvcnkgPSAoZXZlbnRUeXBlID09PSAncmVwbGF5X2V2ZW50JyA/ICdyZXBsYXknIDogZXZlbnRUeXBlKSA7XG5cbiAgICByZXR1cm4gdGhpcy5fcHJlcGFyZUV2ZW50KGV2ZW50LCBoaW50LCBjdXJyZW50U2NvcGUsIGlzb2xhdGlvblNjb3BlKVxuICAgICAgLnRoZW4ocHJlcGFyZWQgPT4ge1xuICAgICAgICBpZiAocHJlcGFyZWQgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlY29yZERyb3BwZWRFdmVudCgnZXZlbnRfcHJvY2Vzc29yJywgZGF0YUNhdGVnb3J5KTtcbiAgICAgICAgICB0aHJvdyBfbWFrZURvTm90U2VuZEV2ZW50RXJyb3IoJ0FuIGV2ZW50IHByb2Nlc3NvciByZXR1cm5lZCBgbnVsbGAsIHdpbGwgbm90IHNlbmQgZXZlbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0ludGVybmFsRXhjZXB0aW9uID0gaGludC5kYXRhICYmIChoaW50LmRhdGEgKS5fX3NlbnRyeV9fID09PSB0cnVlO1xuICAgICAgICBpZiAoaXNJbnRlcm5hbEV4Y2VwdGlvbikge1xuICAgICAgICAgIHJldHVybiBwcmVwYXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NCZWZvcmVTZW5kKHRoaXMsIG9wdGlvbnMsIHByZXBhcmVkLCBoaW50KTtcbiAgICAgICAgcmV0dXJuIF92YWxpZGF0ZUJlZm9yZVNlbmRSZXN1bHQocmVzdWx0LCBiZWZvcmVTZW5kTGFiZWwpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKHByb2Nlc3NlZEV2ZW50ID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3NlZEV2ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5yZWNvcmREcm9wcGVkRXZlbnQoJ2JlZm9yZV9zZW5kJywgZGF0YUNhdGVnb3J5KTtcbiAgICAgICAgICBpZiAoaXNUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgc3BhbnMgPSBldmVudC5zcGFucyB8fCBbXTtcbiAgICAgICAgICAgIC8vIHRoZSB0cmFuc2FjdGlvbiBpdHNlbGYgY291bnRzIGFzIG9uZSBzcGFuLCBwbHVzIGFsbCB0aGUgY2hpbGQgc3BhbnMgdGhhdCBhcmUgYWRkZWRcbiAgICAgICAgICAgIGNvbnN0IHNwYW5Db3VudCA9IDEgKyBzcGFucy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnJlY29yZERyb3BwZWRFdmVudCgnYmVmb3JlX3NlbmQnLCAnc3BhbicsIHNwYW5Db3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IF9tYWtlRG9Ob3RTZW5kRXZlbnRFcnJvcihgJHtiZWZvcmVTZW5kTGFiZWx9IHJldHVybmVkIFxcYG51bGxcXGAsIHdpbGwgbm90IHNlbmQgZXZlbnQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXNzaW9uID0gY3VycmVudFNjb3BlLmdldFNlc3Npb24oKSB8fCBpc29sYXRpb25TY29wZS5nZXRTZXNzaW9uKCk7XG4gICAgICAgIGlmIChpc0Vycm9yICYmIHNlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVTZXNzaW9uRnJvbUV2ZW50KHNlc3Npb24sIHByb2Nlc3NlZEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgY29uc3Qgc3BhbkNvdW50QmVmb3JlID0gcHJvY2Vzc2VkRXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhPy5zcGFuQ291bnRCZWZvcmVQcm9jZXNzaW5nIHx8IDA7XG4gICAgICAgICAgY29uc3Qgc3BhbkNvdW50QWZ0ZXIgPSBwcm9jZXNzZWRFdmVudC5zcGFucyA/IHByb2Nlc3NlZEV2ZW50LnNwYW5zLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgICBjb25zdCBkcm9wcGVkU3BhbkNvdW50ID0gc3BhbkNvdW50QmVmb3JlIC0gc3BhbkNvdW50QWZ0ZXI7XG4gICAgICAgICAgaWYgKGRyb3BwZWRTcGFuQ291bnQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29yZERyb3BwZWRFdmVudCgnYmVmb3JlX3NlbmQnLCAnc3BhbicsIGRyb3BwZWRTcGFuQ291bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vbmUgb2YgdGhlIFNlbnRyeSBidWlsdCBldmVudCBwcm9jZXNzb3Igd2lsbCB1cGRhdGUgdHJhbnNhY3Rpb24gbmFtZSxcbiAgICAgICAgLy8gc28gaWYgdGhlIHRyYW5zYWN0aW9uIG5hbWUgaGFzIGJlZW4gY2hhbmdlZCBieSBhbiBldmVudCBwcm9jZXNzb3IsIHdlIGtub3dcbiAgICAgICAgLy8gaXQgaGFzIHRvIGNvbWUgZnJvbSBjdXN0b20gZXZlbnQgcHJvY2Vzc29yIGFkZGVkIGJ5IGEgdXNlclxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkluZm8gPSBwcm9jZXNzZWRFdmVudC50cmFuc2FjdGlvbl9pbmZvO1xuICAgICAgICBpZiAoaXNUcmFuc2FjdGlvbiAmJiB0cmFuc2FjdGlvbkluZm8gJiYgcHJvY2Vzc2VkRXZlbnQudHJhbnNhY3Rpb24gIT09IGV2ZW50LnRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgY29uc3Qgc291cmNlID0gJ2N1c3RvbSc7XG4gICAgICAgICAgcHJvY2Vzc2VkRXZlbnQudHJhbnNhY3Rpb25faW5mbyA9IHtcbiAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uSW5mbyxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZW5kRXZlbnQocHJvY2Vzc2VkRXZlbnQsIGhpbnQpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRXZlbnQ7XG4gICAgICB9KVxuICAgICAgLnRoZW4obnVsbCwgcmVhc29uID0+IHtcbiAgICAgICAgaWYgKF9pc0RvTm90U2VuZEV2ZW50RXJyb3IocmVhc29uKSB8fCBfaXNJbnRlcm5hbEVycm9yKHJlYXNvbikpIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhcHR1cmVFeGNlcHRpb24ocmVhc29uLCB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgX19zZW50cnlfXzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9yaWdpbmFsRXhjZXB0aW9uOiByZWFzb24sXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBfbWFrZUludGVybmFsRXJyb3IoXG4gICAgICAgICAgYEV2ZW50IHByb2Nlc3NpbmcgcGlwZWxpbmUgdGhyZXcgYW4gZXJyb3IsIG9yaWdpbmFsIGV2ZW50IHdpbGwgbm90IGJlIHNlbnQuIERldGFpbHMgaGF2ZSBiZWVuIHNlbnQgYXMgYSBuZXcgZXZlbnQuXFxuUmVhc29uOiAke3JlYXNvbn1gLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXBpZXMgdGhlIGNsaWVudCB3aXRoIHByb2Nlc3NpbmcgYW5kIGV2ZW50XG4gICAqL1xuICAgX3Byb2Nlc3MocHJvbWlzZSkge1xuICAgIHRoaXMuX251bVByb2Nlc3NpbmcrKztcbiAgICB2b2lkIHByb21pc2UudGhlbihcbiAgICAgIHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5fbnVtUHJvY2Vzc2luZy0tO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9LFxuICAgICAgcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5fbnVtUHJvY2Vzc2luZy0tO1xuICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBvdXRjb21lcyBvbiB0aGlzIGNsaWVudCBhbmQgcmV0dXJucyB0aGVtLlxuICAgKi9cbiAgIF9jbGVhck91dGNvbWVzKCkge1xuICAgIGNvbnN0IG91dGNvbWVzID0gdGhpcy5fb3V0Y29tZXM7XG4gICAgdGhpcy5fb3V0Y29tZXMgPSB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob3V0Y29tZXMpLm1hcCgoW2tleSwgcXVhbnRpdHldKSA9PiB7XG4gICAgICBjb25zdCBbcmVhc29uLCBjYXRlZ29yeV0gPSBrZXkuc3BsaXQoJzonKSA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWFzb24sXG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBxdWFudGl0eSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgY2xpZW50IHJlcG9ydHMgYXMgYW4gZW52ZWxvcGUuXG4gICAqL1xuICAgX2ZsdXNoT3V0Y29tZXMoKSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLmxvZygnRmx1c2hpbmcgb3V0Y29tZXMuLi4nKTtcblxuICAgIGNvbnN0IG91dGNvbWVzID0gdGhpcy5fY2xlYXJPdXRjb21lcygpO1xuXG4gICAgaWYgKG91dGNvbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLmxvZygnTm8gb3V0Y29tZXMgdG8gc2VuZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgcmVhbGx5IHRoZSBvbmx5IHBsYWNlIHdoZXJlIHdlIHdhbnQgdG8gY2hlY2sgZm9yIGEgRFNOIGFuZCBvbmx5IHNlbmQgb3V0Y29tZXMgdGhlblxuICAgIGlmICghdGhpcy5fZHNuKSB7XG4gICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIubG9nKCdObyBkc24gcHJvdmlkZWQsIHdpbGwgbm90IHNlbmQgb3V0Y29tZXMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIubG9nKCdTZW5kaW5nIG91dGNvbWVzOicsIG91dGNvbWVzKTtcblxuICAgIGNvbnN0IGVudmVsb3BlID0gY2xpZW50cmVwb3J0LmNyZWF0ZUNsaWVudFJlcG9ydEVudmVsb3BlKG91dGNvbWVzLCB0aGlzLl9vcHRpb25zLnR1bm5lbCAmJiBkc24uZHNuVG9TdHJpbmcodGhpcy5fZHNuKSk7XG5cbiAgICAvLyBzZW5kRW52ZWxvcGUgc2hvdWxkIG5vdCB0aHJvd1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICB0aGlzLnNlbmRFbnZlbG9wZShlbnZlbG9wZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiB7QGxpbmsgRXZlbnR9IGZyb20gYWxsIGlucHV0cyB0byBgY2FwdHVyZUV4Y2VwdGlvbmAgYW5kIG5vbi1wcmltaXRpdmUgaW5wdXRzIHRvIGBjYXB0dXJlTWVzc2FnZWAuXG4gICAqL1xuXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBDbGllbnRgIGluc3RlYWQuIFRoaXMgYWxpYXMgbWF5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgdmVyc2lvbi5cbiAqL1xuLy8gVE9ETyh2MTApOiBSZW1vdmVcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYENsaWVudGAgaW5zdGVhZC4gVGhpcyBhbGlhcyBtYXkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciB2ZXJzaW9uLlxuICovXG4vLyBUT0RPKHYxMCk6IFJlbW92ZVxuY29uc3QgQmFzZUNsaWVudCA9IENsaWVudDtcblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IHJldHVybiB2YWx1ZSBvZiBjb25maWd1cmVkIGBiZWZvcmVTZW5kYCBvciBgYmVmb3JlU2VuZFRyYW5zYWN0aW9uYCBpcyBvZiBleHBlY3RlZCB0eXBlLCBhbmQgcmV0dXJucyB0aGUgdmFsdWUgaWYgc28uXG4gKi9cbmZ1bmN0aW9uIF92YWxpZGF0ZUJlZm9yZVNlbmRSZXN1bHQoXG4gIGJlZm9yZVNlbmRSZXN1bHQsXG4gIGJlZm9yZVNlbmRMYWJlbCxcbikge1xuICBjb25zdCBpbnZhbGlkVmFsdWVFcnJvciA9IGAke2JlZm9yZVNlbmRMYWJlbH0gbXVzdCByZXR1cm4gXFxgbnVsbFxcYCBvciBhIHZhbGlkIGV2ZW50LmA7XG4gIGlmIChpcy5pc1RoZW5hYmxlKGJlZm9yZVNlbmRSZXN1bHQpKSB7XG4gICAgcmV0dXJuIGJlZm9yZVNlbmRSZXN1bHQudGhlbihcbiAgICAgIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKCFpcy5pc1BsYWluT2JqZWN0KGV2ZW50KSAmJiBldmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IF9tYWtlSW50ZXJuYWxFcnJvcihpbnZhbGlkVmFsdWVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfSxcbiAgICAgIGUgPT4ge1xuICAgICAgICB0aHJvdyBfbWFrZUludGVybmFsRXJyb3IoYCR7YmVmb3JlU2VuZExhYmVsfSByZWplY3RlZCB3aXRoICR7ZX1gKTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfSBlbHNlIGlmICghaXMuaXNQbGFpbk9iamVjdChiZWZvcmVTZW5kUmVzdWx0KSAmJiBiZWZvcmVTZW5kUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgdGhyb3cgX21ha2VJbnRlcm5hbEVycm9yKGludmFsaWRWYWx1ZUVycm9yKTtcbiAgfVxuICByZXR1cm4gYmVmb3JlU2VuZFJlc3VsdDtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHRoZSBtYXRjaGluZyBgYmVmb3JlU2VuZFhYWGAgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NCZWZvcmVTZW5kKFxuICBjbGllbnQsXG4gIG9wdGlvbnMsXG4gIGV2ZW50LFxuICBoaW50LFxuKSB7XG4gIGNvbnN0IHsgYmVmb3JlU2VuZCwgYmVmb3JlU2VuZFRyYW5zYWN0aW9uLCBiZWZvcmVTZW5kU3BhbiB9ID0gb3B0aW9ucztcbiAgbGV0IHByb2Nlc3NlZEV2ZW50ID0gZXZlbnQ7XG5cbiAgaWYgKGlzRXJyb3JFdmVudChwcm9jZXNzZWRFdmVudCkgJiYgYmVmb3JlU2VuZCkge1xuICAgIHJldHVybiBiZWZvcmVTZW5kKHByb2Nlc3NlZEV2ZW50LCBoaW50KTtcbiAgfVxuXG4gIGlmIChpc1RyYW5zYWN0aW9uRXZlbnQocHJvY2Vzc2VkRXZlbnQpKSB7XG4gICAgaWYgKGJlZm9yZVNlbmRTcGFuKSB7XG4gICAgICAvLyBwcm9jZXNzIHJvb3Qgc3BhblxuICAgICAgY29uc3QgcHJvY2Vzc2VkUm9vdFNwYW5Kc29uID0gYmVmb3JlU2VuZFNwYW4odHJhbnNhY3Rpb25FdmVudC5jb252ZXJ0VHJhbnNhY3Rpb25FdmVudFRvU3Bhbkpzb24ocHJvY2Vzc2VkRXZlbnQpKTtcbiAgICAgIGlmICghcHJvY2Vzc2VkUm9vdFNwYW5Kc29uKSB7XG4gICAgICAgIHNwYW5VdGlscy5zaG93U3BhbkRyb3BXYXJuaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgZXZlbnQgd2l0aCBwcm9jZXNzZWQgcm9vdCBzcGFuIHZhbHVlc1xuICAgICAgICBwcm9jZXNzZWRFdmVudCA9IG1lcmdlLm1lcmdlKGV2ZW50LCB0cmFuc2FjdGlvbkV2ZW50LmNvbnZlcnRTcGFuSnNvblRvVHJhbnNhY3Rpb25FdmVudChwcm9jZXNzZWRSb290U3Bhbkpzb24pKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvY2VzcyBjaGlsZCBzcGFuc1xuICAgICAgaWYgKHByb2Nlc3NlZEV2ZW50LnNwYW5zKSB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZFNwYW5zID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3BhbiBvZiBwcm9jZXNzZWRFdmVudC5zcGFucykge1xuICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFNwYW4gPSBiZWZvcmVTZW5kU3BhbihzcGFuKTtcbiAgICAgICAgICBpZiAoIXByb2Nlc3NlZFNwYW4pIHtcbiAgICAgICAgICAgIHNwYW5VdGlscy5zaG93U3BhbkRyb3BXYXJuaW5nKCk7XG4gICAgICAgICAgICBwcm9jZXNzZWRTcGFucy5wdXNoKHNwYW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRTcGFucy5wdXNoKHByb2Nlc3NlZFNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzZWRFdmVudC5zcGFucyA9IHByb2Nlc3NlZFNwYW5zO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiZWZvcmVTZW5kVHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmIChwcm9jZXNzZWRFdmVudC5zcGFucykge1xuICAgICAgICAvLyBXZSBzdG9yZSB0aGUgIyBvZiBzcGFucyBiZWZvcmUgcHJvY2Vzc2luZyBpbiBTREsgbWV0YWRhdGEsXG4gICAgICAgIC8vIHNvIHdlIGNhbiBjb21wYXJlIGl0IGFmdGVyd2FyZHMgdG8gZGV0ZXJtaW5lIGhvdyBtYW55IHNwYW5zIHdlcmUgZHJvcHBlZFxuICAgICAgICBjb25zdCBzcGFuQ291bnRCZWZvcmUgPSBwcm9jZXNzZWRFdmVudC5zcGFucy5sZW5ndGg7XG4gICAgICAgIHByb2Nlc3NlZEV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IHtcbiAgICAgICAgICAuLi5ldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEsXG4gICAgICAgICAgc3BhbkNvdW50QmVmb3JlUHJvY2Vzc2luZzogc3BhbkNvdW50QmVmb3JlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJlZm9yZVNlbmRUcmFuc2FjdGlvbihwcm9jZXNzZWRFdmVudCAsIGhpbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9jZXNzZWRFdmVudDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvckV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzVHJhbnNhY3Rpb25FdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ3RyYW5zYWN0aW9uJztcbn1cblxuLyoqIEV4dHJhY3QgdHJhY2UgaW5mb3JtYXRpb24gZnJvbSBzY29wZSAqL1xuZnVuY3Rpb24gX2dldFRyYWNlSW5mb0Zyb21TY29wZShcbiAgY2xpZW50LFxuICBzY29wZSxcbikge1xuICBpZiAoIXNjb3BlKSB7XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG4gIH1cblxuICByZXR1cm4gY3VycmVudFNjb3Blcy53aXRoU2NvcGUoc2NvcGUsICgpID0+IHtcbiAgICBjb25zdCBzcGFuID0gc3BhblV0aWxzLmdldEFjdGl2ZVNwYW4oKTtcbiAgICBjb25zdCB0cmFjZUNvbnRleHQgPSBzcGFuID8gc3BhblV0aWxzLnNwYW5Ub1RyYWNlQ29udGV4dChzcGFuKSA6IGN1cnJlbnRTY29wZXMuZ2V0VHJhY2VDb250ZXh0RnJvbVNjb3BlKHNjb3BlKTtcbiAgICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0JDEgPSBzcGFuXG4gICAgICA/IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHNwYW4pXG4gICAgICA6IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TY29wZShjbGllbnQsIHNjb3BlKTtcbiAgICByZXR1cm4gW2R5bmFtaWNTYW1wbGluZ0NvbnRleHQkMSwgdHJhY2VDb250ZXh0XTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuQmFzZUNsaWVudCA9IEJhc2VDbGllbnQ7XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbmV4cG9ydHMuX2dldFRyYWNlSW5mb0Zyb21TY29wZSA9IF9nZXRUcmFjZUluZm9Gcm9tU2NvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/client.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/constants.js":(__unused_webpack_module,exports)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst DEFAULT_ENVIRONMENT = 'production';\n\nexports.DEFAULT_ENVIRONMENT = DEFAULT_ENVIRONMENT;\n//# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFOztBQUVBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgREVGQVVMVF9FTlZJUk9OTUVOVCA9ICdwcm9kdWN0aW9uJztcblxuZXhwb3J0cy5ERUZBVUxUX0VOVklST05NRU5UID0gREVGQVVMVF9FTlZJUk9OTUVOVDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/constants.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst index = __webpack_require__(/*! ./asyncContext/index.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/asyncContext/index.js");\nconst carrier = __webpack_require__(/*! ./carrier.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/carrier.js");\nconst scope = __webpack_require__(/*! ./scope.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/scope.js");\nconst propagationContext = __webpack_require__(/*! ./utils-hoist/propagationContext.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/propagationContext.js");\n\n/**\n * Get the currently active scope.\n */\nfunction getCurrentScope() {\n  const carrier$1 = carrier.getMainCarrier();\n  const acs = index.getAsyncContextStrategy(carrier$1);\n  return acs.getCurrentScope();\n}\n\n/**\n * Get the currently active isolation scope.\n * The isolation scope is active for the current execution context.\n */\nfunction getIsolationScope() {\n  const carrier$1 = carrier.getMainCarrier();\n  const acs = index.getAsyncContextStrategy(carrier$1);\n  return acs.getIsolationScope();\n}\n\n/**\n * Get the global scope.\n * This scope is applied to _all_ events.\n */\nfunction getGlobalScope() {\n  return carrier.getGlobalSingleton(\'globalScope\', () => new scope.Scope());\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n */\n\n/**\n * Either creates a new active scope, or sets the given scope as active scope in the given callback.\n */\nfunction withScope(\n  ...rest\n) {\n  const carrier$1 = carrier.getMainCarrier();\n  const acs = index.getAsyncContextStrategy(carrier$1);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [scope, callback] = rest;\n\n    if (!scope) {\n      return acs.withScope(callback);\n    }\n\n    return acs.withSetScope(scope, callback);\n  }\n\n  return acs.withScope(rest[0]);\n}\n\n/**\n * Attempts to fork the current isolation scope and the current scope based on the current async context strategy. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in "normal"\n * applications directly because it comes with pitfalls. Use at your own risk!\n */\n\n/**\n * Either creates a new active isolation scope, or sets the given isolation scope as active scope in the given callback.\n */\nfunction withIsolationScope(\n  ...rest\n\n) {\n  const carrier$1 = carrier.getMainCarrier();\n  const acs = index.getAsyncContextStrategy(carrier$1);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [isolationScope, callback] = rest;\n\n    if (!isolationScope) {\n      return acs.withIsolationScope(callback);\n    }\n\n    return acs.withSetIsolationScope(isolationScope, callback);\n  }\n\n  return acs.withIsolationScope(rest[0]);\n}\n\n/**\n * Get the currently active client.\n */\nfunction getClient() {\n  return getCurrentScope().getClient();\n}\n\n/**\n * Get a trace context for the given scope.\n */\nfunction getTraceContextFromScope(scope) {\n  const propagationContext$1 = scope.getPropagationContext();\n\n  const { traceId, parentSpanId, propagationSpanId } = propagationContext$1;\n\n  const traceContext = {\n    trace_id: traceId,\n    span_id: propagationSpanId || propagationContext.generateSpanId(),\n  };\n\n  if (parentSpanId) {\n    traceContext.parent_span_id = parentSpanId;\n  }\n\n  return traceContext;\n}\n\nexports.getClient = getClient;\nexports.getCurrentScope = getCurrentScope;\nexports.getGlobalScope = getGlobalScope;\nexports.getIsolationScope = getIsolationScope;\nexports.getTraceContextFromScope = getTraceContextFromScope;\nexports.withIsolationScope = withIsolationScope;\nexports.withScope = withScope;\n//# sourceMappingURL=currentScopes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvY3VycmVudFNjb3Blcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxjQUFjLG1CQUFPLENBQUMsOEhBQXlCO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLHdHQUFjO0FBQ3RDLGNBQWMsbUJBQU8sQ0FBQyxvR0FBWTtBQUNsQywyQkFBMkIsbUJBQU8sQ0FBQyxzSkFBcUM7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLDJDQUEyQzs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIseUJBQXlCO0FBQ3pCLGdDQUFnQztBQUNoQywwQkFBMEI7QUFDMUIsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcY3VycmVudFNjb3Blcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgaW5kZXggPSByZXF1aXJlKCcuL2FzeW5jQ29udGV4dC9pbmRleC5qcycpO1xuY29uc3QgY2FycmllciA9IHJlcXVpcmUoJy4vY2Fycmllci5qcycpO1xuY29uc3Qgc2NvcGUgPSByZXF1aXJlKCcuL3Njb3BlLmpzJyk7XG5jb25zdCBwcm9wYWdhdGlvbkNvbnRleHQgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3Byb3BhZ2F0aW9uQ29udGV4dC5qcycpO1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBzY29wZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuICBjb25zdCBjYXJyaWVyJDEgPSBjYXJyaWVyLmdldE1haW5DYXJyaWVyKCk7XG4gIGNvbnN0IGFjcyA9IGluZGV4LmdldEFzeW5jQ29udGV4dFN0cmF0ZWd5KGNhcnJpZXIkMSk7XG4gIHJldHVybiBhY3MuZ2V0Q3VycmVudFNjb3BlKCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIGlzb2xhdGlvbiBzY29wZS5cbiAqIFRoZSBpc29sYXRpb24gc2NvcGUgaXMgYWN0aXZlIGZvciB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZ2V0SXNvbGF0aW9uU2NvcGUoKSB7XG4gIGNvbnN0IGNhcnJpZXIkMSA9IGNhcnJpZXIuZ2V0TWFpbkNhcnJpZXIoKTtcbiAgY29uc3QgYWNzID0gaW5kZXguZ2V0QXN5bmNDb250ZXh0U3RyYXRlZ3koY2FycmllciQxKTtcbiAgcmV0dXJuIGFjcy5nZXRJc29sYXRpb25TY29wZSgpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZ2xvYmFsIHNjb3BlLlxuICogVGhpcyBzY29wZSBpcyBhcHBsaWVkIHRvIF9hbGxfIGV2ZW50cy5cbiAqL1xuZnVuY3Rpb24gZ2V0R2xvYmFsU2NvcGUoKSB7XG4gIHJldHVybiBjYXJyaWVyLmdldEdsb2JhbFNpbmdsZXRvbignZ2xvYmFsU2NvcGUnLCAoKSA9PiBuZXcgc2NvcGUuU2NvcGUoKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzY29wZSB3aXRoIGFuZCBleGVjdXRlcyB0aGUgZ2l2ZW4gb3BlcmF0aW9uIHdpdGhpbi5cbiAqIFRoZSBzY29wZSBpcyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgb25jZSB0aGUgb3BlcmF0aW9uXG4gKiBmaW5pc2hlcyBvciB0aHJvd3MuXG4gKi9cblxuLyoqXG4gKiBFaXRoZXIgY3JlYXRlcyBhIG5ldyBhY3RpdmUgc2NvcGUsIG9yIHNldHMgdGhlIGdpdmVuIHNjb3BlIGFzIGFjdGl2ZSBzY29wZSBpbiB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIHdpdGhTY29wZShcbiAgLi4ucmVzdFxuKSB7XG4gIGNvbnN0IGNhcnJpZXIkMSA9IGNhcnJpZXIuZ2V0TWFpbkNhcnJpZXIoKTtcbiAgY29uc3QgYWNzID0gaW5kZXguZ2V0QXN5bmNDb250ZXh0U3RyYXRlZ3koY2FycmllciQxKTtcblxuICAvLyBJZiBhIHNjb3BlIGlzIGRlZmluZWQsIHdlIHdhbnQgdG8gbWFrZSB0aGlzIHRoZSBhY3RpdmUgc2NvcGUgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBvbmVcbiAgaWYgKHJlc3QubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3QgW3Njb3BlLCBjYWxsYmFja10gPSByZXN0O1xuXG4gICAgaWYgKCFzY29wZSkge1xuICAgICAgcmV0dXJuIGFjcy53aXRoU2NvcGUoY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Mud2l0aFNldFNjb3BlKHNjb3BlLCBjYWxsYmFjayk7XG4gIH1cblxuICByZXR1cm4gYWNzLndpdGhTY29wZShyZXN0WzBdKTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBmb3JrIHRoZSBjdXJyZW50IGlzb2xhdGlvbiBzY29wZSBhbmQgdGhlIGN1cnJlbnQgc2NvcGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgYXN5bmMgY29udGV4dCBzdHJhdGVneS4gSWYgbm9cbiAqIGFzeW5jIGNvbnRleHQgc3RyYXRlZ3kgaXMgc2V0LCB0aGUgaXNvbGF0aW9uIHNjb3BlIGFuZCB0aGUgY3VycmVudCBzY29wZSB3aWxsIG5vdCBiZSBmb3JrZWQgKHRoaXMgaXMgY3VycmVudGx5IHRoZVxuICogY2FzZSwgZm9yIGV4YW1wbGUsIGluIHRoZSBicm93c2VyKS5cbiAqXG4gKiBVc2FnZSBvZiB0aGlzIGZ1bmN0aW9uIGluIGVudmlyb25tZW50cyB3aXRob3V0IGFzeW5jIGNvbnRleHQgc3RyYXRlZ3kgaXMgZGlzY291cmFnZWQgYW5kIG1heSBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgZm9yIFNlbnRyeSBTREsgYW5kIFNESyBpbnRlZ3JhdGlvbiBkZXZlbG9wbWVudC4gSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGJlIHVzZWQgaW4gXCJub3JtYWxcIlxuICogYXBwbGljYXRpb25zIGRpcmVjdGx5IGJlY2F1c2UgaXQgY29tZXMgd2l0aCBwaXRmYWxscy4gVXNlIGF0IHlvdXIgb3duIHJpc2shXG4gKi9cblxuLyoqXG4gKiBFaXRoZXIgY3JlYXRlcyBhIG5ldyBhY3RpdmUgaXNvbGF0aW9uIHNjb3BlLCBvciBzZXRzIHRoZSBnaXZlbiBpc29sYXRpb24gc2NvcGUgYXMgYWN0aXZlIHNjb3BlIGluIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gd2l0aElzb2xhdGlvblNjb3BlKFxuICAuLi5yZXN0XG5cbikge1xuICBjb25zdCBjYXJyaWVyJDEgPSBjYXJyaWVyLmdldE1haW5DYXJyaWVyKCk7XG4gIGNvbnN0IGFjcyA9IGluZGV4LmdldEFzeW5jQ29udGV4dFN0cmF0ZWd5KGNhcnJpZXIkMSk7XG5cbiAgLy8gSWYgYSBzY29wZSBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIG1ha2UgdGhpcyB0aGUgYWN0aXZlIHNjb3BlIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgb25lXG4gIGlmIChyZXN0Lmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IFtpc29sYXRpb25TY29wZSwgY2FsbGJhY2tdID0gcmVzdDtcblxuICAgIGlmICghaXNvbGF0aW9uU2NvcGUpIHtcbiAgICAgIHJldHVybiBhY3Mud2l0aElzb2xhdGlvblNjb3BlKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNzLndpdGhTZXRJc29sYXRpb25TY29wZShpc29sYXRpb25TY29wZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIGFjcy53aXRoSXNvbGF0aW9uU2NvcGUocmVzdFswXSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIGNsaWVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50KCkge1xuICByZXR1cm4gZ2V0Q3VycmVudFNjb3BlKCkuZ2V0Q2xpZW50KCk7XG59XG5cbi8qKlxuICogR2V0IGEgdHJhY2UgY29udGV4dCBmb3IgdGhlIGdpdmVuIHNjb3BlLlxuICovXG5mdW5jdGlvbiBnZXRUcmFjZUNvbnRleHRGcm9tU2NvcGUoc2NvcGUpIHtcbiAgY29uc3QgcHJvcGFnYXRpb25Db250ZXh0JDEgPSBzY29wZS5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKTtcblxuICBjb25zdCB7IHRyYWNlSWQsIHBhcmVudFNwYW5JZCwgcHJvcGFnYXRpb25TcGFuSWQgfSA9IHByb3BhZ2F0aW9uQ29udGV4dCQxO1xuXG4gIGNvbnN0IHRyYWNlQ29udGV4dCA9IHtcbiAgICB0cmFjZV9pZDogdHJhY2VJZCxcbiAgICBzcGFuX2lkOiBwcm9wYWdhdGlvblNwYW5JZCB8fCBwcm9wYWdhdGlvbkNvbnRleHQuZ2VuZXJhdGVTcGFuSWQoKSxcbiAgfTtcblxuICBpZiAocGFyZW50U3BhbklkKSB7XG4gICAgdHJhY2VDb250ZXh0LnBhcmVudF9zcGFuX2lkID0gcGFyZW50U3BhbklkO1xuICB9XG5cbiAgcmV0dXJuIHRyYWNlQ29udGV4dDtcbn1cblxuZXhwb3J0cy5nZXRDbGllbnQgPSBnZXRDbGllbnQ7XG5leHBvcnRzLmdldEN1cnJlbnRTY29wZSA9IGdldEN1cnJlbnRTY29wZTtcbmV4cG9ydHMuZ2V0R2xvYmFsU2NvcGUgPSBnZXRHbG9iYWxTY29wZTtcbmV4cG9ydHMuZ2V0SXNvbGF0aW9uU2NvcGUgPSBnZXRJc29sYXRpb25TY29wZTtcbmV4cG9ydHMuZ2V0VHJhY2VDb250ZXh0RnJvbVNjb3BlID0gZ2V0VHJhY2VDb250ZXh0RnJvbVNjb3BlO1xuZXhwb3J0cy53aXRoSXNvbGF0aW9uU2NvcGUgPSB3aXRoSXNvbGF0aW9uU2NvcGU7XG5leHBvcnRzLndpdGhTY29wZSA9IHdpdGhTY29wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnJlbnRTY29wZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js":(__unused_webpack_module,exports)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\nexports.DEBUG_BUILD = DEBUG_BUILD;\n//# sourceMappingURL=debug-build.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvZGVidWctYnVpbGQuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGRlYnVnLWJ1aWxkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG4vKipcbiAqIFRoaXMgc2VydmVzIGFzIGEgYnVpbGQgdGltZSBmbGFnIHRoYXQgd2lsbCBiZSB0cnVlIGJ5IGRlZmF1bHQsIGJ1dCBmYWxzZSBpbiBub24tZGVidWcgYnVpbGRzIG9yIGlmIHVzZXJzIHJlcGxhY2UgYF9fU0VOVFJZX0RFQlVHX19gIGluIHRoZWlyIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEFUVEVOVElPTjogVGhpcyBjb25zdGFudCBtdXN0IG5ldmVyIGNyb3NzIHBhY2thZ2UgYm91bmRhcmllcyAoaS5lLiBiZSBleHBvcnRlZCkgdG8gZ3VhcmFudGVlIHRoYXQgaXQgY2FuIGJlIHVzZWQgZm9yIHRyZWUgc2hha2luZy5cbiAqL1xuY29uc3QgREVCVUdfQlVJTEQgPSAodHlwZW9mIF9fU0VOVFJZX0RFQlVHX18gPT09ICd1bmRlZmluZWQnIHx8IF9fU0VOVFJZX0RFQlVHX18pO1xuXG5leHBvcnRzLkRFQlVHX0JVSUxEID0gREVCVUdfQlVJTEQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJ1Zy1idWlsZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/defaultScopes.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst carrier = __webpack_require__(/*! ./carrier.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/carrier.js\");\nconst scope = __webpack_require__(/*! ./scope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/scope.js\");\n\n/** Get the default current scope. */\nfunction getDefaultCurrentScope() {\n  return carrier.getGlobalSingleton('defaultCurrentScope', () => new scope.Scope());\n}\n\n/** Get the default isolation scope. */\nfunction getDefaultIsolationScope() {\n  return carrier.getGlobalSingleton('defaultIsolationScope', () => new scope.Scope());\n}\n\nexports.getDefaultCurrentScope = getDefaultCurrentScope;\nexports.getDefaultIsolationScope = getDefaultIsolationScope;\n//# sourceMappingURL=defaultScopes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvZGVmYXVsdFNjb3Blcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBYztBQUN0QyxjQUFjLG1CQUFPLENBQUMsb0dBQVk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QixnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxkZWZhdWx0U2NvcGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBjYXJyaWVyID0gcmVxdWlyZSgnLi9jYXJyaWVyLmpzJyk7XG5jb25zdCBzY29wZSA9IHJlcXVpcmUoJy4vc2NvcGUuanMnKTtcblxuLyoqIEdldCB0aGUgZGVmYXVsdCBjdXJyZW50IHNjb3BlLiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEN1cnJlbnRTY29wZSgpIHtcbiAgcmV0dXJuIGNhcnJpZXIuZ2V0R2xvYmFsU2luZ2xldG9uKCdkZWZhdWx0Q3VycmVudFNjb3BlJywgKCkgPT4gbmV3IHNjb3BlLlNjb3BlKCkpO1xufVxuXG4vKiogR2V0IHRoZSBkZWZhdWx0IGlzb2xhdGlvbiBzY29wZS4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRJc29sYXRpb25TY29wZSgpIHtcbiAgcmV0dXJuIGNhcnJpZXIuZ2V0R2xvYmFsU2luZ2xldG9uKCdkZWZhdWx0SXNvbGF0aW9uU2NvcGUnLCAoKSA9PiBuZXcgc2NvcGUuU2NvcGUoKSk7XG59XG5cbmV4cG9ydHMuZ2V0RGVmYXVsdEN1cnJlbnRTY29wZSA9IGdldERlZmF1bHRDdXJyZW50U2NvcGU7XG5leHBvcnRzLmdldERlZmF1bHRJc29sYXRpb25TY29wZSA9IGdldERlZmF1bHRJc29sYXRpb25TY29wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRTY29wZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/defaultScopes.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/envelope.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst dynamicSamplingContext = __webpack_require__(/*! ./tracing/dynamicSamplingContext.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js\");\nconst spanUtils = __webpack_require__(/*! ./utils/spanUtils.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanUtils.js\");\nconst dsn = __webpack_require__(/*! ./utils-hoist/dsn.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/dsn.js\");\nconst envelope = __webpack_require__(/*! ./utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\n__webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\n__webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\n\n/**\n * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.\n * Merge with existing data if any.\n **/\nfunction enhanceEventWithSdkInfo(event, sdkInfo) {\n  if (!sdkInfo) {\n    return event;\n  }\n  event.sdk = event.sdk || {};\n  event.sdk.name = event.sdk.name || sdkInfo.name;\n  event.sdk.version = event.sdk.version || sdkInfo.version;\n  event.sdk.integrations = [...(event.sdk.integrations || []), ...(sdkInfo.integrations || [])];\n  event.sdk.packages = [...(event.sdk.packages || []), ...(sdkInfo.packages || [])];\n  return event;\n}\n\n/** Creates an envelope from a Session */\nfunction createSessionEnvelope(\n  session,\n  dsn$1,\n  metadata,\n  tunnel,\n) {\n  const sdkInfo = envelope.getSdkMetadataForEnvelopeHeader(metadata);\n  const envelopeHeaders = {\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!tunnel && dsn$1 && { dsn: dsn.dsnToString(dsn$1) }),\n  };\n\n  const envelopeItem =\n    'aggregates' in session ? [{ type: 'sessions' }, session] : [{ type: 'session' }, session.toJSON()];\n\n  return envelope.createEnvelope(envelopeHeaders, [envelopeItem]);\n}\n\n/**\n * Create an Envelope from an event.\n */\nfunction createEventEnvelope(\n  event,\n  dsn,\n  metadata,\n  tunnel,\n) {\n  const sdkInfo = envelope.getSdkMetadataForEnvelopeHeader(metadata);\n\n  /*\n    Note: Due to TS, event.type may be `replay_event`, theoretically.\n    In practice, we never call `createEventEnvelope` with `replay_event` type,\n    and we'd have to adjust a looot of types to make this work properly.\n    We want to avoid casting this around, as that could lead to bugs (e.g. when we add another type)\n    So the safe choice is to really guard against the replay_event type here.\n  */\n  const eventType = event.type && event.type !== 'replay_event' ? event.type : 'event';\n\n  enhanceEventWithSdkInfo(event, metadata?.sdk);\n\n  const envelopeHeaders = envelope.createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete event.sdkProcessingMetadata;\n\n  const eventItem = [{ type: eventType }, event];\n  return envelope.createEnvelope(envelopeHeaders, [eventItem]);\n}\n\n/**\n * Create envelope from Span item.\n *\n * Takes an optional client and runs spans through `beforeSendSpan` if available.\n */\nfunction createSpanEnvelope(spans, client) {\n  function dscHasRequiredProps(dsc) {\n    return !!dsc.trace_id && !!dsc.public_key;\n  }\n\n  // For the moment we'll obtain the DSC from the first span in the array\n  // This might need to be changed if we permit sending multiple spans from\n  // different segments in one envelope\n  const dsc = dynamicSamplingContext.getDynamicSamplingContextFromSpan(spans[0]);\n\n  const dsn$1 = client?.getDsn();\n  const tunnel = client?.getOptions().tunnel;\n\n  const headers = {\n    sent_at: new Date().toISOString(),\n    ...(dscHasRequiredProps(dsc) && { trace: dsc }),\n    ...(!!tunnel && dsn$1 && { dsn: dsn.dsnToString(dsn$1) }),\n  };\n\n  const beforeSendSpan = client?.getOptions().beforeSendSpan;\n  const convertToSpanJSON = beforeSendSpan\n    ? (span) => {\n        const spanJson = spanUtils.spanToJSON(span);\n        const processedSpan = beforeSendSpan(spanJson);\n\n        if (!processedSpan) {\n          spanUtils.showSpanDropWarning();\n          return spanJson;\n        }\n\n        return processedSpan;\n      }\n    : spanUtils.spanToJSON;\n\n  const items = [];\n  for (const span of spans) {\n    const spanJson = convertToSpanJSON(span);\n    if (spanJson) {\n      items.push(envelope.createSpanEnvelopeItem(spanJson));\n    }\n  }\n\n  return envelope.createEnvelope(headers, items);\n}\n\nexports.createEventEnvelope = createEventEnvelope;\nexports.createSessionEnvelope = createSessionEnvelope;\nexports.createSpanEnvelope = createSpanEnvelope;\n//# sourceMappingURL=envelope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvZW52ZWxvcGUuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsK0JBQStCLG1CQUFPLENBQUMsc0pBQXFDO0FBQzVFLGtCQUFrQixtQkFBTyxDQUFDLHdIQUFzQjtBQUNoRCxZQUFZLG1CQUFPLENBQUMsd0hBQXNCO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLGtJQUEyQjtBQUNwRCxtQkFBTyxDQUFDLGdIQUFrQjtBQUMxQixtQkFBTyxDQUFDLDhIQUF5Qjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkMsK0JBQStCLDZCQUE2QjtBQUM1RDs7QUFFQTtBQUNBLGlDQUFpQyxrQkFBa0IsZ0JBQWdCLGlCQUFpQjs7QUFFcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRCwrQkFBK0IsNkJBQTZCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxlbnZlbG9wZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IHJlcXVpcmUoJy4vdHJhY2luZy9keW5hbWljU2FtcGxpbmdDb250ZXh0LmpzJyk7XG5jb25zdCBzcGFuVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3NwYW5VdGlscy5qcycpO1xuY29uc3QgZHNuID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9kc24uanMnKTtcbmNvbnN0IGVudmVsb3BlID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9lbnZlbG9wZS5qcycpO1xucmVxdWlyZSgnLi9kZWJ1Zy1idWlsZC5qcycpO1xucmVxdWlyZSgnLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcblxuLyoqXG4gKiBBcHBseSBTZGtJbmZvIChuYW1lLCB2ZXJzaW9uLCBwYWNrYWdlcywgaW50ZWdyYXRpb25zKSB0byB0aGUgY29ycmVzcG9uZGluZyBldmVudCBrZXkuXG4gKiBNZXJnZSB3aXRoIGV4aXN0aW5nIGRhdGEgaWYgYW55LlxuICoqL1xuZnVuY3Rpb24gZW5oYW5jZUV2ZW50V2l0aFNka0luZm8oZXZlbnQsIHNka0luZm8pIHtcbiAgaWYgKCFzZGtJbmZvKSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIGV2ZW50LnNkayA9IGV2ZW50LnNkayB8fCB7fTtcbiAgZXZlbnQuc2RrLm5hbWUgPSBldmVudC5zZGsubmFtZSB8fCBzZGtJbmZvLm5hbWU7XG4gIGV2ZW50LnNkay52ZXJzaW9uID0gZXZlbnQuc2RrLnZlcnNpb24gfHwgc2RrSW5mby52ZXJzaW9uO1xuICBldmVudC5zZGsuaW50ZWdyYXRpb25zID0gWy4uLihldmVudC5zZGsuaW50ZWdyYXRpb25zIHx8IFtdKSwgLi4uKHNka0luZm8uaW50ZWdyYXRpb25zIHx8IFtdKV07XG4gIGV2ZW50LnNkay5wYWNrYWdlcyA9IFsuLi4oZXZlbnQuc2RrLnBhY2thZ2VzIHx8IFtdKSwgLi4uKHNka0luZm8ucGFja2FnZXMgfHwgW10pXTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKiogQ3JlYXRlcyBhbiBlbnZlbG9wZSBmcm9tIGEgU2Vzc2lvbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2Vzc2lvbkVudmVsb3BlKFxuICBzZXNzaW9uLFxuICBkc24kMSxcbiAgbWV0YWRhdGEsXG4gIHR1bm5lbCxcbikge1xuICBjb25zdCBzZGtJbmZvID0gZW52ZWxvcGUuZ2V0U2RrTWV0YWRhdGFGb3JFbnZlbG9wZUhlYWRlcihtZXRhZGF0YSk7XG4gIGNvbnN0IGVudmVsb3BlSGVhZGVycyA9IHtcbiAgICBzZW50X2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgLi4uKHNka0luZm8gJiYgeyBzZGs6IHNka0luZm8gfSksXG4gICAgLi4uKCEhdHVubmVsICYmIGRzbiQxICYmIHsgZHNuOiBkc24uZHNuVG9TdHJpbmcoZHNuJDEpIH0pLFxuICB9O1xuXG4gIGNvbnN0IGVudmVsb3BlSXRlbSA9XG4gICAgJ2FnZ3JlZ2F0ZXMnIGluIHNlc3Npb24gPyBbeyB0eXBlOiAnc2Vzc2lvbnMnIH0sIHNlc3Npb25dIDogW3sgdHlwZTogJ3Nlc3Npb24nIH0sIHNlc3Npb24udG9KU09OKCldO1xuXG4gIHJldHVybiBlbnZlbG9wZS5jcmVhdGVFbnZlbG9wZShlbnZlbG9wZUhlYWRlcnMsIFtlbnZlbG9wZUl0ZW1dKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gRW52ZWxvcGUgZnJvbSBhbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXZlbnRFbnZlbG9wZShcbiAgZXZlbnQsXG4gIGRzbixcbiAgbWV0YWRhdGEsXG4gIHR1bm5lbCxcbikge1xuICBjb25zdCBzZGtJbmZvID0gZW52ZWxvcGUuZ2V0U2RrTWV0YWRhdGFGb3JFbnZlbG9wZUhlYWRlcihtZXRhZGF0YSk7XG5cbiAgLypcbiAgICBOb3RlOiBEdWUgdG8gVFMsIGV2ZW50LnR5cGUgbWF5IGJlIGByZXBsYXlfZXZlbnRgLCB0aGVvcmV0aWNhbGx5LlxuICAgIEluIHByYWN0aWNlLCB3ZSBuZXZlciBjYWxsIGBjcmVhdGVFdmVudEVudmVsb3BlYCB3aXRoIGByZXBsYXlfZXZlbnRgIHR5cGUsXG4gICAgYW5kIHdlJ2QgaGF2ZSB0byBhZGp1c3QgYSBsb29vdCBvZiB0eXBlcyB0byBtYWtlIHRoaXMgd29yayBwcm9wZXJseS5cbiAgICBXZSB3YW50IHRvIGF2b2lkIGNhc3RpbmcgdGhpcyBhcm91bmQsIGFzIHRoYXQgY291bGQgbGVhZCB0byBidWdzIChlLmcuIHdoZW4gd2UgYWRkIGFub3RoZXIgdHlwZSlcbiAgICBTbyB0aGUgc2FmZSBjaG9pY2UgaXMgdG8gcmVhbGx5IGd1YXJkIGFnYWluc3QgdGhlIHJlcGxheV9ldmVudCB0eXBlIGhlcmUuXG4gICovXG4gIGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50LnR5cGUgJiYgZXZlbnQudHlwZSAhPT0gJ3JlcGxheV9ldmVudCcgPyBldmVudC50eXBlIDogJ2V2ZW50JztcblxuICBlbmhhbmNlRXZlbnRXaXRoU2RrSW5mbyhldmVudCwgbWV0YWRhdGE/LnNkayk7XG5cbiAgY29uc3QgZW52ZWxvcGVIZWFkZXJzID0gZW52ZWxvcGUuY3JlYXRlRXZlbnRFbnZlbG9wZUhlYWRlcnMoZXZlbnQsIHNka0luZm8sIHR1bm5lbCwgZHNuKTtcblxuICAvLyBQcmV2ZW50IHRoaXMgZGF0YSAod2hpY2gsIGlmIGl0IGV4aXN0cywgd2FzIHVzZWQgaW4gZWFybGllciBzdGVwcyBpbiB0aGUgcHJvY2Vzc2luZyBwaXBlbGluZSkgZnJvbSBiZWluZyBzZW50IHRvXG4gIC8vIHNlbnRyeS4gKE5vdGU6IE91ciB1c2Ugb2YgdGhpcyBwcm9wZXJ0eSBjb21lcyBhbmQgZ29lcyB3aXRoIHdoYXRldmVyIHdlIG1pZ2h0IGJlIGRlYnVnZ2luZywgd2hhdGV2ZXIgaGFja3Mgd2UgbWF5XG4gIC8vIGhhdmUgdGVtcG9yYXJpbHkgYWRkZWQsIGV0Yy4gRXZlbiBpZiB3ZSBkb24ndCBoYXBwZW4gdG8gYmUgdXNpbmcgaXQgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLCBsZXQncyBub3QgZ2V0IHJpZFxuICAvLyBvZiB0aGlzIGBkZWxldGVgLCBsZXN0IHdlIG1pc3MgcHV0dGluZyBpdCBiYWNrIGluIHRoZSBuZXh0IHRpbWUgdGhlIHByb3BlcnR5IGlzIGluIHVzZS4pXG4gIGRlbGV0ZSBldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGE7XG5cbiAgY29uc3QgZXZlbnRJdGVtID0gW3sgdHlwZTogZXZlbnRUeXBlIH0sIGV2ZW50XTtcbiAgcmV0dXJuIGVudmVsb3BlLmNyZWF0ZUVudmVsb3BlKGVudmVsb3BlSGVhZGVycywgW2V2ZW50SXRlbV0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBlbnZlbG9wZSBmcm9tIFNwYW4gaXRlbS5cbiAqXG4gKiBUYWtlcyBhbiBvcHRpb25hbCBjbGllbnQgYW5kIHJ1bnMgc3BhbnMgdGhyb3VnaCBgYmVmb3JlU2VuZFNwYW5gIGlmIGF2YWlsYWJsZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3BhbkVudmVsb3BlKHNwYW5zLCBjbGllbnQpIHtcbiAgZnVuY3Rpb24gZHNjSGFzUmVxdWlyZWRQcm9wcyhkc2MpIHtcbiAgICByZXR1cm4gISFkc2MudHJhY2VfaWQgJiYgISFkc2MucHVibGljX2tleTtcbiAgfVxuXG4gIC8vIEZvciB0aGUgbW9tZW50IHdlJ2xsIG9idGFpbiB0aGUgRFNDIGZyb20gdGhlIGZpcnN0IHNwYW4gaW4gdGhlIGFycmF5XG4gIC8vIFRoaXMgbWlnaHQgbmVlZCB0byBiZSBjaGFuZ2VkIGlmIHdlIHBlcm1pdCBzZW5kaW5nIG11bHRpcGxlIHNwYW5zIGZyb21cbiAgLy8gZGlmZmVyZW50IHNlZ21lbnRzIGluIG9uZSBlbnZlbG9wZVxuICBjb25zdCBkc2MgPSBkeW5hbWljU2FtcGxpbmdDb250ZXh0LmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuc1swXSk7XG5cbiAgY29uc3QgZHNuJDEgPSBjbGllbnQ/LmdldERzbigpO1xuICBjb25zdCB0dW5uZWwgPSBjbGllbnQ/LmdldE9wdGlvbnMoKS50dW5uZWw7XG5cbiAgY29uc3QgaGVhZGVycyA9IHtcbiAgICBzZW50X2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgLi4uKGRzY0hhc1JlcXVpcmVkUHJvcHMoZHNjKSAmJiB7IHRyYWNlOiBkc2MgfSksXG4gICAgLi4uKCEhdHVubmVsICYmIGRzbiQxICYmIHsgZHNuOiBkc24uZHNuVG9TdHJpbmcoZHNuJDEpIH0pLFxuICB9O1xuXG4gIGNvbnN0IGJlZm9yZVNlbmRTcGFuID0gY2xpZW50Py5nZXRPcHRpb25zKCkuYmVmb3JlU2VuZFNwYW47XG4gIGNvbnN0IGNvbnZlcnRUb1NwYW5KU09OID0gYmVmb3JlU2VuZFNwYW5cbiAgICA/IChzcGFuKSA9PiB7XG4gICAgICAgIGNvbnN0IHNwYW5Kc29uID0gc3BhblV0aWxzLnNwYW5Ub0pTT04oc3Bhbik7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZFNwYW4gPSBiZWZvcmVTZW5kU3BhbihzcGFuSnNvbik7XG5cbiAgICAgICAgaWYgKCFwcm9jZXNzZWRTcGFuKSB7XG4gICAgICAgICAgc3BhblV0aWxzLnNob3dTcGFuRHJvcFdhcm5pbmcoKTtcbiAgICAgICAgICByZXR1cm4gc3Bhbkpzb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkU3BhbjtcbiAgICAgIH1cbiAgICA6IHNwYW5VdGlscy5zcGFuVG9KU09OO1xuXG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGZvciAoY29uc3Qgc3BhbiBvZiBzcGFucykge1xuICAgIGNvbnN0IHNwYW5Kc29uID0gY29udmVydFRvU3BhbkpTT04oc3Bhbik7XG4gICAgaWYgKHNwYW5Kc29uKSB7XG4gICAgICBpdGVtcy5wdXNoKGVudmVsb3BlLmNyZWF0ZVNwYW5FbnZlbG9wZUl0ZW0oc3Bhbkpzb24pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW52ZWxvcGUuY3JlYXRlRW52ZWxvcGUoaGVhZGVycywgaXRlbXMpO1xufVxuXG5leHBvcnRzLmNyZWF0ZUV2ZW50RW52ZWxvcGUgPSBjcmVhdGVFdmVudEVudmVsb3BlO1xuZXhwb3J0cy5jcmVhdGVTZXNzaW9uRW52ZWxvcGUgPSBjcmVhdGVTZXNzaW9uRW52ZWxvcGU7XG5leHBvcnRzLmNyZWF0ZVNwYW5FbnZlbG9wZSA9IGNyZWF0ZVNwYW5FbnZlbG9wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudmVsb3BlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/envelope.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/eventProcessors.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst debugBuild = __webpack_require__(/*! ./debug-build.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js");\nconst is = __webpack_require__(/*! ./utils-hoist/is.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/is.js");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js");\nconst syncpromise = __webpack_require__(/*! ./utils-hoist/syncpromise.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/syncpromise.js");\n\n/**\n * Process an array of event processors, returning the processed event (or `null` if the event was dropped).\n */\nfunction notifyEventProcessors(\n  processors,\n  event,\n  hint,\n  index = 0,\n) {\n  return new syncpromise.SyncPromise((resolve, reject) => {\n    const processor = processors[index];\n    if (event === null || typeof processor !== \'function\') {\n      resolve(event);\n    } else {\n      const result = processor({ ...event }, hint) ;\n\n      debugBuild.DEBUG_BUILD && processor.id && result === null && logger.logger.log(`Event processor "${processor.id}" dropped event`);\n\n      if (is.isThenable(result)) {\n        void result\n          .then(final => notifyEventProcessors(processors, final, hint, index + 1).then(resolve))\n          .then(null, reject);\n      } else {\n        void notifyEventProcessors(processors, result, hint, index + 1)\n          .then(resolve)\n          .then(null, reject);\n      }\n    }\n  });\n}\n\nexports.notifyEventProcessors = notifyEventProcessors;\n//# sourceMappingURL=eventProcessors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvZXZlbnRQcm9jZXNzb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLG1CQUFtQixtQkFBTyxDQUFDLGdIQUFrQjtBQUM3QyxXQUFXLG1CQUFPLENBQUMsc0hBQXFCO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDaEQsb0JBQW9CLG1CQUFPLENBQUMsd0lBQThCOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixpQ0FBaUMsVUFBVTs7QUFFM0MseUdBQXlHLGFBQWE7O0FBRXRIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcZXZlbnRQcm9jZXNzb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3QgaXMgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2lzLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuY29uc3Qgc3luY3Byb21pc2UgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3N5bmNwcm9taXNlLmpzJyk7XG5cbi8qKlxuICogUHJvY2VzcyBhbiBhcnJheSBvZiBldmVudCBwcm9jZXNzb3JzLCByZXR1cm5pbmcgdGhlIHByb2Nlc3NlZCBldmVudCAob3IgYG51bGxgIGlmIHRoZSBldmVudCB3YXMgZHJvcHBlZCkuXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeUV2ZW50UHJvY2Vzc29ycyhcbiAgcHJvY2Vzc29ycyxcbiAgZXZlbnQsXG4gIGhpbnQsXG4gIGluZGV4ID0gMCxcbikge1xuICByZXR1cm4gbmV3IHN5bmNwcm9taXNlLlN5bmNQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBwcm9jZXNzb3IgPSBwcm9jZXNzb3JzW2luZGV4XTtcbiAgICBpZiAoZXZlbnQgPT09IG51bGwgfHwgdHlwZW9mIHByb2Nlc3NvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVzb2x2ZShldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3Nvcih7IC4uLmV2ZW50IH0sIGhpbnQpIDtcblxuICAgICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBwcm9jZXNzb3IuaWQgJiYgcmVzdWx0ID09PSBudWxsICYmIGxvZ2dlci5sb2dnZXIubG9nKGBFdmVudCBwcm9jZXNzb3IgXCIke3Byb2Nlc3Nvci5pZH1cIiBkcm9wcGVkIGV2ZW50YCk7XG5cbiAgICAgIGlmIChpcy5pc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgdm9pZCByZXN1bHRcbiAgICAgICAgICAudGhlbihmaW5hbCA9PiBub3RpZnlFdmVudFByb2Nlc3NvcnMocHJvY2Vzc29ycywgZmluYWwsIGhpbnQsIGluZGV4ICsgMSkudGhlbihyZXNvbHZlKSlcbiAgICAgICAgICAudGhlbihudWxsLCByZWplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm9pZCBub3RpZnlFdmVudFByb2Nlc3NvcnMocHJvY2Vzc29ycywgcmVzdWx0LCBoaW50LCBpbmRleCArIDEpXG4gICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAudGhlbihudWxsLCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydHMubm90aWZ5RXZlbnRQcm9jZXNzb3JzID0gbm90aWZ5RXZlbnRQcm9jZXNzb3JzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRQcm9jZXNzb3JzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/eventProcessors.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/exports.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst session = __webpack_require__(/*! ./session.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/session.js\");\nconst prepareEvent = __webpack_require__(/*! ./utils/prepareEvent.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/prepareEvent.js\");\nconst is = __webpack_require__(/*! ./utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst misc = __webpack_require__(/*! ./utils-hoist/misc.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js\");\nconst time = __webpack_require__(/*! ./utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst worldwide = __webpack_require__(/*! ./utils-hoist/worldwide.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js\");\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */\nfunction captureException(exception, hint) {\n  return currentScopes.getCurrentScope().captureException(exception, prepareEvent.parseEventHintOrCaptureContext(hint));\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param captureContext Define the level of the message or pass in additional data to attach to the message.\n * @returns the id of the captured message.\n */\nfunction captureMessage(message, captureContext) {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const context = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  return currentScopes.getCurrentScope().captureMessage(message, level, context);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured event.\n */\nfunction captureEvent(event, hint) {\n  return currentScopes.getCurrentScope().captureEvent(event, hint);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\nfunction setContext(name, context) {\n  currentScopes.getIsolationScope().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nfunction setExtras(extras) {\n  currentScopes.getIsolationScope().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nfunction setExtra(key, extra) {\n  currentScopes.getIsolationScope().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nfunction setTags(tags) {\n  currentScopes.getIsolationScope().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nfunction setTag(key, value) {\n  currentScopes.getIsolationScope().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nfunction setUser(user) {\n  currentScopes.getIsolationScope().setUser(user);\n}\n\n/**\n * The last error event id of the isolation scope.\n *\n * Warning: This function really returns the last recorded error event id on the current\n * isolation scope. If you call this function after handling a certain error and another error\n * is captured in between, the last one is returned instead of the one you might expect.\n * Also, ids of events that were never sent to Sentry (for example because\n * they were dropped in `beforeSend`) could be returned.\n *\n * @returns The last event id of the isolation scope.\n */\nfunction lastEventId() {\n  return currentScopes.getIsolationScope().lastEventId();\n}\n\n/**\n * Create a cron monitor check in and send it to Sentry.\n *\n * @param checkIn An object that describes a check in.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction captureCheckIn(checkIn, upsertMonitorConfig) {\n  const scope = currentScopes.getCurrentScope();\n  const client = currentScopes.getClient();\n  if (!client) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('Cannot capture check-in. No client defined.');\n  } else if (!client.captureCheckIn) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('Cannot capture check-in. Client does not support sending check-ins.');\n  } else {\n    return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);\n  }\n\n  return misc.uuid4();\n}\n\n/**\n * Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.\n *\n * @param monitorSlug The distinct slug of the monitor.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction withMonitor(\n  monitorSlug,\n  callback,\n  upsertMonitorConfig,\n) {\n  const checkInId = captureCheckIn({ monitorSlug, status: 'in_progress' }, upsertMonitorConfig);\n  const now = time.timestampInSeconds();\n\n  function finishCheckIn(status) {\n    captureCheckIn({ monitorSlug, status, checkInId, duration: time.timestampInSeconds() - now });\n  }\n\n  return currentScopes.withIsolationScope(() => {\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback();\n    } catch (e) {\n      finishCheckIn('error');\n      throw e;\n    }\n\n    if (is.isThenable(maybePromiseResult)) {\n      Promise.resolve(maybePromiseResult).then(\n        () => {\n          finishCheckIn('ok');\n        },\n        e => {\n          finishCheckIn('error');\n          throw e;\n        },\n      );\n    } else {\n      finishCheckIn('ok');\n    }\n\n    return maybePromiseResult;\n  });\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function flush(timeout) {\n  const client = currentScopes.getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  debugBuild.DEBUG_BUILD && logger.logger.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function close(timeout) {\n  const client = currentScopes.getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  debugBuild.DEBUG_BUILD && logger.logger.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Returns true if Sentry has been properly initialized.\n */\nfunction isInitialized() {\n  return !!currentScopes.getClient();\n}\n\n/** If the SDK is initialized & enabled. */\nfunction isEnabled() {\n  const client = currentScopes.getClient();\n  return client?.getOptions().enabled !== false && !!client?.getTransport();\n}\n\n/**\n * Add an event processor.\n * This will be added to the current isolation scope, ensuring any event that is processed in the current execution\n * context will have the processor applied.\n */\nfunction addEventProcessor(callback) {\n  currentScopes.getIsolationScope().addEventProcessor(callback);\n}\n\n/**\n * Start a session on the current isolation scope.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns the new active session\n */\nfunction startSession(context) {\n  const isolationScope = currentScopes.getIsolationScope();\n  const currentScope = currentScopes.getCurrentScope();\n\n  // Will fetch userAgent if called from browser sdk\n  const { userAgent } = worldwide.GLOBAL_OBJ.navigator || {};\n\n  const session$1 = session.makeSession({\n    user: currentScope.getUser() || isolationScope.getUser(),\n    ...(userAgent && { userAgent }),\n    ...context,\n  });\n\n  // End existing session if there's one\n  const currentSession = isolationScope.getSession();\n  if (currentSession?.status === 'ok') {\n    session.updateSession(currentSession, { status: 'exited' });\n  }\n\n  endSession();\n\n  // Afterwards we set the new session on the scope\n  isolationScope.setSession(session$1);\n\n  return session$1;\n}\n\n/**\n * End the session on the current isolation scope.\n */\nfunction endSession() {\n  const isolationScope = currentScopes.getIsolationScope();\n  const currentScope = currentScopes.getCurrentScope();\n\n  const session$1 = currentScope.getSession() || isolationScope.getSession();\n  if (session$1) {\n    session.closeSession(session$1);\n  }\n  _sendSessionUpdate();\n\n  // the session is over; take it off of the scope\n  isolationScope.setSession();\n}\n\n/**\n * Sends the current Session on the scope\n */\nfunction _sendSessionUpdate() {\n  const isolationScope = currentScopes.getIsolationScope();\n  const client = currentScopes.getClient();\n  const session = isolationScope.getSession();\n  if (session && client) {\n    client.captureSession(session);\n  }\n}\n\n/**\n * Sends the current session on the scope to Sentry\n *\n * @param end If set the session will be marked as exited and removed from the scope.\n *            Defaults to `false`.\n */\nfunction captureSession(end = false) {\n  // both send the update and pull the session from the scope\n  if (end) {\n    endSession();\n    return;\n  }\n\n  // only send the update\n  _sendSessionUpdate();\n}\n\nexports.addEventProcessor = addEventProcessor;\nexports.captureCheckIn = captureCheckIn;\nexports.captureEvent = captureEvent;\nexports.captureException = captureException;\nexports.captureMessage = captureMessage;\nexports.captureSession = captureSession;\nexports.close = close;\nexports.endSession = endSession;\nexports.flush = flush;\nexports.isEnabled = isEnabled;\nexports.isInitialized = isInitialized;\nexports.lastEventId = lastEventId;\nexports.setContext = setContext;\nexports.setExtra = setExtra;\nexports.setExtras = setExtras;\nexports.setTag = setTag;\nexports.setTags = setTags;\nexports.setUser = setUser;\nexports.startSession = startSession;\nexports.withMonitor = withMonitor;\n//# sourceMappingURL=exports.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvZXhwb3J0cy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxzQkFBc0IsbUJBQU8sQ0FBQyxvSEFBb0I7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsZ0hBQWtCO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLHdHQUFjO0FBQ3RDLHFCQUFxQixtQkFBTyxDQUFDLDhIQUF5QjtBQUN0RCxXQUFXLG1CQUFPLENBQUMsc0hBQXFCO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLDBIQUF1QjtBQUM1QyxhQUFhLG1CQUFPLENBQUMsMEhBQXVCO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLG9JQUE0Qjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0NBQW9DO0FBQ3pFOztBQUVBO0FBQ0EscUJBQXFCLDJFQUEyRTtBQUNoRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwrREFBK0QsbUJBQW1CO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0QsbUJBQW1CO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsWUFBWTs7QUFFdEI7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsa0JBQWtCO0FBQzlEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsY0FBYztBQUNkLGVBQWU7QUFDZixlQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGV4cG9ydHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuL2N1cnJlbnRTY29wZXMuanMnKTtcbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBzZXNzaW9uID0gcmVxdWlyZSgnLi9zZXNzaW9uLmpzJyk7XG5jb25zdCBwcmVwYXJlRXZlbnQgPSByZXF1aXJlKCcuL3V0aWxzL3ByZXBhcmVFdmVudC5qcycpO1xuY29uc3QgaXMgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2lzLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuY29uc3QgbWlzYyA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvbWlzYy5qcycpO1xuY29uc3QgdGltZSA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvdGltZS5qcycpO1xuY29uc3Qgd29ybGR3aWRlID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC93b3JsZHdpZGUuanMnKTtcblxuLyoqXG4gKiBDYXB0dXJlcyBhbiBleGNlcHRpb24gZXZlbnQgYW5kIHNlbmRzIGl0IHRvIFNlbnRyeS5cbiAqXG4gKiBAcGFyYW0gZXhjZXB0aW9uIFRoZSBleGNlcHRpb24gdG8gY2FwdHVyZS5cbiAqIEBwYXJhbSBoaW50IE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YSB0byBhdHRhY2ggdG8gdGhlIFNlbnRyeSBldmVudC5cbiAqIEByZXR1cm5zIHRoZSBpZCBvZiB0aGUgY2FwdHVyZWQgU2VudHJ5IGV2ZW50LlxuICovXG5mdW5jdGlvbiBjYXB0dXJlRXhjZXB0aW9uKGV4Y2VwdGlvbiwgaGludCkge1xuICByZXR1cm4gY3VycmVudFNjb3Blcy5nZXRDdXJyZW50U2NvcGUoKS5jYXB0dXJlRXhjZXB0aW9uKGV4Y2VwdGlvbiwgcHJlcGFyZUV2ZW50LnBhcnNlRXZlbnRIaW50T3JDYXB0dXJlQ29udGV4dChoaW50KSk7XG59XG5cbi8qKlxuICogQ2FwdHVyZXMgYSBtZXNzYWdlIGV2ZW50IGFuZCBzZW5kcyBpdCB0byBTZW50cnkuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gc2VuZCB0byBTZW50cnkuXG4gKiBAcGFyYW0gY2FwdHVyZUNvbnRleHQgRGVmaW5lIHRoZSBsZXZlbCBvZiB0aGUgbWVzc2FnZSBvciBwYXNzIGluIGFkZGl0aW9uYWwgZGF0YSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB0aGUgaWQgb2YgdGhlIGNhcHR1cmVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVNZXNzYWdlKG1lc3NhZ2UsIGNhcHR1cmVDb250ZXh0KSB7XG4gIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHByb3ZpZGUgZXhwbGljaXQgc2NvcGVzIHVwZ3JhZGUsIHdpdGhvdXQgY2hhbmdpbmcgdGhlIG9yaWdpbmFsXG4gIC8vIGFyaXR5IG9mIHRoZSBgY2FwdHVyZU1lc3NhZ2UobWVzc2FnZSwgbGV2ZWwpYCBtZXRob2QuXG4gIGNvbnN0IGxldmVsID0gdHlwZW9mIGNhcHR1cmVDb250ZXh0ID09PSAnc3RyaW5nJyA/IGNhcHR1cmVDb250ZXh0IDogdW5kZWZpbmVkO1xuICBjb25zdCBjb250ZXh0ID0gdHlwZW9mIGNhcHR1cmVDb250ZXh0ICE9PSAnc3RyaW5nJyA/IHsgY2FwdHVyZUNvbnRleHQgfSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGN1cnJlbnRTY29wZXMuZ2V0Q3VycmVudFNjb3BlKCkuY2FwdHVyZU1lc3NhZ2UobWVzc2FnZSwgbGV2ZWwsIGNvbnRleHQpO1xufVxuXG4vKipcbiAqIENhcHR1cmVzIGEgbWFudWFsbHkgY3JlYXRlZCBldmVudCBhbmQgc2VuZHMgaXQgdG8gU2VudHJ5LlxuICpcbiAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gc2VuZCB0byBTZW50cnkuXG4gKiBAcGFyYW0gaGludCBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGEgdG8gYXR0YWNoIHRvIHRoZSBTZW50cnkgZXZlbnQuXG4gKiBAcmV0dXJucyB0aGUgaWQgb2YgdGhlIGNhcHR1cmVkIGV2ZW50LlxuICovXG5mdW5jdGlvbiBjYXB0dXJlRXZlbnQoZXZlbnQsIGhpbnQpIHtcbiAgcmV0dXJuIGN1cnJlbnRTY29wZXMuZ2V0Q3VycmVudFNjb3BlKCkuY2FwdHVyZUV2ZW50KGV2ZW50LCBoaW50KTtcbn1cblxuLyoqXG4gKiBTZXRzIGNvbnRleHQgZGF0YSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICogQHBhcmFtIG5hbWUgb2YgdGhlIGNvbnRleHRcbiAqIEBwYXJhbSBjb250ZXh0IEFueSBraW5kIG9mIGRhdGEuIFRoaXMgZGF0YSB3aWxsIGJlIG5vcm1hbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIHNldENvbnRleHQobmFtZSwgY29udGV4dCkge1xuICBjdXJyZW50U2NvcGVzLmdldElzb2xhdGlvblNjb3BlKCkuc2V0Q29udGV4dChuYW1lLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBTZXQgYW4gb2JqZWN0IHRoYXQgd2lsbCBiZSBtZXJnZWQgc2VudCBhcyBleHRyYSBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICogQHBhcmFtIGV4dHJhcyBFeHRyYXMgb2JqZWN0IHRvIG1lcmdlIGludG8gY3VycmVudCBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBzZXRFeHRyYXMoZXh0cmFzKSB7XG4gIGN1cnJlbnRTY29wZXMuZ2V0SXNvbGF0aW9uU2NvcGUoKS5zZXRFeHRyYXMoZXh0cmFzKTtcbn1cblxuLyoqXG4gKiBTZXQga2V5OnZhbHVlIHRoYXQgd2lsbCBiZSBzZW50IGFzIGV4dHJhIGRhdGEgd2l0aCB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ga2V5IFN0cmluZyBvZiBleHRyYVxuICogQHBhcmFtIGV4dHJhIEFueSBraW5kIG9mIGRhdGEuIFRoaXMgZGF0YSB3aWxsIGJlIG5vcm1hbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIHNldEV4dHJhKGtleSwgZXh0cmEpIHtcbiAgY3VycmVudFNjb3Blcy5nZXRJc29sYXRpb25TY29wZSgpLnNldEV4dHJhKGtleSwgZXh0cmEpO1xufVxuXG4vKipcbiAqIFNldCBhbiBvYmplY3QgdGhhdCB3aWxsIGJlIG1lcmdlZCBzZW50IGFzIHRhZ3MgZGF0YSB3aXRoIHRoZSBldmVudC5cbiAqIEBwYXJhbSB0YWdzIFRhZ3MgY29udGV4dCBvYmplY3QgdG8gbWVyZ2UgaW50byBjdXJyZW50IGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIHNldFRhZ3ModGFncykge1xuICBjdXJyZW50U2NvcGVzLmdldElzb2xhdGlvblNjb3BlKCkuc2V0VGFncyh0YWdzKTtcbn1cblxuLyoqXG4gKiBTZXQga2V5OnZhbHVlIHRoYXQgd2lsbCBiZSBzZW50IGFzIHRhZ3MgZGF0YSB3aXRoIHRoZSBldmVudC5cbiAqXG4gKiBDYW4gYWxzbyBiZSB1c2VkIHRvIHVuc2V0IGEgdGFnLCBieSBwYXNzaW5nIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSBrZXkgU3RyaW5nIGtleSBvZiB0YWdcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSBvZiB0YWdcbiAqL1xuZnVuY3Rpb24gc2V0VGFnKGtleSwgdmFsdWUpIHtcbiAgY3VycmVudFNjb3Blcy5nZXRJc29sYXRpb25TY29wZSgpLnNldFRhZyhrZXksIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHVzZXIgY29udGV4dCBpbmZvcm1hdGlvbiBmb3IgZnV0dXJlIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0gdXNlciBVc2VyIGNvbnRleHQgb2JqZWN0IHRvIGJlIHNldCBpbiB0aGUgY3VycmVudCBjb250ZXh0LiBQYXNzIGBudWxsYCB0byB1bnNldCB0aGUgdXNlci5cbiAqL1xuZnVuY3Rpb24gc2V0VXNlcih1c2VyKSB7XG4gIGN1cnJlbnRTY29wZXMuZ2V0SXNvbGF0aW9uU2NvcGUoKS5zZXRVc2VyKHVzZXIpO1xufVxuXG4vKipcbiAqIFRoZSBsYXN0IGVycm9yIGV2ZW50IGlkIG9mIHRoZSBpc29sYXRpb24gc2NvcGUuXG4gKlxuICogV2FybmluZzogVGhpcyBmdW5jdGlvbiByZWFsbHkgcmV0dXJucyB0aGUgbGFzdCByZWNvcmRlZCBlcnJvciBldmVudCBpZCBvbiB0aGUgY3VycmVudFxuICogaXNvbGF0aW9uIHNjb3BlLiBJZiB5b3UgY2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIGhhbmRsaW5nIGEgY2VydGFpbiBlcnJvciBhbmQgYW5vdGhlciBlcnJvclxuICogaXMgY2FwdHVyZWQgaW4gYmV0d2VlbiwgdGhlIGxhc3Qgb25lIGlzIHJldHVybmVkIGluc3RlYWQgb2YgdGhlIG9uZSB5b3UgbWlnaHQgZXhwZWN0LlxuICogQWxzbywgaWRzIG9mIGV2ZW50cyB0aGF0IHdlcmUgbmV2ZXIgc2VudCB0byBTZW50cnkgKGZvciBleGFtcGxlIGJlY2F1c2VcbiAqIHRoZXkgd2VyZSBkcm9wcGVkIGluIGBiZWZvcmVTZW5kYCkgY291bGQgYmUgcmV0dXJuZWQuXG4gKlxuICogQHJldHVybnMgVGhlIGxhc3QgZXZlbnQgaWQgb2YgdGhlIGlzb2xhdGlvbiBzY29wZS5cbiAqL1xuZnVuY3Rpb24gbGFzdEV2ZW50SWQoKSB7XG4gIHJldHVybiBjdXJyZW50U2NvcGVzLmdldElzb2xhdGlvblNjb3BlKCkubGFzdEV2ZW50SWQoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjcm9uIG1vbml0b3IgY2hlY2sgaW4gYW5kIHNlbmQgaXQgdG8gU2VudHJ5LlxuICpcbiAqIEBwYXJhbSBjaGVja0luIEFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIGNoZWNrIGluLlxuICogQHBhcmFtIHVwc2VydE1vbml0b3JDb25maWcgQW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbW9uaXRvciBjb25maWcuIFVzZSB0aGlzIGlmIHlvdSB3YW50XG4gKiB0byBjcmVhdGUgYSBtb25pdG9yIGF1dG9tYXRpY2FsbHkgd2hlbiBzZW5kaW5nIGEgY2hlY2sgaW4uXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVDaGVja0luKGNoZWNrSW4sIHVwc2VydE1vbml0b3JDb25maWcpIHtcbiAgY29uc3Qgc2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldEN1cnJlbnRTY29wZSgpO1xuICBjb25zdCBjbGllbnQgPSBjdXJyZW50U2NvcGVzLmdldENsaWVudCgpO1xuICBpZiAoIWNsaWVudCkge1xuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdDYW5ub3QgY2FwdHVyZSBjaGVjay1pbi4gTm8gY2xpZW50IGRlZmluZWQuJyk7XG4gIH0gZWxzZSBpZiAoIWNsaWVudC5jYXB0dXJlQ2hlY2tJbikge1xuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdDYW5ub3QgY2FwdHVyZSBjaGVjay1pbi4gQ2xpZW50IGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyBjaGVjay1pbnMuJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNsaWVudC5jYXB0dXJlQ2hlY2tJbihjaGVja0luLCB1cHNlcnRNb25pdG9yQ29uZmlnLCBzY29wZSk7XG4gIH1cblxuICByZXR1cm4gbWlzYy51dWlkNCgpO1xufVxuXG4vKipcbiAqIFdyYXBzIGEgY2FsbGJhY2sgd2l0aCBhIGNyb24gbW9uaXRvciBjaGVjayBpbi4gVGhlIGNoZWNrIGluIHdpbGwgYmUgc2VudCB0byBTZW50cnkgd2hlbiB0aGUgY2FsbGJhY2sgZmluaXNoZXMuXG4gKlxuICogQHBhcmFtIG1vbml0b3JTbHVnIFRoZSBkaXN0aW5jdCBzbHVnIG9mIHRoZSBtb25pdG9yLlxuICogQHBhcmFtIHVwc2VydE1vbml0b3JDb25maWcgQW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbW9uaXRvciBjb25maWcuIFVzZSB0aGlzIGlmIHlvdSB3YW50XG4gKiB0byBjcmVhdGUgYSBtb25pdG9yIGF1dG9tYXRpY2FsbHkgd2hlbiBzZW5kaW5nIGEgY2hlY2sgaW4uXG4gKi9cbmZ1bmN0aW9uIHdpdGhNb25pdG9yKFxuICBtb25pdG9yU2x1ZyxcbiAgY2FsbGJhY2ssXG4gIHVwc2VydE1vbml0b3JDb25maWcsXG4pIHtcbiAgY29uc3QgY2hlY2tJbklkID0gY2FwdHVyZUNoZWNrSW4oeyBtb25pdG9yU2x1Zywgc3RhdHVzOiAnaW5fcHJvZ3Jlc3MnIH0sIHVwc2VydE1vbml0b3JDb25maWcpO1xuICBjb25zdCBub3cgPSB0aW1lLnRpbWVzdGFtcEluU2Vjb25kcygpO1xuXG4gIGZ1bmN0aW9uIGZpbmlzaENoZWNrSW4oc3RhdHVzKSB7XG4gICAgY2FwdHVyZUNoZWNrSW4oeyBtb25pdG9yU2x1Zywgc3RhdHVzLCBjaGVja0luSWQsIGR1cmF0aW9uOiB0aW1lLnRpbWVzdGFtcEluU2Vjb25kcygpIC0gbm93IH0pO1xuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRTY29wZXMud2l0aElzb2xhdGlvblNjb3BlKCgpID0+IHtcbiAgICBsZXQgbWF5YmVQcm9taXNlUmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBtYXliZVByb21pc2VSZXN1bHQgPSBjYWxsYmFjaygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGZpbmlzaENoZWNrSW4oJ2Vycm9yJyk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChpcy5pc1RoZW5hYmxlKG1heWJlUHJvbWlzZVJlc3VsdCkpIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZShtYXliZVByb21pc2VSZXN1bHQpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBmaW5pc2hDaGVja0luKCdvaycpO1xuICAgICAgICB9LFxuICAgICAgICBlID0+IHtcbiAgICAgICAgICBmaW5pc2hDaGVja0luKCdlcnJvcicpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5pc2hDaGVja0luKCdvaycpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZVByb21pc2VSZXN1bHQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIENhbGwgYGZsdXNoKClgIG9uIHRoZSBjdXJyZW50IGNsaWVudCwgaWYgdGhlcmUgaXMgb25lLiBTZWUge0BsaW5rIENsaWVudC5mbHVzaH0uXG4gKlxuICogQHBhcmFtIHRpbWVvdXQgTWF4aW11bSB0aW1lIGluIG1zIHRoZSBjbGllbnQgc2hvdWxkIHdhaXQgdG8gZmx1c2ggaXRzIGV2ZW50IHF1ZXVlLiBPbWl0dGluZyB0aGlzIHBhcmFtZXRlciB3aWxsIGNhdXNlXG4gKiB0aGUgY2xpZW50IHRvIHdhaXQgdW50aWwgYWxsIGV2ZW50cyBhcmUgc2VudCBiZWZvcmUgcmVzb2x2aW5nIHRoZSBwcm9taXNlLlxuICogQHJldHVybnMgQSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIGB0cnVlYCBpZiB0aGUgcXVldWUgc3VjY2Vzc2Z1bGx5IGRyYWlucyBiZWZvcmUgdGhlIHRpbWVvdXQsIG9yIGBmYWxzZWAgaWYgaXRcbiAqIGRvZXNuJ3QgKG9yIGlmIHRoZXJlJ3Mgbm8gY2xpZW50IGRlZmluZWQpLlxuICovXG5hc3luYyBmdW5jdGlvbiBmbHVzaCh0aW1lb3V0KSB7XG4gIGNvbnN0IGNsaWVudCA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG4gIGlmIChjbGllbnQpIHtcbiAgICByZXR1cm4gY2xpZW50LmZsdXNoKHRpbWVvdXQpO1xuICB9XG4gIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdDYW5ub3QgZmx1c2ggZXZlbnRzLiBObyBjbGllbnQgZGVmaW5lZC4nKTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG59XG5cbi8qKlxuICogQ2FsbCBgY2xvc2UoKWAgb24gdGhlIGN1cnJlbnQgY2xpZW50LCBpZiB0aGVyZSBpcyBvbmUuIFNlZSB7QGxpbmsgQ2xpZW50LmNsb3NlfS5cbiAqXG4gKiBAcGFyYW0gdGltZW91dCBNYXhpbXVtIHRpbWUgaW4gbXMgdGhlIGNsaWVudCBzaG91bGQgd2FpdCB0byBmbHVzaCBpdHMgZXZlbnQgcXVldWUgYmVmb3JlIHNodXR0aW5nIGRvd24uIE9taXR0aW5nIHRoaXNcbiAqIHBhcmFtZXRlciB3aWxsIGNhdXNlIHRoZSBjbGllbnQgdG8gd2FpdCB1bnRpbCBhbGwgZXZlbnRzIGFyZSBzZW50IGJlZm9yZSBkaXNhYmxpbmcgaXRzZWxmLlxuICogQHJldHVybnMgQSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIGB0cnVlYCBpZiB0aGUgcXVldWUgc3VjY2Vzc2Z1bGx5IGRyYWlucyBiZWZvcmUgdGhlIHRpbWVvdXQsIG9yIGBmYWxzZWAgaWYgaXRcbiAqIGRvZXNuJ3QgKG9yIGlmIHRoZXJlJ3Mgbm8gY2xpZW50IGRlZmluZWQpLlxuICovXG5hc3luYyBmdW5jdGlvbiBjbG9zZSh0aW1lb3V0KSB7XG4gIGNvbnN0IGNsaWVudCA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG4gIGlmIChjbGllbnQpIHtcbiAgICByZXR1cm4gY2xpZW50LmNsb3NlKHRpbWVvdXQpO1xuICB9XG4gIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdDYW5ub3QgZmx1c2ggZXZlbnRzIGFuZCBkaXNhYmxlIFNESy4gTm8gY2xpZW50IGRlZmluZWQuJyk7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBTZW50cnkgaGFzIGJlZW4gcHJvcGVybHkgaW5pdGlhbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzSW5pdGlhbGl6ZWQoKSB7XG4gIHJldHVybiAhIWN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG59XG5cbi8qKiBJZiB0aGUgU0RLIGlzIGluaXRpYWxpemVkICYgZW5hYmxlZC4gKi9cbmZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcbiAgY29uc3QgY2xpZW50ID0gY3VycmVudFNjb3Blcy5nZXRDbGllbnQoKTtcbiAgcmV0dXJuIGNsaWVudD8uZ2V0T3B0aW9ucygpLmVuYWJsZWQgIT09IGZhbHNlICYmICEhY2xpZW50Py5nZXRUcmFuc3BvcnQoKTtcbn1cblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgcHJvY2Vzc29yLlxuICogVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjdXJyZW50IGlzb2xhdGlvbiBzY29wZSwgZW5zdXJpbmcgYW55IGV2ZW50IHRoYXQgaXMgcHJvY2Vzc2VkIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvblxuICogY29udGV4dCB3aWxsIGhhdmUgdGhlIHByb2Nlc3NvciBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBhZGRFdmVudFByb2Nlc3NvcihjYWxsYmFjaykge1xuICBjdXJyZW50U2NvcGVzLmdldElzb2xhdGlvblNjb3BlKCkuYWRkRXZlbnRQcm9jZXNzb3IoY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFN0YXJ0IGEgc2Vzc2lvbiBvbiB0aGUgY3VycmVudCBpc29sYXRpb24gc2NvcGUuXG4gKlxuICogQHBhcmFtIGNvbnRleHQgKG9wdGlvbmFsKSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgcmV0dXJuZWQgc2Vzc2lvbiBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB0aGUgbmV3IGFjdGl2ZSBzZXNzaW9uXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0U2Vzc2lvbihjb250ZXh0KSB7XG4gIGNvbnN0IGlzb2xhdGlvblNjb3BlID0gY3VycmVudFNjb3Blcy5nZXRJc29sYXRpb25TY29wZSgpO1xuICBjb25zdCBjdXJyZW50U2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldEN1cnJlbnRTY29wZSgpO1xuXG4gIC8vIFdpbGwgZmV0Y2ggdXNlckFnZW50IGlmIGNhbGxlZCBmcm9tIGJyb3dzZXIgc2RrXG4gIGNvbnN0IHsgdXNlckFnZW50IH0gPSB3b3JsZHdpZGUuR0xPQkFMX09CSi5uYXZpZ2F0b3IgfHwge307XG5cbiAgY29uc3Qgc2Vzc2lvbiQxID0gc2Vzc2lvbi5tYWtlU2Vzc2lvbih7XG4gICAgdXNlcjogY3VycmVudFNjb3BlLmdldFVzZXIoKSB8fCBpc29sYXRpb25TY29wZS5nZXRVc2VyKCksXG4gICAgLi4uKHVzZXJBZ2VudCAmJiB7IHVzZXJBZ2VudCB9KSxcbiAgICAuLi5jb250ZXh0LFxuICB9KTtcblxuICAvLyBFbmQgZXhpc3Rpbmcgc2Vzc2lvbiBpZiB0aGVyZSdzIG9uZVxuICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IGlzb2xhdGlvblNjb3BlLmdldFNlc3Npb24oKTtcbiAgaWYgKGN1cnJlbnRTZXNzaW9uPy5zdGF0dXMgPT09ICdvaycpIHtcbiAgICBzZXNzaW9uLnVwZGF0ZVNlc3Npb24oY3VycmVudFNlc3Npb24sIHsgc3RhdHVzOiAnZXhpdGVkJyB9KTtcbiAgfVxuXG4gIGVuZFNlc3Npb24oKTtcblxuICAvLyBBZnRlcndhcmRzIHdlIHNldCB0aGUgbmV3IHNlc3Npb24gb24gdGhlIHNjb3BlXG4gIGlzb2xhdGlvblNjb3BlLnNldFNlc3Npb24oc2Vzc2lvbiQxKTtcblxuICByZXR1cm4gc2Vzc2lvbiQxO1xufVxuXG4vKipcbiAqIEVuZCB0aGUgc2Vzc2lvbiBvbiB0aGUgY3VycmVudCBpc29sYXRpb24gc2NvcGUuXG4gKi9cbmZ1bmN0aW9uIGVuZFNlc3Npb24oKSB7XG4gIGNvbnN0IGlzb2xhdGlvblNjb3BlID0gY3VycmVudFNjb3Blcy5nZXRJc29sYXRpb25TY29wZSgpO1xuICBjb25zdCBjdXJyZW50U2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldEN1cnJlbnRTY29wZSgpO1xuXG4gIGNvbnN0IHNlc3Npb24kMSA9IGN1cnJlbnRTY29wZS5nZXRTZXNzaW9uKCkgfHwgaXNvbGF0aW9uU2NvcGUuZ2V0U2Vzc2lvbigpO1xuICBpZiAoc2Vzc2lvbiQxKSB7XG4gICAgc2Vzc2lvbi5jbG9zZVNlc3Npb24oc2Vzc2lvbiQxKTtcbiAgfVxuICBfc2VuZFNlc3Npb25VcGRhdGUoKTtcblxuICAvLyB0aGUgc2Vzc2lvbiBpcyBvdmVyOyB0YWtlIGl0IG9mZiBvZiB0aGUgc2NvcGVcbiAgaXNvbGF0aW9uU2NvcGUuc2V0U2Vzc2lvbigpO1xufVxuXG4vKipcbiAqIFNlbmRzIHRoZSBjdXJyZW50IFNlc3Npb24gb24gdGhlIHNjb3BlXG4gKi9cbmZ1bmN0aW9uIF9zZW5kU2Vzc2lvblVwZGF0ZSgpIHtcbiAgY29uc3QgaXNvbGF0aW9uU2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldElzb2xhdGlvblNjb3BlKCk7XG4gIGNvbnN0IGNsaWVudCA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG4gIGNvbnN0IHNlc3Npb24gPSBpc29sYXRpb25TY29wZS5nZXRTZXNzaW9uKCk7XG4gIGlmIChzZXNzaW9uICYmIGNsaWVudCkge1xuICAgIGNsaWVudC5jYXB0dXJlU2Vzc2lvbihzZXNzaW9uKTtcbiAgfVxufVxuXG4vKipcbiAqIFNlbmRzIHRoZSBjdXJyZW50IHNlc3Npb24gb24gdGhlIHNjb3BlIHRvIFNlbnRyeVxuICpcbiAqIEBwYXJhbSBlbmQgSWYgc2V0IHRoZSBzZXNzaW9uIHdpbGwgYmUgbWFya2VkIGFzIGV4aXRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBzY29wZS5cbiAqICAgICAgICAgICAgRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FwdHVyZVNlc3Npb24oZW5kID0gZmFsc2UpIHtcbiAgLy8gYm90aCBzZW5kIHRoZSB1cGRhdGUgYW5kIHB1bGwgdGhlIHNlc3Npb24gZnJvbSB0aGUgc2NvcGVcbiAgaWYgKGVuZCkge1xuICAgIGVuZFNlc3Npb24oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBvbmx5IHNlbmQgdGhlIHVwZGF0ZVxuICBfc2VuZFNlc3Npb25VcGRhdGUoKTtcbn1cblxuZXhwb3J0cy5hZGRFdmVudFByb2Nlc3NvciA9IGFkZEV2ZW50UHJvY2Vzc29yO1xuZXhwb3J0cy5jYXB0dXJlQ2hlY2tJbiA9IGNhcHR1cmVDaGVja0luO1xuZXhwb3J0cy5jYXB0dXJlRXZlbnQgPSBjYXB0dXJlRXZlbnQ7XG5leHBvcnRzLmNhcHR1cmVFeGNlcHRpb24gPSBjYXB0dXJlRXhjZXB0aW9uO1xuZXhwb3J0cy5jYXB0dXJlTWVzc2FnZSA9IGNhcHR1cmVNZXNzYWdlO1xuZXhwb3J0cy5jYXB0dXJlU2Vzc2lvbiA9IGNhcHR1cmVTZXNzaW9uO1xuZXhwb3J0cy5jbG9zZSA9IGNsb3NlO1xuZXhwb3J0cy5lbmRTZXNzaW9uID0gZW5kU2Vzc2lvbjtcbmV4cG9ydHMuZmx1c2ggPSBmbHVzaDtcbmV4cG9ydHMuaXNFbmFibGVkID0gaXNFbmFibGVkO1xuZXhwb3J0cy5pc0luaXRpYWxpemVkID0gaXNJbml0aWFsaXplZDtcbmV4cG9ydHMubGFzdEV2ZW50SWQgPSBsYXN0RXZlbnRJZDtcbmV4cG9ydHMuc2V0Q29udGV4dCA9IHNldENvbnRleHQ7XG5leHBvcnRzLnNldEV4dHJhID0gc2V0RXh0cmE7XG5leHBvcnRzLnNldEV4dHJhcyA9IHNldEV4dHJhcztcbmV4cG9ydHMuc2V0VGFnID0gc2V0VGFnO1xuZXhwb3J0cy5zZXRUYWdzID0gc2V0VGFncztcbmV4cG9ydHMuc2V0VXNlciA9IHNldFVzZXI7XG5leHBvcnRzLnN0YXJ0U2Vzc2lvbiA9IHN0YXJ0U2Vzc2lvbjtcbmV4cG9ydHMud2l0aE1vbml0b3IgPSB3aXRoTW9uaXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cG9ydHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/exports.js\n")}};