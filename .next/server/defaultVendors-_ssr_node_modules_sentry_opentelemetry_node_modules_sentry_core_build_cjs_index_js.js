exports.id="defaultVendors-_ssr_node_modules_sentry_opentelemetry_node_modules_sentry_core_build_cjs_index_js",exports.ids=["defaultVendors-_ssr_node_modules_sentry_opentelemetry_node_modules_sentry_core_build_cjs_index_js"],exports.modules={"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/feedback.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js\");\n\n/**\n * Send user feedback to Sentry.\n */\nfunction captureFeedback(\n  params,\n  hint = {},\n  scope = currentScopes.getCurrentScope(),\n) {\n  const { message, name, email, url, source, associatedEventId, tags } = params;\n\n  const feedbackEvent = {\n    contexts: {\n      feedback: {\n        contact_email: email,\n        name,\n        message,\n        url,\n        source,\n        associated_event_id: associatedEventId,\n      },\n    },\n    type: 'feedback',\n    level: 'info',\n    tags,\n  };\n\n  const client = scope?.getClient() || currentScopes.getClient();\n\n  if (client) {\n    client.emit('beforeSendFeedback', feedbackEvent, hint);\n  }\n\n  const eventId = scope.captureEvent(feedbackEvent, hint);\n\n  return eventId;\n}\n\nexports.captureFeedback = captureFeedback;\n//# sourceMappingURL=feedback.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ZlZWRiYWNrLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLHNCQUFzQixtQkFBTyxDQUFDLDJIQUFvQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVSw2REFBNkQ7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGZlZWRiYWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5cbi8qKlxuICogU2VuZCB1c2VyIGZlZWRiYWNrIHRvIFNlbnRyeS5cbiAqL1xuZnVuY3Rpb24gY2FwdHVyZUZlZWRiYWNrKFxuICBwYXJhbXMsXG4gIGhpbnQgPSB7fSxcbiAgc2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldEN1cnJlbnRTY29wZSgpLFxuKSB7XG4gIGNvbnN0IHsgbWVzc2FnZSwgbmFtZSwgZW1haWwsIHVybCwgc291cmNlLCBhc3NvY2lhdGVkRXZlbnRJZCwgdGFncyB9ID0gcGFyYW1zO1xuXG4gIGNvbnN0IGZlZWRiYWNrRXZlbnQgPSB7XG4gICAgY29udGV4dHM6IHtcbiAgICAgIGZlZWRiYWNrOiB7XG4gICAgICAgIGNvbnRhY3RfZW1haWw6IGVtYWlsLFxuICAgICAgICBuYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB1cmwsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgYXNzb2NpYXRlZF9ldmVudF9pZDogYXNzb2NpYXRlZEV2ZW50SWQsXG4gICAgICB9LFxuICAgIH0sXG4gICAgdHlwZTogJ2ZlZWRiYWNrJyxcbiAgICBsZXZlbDogJ2luZm8nLFxuICAgIHRhZ3MsXG4gIH07XG5cbiAgY29uc3QgY2xpZW50ID0gc2NvcGU/LmdldENsaWVudCgpIHx8IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG5cbiAgaWYgKGNsaWVudCkge1xuICAgIGNsaWVudC5lbWl0KCdiZWZvcmVTZW5kRmVlZGJhY2snLCBmZWVkYmFja0V2ZW50LCBoaW50KTtcbiAgfVxuXG4gIGNvbnN0IGV2ZW50SWQgPSBzY29wZS5jYXB0dXJlRXZlbnQoZmVlZGJhY2tFdmVudCwgaGludCk7XG5cbiAgcmV0dXJuIGV2ZW50SWQ7XG59XG5cbmV4cG9ydHMuY2FwdHVyZUZlZWRiYWNrID0gY2FwdHVyZUZlZWRiYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmVlZGJhY2suanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/feedback.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/fetch.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst semanticAttributes = __webpack_require__(/*! ./semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\n__webpack_require__(/*! ./tracing/errors.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/errors.js\");\n__webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst is = __webpack_require__(/*! ./utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\n__webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst hasSpansEnabled = __webpack_require__(/*! ./utils/hasSpansEnabled.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/hasSpansEnabled.js\");\nconst spanUtils = __webpack_require__(/*! ./utils/spanUtils.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanUtils.js\");\n__webpack_require__(/*! ./utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst baggage = __webpack_require__(/*! ./utils-hoist/baggage.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/baggage.js\");\nconst sentryNonRecordingSpan = __webpack_require__(/*! ./tracing/sentryNonRecordingSpan.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sentryNonRecordingSpan.js\");\nconst spanstatus = __webpack_require__(/*! ./tracing/spanstatus.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js\");\nconst trace = __webpack_require__(/*! ./tracing/trace.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/trace.js\");\nconst traceData = __webpack_require__(/*! ./utils/traceData.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/traceData.js\");\nconst url = __webpack_require__(/*! ./utils-hoist/url.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/url.js\");\n\n/**\n * Create and track fetch request spans for usage in combination with `addFetchInstrumentationHandler`.\n *\n * @returns Span if a span was created, otherwise void.\n */\nfunction instrumentFetchRequest(\n  handlerData,\n  shouldCreateSpan,\n  shouldAttachHeaders,\n  spans,\n  spanOrigin = 'auto.http.browser',\n) {\n  if (!handlerData.fetchData) {\n    return undefined;\n  }\n\n  const { method, url } = handlerData.fetchData;\n\n  const shouldCreateSpanResult = hasSpansEnabled.hasSpansEnabled() && shouldCreateSpan(url);\n\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      endSpan(span, handlerData);\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n\n  const hasParent = !!spanUtils.getActiveSpan();\n\n  const span =\n    shouldCreateSpanResult && hasParent\n      ? trace.startInactiveSpan(getSpanStartOptions(url, method, spanOrigin))\n      : new sentryNonRecordingSpan.SentryNonRecordingSpan();\n\n  handlerData.fetchData.__span = span.spanContext().spanId;\n  spans[span.spanContext().spanId] = span;\n\n  if (shouldAttachHeaders(handlerData.fetchData.url)) {\n    const request = handlerData.args[0];\n\n    const options = handlerData.args[1] || {};\n\n    const headers = _addTracingHeadersToFetchRequest(\n      request,\n      options,\n      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n      // we do not want to use the span as base for the trace headers,\n      // which means that the headers will be generated from the scope and the sampling decision is deferred\n      hasSpansEnabled.hasSpansEnabled() && hasParent ? span : undefined,\n    );\n    if (headers) {\n      // Ensure this is actually set, if no options have been passed previously\n      handlerData.args[1] = options;\n      options.headers = headers;\n    }\n  }\n\n  const client = currentScopes.getClient();\n\n  if (client) {\n    const fetchHint = {\n      input: handlerData.args,\n      response: handlerData.response,\n      startTimestamp: handlerData.startTimestamp,\n      endTimestamp: handlerData.endTimestamp,\n    } ;\n\n    client.emit('beforeOutgoingRequestSpan', span, fetchHint);\n  }\n\n  return span;\n}\n\n/**\n * Adds sentry-trace and baggage headers to the various forms of fetch headers.\n * exported only for testing purposes\n *\n * When we determine if we should add a baggage header, there are 3 cases:\n * 1. No previous baggage header -> add baggage\n * 2. Previous baggage header has no sentry baggage values -> add our baggage\n * 3. Previous baggage header has sentry baggage values -> do nothing (might have been added manually by users)\n */\n// eslint-disable-next-line complexity -- yup it's this complicated :(\nfunction _addTracingHeadersToFetchRequest(\n  request,\n  fetchOptionsObj\n\n,\n  span,\n) {\n  const traceHeaders = traceData.getTraceData({ span });\n  const sentryTrace = traceHeaders['sentry-trace'];\n  const baggage = traceHeaders.baggage;\n\n  // Nothing to do, when we return undefined here, the original headers will be used\n  if (!sentryTrace) {\n    return undefined;\n  }\n\n  const originalHeaders = fetchOptionsObj.headers || (is.isRequest(request) ? request.headers : undefined);\n\n  if (!originalHeaders) {\n    return { ...traceHeaders };\n  } else if (isHeaders(originalHeaders)) {\n    const newHeaders = new Headers(originalHeaders);\n\n    // We don't want to override manually added sentry headers\n    if (!newHeaders.get('sentry-trace')) {\n      newHeaders.set('sentry-trace', sentryTrace);\n    }\n\n    if (baggage) {\n      const prevBaggageHeader = newHeaders.get('baggage');\n\n      if (!prevBaggageHeader) {\n        newHeaders.set('baggage', baggage);\n      } else if (!baggageHeaderHasSentryBaggageValues(prevBaggageHeader)) {\n        newHeaders.set('baggage', `${prevBaggageHeader},${baggage}`);\n      }\n    }\n\n    return newHeaders;\n  } else if (Array.isArray(originalHeaders)) {\n    const newHeaders = [...originalHeaders];\n\n    if (!originalHeaders.find(header => header[0] === 'sentry-trace')) {\n      newHeaders.push(['sentry-trace', sentryTrace]);\n    }\n\n    const prevBaggageHeaderWithSentryValues = originalHeaders.find(\n      header => header[0] === 'baggage' && baggageHeaderHasSentryBaggageValues(header[1]),\n    );\n\n    if (baggage && !prevBaggageHeaderWithSentryValues) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.push(['baggage', baggage]);\n    }\n\n    return newHeaders ;\n  } else {\n    const existingSentryTraceHeader = 'sentry-trace' in originalHeaders ? originalHeaders['sentry-trace'] : undefined;\n\n    const existingBaggageHeader = 'baggage' in originalHeaders ? originalHeaders.baggage : undefined;\n    const newBaggageHeaders = existingBaggageHeader\n      ? Array.isArray(existingBaggageHeader)\n        ? [...existingBaggageHeader]\n        : [existingBaggageHeader]\n      : [];\n\n    const prevBaggageHeaderWithSentryValues =\n      existingBaggageHeader &&\n      (Array.isArray(existingBaggageHeader)\n        ? existingBaggageHeader.find(headerItem => baggageHeaderHasSentryBaggageValues(headerItem))\n        : baggageHeaderHasSentryBaggageValues(existingBaggageHeader));\n\n    if (baggage && !prevBaggageHeaderWithSentryValues) {\n      newBaggageHeaders.push(baggage);\n    }\n\n    return {\n      ...(originalHeaders ),\n      'sentry-trace': (existingSentryTraceHeader ) ?? sentryTrace,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined,\n    };\n  }\n}\n\nfunction endSpan(span, handlerData) {\n  if (handlerData.response) {\n    spanstatus.setHttpStatus(span, handlerData.response.status);\n\n    const contentLength = handlerData.response?.headers && handlerData.response.headers.get('content-length');\n\n    if (contentLength) {\n      const contentLengthNum = parseInt(contentLength);\n      if (contentLengthNum > 0) {\n        span.setAttribute('http.response_content_length', contentLengthNum);\n      }\n    }\n  } else if (handlerData.error) {\n    span.setStatus({ code: spanstatus.SPAN_STATUS_ERROR, message: 'internal_error' });\n  }\n  span.end();\n}\n\nfunction baggageHeaderHasSentryBaggageValues(baggageHeader) {\n  return baggageHeader.split(',').some(baggageEntry => baggageEntry.trim().startsWith(baggage.SENTRY_BAGGAGE_KEY_PREFIX));\n}\n\nfunction isHeaders(headers) {\n  return typeof Headers !== 'undefined' && is.isInstanceOf(headers, Headers);\n}\n\nfunction getSpanStartOptions(\n  url$1,\n  method,\n  spanOrigin,\n) {\n  const parsedUrl = url.parseStringToURLObject(url$1);\n  return {\n    name: parsedUrl ? `${method} ${url.getSanitizedUrlStringFromUrlObject(parsedUrl)}` : method,\n    attributes: getFetchSpanAttributes(url$1, parsedUrl, method, spanOrigin),\n  };\n}\n\nfunction getFetchSpanAttributes(\n  url$1,\n  parsedUrl,\n  method,\n  spanOrigin,\n) {\n  const attributes = {\n    url: url$1,\n    type: 'fetch',\n    'http.method': method,\n    [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanOrigin,\n    [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client',\n  };\n  if (parsedUrl) {\n    if (!url.isURLObjectRelative(parsedUrl)) {\n      attributes['http.url'] = parsedUrl.href;\n      attributes['server.address'] = parsedUrl.host;\n    }\n    if (parsedUrl.search) {\n      attributes['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      attributes['http.fragment'] = parsedUrl.hash;\n    }\n  }\n  return attributes;\n}\n\nexports._addTracingHeadersToFetchRequest = _addTracingHeadersToFetchRequest;\nexports.instrumentFetchRequest = instrumentFetchRequest;\n//# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ZldGNoLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLHNCQUFzQixtQkFBTyxDQUFDLDJIQUFvQjtBQUNsRCwyQkFBMkIsbUJBQU8sQ0FBQyxxSUFBeUI7QUFDNUQsbUJBQU8sQ0FBQyw2SEFBcUI7QUFDN0IsbUJBQU8sQ0FBQyx1SEFBa0I7QUFDMUIsV0FBVyxtQkFBTyxDQUFDLDZIQUFxQjtBQUN4QyxtQkFBTyxDQUFDLHFJQUF5QjtBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQywySUFBNEI7QUFDNUQsa0JBQWtCLG1CQUFPLENBQUMsK0hBQXNCO0FBQ2hELG1CQUFPLENBQUMsaUlBQXVCO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLHVJQUEwQjtBQUNsRCwrQkFBK0IsbUJBQU8sQ0FBQyw2SkFBcUM7QUFDNUUsbUJBQW1CLG1CQUFPLENBQUMscUlBQXlCO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQywySEFBb0I7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsK0hBQXNCO0FBQ2hELFlBQVksbUJBQU8sQ0FBQywrSEFBc0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGNBQWM7O0FBRXhCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHFDQUFxQyxrQkFBa0IsR0FBRyxRQUFRO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHFCQUFxQiwrREFBK0Q7QUFDcEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUSxFQUFFLGtEQUFrRDtBQUNyRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4Qyw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcZmV0Y2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuL2N1cnJlbnRTY29wZXMuanMnKTtcbmNvbnN0IHNlbWFudGljQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vc2VtYW50aWNBdHRyaWJ1dGVzLmpzJyk7XG5yZXF1aXJlKCcuL3RyYWNpbmcvZXJyb3JzLmpzJyk7XG5yZXF1aXJlKCcuL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBpcyA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvaXMuanMnKTtcbnJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCBoYXNTcGFuc0VuYWJsZWQgPSByZXF1aXJlKCcuL3V0aWxzL2hhc1NwYW5zRW5hYmxlZC5qcycpO1xuY29uc3Qgc3BhblV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9zcGFuVXRpbHMuanMnKTtcbnJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvdGltZS5qcycpO1xuY29uc3QgYmFnZ2FnZSA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvYmFnZ2FnZS5qcycpO1xuY29uc3Qgc2VudHJ5Tm9uUmVjb3JkaW5nU3BhbiA9IHJlcXVpcmUoJy4vdHJhY2luZy9zZW50cnlOb25SZWNvcmRpbmdTcGFuLmpzJyk7XG5jb25zdCBzcGFuc3RhdHVzID0gcmVxdWlyZSgnLi90cmFjaW5nL3NwYW5zdGF0dXMuanMnKTtcbmNvbnN0IHRyYWNlID0gcmVxdWlyZSgnLi90cmFjaW5nL3RyYWNlLmpzJyk7XG5jb25zdCB0cmFjZURhdGEgPSByZXF1aXJlKCcuL3V0aWxzL3RyYWNlRGF0YS5qcycpO1xuY29uc3QgdXJsID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC91cmwuanMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHRyYWNrIGZldGNoIHJlcXVlc3Qgc3BhbnMgZm9yIHVzYWdlIGluIGNvbWJpbmF0aW9uIHdpdGggYGFkZEZldGNoSW5zdHJ1bWVudGF0aW9uSGFuZGxlcmAuXG4gKlxuICogQHJldHVybnMgU3BhbiBpZiBhIHNwYW4gd2FzIGNyZWF0ZWQsIG90aGVyd2lzZSB2b2lkLlxuICovXG5mdW5jdGlvbiBpbnN0cnVtZW50RmV0Y2hSZXF1ZXN0KFxuICBoYW5kbGVyRGF0YSxcbiAgc2hvdWxkQ3JlYXRlU3BhbixcbiAgc2hvdWxkQXR0YWNoSGVhZGVycyxcbiAgc3BhbnMsXG4gIHNwYW5PcmlnaW4gPSAnYXV0by5odHRwLmJyb3dzZXInLFxuKSB7XG4gIGlmICghaGFuZGxlckRhdGEuZmV0Y2hEYXRhKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHsgbWV0aG9kLCB1cmwgfSA9IGhhbmRsZXJEYXRhLmZldGNoRGF0YTtcblxuICBjb25zdCBzaG91bGRDcmVhdGVTcGFuUmVzdWx0ID0gaGFzU3BhbnNFbmFibGVkLmhhc1NwYW5zRW5hYmxlZCgpICYmIHNob3VsZENyZWF0ZVNwYW4odXJsKTtcblxuICBpZiAoaGFuZGxlckRhdGEuZW5kVGltZXN0YW1wICYmIHNob3VsZENyZWF0ZVNwYW5SZXN1bHQpIHtcbiAgICBjb25zdCBzcGFuSWQgPSBoYW5kbGVyRGF0YS5mZXRjaERhdGEuX19zcGFuO1xuICAgIGlmICghc3BhbklkKSByZXR1cm47XG5cbiAgICBjb25zdCBzcGFuID0gc3BhbnNbc3BhbklkXTtcbiAgICBpZiAoc3Bhbikge1xuICAgICAgZW5kU3BhbihzcGFuLCBoYW5kbGVyRGF0YSk7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgIGRlbGV0ZSBzcGFuc1tzcGFuSWRdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgaGFzUGFyZW50ID0gISFzcGFuVXRpbHMuZ2V0QWN0aXZlU3BhbigpO1xuXG4gIGNvbnN0IHNwYW4gPVxuICAgIHNob3VsZENyZWF0ZVNwYW5SZXN1bHQgJiYgaGFzUGFyZW50XG4gICAgICA/IHRyYWNlLnN0YXJ0SW5hY3RpdmVTcGFuKGdldFNwYW5TdGFydE9wdGlvbnModXJsLCBtZXRob2QsIHNwYW5PcmlnaW4pKVxuICAgICAgOiBuZXcgc2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbi5TZW50cnlOb25SZWNvcmRpbmdTcGFuKCk7XG5cbiAgaGFuZGxlckRhdGEuZmV0Y2hEYXRhLl9fc3BhbiA9IHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQ7XG4gIHNwYW5zW3NwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWRdID0gc3BhbjtcblxuICBpZiAoc2hvdWxkQXR0YWNoSGVhZGVycyhoYW5kbGVyRGF0YS5mZXRjaERhdGEudXJsKSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBoYW5kbGVyRGF0YS5hcmdzWzBdO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGhhbmRsZXJEYXRhLmFyZ3NbMV0gfHwge307XG5cbiAgICBjb25zdCBoZWFkZXJzID0gX2FkZFRyYWNpbmdIZWFkZXJzVG9GZXRjaFJlcXVlc3QoXG4gICAgICByZXF1ZXN0LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIC8vIElmIHBlcmZvcm1hbmNlIGlzIGRpc2FibGVkIChUV1ApIG9yIHRoZXJlJ3Mgbm8gYWN0aXZlIHJvb3Qgc3BhbiAocGFnZWxvYWQvbmF2aWdhdGlvbi9pbnRlcmFjdGlvbiksXG4gICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byB1c2UgdGhlIHNwYW4gYXMgYmFzZSBmb3IgdGhlIHRyYWNlIGhlYWRlcnMsXG4gICAgICAvLyB3aGljaCBtZWFucyB0aGF0IHRoZSBoZWFkZXJzIHdpbGwgYmUgZ2VuZXJhdGVkIGZyb20gdGhlIHNjb3BlIGFuZCB0aGUgc2FtcGxpbmcgZGVjaXNpb24gaXMgZGVmZXJyZWRcbiAgICAgIGhhc1NwYW5zRW5hYmxlZC5oYXNTcGFuc0VuYWJsZWQoKSAmJiBoYXNQYXJlbnQgPyBzcGFuIDogdW5kZWZpbmVkLFxuICAgICk7XG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGlzIGlzIGFjdHVhbGx5IHNldCwgaWYgbm8gb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkIHByZXZpb3VzbHlcbiAgICAgIGhhbmRsZXJEYXRhLmFyZ3NbMV0gPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB9XG4gIH1cblxuICBjb25zdCBjbGllbnQgPSBjdXJyZW50U2NvcGVzLmdldENsaWVudCgpO1xuXG4gIGlmIChjbGllbnQpIHtcbiAgICBjb25zdCBmZXRjaEhpbnQgPSB7XG4gICAgICBpbnB1dDogaGFuZGxlckRhdGEuYXJncyxcbiAgICAgIHJlc3BvbnNlOiBoYW5kbGVyRGF0YS5yZXNwb25zZSxcbiAgICAgIHN0YXJ0VGltZXN0YW1wOiBoYW5kbGVyRGF0YS5zdGFydFRpbWVzdGFtcCxcbiAgICAgIGVuZFRpbWVzdGFtcDogaGFuZGxlckRhdGEuZW5kVGltZXN0YW1wLFxuICAgIH0gO1xuXG4gICAgY2xpZW50LmVtaXQoJ2JlZm9yZU91dGdvaW5nUmVxdWVzdFNwYW4nLCBzcGFuLCBmZXRjaEhpbnQpO1xuICB9XG5cbiAgcmV0dXJuIHNwYW47XG59XG5cbi8qKlxuICogQWRkcyBzZW50cnktdHJhY2UgYW5kIGJhZ2dhZ2UgaGVhZGVycyB0byB0aGUgdmFyaW91cyBmb3JtcyBvZiBmZXRjaCBoZWFkZXJzLlxuICogZXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICpcbiAqIFdoZW4gd2UgZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBhZGQgYSBiYWdnYWdlIGhlYWRlciwgdGhlcmUgYXJlIDMgY2FzZXM6XG4gKiAxLiBObyBwcmV2aW91cyBiYWdnYWdlIGhlYWRlciAtPiBhZGQgYmFnZ2FnZVxuICogMi4gUHJldmlvdXMgYmFnZ2FnZSBoZWFkZXIgaGFzIG5vIHNlbnRyeSBiYWdnYWdlIHZhbHVlcyAtPiBhZGQgb3VyIGJhZ2dhZ2VcbiAqIDMuIFByZXZpb3VzIGJhZ2dhZ2UgaGVhZGVyIGhhcyBzZW50cnkgYmFnZ2FnZSB2YWx1ZXMgLT4gZG8gbm90aGluZyAobWlnaHQgaGF2ZSBiZWVuIGFkZGVkIG1hbnVhbGx5IGJ5IHVzZXJzKVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSAtLSB5dXAgaXQncyB0aGlzIGNvbXBsaWNhdGVkIDooXG5mdW5jdGlvbiBfYWRkVHJhY2luZ0hlYWRlcnNUb0ZldGNoUmVxdWVzdChcbiAgcmVxdWVzdCxcbiAgZmV0Y2hPcHRpb25zT2JqXG5cbixcbiAgc3Bhbixcbikge1xuICBjb25zdCB0cmFjZUhlYWRlcnMgPSB0cmFjZURhdGEuZ2V0VHJhY2VEYXRhKHsgc3BhbiB9KTtcbiAgY29uc3Qgc2VudHJ5VHJhY2UgPSB0cmFjZUhlYWRlcnNbJ3NlbnRyeS10cmFjZSddO1xuICBjb25zdCBiYWdnYWdlID0gdHJhY2VIZWFkZXJzLmJhZ2dhZ2U7XG5cbiAgLy8gTm90aGluZyB0byBkbywgd2hlbiB3ZSByZXR1cm4gdW5kZWZpbmVkIGhlcmUsIHRoZSBvcmlnaW5hbCBoZWFkZXJzIHdpbGwgYmUgdXNlZFxuICBpZiAoIXNlbnRyeVRyYWNlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IG9yaWdpbmFsSGVhZGVycyA9IGZldGNoT3B0aW9uc09iai5oZWFkZXJzIHx8IChpcy5pc1JlcXVlc3QocmVxdWVzdCkgPyByZXF1ZXN0LmhlYWRlcnMgOiB1bmRlZmluZWQpO1xuXG4gIGlmICghb3JpZ2luYWxIZWFkZXJzKSB7XG4gICAgcmV0dXJuIHsgLi4udHJhY2VIZWFkZXJzIH07XG4gIH0gZWxzZSBpZiAoaXNIZWFkZXJzKG9yaWdpbmFsSGVhZGVycykpIHtcbiAgICBjb25zdCBuZXdIZWFkZXJzID0gbmV3IEhlYWRlcnMob3JpZ2luYWxIZWFkZXJzKTtcblxuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgbWFudWFsbHkgYWRkZWQgc2VudHJ5IGhlYWRlcnNcbiAgICBpZiAoIW5ld0hlYWRlcnMuZ2V0KCdzZW50cnktdHJhY2UnKSkge1xuICAgICAgbmV3SGVhZGVycy5zZXQoJ3NlbnRyeS10cmFjZScsIHNlbnRyeVRyYWNlKTtcbiAgICB9XG5cbiAgICBpZiAoYmFnZ2FnZSkge1xuICAgICAgY29uc3QgcHJldkJhZ2dhZ2VIZWFkZXIgPSBuZXdIZWFkZXJzLmdldCgnYmFnZ2FnZScpO1xuXG4gICAgICBpZiAoIXByZXZCYWdnYWdlSGVhZGVyKSB7XG4gICAgICAgIG5ld0hlYWRlcnMuc2V0KCdiYWdnYWdlJywgYmFnZ2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKCFiYWdnYWdlSGVhZGVySGFzU2VudHJ5QmFnZ2FnZVZhbHVlcyhwcmV2QmFnZ2FnZUhlYWRlcikpIHtcbiAgICAgICAgbmV3SGVhZGVycy5zZXQoJ2JhZ2dhZ2UnLCBgJHtwcmV2QmFnZ2FnZUhlYWRlcn0sJHtiYWdnYWdlfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdIZWFkZXJzO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luYWxIZWFkZXJzKSkge1xuICAgIGNvbnN0IG5ld0hlYWRlcnMgPSBbLi4ub3JpZ2luYWxIZWFkZXJzXTtcblxuICAgIGlmICghb3JpZ2luYWxIZWFkZXJzLmZpbmQoaGVhZGVyID0+IGhlYWRlclswXSA9PT0gJ3NlbnRyeS10cmFjZScpKSB7XG4gICAgICBuZXdIZWFkZXJzLnB1c2goWydzZW50cnktdHJhY2UnLCBzZW50cnlUcmFjZV0pO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZCYWdnYWdlSGVhZGVyV2l0aFNlbnRyeVZhbHVlcyA9IG9yaWdpbmFsSGVhZGVycy5maW5kKFxuICAgICAgaGVhZGVyID0+IGhlYWRlclswXSA9PT0gJ2JhZ2dhZ2UnICYmIGJhZ2dhZ2VIZWFkZXJIYXNTZW50cnlCYWdnYWdlVmFsdWVzKGhlYWRlclsxXSksXG4gICAgKTtcblxuICAgIGlmIChiYWdnYWdlICYmICFwcmV2QmFnZ2FnZUhlYWRlcldpdGhTZW50cnlWYWx1ZXMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBlbnRyaWVzIHdpdGggdGhlIHNhbWUga2V5LCB0aGUgYnJvd3NlciB3aWxsIG1lcmdlIHRoZSB2YWx1ZXMgaW50byBhIHNpbmdsZSByZXF1ZXN0IGhlYWRlci5cbiAgICAgIC8vIEl0cyB0aGVyZWZvcmUgc2FmZSB0byBzaW1wbHkgcHVzaCBhIFwiYmFnZ2FnZVwiIGVudHJ5LCBldmVuIHRob3VnaCB0aGVyZSBtaWdodCBhbHJlYWR5IGJlIGFub3RoZXIgYmFnZ2FnZSBoZWFkZXIuXG4gICAgICBuZXdIZWFkZXJzLnB1c2goWydiYWdnYWdlJywgYmFnZ2FnZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdIZWFkZXJzIDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBleGlzdGluZ1NlbnRyeVRyYWNlSGVhZGVyID0gJ3NlbnRyeS10cmFjZScgaW4gb3JpZ2luYWxIZWFkZXJzID8gb3JpZ2luYWxIZWFkZXJzWydzZW50cnktdHJhY2UnXSA6IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IGV4aXN0aW5nQmFnZ2FnZUhlYWRlciA9ICdiYWdnYWdlJyBpbiBvcmlnaW5hbEhlYWRlcnMgPyBvcmlnaW5hbEhlYWRlcnMuYmFnZ2FnZSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBuZXdCYWdnYWdlSGVhZGVycyA9IGV4aXN0aW5nQmFnZ2FnZUhlYWRlclxuICAgICAgPyBBcnJheS5pc0FycmF5KGV4aXN0aW5nQmFnZ2FnZUhlYWRlcilcbiAgICAgICAgPyBbLi4uZXhpc3RpbmdCYWdnYWdlSGVhZGVyXVxuICAgICAgICA6IFtleGlzdGluZ0JhZ2dhZ2VIZWFkZXJdXG4gICAgICA6IFtdO1xuXG4gICAgY29uc3QgcHJldkJhZ2dhZ2VIZWFkZXJXaXRoU2VudHJ5VmFsdWVzID1cbiAgICAgIGV4aXN0aW5nQmFnZ2FnZUhlYWRlciAmJlxuICAgICAgKEFycmF5LmlzQXJyYXkoZXhpc3RpbmdCYWdnYWdlSGVhZGVyKVxuICAgICAgICA/IGV4aXN0aW5nQmFnZ2FnZUhlYWRlci5maW5kKGhlYWRlckl0ZW0gPT4gYmFnZ2FnZUhlYWRlckhhc1NlbnRyeUJhZ2dhZ2VWYWx1ZXMoaGVhZGVySXRlbSkpXG4gICAgICAgIDogYmFnZ2FnZUhlYWRlckhhc1NlbnRyeUJhZ2dhZ2VWYWx1ZXMoZXhpc3RpbmdCYWdnYWdlSGVhZGVyKSk7XG5cbiAgICBpZiAoYmFnZ2FnZSAmJiAhcHJldkJhZ2dhZ2VIZWFkZXJXaXRoU2VudHJ5VmFsdWVzKSB7XG4gICAgICBuZXdCYWdnYWdlSGVhZGVycy5wdXNoKGJhZ2dhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi4ob3JpZ2luYWxIZWFkZXJzICksXG4gICAgICAnc2VudHJ5LXRyYWNlJzogKGV4aXN0aW5nU2VudHJ5VHJhY2VIZWFkZXIgKSA/PyBzZW50cnlUcmFjZSxcbiAgICAgIGJhZ2dhZ2U6IG5ld0JhZ2dhZ2VIZWFkZXJzLmxlbmd0aCA+IDAgPyBuZXdCYWdnYWdlSGVhZGVycy5qb2luKCcsJykgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRTcGFuKHNwYW4sIGhhbmRsZXJEYXRhKSB7XG4gIGlmIChoYW5kbGVyRGF0YS5yZXNwb25zZSkge1xuICAgIHNwYW5zdGF0dXMuc2V0SHR0cFN0YXR1cyhzcGFuLCBoYW5kbGVyRGF0YS5yZXNwb25zZS5zdGF0dXMpO1xuXG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IGhhbmRsZXJEYXRhLnJlc3BvbnNlPy5oZWFkZXJzICYmIGhhbmRsZXJEYXRhLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpO1xuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGhOdW0gPSBwYXJzZUludChjb250ZW50TGVuZ3RoKTtcbiAgICAgIGlmIChjb250ZW50TGVuZ3RoTnVtID4gMCkge1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZSgnaHR0cC5yZXNwb25zZV9jb250ZW50X2xlbmd0aCcsIGNvbnRlbnRMZW5ndGhOdW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChoYW5kbGVyRGF0YS5lcnJvcikge1xuICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogc3BhbnN0YXR1cy5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ2ludGVybmFsX2Vycm9yJyB9KTtcbiAgfVxuICBzcGFuLmVuZCgpO1xufVxuXG5mdW5jdGlvbiBiYWdnYWdlSGVhZGVySGFzU2VudHJ5QmFnZ2FnZVZhbHVlcyhiYWdnYWdlSGVhZGVyKSB7XG4gIHJldHVybiBiYWdnYWdlSGVhZGVyLnNwbGl0KCcsJykuc29tZShiYWdnYWdlRW50cnkgPT4gYmFnZ2FnZUVudHJ5LnRyaW0oKS5zdGFydHNXaXRoKGJhZ2dhZ2UuU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWCkpO1xufVxuXG5mdW5jdGlvbiBpc0hlYWRlcnMoaGVhZGVycykge1xuICByZXR1cm4gdHlwZW9mIEhlYWRlcnMgIT09ICd1bmRlZmluZWQnICYmIGlzLmlzSW5zdGFuY2VPZihoZWFkZXJzLCBIZWFkZXJzKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3BhblN0YXJ0T3B0aW9ucyhcbiAgdXJsJDEsXG4gIG1ldGhvZCxcbiAgc3Bhbk9yaWdpbixcbikge1xuICBjb25zdCBwYXJzZWRVcmwgPSB1cmwucGFyc2VTdHJpbmdUb1VSTE9iamVjdCh1cmwkMSk7XG4gIHJldHVybiB7XG4gICAgbmFtZTogcGFyc2VkVXJsID8gYCR7bWV0aG9kfSAke3VybC5nZXRTYW5pdGl6ZWRVcmxTdHJpbmdGcm9tVXJsT2JqZWN0KHBhcnNlZFVybCl9YCA6IG1ldGhvZCxcbiAgICBhdHRyaWJ1dGVzOiBnZXRGZXRjaFNwYW5BdHRyaWJ1dGVzKHVybCQxLCBwYXJzZWRVcmwsIG1ldGhvZCwgc3Bhbk9yaWdpbiksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEZldGNoU3BhbkF0dHJpYnV0ZXMoXG4gIHVybCQxLFxuICBwYXJzZWRVcmwsXG4gIG1ldGhvZCxcbiAgc3Bhbk9yaWdpbixcbikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgIHVybDogdXJsJDEsXG4gICAgdHlwZTogJ2ZldGNoJyxcbiAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06IHNwYW5PcmlnaW4sXG4gICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXTogJ2h0dHAuY2xpZW50JyxcbiAgfTtcbiAgaWYgKHBhcnNlZFVybCkge1xuICAgIGlmICghdXJsLmlzVVJMT2JqZWN0UmVsYXRpdmUocGFyc2VkVXJsKSkge1xuICAgICAgYXR0cmlidXRlc1snaHR0cC51cmwnXSA9IHBhcnNlZFVybC5ocmVmO1xuICAgICAgYXR0cmlidXRlc1snc2VydmVyLmFkZHJlc3MnXSA9IHBhcnNlZFVybC5ob3N0O1xuICAgIH1cbiAgICBpZiAocGFyc2VkVXJsLnNlYXJjaCkge1xuICAgICAgYXR0cmlidXRlc1snaHR0cC5xdWVyeSddID0gcGFyc2VkVXJsLnNlYXJjaDtcbiAgICB9XG4gICAgaWYgKHBhcnNlZFVybC5oYXNoKSB7XG4gICAgICBhdHRyaWJ1dGVzWydodHRwLmZyYWdtZW50J10gPSBwYXJzZWRVcmwuaGFzaDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5cbmV4cG9ydHMuX2FkZFRyYWNpbmdIZWFkZXJzVG9GZXRjaFJlcXVlc3QgPSBfYWRkVHJhY2luZ0hlYWRlcnNUb0ZldGNoUmVxdWVzdDtcbmV4cG9ydHMuaW5zdHJ1bWVudEZldGNoUmVxdWVzdCA9IGluc3RydW1lbnRGZXRjaFJlcXVlc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/fetch.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst errors = __webpack_require__(/*! ./tracing/errors.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/errors.js");\nconst utils = __webpack_require__(/*! ./tracing/utils.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/utils.js");\nconst idleSpan = __webpack_require__(/*! ./tracing/idleSpan.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/idleSpan.js");\nconst sentrySpan = __webpack_require__(/*! ./tracing/sentrySpan.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sentrySpan.js");\nconst sentryNonRecordingSpan = __webpack_require__(/*! ./tracing/sentryNonRecordingSpan.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sentryNonRecordingSpan.js");\nconst spanstatus = __webpack_require__(/*! ./tracing/spanstatus.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js");\nconst trace = __webpack_require__(/*! ./tracing/trace.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/trace.js");\nconst dynamicSamplingContext = __webpack_require__(/*! ./tracing/dynamicSamplingContext.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js");\nconst measurement = __webpack_require__(/*! ./tracing/measurement.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/measurement.js");\nconst sampling = __webpack_require__(/*! ./tracing/sampling.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sampling.js");\nconst logSpans = __webpack_require__(/*! ./tracing/logSpans.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/logSpans.js");\nconst semanticAttributes = __webpack_require__(/*! ./semanticAttributes.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/semanticAttributes.js");\nconst envelope = __webpack_require__(/*! ./envelope.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/envelope.js");\nconst exports$1 = __webpack_require__(/*! ./exports.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/exports.js");\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js");\nconst defaultScopes = __webpack_require__(/*! ./defaultScopes.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/defaultScopes.js");\nconst index = __webpack_require__(/*! ./asyncContext/index.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/asyncContext/index.js");\nconst carrier = __webpack_require__(/*! ./carrier.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/carrier.js");\nconst session = __webpack_require__(/*! ./session.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/session.js");\nconst scope = __webpack_require__(/*! ./scope.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/scope.js");\nconst eventProcessors = __webpack_require__(/*! ./eventProcessors.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/eventProcessors.js");\nconst api = __webpack_require__(/*! ./api.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/api.js");\nconst client = __webpack_require__(/*! ./client.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/client.js");\nconst serverRuntimeClient = __webpack_require__(/*! ./server-runtime-client.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/server-runtime-client.js");\nconst sdk = __webpack_require__(/*! ./sdk.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/sdk.js");\nconst base = __webpack_require__(/*! ./transports/base.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/transports/base.js");\nconst offline = __webpack_require__(/*! ./transports/offline.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/transports/offline.js");\nconst multiplexed = __webpack_require__(/*! ./transports/multiplexed.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/transports/multiplexed.js");\nconst integration = __webpack_require__(/*! ./integration.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js");\nconst applyScopeDataToEvent = __webpack_require__(/*! ./utils/applyScopeDataToEvent.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/applyScopeDataToEvent.js");\nconst prepareEvent = __webpack_require__(/*! ./utils/prepareEvent.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/prepareEvent.js");\nconst checkin = __webpack_require__(/*! ./checkin.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/checkin.js");\nconst hasSpansEnabled = __webpack_require__(/*! ./utils/hasSpansEnabled.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/hasSpansEnabled.js");\nconst isSentryRequestUrl = __webpack_require__(/*! ./utils/isSentryRequestUrl.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/isSentryRequestUrl.js");\nconst handleCallbackErrors = __webpack_require__(/*! ./utils/handleCallbackErrors.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/handleCallbackErrors.js");\nconst parameterize = __webpack_require__(/*! ./utils/parameterize.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/parameterize.js");\nconst ipAddress = __webpack_require__(/*! ./utils/ipAddress.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/ipAddress.js");\nconst spanUtils = __webpack_require__(/*! ./utils/spanUtils.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanUtils.js");\nconst parseSampleRate = __webpack_require__(/*! ./utils/parseSampleRate.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/parseSampleRate.js");\nconst sdkMetadata = __webpack_require__(/*! ./utils/sdkMetadata.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/sdkMetadata.js");\nconst traceData = __webpack_require__(/*! ./utils/traceData.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/traceData.js");\nconst meta = __webpack_require__(/*! ./utils/meta.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/meta.js");\nconst request = __webpack_require__(/*! ./utils/request.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/request.js");\nconst constants = __webpack_require__(/*! ./constants.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/constants.js");\nconst breadcrumbs = __webpack_require__(/*! ./breadcrumbs.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/breadcrumbs.js");\nconst functiontostring = __webpack_require__(/*! ./integrations/functiontostring.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/functiontostring.js");\nconst eventFilters = __webpack_require__(/*! ./integrations/eventFilters.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/eventFilters.js");\nconst linkederrors = __webpack_require__(/*! ./integrations/linkederrors.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/linkederrors.js");\nconst metadata = __webpack_require__(/*! ./integrations/metadata.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/metadata.js");\nconst requestdata = __webpack_require__(/*! ./integrations/requestdata.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/requestdata.js");\nconst captureconsole = __webpack_require__(/*! ./integrations/captureconsole.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/captureconsole.js");\nconst dedupe = __webpack_require__(/*! ./integrations/dedupe.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/dedupe.js");\nconst extraerrordata = __webpack_require__(/*! ./integrations/extraerrordata.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/extraerrordata.js");\nconst rewriteframes = __webpack_require__(/*! ./integrations/rewriteframes.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/rewriteframes.js");\nconst supabase = __webpack_require__(/*! ./integrations/supabase.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/supabase.js");\nconst zoderrors = __webpack_require__(/*! ./integrations/zoderrors.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/zoderrors.js");\nconst thirdPartyErrorsFilter = __webpack_require__(/*! ./integrations/third-party-errors-filter.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/third-party-errors-filter.js");\nconst console = __webpack_require__(/*! ./integrations/console.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/console.js");\nconst profiling = __webpack_require__(/*! ./profiling.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/profiling.js");\nconst fetch = __webpack_require__(/*! ./fetch.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/fetch.js");\nconst trpc = __webpack_require__(/*! ./trpc.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/trpc.js");\nconst mcpServer = __webpack_require__(/*! ./mcp-server.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/mcp-server.js");\nconst feedback = __webpack_require__(/*! ./feedback.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/feedback.js");\nconst exports$2 = __webpack_require__(/*! ./logs/exports.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/exports.js");\nconst consoleIntegration = __webpack_require__(/*! ./logs/console-integration.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/console-integration.js");\nconst aggregateErrors = __webpack_require__(/*! ./utils-hoist/aggregate-errors.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/aggregate-errors.js");\nconst breadcrumbLogLevel = __webpack_require__(/*! ./utils-hoist/breadcrumb-log-level.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/breadcrumb-log-level.js");\nconst browser = __webpack_require__(/*! ./utils-hoist/browser.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/browser.js");\nconst dsn = __webpack_require__(/*! ./utils-hoist/dsn.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/dsn.js");\nconst error = __webpack_require__(/*! ./utils-hoist/error.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/error.js");\nconst worldwide = __webpack_require__(/*! ./utils-hoist/worldwide.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js");\nconst console$1 = __webpack_require__(/*! ./utils-hoist/instrument/console.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/console.js");\nconst fetch$1 = __webpack_require__(/*! ./utils-hoist/instrument/fetch.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/fetch.js");\nconst globalError = __webpack_require__(/*! ./utils-hoist/instrument/globalError.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/globalError.js");\nconst globalUnhandledRejection = __webpack_require__(/*! ./utils-hoist/instrument/globalUnhandledRejection.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/globalUnhandledRejection.js");\nconst handlers = __webpack_require__(/*! ./utils-hoist/instrument/handlers.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/handlers.js");\nconst is = __webpack_require__(/*! ./utils-hoist/is.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/is.js");\nconst isBrowser = __webpack_require__(/*! ./utils-hoist/isBrowser.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/isBrowser.js");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js");\nconst misc = __webpack_require__(/*! ./utils-hoist/misc.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js");\nconst node = __webpack_require__(/*! ./utils-hoist/node.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/node.js");\nconst normalize = __webpack_require__(/*! ./utils-hoist/normalize.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/normalize.js");\nconst object = __webpack_require__(/*! ./utils-hoist/object.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/object.js");\nconst path = __webpack_require__(/*! ./utils-hoist/path.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/path.js");\nconst promisebuffer = __webpack_require__(/*! ./utils-hoist/promisebuffer.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/promisebuffer.js");\nconst severity = __webpack_require__(/*! ./utils-hoist/severity.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/severity.js");\nconst stacktrace = __webpack_require__(/*! ./utils-hoist/stacktrace.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/stacktrace.js");\nconst nodeStackTrace = __webpack_require__(/*! ./utils-hoist/node-stack-trace.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/node-stack-trace.js");\nconst string = __webpack_require__(/*! ./utils-hoist/string.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/string.js");\nconst supports = __webpack_require__(/*! ./utils-hoist/supports.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/supports.js");\nconst syncpromise = __webpack_require__(/*! ./utils-hoist/syncpromise.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/syncpromise.js");\nconst time = __webpack_require__(/*! ./utils-hoist/time.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/time.js");\nconst tracing = __webpack_require__(/*! ./utils-hoist/tracing.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/tracing.js");\nconst env = __webpack_require__(/*! ./utils-hoist/env.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/env.js");\nconst envelope$1 = __webpack_require__(/*! ./utils-hoist/envelope.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js");\nconst clientreport = __webpack_require__(/*! ./utils-hoist/clientreport.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/clientreport.js");\nconst ratelimit = __webpack_require__(/*! ./utils-hoist/ratelimit.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/ratelimit.js");\nconst baggage = __webpack_require__(/*! ./utils-hoist/baggage.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/baggage.js");\nconst url = __webpack_require__(/*! ./utils-hoist/url.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/url.js");\nconst eventbuilder = __webpack_require__(/*! ./utils-hoist/eventbuilder.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/eventbuilder.js");\nconst anr = __webpack_require__(/*! ./utils-hoist/anr.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/anr.js");\nconst lru = __webpack_require__(/*! ./utils-hoist/lru.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/lru.js");\nconst propagationContext = __webpack_require__(/*! ./utils-hoist/propagationContext.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/propagationContext.js");\nconst vercelWaitUntil = __webpack_require__(/*! ./utils-hoist/vercelWaitUntil.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/vercelWaitUntil.js");\nconst version = __webpack_require__(/*! ./utils-hoist/version.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/version.js");\nconst debugIds = __webpack_require__(/*! ./utils-hoist/debug-ids.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/debug-ids.js");\nconst escapeStringForRegex = __webpack_require__(/*! ./utils-hoist/vendor/escapeStringForRegex.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/vendor/escapeStringForRegex.js");\n\n\n\nexports.registerSpanErrorInstrumentation = errors.registerSpanErrorInstrumentation;\nexports.getCapturedScopesOnSpan = utils.getCapturedScopesOnSpan;\nexports.setCapturedScopesOnSpan = utils.setCapturedScopesOnSpan;\nexports.TRACING_DEFAULTS = idleSpan.TRACING_DEFAULTS;\nexports.startIdleSpan = idleSpan.startIdleSpan;\nexports.SentrySpan = sentrySpan.SentrySpan;\nexports.SentryNonRecordingSpan = sentryNonRecordingSpan.SentryNonRecordingSpan;\nexports.SPAN_STATUS_ERROR = spanstatus.SPAN_STATUS_ERROR;\nexports.SPAN_STATUS_OK = spanstatus.SPAN_STATUS_OK;\nexports.SPAN_STATUS_UNSET = spanstatus.SPAN_STATUS_UNSET;\nexports.getSpanStatusFromHttpCode = spanstatus.getSpanStatusFromHttpCode;\nexports.setHttpStatus = spanstatus.setHttpStatus;\nexports.continueTrace = trace.continueTrace;\nexports.startInactiveSpan = trace.startInactiveSpan;\nexports.startNewTrace = trace.startNewTrace;\nexports.startSpan = trace.startSpan;\nexports.startSpanManual = trace.startSpanManual;\nexports.suppressTracing = trace.suppressTracing;\nexports.withActiveSpan = trace.withActiveSpan;\nexports.getDynamicSamplingContextFromClient = dynamicSamplingContext.getDynamicSamplingContextFromClient;\nexports.getDynamicSamplingContextFromScope = dynamicSamplingContext.getDynamicSamplingContextFromScope;\nexports.getDynamicSamplingContextFromSpan = dynamicSamplingContext.getDynamicSamplingContextFromSpan;\nexports.spanToBaggageHeader = dynamicSamplingContext.spanToBaggageHeader;\nexports.setMeasurement = measurement.setMeasurement;\nexports.timedEventsToMeasurements = measurement.timedEventsToMeasurements;\nexports.sampleSpan = sampling.sampleSpan;\nexports.logSpanEnd = logSpans.logSpanEnd;\nexports.logSpanStart = logSpans.logSpanStart;\nexports.SEMANTIC_ATTRIBUTE_CACHE_HIT = semanticAttributes.SEMANTIC_ATTRIBUTE_CACHE_HIT;\nexports.SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = semanticAttributes.SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE;\nexports.SEMANTIC_ATTRIBUTE_CACHE_KEY = semanticAttributes.SEMANTIC_ATTRIBUTE_CACHE_KEY;\nexports.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = semanticAttributes.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME;\nexports.SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD = semanticAttributes.SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD;\nexports.SEMANTIC_ATTRIBUTE_PROFILE_ID = semanticAttributes.SEMANTIC_ATTRIBUTE_PROFILE_ID;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_OP = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE;\nexports.SEMANTIC_ATTRIBUTE_URL_FULL = semanticAttributes.SEMANTIC_ATTRIBUTE_URL_FULL;\nexports.SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE = semanticAttributes.SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE;\nexports.createEventEnvelope = envelope.createEventEnvelope;\nexports.createSessionEnvelope = envelope.createSessionEnvelope;\nexports.createSpanEnvelope = envelope.createSpanEnvelope;\nexports.addEventProcessor = exports$1.addEventProcessor;\nexports.captureCheckIn = exports$1.captureCheckIn;\nexports.captureEvent = exports$1.captureEvent;\nexports.captureException = exports$1.captureException;\nexports.captureMessage = exports$1.captureMessage;\nexports.captureSession = exports$1.captureSession;\nexports.close = exports$1.close;\nexports.endSession = exports$1.endSession;\nexports.flush = exports$1.flush;\nexports.isEnabled = exports$1.isEnabled;\nexports.isInitialized = exports$1.isInitialized;\nexports.lastEventId = exports$1.lastEventId;\nexports.setContext = exports$1.setContext;\nexports.setExtra = exports$1.setExtra;\nexports.setExtras = exports$1.setExtras;\nexports.setTag = exports$1.setTag;\nexports.setTags = exports$1.setTags;\nexports.setUser = exports$1.setUser;\nexports.startSession = exports$1.startSession;\nexports.withMonitor = exports$1.withMonitor;\nexports.getClient = currentScopes.getClient;\nexports.getCurrentScope = currentScopes.getCurrentScope;\nexports.getGlobalScope = currentScopes.getGlobalScope;\nexports.getIsolationScope = currentScopes.getIsolationScope;\nexports.getTraceContextFromScope = currentScopes.getTraceContextFromScope;\nexports.withIsolationScope = currentScopes.withIsolationScope;\nexports.withScope = currentScopes.withScope;\nexports.getDefaultCurrentScope = defaultScopes.getDefaultCurrentScope;\nexports.getDefaultIsolationScope = defaultScopes.getDefaultIsolationScope;\nexports.setAsyncContextStrategy = index.setAsyncContextStrategy;\nexports.getGlobalSingleton = carrier.getGlobalSingleton;\nexports.getMainCarrier = carrier.getMainCarrier;\nexports.closeSession = session.closeSession;\nexports.makeSession = session.makeSession;\nexports.updateSession = session.updateSession;\nexports.Scope = scope.Scope;\nexports.notifyEventProcessors = eventProcessors.notifyEventProcessors;\nexports.getEnvelopeEndpointWithUrlEncodedAuth = api.getEnvelopeEndpointWithUrlEncodedAuth;\nexports.getReportDialogEndpoint = api.getReportDialogEndpoint;\nexports.BaseClient = client.BaseClient;\nexports.Client = client.Client;\nexports.ServerRuntimeClient = serverRuntimeClient.ServerRuntimeClient;\nexports.initAndBind = sdk.initAndBind;\nexports.setCurrentClient = sdk.setCurrentClient;\nexports.createTransport = base.createTransport;\nexports.makeOfflineTransport = offline.makeOfflineTransport;\nexports.makeMultiplexedTransport = multiplexed.makeMultiplexedTransport;\nexports.addIntegration = integration.addIntegration;\nexports.defineIntegration = integration.defineIntegration;\nexports.getIntegrationsToSetup = integration.getIntegrationsToSetup;\nexports.applyScopeDataToEvent = applyScopeDataToEvent.applyScopeDataToEvent;\nexports.mergeScopeData = applyScopeDataToEvent.mergeScopeData;\nexports.prepareEvent = prepareEvent.prepareEvent;\nexports.createCheckInEnvelope = checkin.createCheckInEnvelope;\nexports.hasSpansEnabled = hasSpansEnabled.hasSpansEnabled;\nexports.hasTracingEnabled = hasSpansEnabled.hasTracingEnabled;\nexports.isSentryRequestUrl = isSentryRequestUrl.isSentryRequestUrl;\nexports.handleCallbackErrors = handleCallbackErrors.handleCallbackErrors;\nexports.fmt = parameterize.fmt;\nexports.parameterize = parameterize.parameterize;\nexports.addAutoIpAddressToSession = ipAddress.addAutoIpAddressToSession;\nexports.addAutoIpAddressToUser = ipAddress.addAutoIpAddressToUser;\nexports.addChildSpanToSpan = spanUtils.addChildSpanToSpan;\nexports.convertSpanLinksForEnvelope = spanUtils.convertSpanLinksForEnvelope;\nexports.getActiveSpan = spanUtils.getActiveSpan;\nexports.getRootSpan = spanUtils.getRootSpan;\nexports.getSpanDescendants = spanUtils.getSpanDescendants;\nexports.getStatusMessage = spanUtils.getStatusMessage;\nexports.spanIsSampled = spanUtils.spanIsSampled;\nexports.spanTimeInputToSeconds = spanUtils.spanTimeInputToSeconds;\nexports.spanToJSON = spanUtils.spanToJSON;\nexports.spanToTraceContext = spanUtils.spanToTraceContext;\nexports.spanToTraceHeader = spanUtils.spanToTraceHeader;\nexports.updateSpanName = spanUtils.updateSpanName;\nexports.parseSampleRate = parseSampleRate.parseSampleRate;\nexports.applySdkMetadata = sdkMetadata.applySdkMetadata;\nexports.getTraceData = traceData.getTraceData;\nexports.getTraceMetaTags = meta.getTraceMetaTags;\nexports.extractQueryParamsFromUrl = request.extractQueryParamsFromUrl;\nexports.headersToDict = request.headersToDict;\nexports.httpRequestToRequestData = request.httpRequestToRequestData;\nexports.winterCGHeadersToDict = request.winterCGHeadersToDict;\nexports.winterCGRequestToRequestData = request.winterCGRequestToRequestData;\nexports.DEFAULT_ENVIRONMENT = constants.DEFAULT_ENVIRONMENT;\nexports.addBreadcrumb = breadcrumbs.addBreadcrumb;\nexports.functionToStringIntegration = functiontostring.functionToStringIntegration;\nexports.eventFiltersIntegration = eventFilters.eventFiltersIntegration;\nexports.inboundFiltersIntegration = eventFilters.inboundFiltersIntegration;\nexports.linkedErrorsIntegration = linkederrors.linkedErrorsIntegration;\nexports.moduleMetadataIntegration = metadata.moduleMetadataIntegration;\nexports.requestDataIntegration = requestdata.requestDataIntegration;\nexports.captureConsoleIntegration = captureconsole.captureConsoleIntegration;\nexports.dedupeIntegration = dedupe.dedupeIntegration;\nexports.extraErrorDataIntegration = extraerrordata.extraErrorDataIntegration;\nexports.rewriteFramesIntegration = rewriteframes.rewriteFramesIntegration;\nexports.instrumentSupabaseClient = supabase.instrumentSupabaseClient;\nexports.supabaseIntegration = supabase.supabaseIntegration;\nexports.zodErrorsIntegration = zoderrors.zodErrorsIntegration;\nexports.thirdPartyErrorFilterIntegration = thirdPartyErrorsFilter.thirdPartyErrorFilterIntegration;\nexports.consoleIntegration = console.consoleIntegration;\nexports.profiler = profiling.profiler;\nexports.instrumentFetchRequest = fetch.instrumentFetchRequest;\nexports.trpcMiddleware = trpc.trpcMiddleware;\nexports.wrapMcpServerWithSentry = mcpServer.wrapMcpServerWithSentry;\nexports.captureFeedback = feedback.captureFeedback;\nexports._INTERNAL_captureLog = exports$2._INTERNAL_captureLog;\nexports._INTERNAL_captureSerializedLog = exports$2._INTERNAL_captureSerializedLog;\nexports._INTERNAL_flushLogsBuffer = exports$2._INTERNAL_flushLogsBuffer;\nexports.consoleLoggingIntegration = consoleIntegration.consoleLoggingIntegration;\nexports.applyAggregateErrorsToEvent = aggregateErrors.applyAggregateErrorsToEvent;\nexports.getBreadcrumbLogLevelFromHttpStatusCode = breadcrumbLogLevel.getBreadcrumbLogLevelFromHttpStatusCode;\nexports.getComponentName = browser.getComponentName;\nexports.getLocationHref = browser.getLocationHref;\nexports.htmlTreeAsString = browser.htmlTreeAsString;\nexports.dsnFromString = dsn.dsnFromString;\nexports.dsnToString = dsn.dsnToString;\nexports.makeDsn = dsn.makeDsn;\nexports.SentryError = error.SentryError;\nexports.GLOBAL_OBJ = worldwide.GLOBAL_OBJ;\nexports.addConsoleInstrumentationHandler = console$1.addConsoleInstrumentationHandler;\nexports.addFetchEndInstrumentationHandler = fetch$1.addFetchEndInstrumentationHandler;\nexports.addFetchInstrumentationHandler = fetch$1.addFetchInstrumentationHandler;\nexports.addGlobalErrorInstrumentationHandler = globalError.addGlobalErrorInstrumentationHandler;\nexports.addGlobalUnhandledRejectionInstrumentationHandler = globalUnhandledRejection.addGlobalUnhandledRejectionInstrumentationHandler;\nexports.addHandler = handlers.addHandler;\nexports.maybeInstrument = handlers.maybeInstrument;\nexports.resetInstrumentationHandlers = handlers.resetInstrumentationHandlers;\nexports.triggerHandlers = handlers.triggerHandlers;\nexports.isDOMError = is.isDOMError;\nexports.isDOMException = is.isDOMException;\nexports.isElement = is.isElement;\nexports.isError = is.isError;\nexports.isErrorEvent = is.isErrorEvent;\nexports.isEvent = is.isEvent;\nexports.isInstanceOf = is.isInstanceOf;\nexports.isParameterizedString = is.isParameterizedString;\nexports.isPlainObject = is.isPlainObject;\nexports.isPrimitive = is.isPrimitive;\nexports.isRegExp = is.isRegExp;\nexports.isString = is.isString;\nexports.isSyntheticEvent = is.isSyntheticEvent;\nexports.isThenable = is.isThenable;\nexports.isVueViewModel = is.isVueViewModel;\nexports.isBrowser = isBrowser.isBrowser;\nexports.CONSOLE_LEVELS = logger.CONSOLE_LEVELS;\nexports.consoleSandbox = logger.consoleSandbox;\nexports.logger = logger.logger;\nexports.originalConsoleMethods = logger.originalConsoleMethods;\nexports.addContextToFrame = misc.addContextToFrame;\nexports.addExceptionMechanism = misc.addExceptionMechanism;\nexports.addExceptionTypeValue = misc.addExceptionTypeValue;\nexports.checkOrSetAlreadyCaught = misc.checkOrSetAlreadyCaught;\nexports.getEventDescription = misc.getEventDescription;\nexports.parseSemver = misc.parseSemver;\nexports.uuid4 = misc.uuid4;\nexports.isNodeEnv = node.isNodeEnv;\nexports.loadModule = node.loadModule;\nexports.normalize = normalize.normalize;\nexports.normalizeToSize = normalize.normalizeToSize;\nexports.normalizeUrlToBase = normalize.normalizeUrlToBase;\nexports.addNonEnumerableProperty = object.addNonEnumerableProperty;\nexports.convertToPlainObject = object.convertToPlainObject;\nexports.dropUndefinedKeys = object.dropUndefinedKeys;\nexports.extractExceptionKeysForMessage = object.extractExceptionKeysForMessage;\nexports.fill = object.fill;\nexports.getOriginalFunction = object.getOriginalFunction;\nexports.markFunctionWrapped = object.markFunctionWrapped;\nexports.objectify = object.objectify;\nexports.basename = path.basename;\nexports.dirname = path.dirname;\nexports.isAbsolute = path.isAbsolute;\nexports.join = path.join;\nexports.normalizePath = path.normalizePath;\nexports.relative = path.relative;\nexports.resolve = path.resolve;\nexports.SENTRY_BUFFER_FULL_ERROR = promisebuffer.SENTRY_BUFFER_FULL_ERROR;\nexports.makePromiseBuffer = promisebuffer.makePromiseBuffer;\nexports.severityLevelFromString = severity.severityLevelFromString;\nexports.UNKNOWN_FUNCTION = stacktrace.UNKNOWN_FUNCTION;\nexports.createStackParser = stacktrace.createStackParser;\nexports.getFramesFromEvent = stacktrace.getFramesFromEvent;\nexports.getFunctionName = stacktrace.getFunctionName;\nexports.stackParserFromStackParserOptions = stacktrace.stackParserFromStackParserOptions;\nexports.stripSentryFramesAndReverse = stacktrace.stripSentryFramesAndReverse;\nexports.filenameIsInApp = nodeStackTrace.filenameIsInApp;\nexports.node = nodeStackTrace.node;\nexports.nodeStackLineParser = nodeStackTrace.nodeStackLineParser;\nexports.isMatchingPattern = string.isMatchingPattern;\nexports.safeJoin = string.safeJoin;\nexports.snipLine = string.snipLine;\nexports.stringMatchesSomePattern = string.stringMatchesSomePattern;\nexports.truncate = string.truncate;\nexports.isNativeFunction = supports.isNativeFunction;\nexports.supportsDOMError = supports.supportsDOMError;\nexports.supportsDOMException = supports.supportsDOMException;\nexports.supportsErrorEvent = supports.supportsErrorEvent;\nexports.supportsFetch = supports.supportsFetch;\nexports.supportsHistory = supports.supportsHistory;\nexports.supportsNativeFetch = supports.supportsNativeFetch;\nexports.supportsReferrerPolicy = supports.supportsReferrerPolicy;\nexports.supportsReportingObserver = supports.supportsReportingObserver;\nexports.SyncPromise = syncpromise.SyncPromise;\nexports.rejectedSyncPromise = syncpromise.rejectedSyncPromise;\nexports.resolvedSyncPromise = syncpromise.resolvedSyncPromise;\nexports.browserPerformanceTimeOrigin = time.browserPerformanceTimeOrigin;\nexports.dateTimestampInSeconds = time.dateTimestampInSeconds;\nexports.timestampInSeconds = time.timestampInSeconds;\nexports.TRACEPARENT_REGEXP = tracing.TRACEPARENT_REGEXP;\nexports.extractTraceparentData = tracing.extractTraceparentData;\nexports.generateSentryTraceHeader = tracing.generateSentryTraceHeader;\nexports.propagationContextFromHeaders = tracing.propagationContextFromHeaders;\nexports.getSDKSource = env.getSDKSource;\nexports.isBrowserBundle = env.isBrowserBundle;\nexports.addItemToEnvelope = envelope$1.addItemToEnvelope;\nexports.createAttachmentEnvelopeItem = envelope$1.createAttachmentEnvelopeItem;\nexports.createEnvelope = envelope$1.createEnvelope;\nexports.createEventEnvelopeHeaders = envelope$1.createEventEnvelopeHeaders;\nexports.createSpanEnvelopeItem = envelope$1.createSpanEnvelopeItem;\nexports.envelopeContainsItemType = envelope$1.envelopeContainsItemType;\nexports.envelopeItemTypeToDataCategory = envelope$1.envelopeItemTypeToDataCategory;\nexports.forEachEnvelopeItem = envelope$1.forEachEnvelopeItem;\nexports.getSdkMetadataForEnvelopeHeader = envelope$1.getSdkMetadataForEnvelopeHeader;\nexports.parseEnvelope = envelope$1.parseEnvelope;\nexports.serializeEnvelope = envelope$1.serializeEnvelope;\nexports.createClientReportEnvelope = clientreport.createClientReportEnvelope;\nexports.DEFAULT_RETRY_AFTER = ratelimit.DEFAULT_RETRY_AFTER;\nexports.disabledUntil = ratelimit.disabledUntil;\nexports.isRateLimited = ratelimit.isRateLimited;\nexports.parseRetryAfterHeader = ratelimit.parseRetryAfterHeader;\nexports.updateRateLimits = ratelimit.updateRateLimits;\nexports.MAX_BAGGAGE_STRING_LENGTH = baggage.MAX_BAGGAGE_STRING_LENGTH;\nexports.SENTRY_BAGGAGE_KEY_PREFIX = baggage.SENTRY_BAGGAGE_KEY_PREFIX;\nexports.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = baggage.SENTRY_BAGGAGE_KEY_PREFIX_REGEX;\nexports.baggageHeaderToDynamicSamplingContext = baggage.baggageHeaderToDynamicSamplingContext;\nexports.dynamicSamplingContextToSentryBaggageHeader = baggage.dynamicSamplingContextToSentryBaggageHeader;\nexports.objectToBaggageHeader = baggage.objectToBaggageHeader;\nexports.parseBaggageHeader = baggage.parseBaggageHeader;\nexports.getHttpSpanDetailsFromUrlObject = url.getHttpSpanDetailsFromUrlObject;\nexports.getSanitizedUrlString = url.getSanitizedUrlString;\nexports.getSanitizedUrlStringFromUrlObject = url.getSanitizedUrlStringFromUrlObject;\nexports.isURLObjectRelative = url.isURLObjectRelative;\nexports.parseStringToURLObject = url.parseStringToURLObject;\nexports.parseUrl = url.parseUrl;\nexports.stripUrlQueryAndFragment = url.stripUrlQueryAndFragment;\nexports.eventFromMessage = eventbuilder.eventFromMessage;\nexports.eventFromUnknownInput = eventbuilder.eventFromUnknownInput;\nexports.exceptionFromError = eventbuilder.exceptionFromError;\nexports.parseStackFrames = eventbuilder.parseStackFrames;\nexports.callFrameToStackFrame = anr.callFrameToStackFrame;\nexports.watchdogTimer = anr.watchdogTimer;\nexports.LRUMap = lru.LRUMap;\nexports.generateSpanId = propagationContext.generateSpanId;\nexports.generateTraceId = propagationContext.generateTraceId;\nexports.vercelWaitUntil = vercelWaitUntil.vercelWaitUntil;\nexports.SDK_VERSION = version.SDK_VERSION;\nexports.getDebugImagesForResources = debugIds.getDebugImagesForResources;\nexports.getFilenameToDebugIdMap = debugIds.getFilenameToDebugIdMap;\nexports.escapeStringForRegex = escapeStringForRegex.escapeStringForRegex;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLGVBQWUsbUJBQU8sQ0FBQyw2SEFBcUI7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLDJIQUFvQjtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyxpSUFBdUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMscUlBQXlCO0FBQ3BELCtCQUErQixtQkFBTyxDQUFDLDZKQUFxQztBQUM1RSxtQkFBbUIsbUJBQU8sQ0FBQyxxSUFBeUI7QUFDcEQsY0FBYyxtQkFBTyxDQUFDLDJIQUFvQjtBQUMxQywrQkFBK0IsbUJBQU8sQ0FBQyw2SkFBcUM7QUFDNUUsb0JBQW9CLG1CQUFPLENBQUMsdUlBQTBCO0FBQ3RELGlCQUFpQixtQkFBTyxDQUFDLGlJQUF1QjtBQUNoRCxpQkFBaUIsbUJBQU8sQ0FBQyxpSUFBdUI7QUFDaEQsMkJBQTJCLG1CQUFPLENBQUMscUlBQXlCO0FBQzVELGlCQUFpQixtQkFBTyxDQUFDLGlIQUFlO0FBQ3hDLGtCQUFrQixtQkFBTyxDQUFDLCtHQUFjO0FBQ3hDLHNCQUFzQixtQkFBTyxDQUFDLDJIQUFvQjtBQUNsRCxzQkFBc0IsbUJBQU8sQ0FBQywySEFBb0I7QUFDbEQsY0FBYyxtQkFBTyxDQUFDLHFJQUF5QjtBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQywrR0FBYztBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQywrR0FBYztBQUN0QyxjQUFjLG1CQUFPLENBQUMsMkdBQVk7QUFDbEMsd0JBQXdCLG1CQUFPLENBQUMsK0hBQXNCO0FBQ3RELFlBQVksbUJBQU8sQ0FBQyx1R0FBVTtBQUM5QixlQUFlLG1CQUFPLENBQUMsNkdBQWE7QUFDcEMsNEJBQTRCLG1CQUFPLENBQUMsMklBQTRCO0FBQ2hFLFlBQVksbUJBQU8sQ0FBQyx1R0FBVTtBQUM5QixhQUFhLG1CQUFPLENBQUMsK0hBQXNCO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLHFJQUF5QjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQyw2SUFBNkI7QUFDekQsb0JBQW9CLG1CQUFPLENBQUMsdUhBQWtCO0FBQzlDLDhCQUE4QixtQkFBTyxDQUFDLHVKQUFrQztBQUN4RSxxQkFBcUIsbUJBQU8sQ0FBQyxxSUFBeUI7QUFDdEQsZ0JBQWdCLG1CQUFPLENBQUMsK0dBQWM7QUFDdEMsd0JBQXdCLG1CQUFPLENBQUMsMklBQTRCO0FBQzVELDJCQUEyQixtQkFBTyxDQUFDLGlKQUErQjtBQUNsRSw2QkFBNkIsbUJBQU8sQ0FBQyxxSkFBaUM7QUFDdEUscUJBQXFCLG1CQUFPLENBQUMscUlBQXlCO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLCtIQUFzQjtBQUNoRCxrQkFBa0IsbUJBQU8sQ0FBQywrSEFBc0I7QUFDaEQsd0JBQXdCLG1CQUFPLENBQUMsMklBQTRCO0FBQzVELG9CQUFvQixtQkFBTyxDQUFDLG1JQUF3QjtBQUNwRCxrQkFBa0IsbUJBQU8sQ0FBQywrSEFBc0I7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLHFIQUFpQjtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQywySEFBb0I7QUFDNUMsa0JBQWtCLG1CQUFPLENBQUMsbUhBQWdCO0FBQzFDLG9CQUFvQixtQkFBTyxDQUFDLHVIQUFrQjtBQUM5Qyx5QkFBeUIsbUJBQU8sQ0FBQywySkFBb0M7QUFDckUscUJBQXFCLG1CQUFPLENBQUMsbUpBQWdDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLG1KQUFnQztBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQywySUFBNEI7QUFDckQsb0JBQW9CLG1CQUFPLENBQUMsaUpBQStCO0FBQzNELHVCQUF1QixtQkFBTyxDQUFDLHVKQUFrQztBQUNqRSxlQUFlLG1CQUFPLENBQUMsdUlBQTBCO0FBQ2pELHVCQUF1QixtQkFBTyxDQUFDLHVKQUFrQztBQUNqRSxzQkFBc0IsbUJBQU8sQ0FBQyxxSkFBaUM7QUFDL0QsaUJBQWlCLG1CQUFPLENBQUMsMklBQTRCO0FBQ3JELGtCQUFrQixtQkFBTyxDQUFDLDZJQUE2QjtBQUN2RCwrQkFBK0IsbUJBQU8sQ0FBQyw2S0FBNkM7QUFDcEYsZ0JBQWdCLG1CQUFPLENBQUMseUlBQTJCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLG1IQUFnQjtBQUMxQyxjQUFjLG1CQUFPLENBQUMsMkdBQVk7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLHlHQUFXO0FBQ2hDLGtCQUFrQixtQkFBTyxDQUFDLHFIQUFpQjtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyxpSEFBZTtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyx5SEFBbUI7QUFDN0MsMkJBQTJCLG1CQUFPLENBQUMsaUpBQStCO0FBQ2xFLHdCQUF3QixtQkFBTyxDQUFDLHlKQUFtQztBQUNuRSwyQkFBMkIsbUJBQU8sQ0FBQyxpS0FBdUM7QUFDMUUsZ0JBQWdCLG1CQUFPLENBQUMsdUlBQTBCO0FBQ2xELFlBQVksbUJBQU8sQ0FBQywrSEFBc0I7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLG1JQUF3QjtBQUM5QyxrQkFBa0IsbUJBQU8sQ0FBQywySUFBNEI7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsNkpBQXFDO0FBQy9ELGdCQUFnQixtQkFBTyxDQUFDLHlKQUFtQztBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQyxxS0FBeUM7QUFDckUsaUNBQWlDLG1CQUFPLENBQUMsK0xBQXNEO0FBQy9GLGlCQUFpQixtQkFBTyxDQUFDLCtKQUFzQztBQUMvRCxXQUFXLG1CQUFPLENBQUMsNkhBQXFCO0FBQ3hDLGtCQUFrQixtQkFBTyxDQUFDLDJJQUE0QjtBQUN0RCxlQUFlLG1CQUFPLENBQUMscUlBQXlCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQyxpSUFBdUI7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLGlJQUF1QjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQywySUFBNEI7QUFDdEQsZUFBZSxtQkFBTyxDQUFDLHFJQUF5QjtBQUNoRCxhQUFhLG1CQUFPLENBQUMsaUlBQXVCO0FBQzVDLHNCQUFzQixtQkFBTyxDQUFDLG1KQUFnQztBQUM5RCxpQkFBaUIsbUJBQU8sQ0FBQyx5SUFBMkI7QUFDcEQsbUJBQW1CLG1CQUFPLENBQUMsNklBQTZCO0FBQ3hELHVCQUF1QixtQkFBTyxDQUFDLHlKQUFtQztBQUNsRSxlQUFlLG1CQUFPLENBQUMscUlBQXlCO0FBQ2hELGlCQUFpQixtQkFBTyxDQUFDLHlJQUEyQjtBQUNwRCxvQkFBb0IsbUJBQU8sQ0FBQywrSUFBOEI7QUFDMUQsYUFBYSxtQkFBTyxDQUFDLGlJQUF1QjtBQUM1QyxnQkFBZ0IsbUJBQU8sQ0FBQyx1SUFBMEI7QUFDbEQsWUFBWSxtQkFBTyxDQUFDLCtIQUFzQjtBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQyx5SUFBMkI7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsaUpBQStCO0FBQzVELGtCQUFrQixtQkFBTyxDQUFDLDJJQUE0QjtBQUN0RCxnQkFBZ0IsbUJBQU8sQ0FBQyx1SUFBMEI7QUFDbEQsWUFBWSxtQkFBTyxDQUFDLCtIQUFzQjtBQUMxQyxxQkFBcUIsbUJBQU8sQ0FBQyxpSkFBK0I7QUFDNUQsWUFBWSxtQkFBTyxDQUFDLCtIQUFzQjtBQUMxQyxZQUFZLG1CQUFPLENBQUMsK0hBQXNCO0FBQzFDLDJCQUEyQixtQkFBTyxDQUFDLDZKQUFxQztBQUN4RSx3QkFBd0IsbUJBQU8sQ0FBQyx1SkFBa0M7QUFDbEUsZ0JBQWdCLG1CQUFPLENBQUMsdUlBQTBCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLDJJQUE0QjtBQUNyRCw2QkFBNkIsbUJBQU8sQ0FBQywrS0FBOEM7Ozs7QUFJbkYsd0NBQXdDO0FBQ3hDLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0Isd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsOEJBQThCO0FBQzlCLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIseUJBQXlCO0FBQ3pCLGlDQUFpQztBQUNqQyxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLDJDQUEyQztBQUMzQywwQ0FBMEM7QUFDMUMseUNBQXlDO0FBQ3pDLDJCQUEyQjtBQUMzQixzQkFBc0I7QUFDdEIsaUNBQWlDO0FBQ2pDLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG9DQUFvQztBQUNwQywwQ0FBMEM7QUFDMUMsb0NBQW9DO0FBQ3BDLHlDQUF5QztBQUN6Qyw4Q0FBOEM7QUFDOUMscUNBQXFDO0FBQ3JDLGtEQUFrRDtBQUNsRCx5REFBeUQ7QUFDekQsa0RBQWtEO0FBQ2xELG1EQUFtRDtBQUNuRCxvQ0FBb0M7QUFDcEMsd0NBQXdDO0FBQ3hDLDREQUE0RDtBQUM1RCw2Q0FBNkM7QUFDN0Msd0NBQXdDO0FBQ3hDLG1DQUFtQztBQUNuQyx5Q0FBeUM7QUFDekMsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsY0FBYztBQUNkLGVBQWU7QUFDZixlQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsZ0NBQWdDO0FBQ2hDLDBCQUEwQjtBQUMxQixpQkFBaUI7QUFDakIsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2IsNkJBQTZCO0FBQzdCLDZDQUE2QztBQUM3QywrQkFBK0I7QUFDL0Isa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCwyQkFBMkI7QUFDM0IsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQyxzQkFBc0I7QUFDdEIseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0Isc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQiw2QkFBNkI7QUFDN0IsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLFdBQVc7QUFDWCxvQkFBb0I7QUFDcEIsaUNBQWlDO0FBQ2pDLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsbUNBQW1DO0FBQ25DLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsOEJBQThCO0FBQzlCLGtCQUFrQjtBQUNsQiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIsaUNBQWlDO0FBQ2pDLHFCQUFxQjtBQUNyQixnQ0FBZ0M7QUFDaEMsNkJBQTZCO0FBQzdCLG9DQUFvQztBQUNwQywyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCLG1DQUFtQztBQUNuQywrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyx5QkFBeUI7QUFDekIsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1Qix3Q0FBd0M7QUFDeEMsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQiw4QkFBOEI7QUFDOUIsc0JBQXNCO0FBQ3RCLCtCQUErQjtBQUMvQix1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCLHNDQUFzQztBQUN0QyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLG1DQUFtQztBQUNuQywrQ0FBK0M7QUFDL0Msd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQix3Q0FBd0M7QUFDeEMseUNBQXlDO0FBQ3pDLHNDQUFzQztBQUN0Qyw0Q0FBNEM7QUFDNUMseURBQXlEO0FBQ3pELGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIsb0NBQW9DO0FBQ3BDLHVCQUF1QjtBQUN2QixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCLGVBQWU7QUFDZixvQkFBb0I7QUFDcEIsNkJBQTZCO0FBQzdCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQix3QkFBd0I7QUFDeEIsa0JBQWtCO0FBQ2xCLHNCQUFzQjtBQUN0QixpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixjQUFjO0FBQ2QsOEJBQThCO0FBQzlCLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQiwyQkFBMkI7QUFDM0IsbUJBQW1CO0FBQ25CLGFBQWE7QUFDYixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsMEJBQTBCO0FBQzFCLGdDQUFnQztBQUNoQyw0QkFBNEI7QUFDNUIseUJBQXlCO0FBQ3pCLHNDQUFzQztBQUN0QyxZQUFZO0FBQ1osMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGdDQUFnQztBQUNoQyx5QkFBeUI7QUFDekIsK0JBQStCO0FBQy9CLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2Qix5Q0FBeUM7QUFDekMsbUNBQW1DO0FBQ25DLHVCQUF1QjtBQUN2QixZQUFZO0FBQ1osMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6QixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdDQUFnQztBQUNoQyxnQkFBZ0I7QUFDaEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qiw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkIsMkJBQTJCO0FBQzNCLDhCQUE4QjtBQUM5QixpQ0FBaUM7QUFDakMsbUJBQW1CO0FBQ25CLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0Isb0NBQW9DO0FBQ3BDLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5QixpQ0FBaUM7QUFDakMscUNBQXFDO0FBQ3JDLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLG9DQUFvQztBQUNwQyxzQkFBc0I7QUFDdEIsa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QixnQ0FBZ0M7QUFDaEMsc0NBQXNDO0FBQ3RDLDJCQUEyQjtBQUMzQix1Q0FBdUM7QUFDdkMscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6QixrQ0FBa0M7QUFDbEMsMkJBQTJCO0FBQzNCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsNkJBQTZCO0FBQzdCLHdCQUF3QjtBQUN4QixpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLHVDQUF1QztBQUN2Qyw2Q0FBNkM7QUFDN0MsbURBQW1EO0FBQ25ELDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIsdUNBQXVDO0FBQ3ZDLDZCQUE2QjtBQUM3QiwwQ0FBMEM7QUFDMUMsMkJBQTJCO0FBQzNCLDhCQUE4QjtBQUM5QixnQkFBZ0I7QUFDaEIsZ0NBQWdDO0FBQ2hDLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0IsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0IscUJBQXFCO0FBQ3JCLGNBQWM7QUFDZCxzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkIsa0NBQWtDO0FBQ2xDLCtCQUErQjtBQUMvQiw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vdHJhY2luZy9lcnJvcnMuanMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi90cmFjaW5nL3V0aWxzLmpzJyk7XG5jb25zdCBpZGxlU3BhbiA9IHJlcXVpcmUoJy4vdHJhY2luZy9pZGxlU3Bhbi5qcycpO1xuY29uc3Qgc2VudHJ5U3BhbiA9IHJlcXVpcmUoJy4vdHJhY2luZy9zZW50cnlTcGFuLmpzJyk7XG5jb25zdCBzZW50cnlOb25SZWNvcmRpbmdTcGFuID0gcmVxdWlyZSgnLi90cmFjaW5nL3NlbnRyeU5vblJlY29yZGluZ1NwYW4uanMnKTtcbmNvbnN0IHNwYW5zdGF0dXMgPSByZXF1aXJlKCcuL3RyYWNpbmcvc3BhbnN0YXR1cy5qcycpO1xuY29uc3QgdHJhY2UgPSByZXF1aXJlKCcuL3RyYWNpbmcvdHJhY2UuanMnKTtcbmNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSByZXF1aXJlKCcuL3RyYWNpbmcvZHluYW1pY1NhbXBsaW5nQ29udGV4dC5qcycpO1xuY29uc3QgbWVhc3VyZW1lbnQgPSByZXF1aXJlKCcuL3RyYWNpbmcvbWVhc3VyZW1lbnQuanMnKTtcbmNvbnN0IHNhbXBsaW5nID0gcmVxdWlyZSgnLi90cmFjaW5nL3NhbXBsaW5nLmpzJyk7XG5jb25zdCBsb2dTcGFucyA9IHJlcXVpcmUoJy4vdHJhY2luZy9sb2dTcGFucy5qcycpO1xuY29uc3Qgc2VtYW50aWNBdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9zZW1hbnRpY0F0dHJpYnV0ZXMuanMnKTtcbmNvbnN0IGVudmVsb3BlID0gcmVxdWlyZSgnLi9lbnZlbG9wZS5qcycpO1xuY29uc3QgZXhwb3J0cyQxID0gcmVxdWlyZSgnLi9leHBvcnRzLmpzJyk7XG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBkZWZhdWx0U2NvcGVzID0gcmVxdWlyZSgnLi9kZWZhdWx0U2NvcGVzLmpzJyk7XG5jb25zdCBpbmRleCA9IHJlcXVpcmUoJy4vYXN5bmNDb250ZXh0L2luZGV4LmpzJyk7XG5jb25zdCBjYXJyaWVyID0gcmVxdWlyZSgnLi9jYXJyaWVyLmpzJyk7XG5jb25zdCBzZXNzaW9uID0gcmVxdWlyZSgnLi9zZXNzaW9uLmpzJyk7XG5jb25zdCBzY29wZSA9IHJlcXVpcmUoJy4vc2NvcGUuanMnKTtcbmNvbnN0IGV2ZW50UHJvY2Vzc29ycyA9IHJlcXVpcmUoJy4vZXZlbnRQcm9jZXNzb3JzLmpzJyk7XG5jb25zdCBhcGkgPSByZXF1aXJlKCcuL2FwaS5qcycpO1xuY29uc3QgY2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQuanMnKTtcbmNvbnN0IHNlcnZlclJ1bnRpbWVDbGllbnQgPSByZXF1aXJlKCcuL3NlcnZlci1ydW50aW1lLWNsaWVudC5qcycpO1xuY29uc3Qgc2RrID0gcmVxdWlyZSgnLi9zZGsuanMnKTtcbmNvbnN0IGJhc2UgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvYmFzZS5qcycpO1xuY29uc3Qgb2ZmbGluZSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9vZmZsaW5lLmpzJyk7XG5jb25zdCBtdWx0aXBsZXhlZCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9tdWx0aXBsZXhlZC5qcycpO1xuY29uc3QgaW50ZWdyYXRpb24gPSByZXF1aXJlKCcuL2ludGVncmF0aW9uLmpzJyk7XG5jb25zdCBhcHBseVNjb3BlRGF0YVRvRXZlbnQgPSByZXF1aXJlKCcuL3V0aWxzL2FwcGx5U2NvcGVEYXRhVG9FdmVudC5qcycpO1xuY29uc3QgcHJlcGFyZUV2ZW50ID0gcmVxdWlyZSgnLi91dGlscy9wcmVwYXJlRXZlbnQuanMnKTtcbmNvbnN0IGNoZWNraW4gPSByZXF1aXJlKCcuL2NoZWNraW4uanMnKTtcbmNvbnN0IGhhc1NwYW5zRW5hYmxlZCA9IHJlcXVpcmUoJy4vdXRpbHMvaGFzU3BhbnNFbmFibGVkLmpzJyk7XG5jb25zdCBpc1NlbnRyeVJlcXVlc3RVcmwgPSByZXF1aXJlKCcuL3V0aWxzL2lzU2VudHJ5UmVxdWVzdFVybC5qcycpO1xuY29uc3QgaGFuZGxlQ2FsbGJhY2tFcnJvcnMgPSByZXF1aXJlKCcuL3V0aWxzL2hhbmRsZUNhbGxiYWNrRXJyb3JzLmpzJyk7XG5jb25zdCBwYXJhbWV0ZXJpemUgPSByZXF1aXJlKCcuL3V0aWxzL3BhcmFtZXRlcml6ZS5qcycpO1xuY29uc3QgaXBBZGRyZXNzID0gcmVxdWlyZSgnLi91dGlscy9pcEFkZHJlc3MuanMnKTtcbmNvbnN0IHNwYW5VdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvc3BhblV0aWxzLmpzJyk7XG5jb25zdCBwYXJzZVNhbXBsZVJhdGUgPSByZXF1aXJlKCcuL3V0aWxzL3BhcnNlU2FtcGxlUmF0ZS5qcycpO1xuY29uc3Qgc2RrTWV0YWRhdGEgPSByZXF1aXJlKCcuL3V0aWxzL3Nka01ldGFkYXRhLmpzJyk7XG5jb25zdCB0cmFjZURhdGEgPSByZXF1aXJlKCcuL3V0aWxzL3RyYWNlRGF0YS5qcycpO1xuY29uc3QgbWV0YSA9IHJlcXVpcmUoJy4vdXRpbHMvbWV0YS5qcycpO1xuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJy4vdXRpbHMvcmVxdWVzdC5qcycpO1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMuanMnKTtcbmNvbnN0IGJyZWFkY3J1bWJzID0gcmVxdWlyZSgnLi9icmVhZGNydW1icy5qcycpO1xuY29uc3QgZnVuY3Rpb250b3N0cmluZyA9IHJlcXVpcmUoJy4vaW50ZWdyYXRpb25zL2Z1bmN0aW9udG9zdHJpbmcuanMnKTtcbmNvbnN0IGV2ZW50RmlsdGVycyA9IHJlcXVpcmUoJy4vaW50ZWdyYXRpb25zL2V2ZW50RmlsdGVycy5qcycpO1xuY29uc3QgbGlua2VkZXJyb3JzID0gcmVxdWlyZSgnLi9pbnRlZ3JhdGlvbnMvbGlua2VkZXJyb3JzLmpzJyk7XG5jb25zdCBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vaW50ZWdyYXRpb25zL21ldGFkYXRhLmpzJyk7XG5jb25zdCByZXF1ZXN0ZGF0YSA9IHJlcXVpcmUoJy4vaW50ZWdyYXRpb25zL3JlcXVlc3RkYXRhLmpzJyk7XG5jb25zdCBjYXB0dXJlY29uc29sZSA9IHJlcXVpcmUoJy4vaW50ZWdyYXRpb25zL2NhcHR1cmVjb25zb2xlLmpzJyk7XG5jb25zdCBkZWR1cGUgPSByZXF1aXJlKCcuL2ludGVncmF0aW9ucy9kZWR1cGUuanMnKTtcbmNvbnN0IGV4dHJhZXJyb3JkYXRhID0gcmVxdWlyZSgnLi9pbnRlZ3JhdGlvbnMvZXh0cmFlcnJvcmRhdGEuanMnKTtcbmNvbnN0IHJld3JpdGVmcmFtZXMgPSByZXF1aXJlKCcuL2ludGVncmF0aW9ucy9yZXdyaXRlZnJhbWVzLmpzJyk7XG5jb25zdCBzdXBhYmFzZSA9IHJlcXVpcmUoJy4vaW50ZWdyYXRpb25zL3N1cGFiYXNlLmpzJyk7XG5jb25zdCB6b2RlcnJvcnMgPSByZXF1aXJlKCcuL2ludGVncmF0aW9ucy96b2RlcnJvcnMuanMnKTtcbmNvbnN0IHRoaXJkUGFydHlFcnJvcnNGaWx0ZXIgPSByZXF1aXJlKCcuL2ludGVncmF0aW9ucy90aGlyZC1wYXJ0eS1lcnJvcnMtZmlsdGVyLmpzJyk7XG5jb25zdCBjb25zb2xlID0gcmVxdWlyZSgnLi9pbnRlZ3JhdGlvbnMvY29uc29sZS5qcycpO1xuY29uc3QgcHJvZmlsaW5nID0gcmVxdWlyZSgnLi9wcm9maWxpbmcuanMnKTtcbmNvbnN0IGZldGNoID0gcmVxdWlyZSgnLi9mZXRjaC5qcycpO1xuY29uc3QgdHJwYyA9IHJlcXVpcmUoJy4vdHJwYy5qcycpO1xuY29uc3QgbWNwU2VydmVyID0gcmVxdWlyZSgnLi9tY3Atc2VydmVyLmpzJyk7XG5jb25zdCBmZWVkYmFjayA9IHJlcXVpcmUoJy4vZmVlZGJhY2suanMnKTtcbmNvbnN0IGV4cG9ydHMkMiA9IHJlcXVpcmUoJy4vbG9ncy9leHBvcnRzLmpzJyk7XG5jb25zdCBjb25zb2xlSW50ZWdyYXRpb24gPSByZXF1aXJlKCcuL2xvZ3MvY29uc29sZS1pbnRlZ3JhdGlvbi5qcycpO1xuY29uc3QgYWdncmVnYXRlRXJyb3JzID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9hZ2dyZWdhdGUtZXJyb3JzLmpzJyk7XG5jb25zdCBicmVhZGNydW1iTG9nTGV2ZWwgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2JyZWFkY3J1bWItbG9nLWxldmVsLmpzJyk7XG5jb25zdCBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9icm93c2VyLmpzJyk7XG5jb25zdCBkc24gPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2Rzbi5qcycpO1xuY29uc3QgZXJyb3IgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2Vycm9yLmpzJyk7XG5jb25zdCB3b3JsZHdpZGUgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3dvcmxkd2lkZS5qcycpO1xuY29uc3QgY29uc29sZSQxID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9pbnN0cnVtZW50L2NvbnNvbGUuanMnKTtcbmNvbnN0IGZldGNoJDEgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2luc3RydW1lbnQvZmV0Y2guanMnKTtcbmNvbnN0IGdsb2JhbEVycm9yID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9pbnN0cnVtZW50L2dsb2JhbEVycm9yLmpzJyk7XG5jb25zdCBnbG9iYWxVbmhhbmRsZWRSZWplY3Rpb24gPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2luc3RydW1lbnQvZ2xvYmFsVW5oYW5kbGVkUmVqZWN0aW9uLmpzJyk7XG5jb25zdCBoYW5kbGVycyA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvaW5zdHJ1bWVudC9oYW5kbGVycy5qcycpO1xuY29uc3QgaXMgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2lzLmpzJyk7XG5jb25zdCBpc0Jyb3dzZXIgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2lzQnJvd3Nlci5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IG1pc2MgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L21pc2MuanMnKTtcbmNvbnN0IG5vZGUgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L25vZGUuanMnKTtcbmNvbnN0IG5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3Qvbm9ybWFsaXplLmpzJyk7XG5jb25zdCBvYmplY3QgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L29iamVjdC5qcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvcGF0aC5qcycpO1xuY29uc3QgcHJvbWlzZWJ1ZmZlciA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvcHJvbWlzZWJ1ZmZlci5qcycpO1xuY29uc3Qgc2V2ZXJpdHkgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3NldmVyaXR5LmpzJyk7XG5jb25zdCBzdGFja3RyYWNlID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9zdGFja3RyYWNlLmpzJyk7XG5jb25zdCBub2RlU3RhY2tUcmFjZSA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3Qvbm9kZS1zdGFjay10cmFjZS5qcycpO1xuY29uc3Qgc3RyaW5nID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9zdHJpbmcuanMnKTtcbmNvbnN0IHN1cHBvcnRzID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9zdXBwb3J0cy5qcycpO1xuY29uc3Qgc3luY3Byb21pc2UgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3N5bmNwcm9taXNlLmpzJyk7XG5jb25zdCB0aW1lID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC90aW1lLmpzJyk7XG5jb25zdCB0cmFjaW5nID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC90cmFjaW5nLmpzJyk7XG5jb25zdCBlbnYgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2Vudi5qcycpO1xuY29uc3QgZW52ZWxvcGUkMSA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvZW52ZWxvcGUuanMnKTtcbmNvbnN0IGNsaWVudHJlcG9ydCA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvY2xpZW50cmVwb3J0LmpzJyk7XG5jb25zdCByYXRlbGltaXQgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3JhdGVsaW1pdC5qcycpO1xuY29uc3QgYmFnZ2FnZSA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvYmFnZ2FnZS5qcycpO1xuY29uc3QgdXJsID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC91cmwuanMnKTtcbmNvbnN0IGV2ZW50YnVpbGRlciA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvZXZlbnRidWlsZGVyLmpzJyk7XG5jb25zdCBhbnIgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2Fuci5qcycpO1xuY29uc3QgbHJ1ID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9scnUuanMnKTtcbmNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvcHJvcGFnYXRpb25Db250ZXh0LmpzJyk7XG5jb25zdCB2ZXJjZWxXYWl0VW50aWwgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3ZlcmNlbFdhaXRVbnRpbC5qcycpO1xuY29uc3QgdmVyc2lvbiA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvdmVyc2lvbi5qcycpO1xuY29uc3QgZGVidWdJZHMgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2RlYnVnLWlkcy5qcycpO1xuY29uc3QgZXNjYXBlU3RyaW5nRm9yUmVnZXggPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3ZlbmRvci9lc2NhcGVTdHJpbmdGb3JSZWdleC5qcycpO1xuXG5cblxuZXhwb3J0cy5yZWdpc3RlclNwYW5FcnJvckluc3RydW1lbnRhdGlvbiA9IGVycm9ycy5yZWdpc3RlclNwYW5FcnJvckluc3RydW1lbnRhdGlvbjtcbmV4cG9ydHMuZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4gPSB1dGlscy5nZXRDYXB0dXJlZFNjb3Blc09uU3BhbjtcbmV4cG9ydHMuc2V0Q2FwdHVyZWRTY29wZXNPblNwYW4gPSB1dGlscy5zZXRDYXB0dXJlZFNjb3Blc09uU3BhbjtcbmV4cG9ydHMuVFJBQ0lOR19ERUZBVUxUUyA9IGlkbGVTcGFuLlRSQUNJTkdfREVGQVVMVFM7XG5leHBvcnRzLnN0YXJ0SWRsZVNwYW4gPSBpZGxlU3Bhbi5zdGFydElkbGVTcGFuO1xuZXhwb3J0cy5TZW50cnlTcGFuID0gc2VudHJ5U3Bhbi5TZW50cnlTcGFuO1xuZXhwb3J0cy5TZW50cnlOb25SZWNvcmRpbmdTcGFuID0gc2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbi5TZW50cnlOb25SZWNvcmRpbmdTcGFuO1xuZXhwb3J0cy5TUEFOX1NUQVRVU19FUlJPUiA9IHNwYW5zdGF0dXMuU1BBTl9TVEFUVVNfRVJST1I7XG5leHBvcnRzLlNQQU5fU1RBVFVTX09LID0gc3BhbnN0YXR1cy5TUEFOX1NUQVRVU19PSztcbmV4cG9ydHMuU1BBTl9TVEFUVVNfVU5TRVQgPSBzcGFuc3RhdHVzLlNQQU5fU1RBVFVTX1VOU0VUO1xuZXhwb3J0cy5nZXRTcGFuU3RhdHVzRnJvbUh0dHBDb2RlID0gc3BhbnN0YXR1cy5nZXRTcGFuU3RhdHVzRnJvbUh0dHBDb2RlO1xuZXhwb3J0cy5zZXRIdHRwU3RhdHVzID0gc3BhbnN0YXR1cy5zZXRIdHRwU3RhdHVzO1xuZXhwb3J0cy5jb250aW51ZVRyYWNlID0gdHJhY2UuY29udGludWVUcmFjZTtcbmV4cG9ydHMuc3RhcnRJbmFjdGl2ZVNwYW4gPSB0cmFjZS5zdGFydEluYWN0aXZlU3BhbjtcbmV4cG9ydHMuc3RhcnROZXdUcmFjZSA9IHRyYWNlLnN0YXJ0TmV3VHJhY2U7XG5leHBvcnRzLnN0YXJ0U3BhbiA9IHRyYWNlLnN0YXJ0U3BhbjtcbmV4cG9ydHMuc3RhcnRTcGFuTWFudWFsID0gdHJhY2Uuc3RhcnRTcGFuTWFudWFsO1xuZXhwb3J0cy5zdXBwcmVzc1RyYWNpbmcgPSB0cmFjZS5zdXBwcmVzc1RyYWNpbmc7XG5leHBvcnRzLndpdGhBY3RpdmVTcGFuID0gdHJhY2Uud2l0aEFjdGl2ZVNwYW47XG5leHBvcnRzLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tQ2xpZW50ID0gZHluYW1pY1NhbXBsaW5nQ29udGV4dC5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbUNsaWVudDtcbmV4cG9ydHMuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TY29wZSA9IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TY29wZTtcbmV4cG9ydHMuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuID0gZHluYW1pY1NhbXBsaW5nQ29udGV4dC5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW47XG5leHBvcnRzLnNwYW5Ub0JhZ2dhZ2VIZWFkZXIgPSBkeW5hbWljU2FtcGxpbmdDb250ZXh0LnNwYW5Ub0JhZ2dhZ2VIZWFkZXI7XG5leHBvcnRzLnNldE1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnQuc2V0TWVhc3VyZW1lbnQ7XG5leHBvcnRzLnRpbWVkRXZlbnRzVG9NZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudC50aW1lZEV2ZW50c1RvTWVhc3VyZW1lbnRzO1xuZXhwb3J0cy5zYW1wbGVTcGFuID0gc2FtcGxpbmcuc2FtcGxlU3BhbjtcbmV4cG9ydHMubG9nU3BhbkVuZCA9IGxvZ1NwYW5zLmxvZ1NwYW5FbmQ7XG5leHBvcnRzLmxvZ1NwYW5TdGFydCA9IGxvZ1NwYW5zLmxvZ1NwYW5TdGFydDtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX0NBQ0hFX0hJVCA9IHNlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfSElUO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfSVRFTV9TSVpFID0gc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9JVEVNX1NJWkU7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9LRVkgPSBzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX0NBQ0hFX0tFWTtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX0VYQ0xVU0lWRV9USU1FID0gc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9FWENMVVNJVkVfVElNRTtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX0hUVFBfUkVRVUVTVF9NRVRIT0QgPSBzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX0hUVFBfUkVRVUVTVF9NRVRIT0Q7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9QUk9GSUxFX0lEID0gc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9QUk9GSUxFX0lEO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0NVU1RPTV9TUEFOX05BTUUgPSBzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0lETEVfU1BBTl9GSU5JU0hfUkVBU09OID0gc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfSURMRV9TUEFOX0ZJTklTSF9SRUFTT047XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfTUVBU1VSRU1FTlRfVU5JVCA9IHNlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX01FQVNVUkVNRU5UX1VOSVQ7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfTUVBU1VSRU1FTlRfVkFMVUUgPSBzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9NRUFTVVJFTUVOVF9WQUxVRTtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUCA9IHNlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTiA9IHNlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTjtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QUkVWSU9VU19UUkFDRV9TQU1QTEVfUkFURSA9IHNlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1BSRVZJT1VTX1RSQUNFX1NBTVBMRV9SQVRFO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFID0gc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEU7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFID0gc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfVVJMX0ZVTEwgPSBzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1VSTF9GVUxMO1xuZXhwb3J0cy5TRU1BTlRJQ19MSU5LX0FUVFJJQlVURV9MSU5LX1RZUEUgPSBzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfTElOS19BVFRSSUJVVEVfTElOS19UWVBFO1xuZXhwb3J0cy5jcmVhdGVFdmVudEVudmVsb3BlID0gZW52ZWxvcGUuY3JlYXRlRXZlbnRFbnZlbG9wZTtcbmV4cG9ydHMuY3JlYXRlU2Vzc2lvbkVudmVsb3BlID0gZW52ZWxvcGUuY3JlYXRlU2Vzc2lvbkVudmVsb3BlO1xuZXhwb3J0cy5jcmVhdGVTcGFuRW52ZWxvcGUgPSBlbnZlbG9wZS5jcmVhdGVTcGFuRW52ZWxvcGU7XG5leHBvcnRzLmFkZEV2ZW50UHJvY2Vzc29yID0gZXhwb3J0cyQxLmFkZEV2ZW50UHJvY2Vzc29yO1xuZXhwb3J0cy5jYXB0dXJlQ2hlY2tJbiA9IGV4cG9ydHMkMS5jYXB0dXJlQ2hlY2tJbjtcbmV4cG9ydHMuY2FwdHVyZUV2ZW50ID0gZXhwb3J0cyQxLmNhcHR1cmVFdmVudDtcbmV4cG9ydHMuY2FwdHVyZUV4Y2VwdGlvbiA9IGV4cG9ydHMkMS5jYXB0dXJlRXhjZXB0aW9uO1xuZXhwb3J0cy5jYXB0dXJlTWVzc2FnZSA9IGV4cG9ydHMkMS5jYXB0dXJlTWVzc2FnZTtcbmV4cG9ydHMuY2FwdHVyZVNlc3Npb24gPSBleHBvcnRzJDEuY2FwdHVyZVNlc3Npb247XG5leHBvcnRzLmNsb3NlID0gZXhwb3J0cyQxLmNsb3NlO1xuZXhwb3J0cy5lbmRTZXNzaW9uID0gZXhwb3J0cyQxLmVuZFNlc3Npb247XG5leHBvcnRzLmZsdXNoID0gZXhwb3J0cyQxLmZsdXNoO1xuZXhwb3J0cy5pc0VuYWJsZWQgPSBleHBvcnRzJDEuaXNFbmFibGVkO1xuZXhwb3J0cy5pc0luaXRpYWxpemVkID0gZXhwb3J0cyQxLmlzSW5pdGlhbGl6ZWQ7XG5leHBvcnRzLmxhc3RFdmVudElkID0gZXhwb3J0cyQxLmxhc3RFdmVudElkO1xuZXhwb3J0cy5zZXRDb250ZXh0ID0gZXhwb3J0cyQxLnNldENvbnRleHQ7XG5leHBvcnRzLnNldEV4dHJhID0gZXhwb3J0cyQxLnNldEV4dHJhO1xuZXhwb3J0cy5zZXRFeHRyYXMgPSBleHBvcnRzJDEuc2V0RXh0cmFzO1xuZXhwb3J0cy5zZXRUYWcgPSBleHBvcnRzJDEuc2V0VGFnO1xuZXhwb3J0cy5zZXRUYWdzID0gZXhwb3J0cyQxLnNldFRhZ3M7XG5leHBvcnRzLnNldFVzZXIgPSBleHBvcnRzJDEuc2V0VXNlcjtcbmV4cG9ydHMuc3RhcnRTZXNzaW9uID0gZXhwb3J0cyQxLnN0YXJ0U2Vzc2lvbjtcbmV4cG9ydHMud2l0aE1vbml0b3IgPSBleHBvcnRzJDEud2l0aE1vbml0b3I7XG5leHBvcnRzLmdldENsaWVudCA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50O1xuZXhwb3J0cy5nZXRDdXJyZW50U2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldEN1cnJlbnRTY29wZTtcbmV4cG9ydHMuZ2V0R2xvYmFsU2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldEdsb2JhbFNjb3BlO1xuZXhwb3J0cy5nZXRJc29sYXRpb25TY29wZSA9IGN1cnJlbnRTY29wZXMuZ2V0SXNvbGF0aW9uU2NvcGU7XG5leHBvcnRzLmdldFRyYWNlQ29udGV4dEZyb21TY29wZSA9IGN1cnJlbnRTY29wZXMuZ2V0VHJhY2VDb250ZXh0RnJvbVNjb3BlO1xuZXhwb3J0cy53aXRoSXNvbGF0aW9uU2NvcGUgPSBjdXJyZW50U2NvcGVzLndpdGhJc29sYXRpb25TY29wZTtcbmV4cG9ydHMud2l0aFNjb3BlID0gY3VycmVudFNjb3Blcy53aXRoU2NvcGU7XG5leHBvcnRzLmdldERlZmF1bHRDdXJyZW50U2NvcGUgPSBkZWZhdWx0U2NvcGVzLmdldERlZmF1bHRDdXJyZW50U2NvcGU7XG5leHBvcnRzLmdldERlZmF1bHRJc29sYXRpb25TY29wZSA9IGRlZmF1bHRTY29wZXMuZ2V0RGVmYXVsdElzb2xhdGlvblNjb3BlO1xuZXhwb3J0cy5zZXRBc3luY0NvbnRleHRTdHJhdGVneSA9IGluZGV4LnNldEFzeW5jQ29udGV4dFN0cmF0ZWd5O1xuZXhwb3J0cy5nZXRHbG9iYWxTaW5nbGV0b24gPSBjYXJyaWVyLmdldEdsb2JhbFNpbmdsZXRvbjtcbmV4cG9ydHMuZ2V0TWFpbkNhcnJpZXIgPSBjYXJyaWVyLmdldE1haW5DYXJyaWVyO1xuZXhwb3J0cy5jbG9zZVNlc3Npb24gPSBzZXNzaW9uLmNsb3NlU2Vzc2lvbjtcbmV4cG9ydHMubWFrZVNlc3Npb24gPSBzZXNzaW9uLm1ha2VTZXNzaW9uO1xuZXhwb3J0cy51cGRhdGVTZXNzaW9uID0gc2Vzc2lvbi51cGRhdGVTZXNzaW9uO1xuZXhwb3J0cy5TY29wZSA9IHNjb3BlLlNjb3BlO1xuZXhwb3J0cy5ub3RpZnlFdmVudFByb2Nlc3NvcnMgPSBldmVudFByb2Nlc3NvcnMubm90aWZ5RXZlbnRQcm9jZXNzb3JzO1xuZXhwb3J0cy5nZXRFbnZlbG9wZUVuZHBvaW50V2l0aFVybEVuY29kZWRBdXRoID0gYXBpLmdldEVudmVsb3BlRW5kcG9pbnRXaXRoVXJsRW5jb2RlZEF1dGg7XG5leHBvcnRzLmdldFJlcG9ydERpYWxvZ0VuZHBvaW50ID0gYXBpLmdldFJlcG9ydERpYWxvZ0VuZHBvaW50O1xuZXhwb3J0cy5CYXNlQ2xpZW50ID0gY2xpZW50LkJhc2VDbGllbnQ7XG5leHBvcnRzLkNsaWVudCA9IGNsaWVudC5DbGllbnQ7XG5leHBvcnRzLlNlcnZlclJ1bnRpbWVDbGllbnQgPSBzZXJ2ZXJSdW50aW1lQ2xpZW50LlNlcnZlclJ1bnRpbWVDbGllbnQ7XG5leHBvcnRzLmluaXRBbmRCaW5kID0gc2RrLmluaXRBbmRCaW5kO1xuZXhwb3J0cy5zZXRDdXJyZW50Q2xpZW50ID0gc2RrLnNldEN1cnJlbnRDbGllbnQ7XG5leHBvcnRzLmNyZWF0ZVRyYW5zcG9ydCA9IGJhc2UuY3JlYXRlVHJhbnNwb3J0O1xuZXhwb3J0cy5tYWtlT2ZmbGluZVRyYW5zcG9ydCA9IG9mZmxpbmUubWFrZU9mZmxpbmVUcmFuc3BvcnQ7XG5leHBvcnRzLm1ha2VNdWx0aXBsZXhlZFRyYW5zcG9ydCA9IG11bHRpcGxleGVkLm1ha2VNdWx0aXBsZXhlZFRyYW5zcG9ydDtcbmV4cG9ydHMuYWRkSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5hZGRJbnRlZ3JhdGlvbjtcbmV4cG9ydHMuZGVmaW5lSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbjtcbmV4cG9ydHMuZ2V0SW50ZWdyYXRpb25zVG9TZXR1cCA9IGludGVncmF0aW9uLmdldEludGVncmF0aW9uc1RvU2V0dXA7XG5leHBvcnRzLmFwcGx5U2NvcGVEYXRhVG9FdmVudCA9IGFwcGx5U2NvcGVEYXRhVG9FdmVudC5hcHBseVNjb3BlRGF0YVRvRXZlbnQ7XG5leHBvcnRzLm1lcmdlU2NvcGVEYXRhID0gYXBwbHlTY29wZURhdGFUb0V2ZW50Lm1lcmdlU2NvcGVEYXRhO1xuZXhwb3J0cy5wcmVwYXJlRXZlbnQgPSBwcmVwYXJlRXZlbnQucHJlcGFyZUV2ZW50O1xuZXhwb3J0cy5jcmVhdGVDaGVja0luRW52ZWxvcGUgPSBjaGVja2luLmNyZWF0ZUNoZWNrSW5FbnZlbG9wZTtcbmV4cG9ydHMuaGFzU3BhbnNFbmFibGVkID0gaGFzU3BhbnNFbmFibGVkLmhhc1NwYW5zRW5hYmxlZDtcbmV4cG9ydHMuaGFzVHJhY2luZ0VuYWJsZWQgPSBoYXNTcGFuc0VuYWJsZWQuaGFzVHJhY2luZ0VuYWJsZWQ7XG5leHBvcnRzLmlzU2VudHJ5UmVxdWVzdFVybCA9IGlzU2VudHJ5UmVxdWVzdFVybC5pc1NlbnRyeVJlcXVlc3RVcmw7XG5leHBvcnRzLmhhbmRsZUNhbGxiYWNrRXJyb3JzID0gaGFuZGxlQ2FsbGJhY2tFcnJvcnMuaGFuZGxlQ2FsbGJhY2tFcnJvcnM7XG5leHBvcnRzLmZtdCA9IHBhcmFtZXRlcml6ZS5mbXQ7XG5leHBvcnRzLnBhcmFtZXRlcml6ZSA9IHBhcmFtZXRlcml6ZS5wYXJhbWV0ZXJpemU7XG5leHBvcnRzLmFkZEF1dG9JcEFkZHJlc3NUb1Nlc3Npb24gPSBpcEFkZHJlc3MuYWRkQXV0b0lwQWRkcmVzc1RvU2Vzc2lvbjtcbmV4cG9ydHMuYWRkQXV0b0lwQWRkcmVzc1RvVXNlciA9IGlwQWRkcmVzcy5hZGRBdXRvSXBBZGRyZXNzVG9Vc2VyO1xuZXhwb3J0cy5hZGRDaGlsZFNwYW5Ub1NwYW4gPSBzcGFuVXRpbHMuYWRkQ2hpbGRTcGFuVG9TcGFuO1xuZXhwb3J0cy5jb252ZXJ0U3BhbkxpbmtzRm9yRW52ZWxvcGUgPSBzcGFuVXRpbHMuY29udmVydFNwYW5MaW5rc0ZvckVudmVsb3BlO1xuZXhwb3J0cy5nZXRBY3RpdmVTcGFuID0gc3BhblV0aWxzLmdldEFjdGl2ZVNwYW47XG5leHBvcnRzLmdldFJvb3RTcGFuID0gc3BhblV0aWxzLmdldFJvb3RTcGFuO1xuZXhwb3J0cy5nZXRTcGFuRGVzY2VuZGFudHMgPSBzcGFuVXRpbHMuZ2V0U3BhbkRlc2NlbmRhbnRzO1xuZXhwb3J0cy5nZXRTdGF0dXNNZXNzYWdlID0gc3BhblV0aWxzLmdldFN0YXR1c01lc3NhZ2U7XG5leHBvcnRzLnNwYW5Jc1NhbXBsZWQgPSBzcGFuVXRpbHMuc3BhbklzU2FtcGxlZDtcbmV4cG9ydHMuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyA9IHNwYW5VdGlscy5zcGFuVGltZUlucHV0VG9TZWNvbmRzO1xuZXhwb3J0cy5zcGFuVG9KU09OID0gc3BhblV0aWxzLnNwYW5Ub0pTT047XG5leHBvcnRzLnNwYW5Ub1RyYWNlQ29udGV4dCA9IHNwYW5VdGlscy5zcGFuVG9UcmFjZUNvbnRleHQ7XG5leHBvcnRzLnNwYW5Ub1RyYWNlSGVhZGVyID0gc3BhblV0aWxzLnNwYW5Ub1RyYWNlSGVhZGVyO1xuZXhwb3J0cy51cGRhdGVTcGFuTmFtZSA9IHNwYW5VdGlscy51cGRhdGVTcGFuTmFtZTtcbmV4cG9ydHMucGFyc2VTYW1wbGVSYXRlID0gcGFyc2VTYW1wbGVSYXRlLnBhcnNlU2FtcGxlUmF0ZTtcbmV4cG9ydHMuYXBwbHlTZGtNZXRhZGF0YSA9IHNka01ldGFkYXRhLmFwcGx5U2RrTWV0YWRhdGE7XG5leHBvcnRzLmdldFRyYWNlRGF0YSA9IHRyYWNlRGF0YS5nZXRUcmFjZURhdGE7XG5leHBvcnRzLmdldFRyYWNlTWV0YVRhZ3MgPSBtZXRhLmdldFRyYWNlTWV0YVRhZ3M7XG5leHBvcnRzLmV4dHJhY3RRdWVyeVBhcmFtc0Zyb21VcmwgPSByZXF1ZXN0LmV4dHJhY3RRdWVyeVBhcmFtc0Zyb21Vcmw7XG5leHBvcnRzLmhlYWRlcnNUb0RpY3QgPSByZXF1ZXN0LmhlYWRlcnNUb0RpY3Q7XG5leHBvcnRzLmh0dHBSZXF1ZXN0VG9SZXF1ZXN0RGF0YSA9IHJlcXVlc3QuaHR0cFJlcXVlc3RUb1JlcXVlc3REYXRhO1xuZXhwb3J0cy53aW50ZXJDR0hlYWRlcnNUb0RpY3QgPSByZXF1ZXN0LndpbnRlckNHSGVhZGVyc1RvRGljdDtcbmV4cG9ydHMud2ludGVyQ0dSZXF1ZXN0VG9SZXF1ZXN0RGF0YSA9IHJlcXVlc3Qud2ludGVyQ0dSZXF1ZXN0VG9SZXF1ZXN0RGF0YTtcbmV4cG9ydHMuREVGQVVMVF9FTlZJUk9OTUVOVCA9IGNvbnN0YW50cy5ERUZBVUxUX0VOVklST05NRU5UO1xuZXhwb3J0cy5hZGRCcmVhZGNydW1iID0gYnJlYWRjcnVtYnMuYWRkQnJlYWRjcnVtYjtcbmV4cG9ydHMuZnVuY3Rpb25Ub1N0cmluZ0ludGVncmF0aW9uID0gZnVuY3Rpb250b3N0cmluZy5mdW5jdGlvblRvU3RyaW5nSW50ZWdyYXRpb247XG5leHBvcnRzLmV2ZW50RmlsdGVyc0ludGVncmF0aW9uID0gZXZlbnRGaWx0ZXJzLmV2ZW50RmlsdGVyc0ludGVncmF0aW9uO1xuZXhwb3J0cy5pbmJvdW5kRmlsdGVyc0ludGVncmF0aW9uID0gZXZlbnRGaWx0ZXJzLmluYm91bmRGaWx0ZXJzSW50ZWdyYXRpb247XG5leHBvcnRzLmxpbmtlZEVycm9yc0ludGVncmF0aW9uID0gbGlua2VkZXJyb3JzLmxpbmtlZEVycm9yc0ludGVncmF0aW9uO1xuZXhwb3J0cy5tb2R1bGVNZXRhZGF0YUludGVncmF0aW9uID0gbWV0YWRhdGEubW9kdWxlTWV0YWRhdGFJbnRlZ3JhdGlvbjtcbmV4cG9ydHMucmVxdWVzdERhdGFJbnRlZ3JhdGlvbiA9IHJlcXVlc3RkYXRhLnJlcXVlc3REYXRhSW50ZWdyYXRpb247XG5leHBvcnRzLmNhcHR1cmVDb25zb2xlSW50ZWdyYXRpb24gPSBjYXB0dXJlY29uc29sZS5jYXB0dXJlQ29uc29sZUludGVncmF0aW9uO1xuZXhwb3J0cy5kZWR1cGVJbnRlZ3JhdGlvbiA9IGRlZHVwZS5kZWR1cGVJbnRlZ3JhdGlvbjtcbmV4cG9ydHMuZXh0cmFFcnJvckRhdGFJbnRlZ3JhdGlvbiA9IGV4dHJhZXJyb3JkYXRhLmV4dHJhRXJyb3JEYXRhSW50ZWdyYXRpb247XG5leHBvcnRzLnJld3JpdGVGcmFtZXNJbnRlZ3JhdGlvbiA9IHJld3JpdGVmcmFtZXMucmV3cml0ZUZyYW1lc0ludGVncmF0aW9uO1xuZXhwb3J0cy5pbnN0cnVtZW50U3VwYWJhc2VDbGllbnQgPSBzdXBhYmFzZS5pbnN0cnVtZW50U3VwYWJhc2VDbGllbnQ7XG5leHBvcnRzLnN1cGFiYXNlSW50ZWdyYXRpb24gPSBzdXBhYmFzZS5zdXBhYmFzZUludGVncmF0aW9uO1xuZXhwb3J0cy56b2RFcnJvcnNJbnRlZ3JhdGlvbiA9IHpvZGVycm9ycy56b2RFcnJvcnNJbnRlZ3JhdGlvbjtcbmV4cG9ydHMudGhpcmRQYXJ0eUVycm9yRmlsdGVySW50ZWdyYXRpb24gPSB0aGlyZFBhcnR5RXJyb3JzRmlsdGVyLnRoaXJkUGFydHlFcnJvckZpbHRlckludGVncmF0aW9uO1xuZXhwb3J0cy5jb25zb2xlSW50ZWdyYXRpb24gPSBjb25zb2xlLmNvbnNvbGVJbnRlZ3JhdGlvbjtcbmV4cG9ydHMucHJvZmlsZXIgPSBwcm9maWxpbmcucHJvZmlsZXI7XG5leHBvcnRzLmluc3RydW1lbnRGZXRjaFJlcXVlc3QgPSBmZXRjaC5pbnN0cnVtZW50RmV0Y2hSZXF1ZXN0O1xuZXhwb3J0cy50cnBjTWlkZGxld2FyZSA9IHRycGMudHJwY01pZGRsZXdhcmU7XG5leHBvcnRzLndyYXBNY3BTZXJ2ZXJXaXRoU2VudHJ5ID0gbWNwU2VydmVyLndyYXBNY3BTZXJ2ZXJXaXRoU2VudHJ5O1xuZXhwb3J0cy5jYXB0dXJlRmVlZGJhY2sgPSBmZWVkYmFjay5jYXB0dXJlRmVlZGJhY2s7XG5leHBvcnRzLl9JTlRFUk5BTF9jYXB0dXJlTG9nID0gZXhwb3J0cyQyLl9JTlRFUk5BTF9jYXB0dXJlTG9nO1xuZXhwb3J0cy5fSU5URVJOQUxfY2FwdHVyZVNlcmlhbGl6ZWRMb2cgPSBleHBvcnRzJDIuX0lOVEVSTkFMX2NhcHR1cmVTZXJpYWxpemVkTG9nO1xuZXhwb3J0cy5fSU5URVJOQUxfZmx1c2hMb2dzQnVmZmVyID0gZXhwb3J0cyQyLl9JTlRFUk5BTF9mbHVzaExvZ3NCdWZmZXI7XG5leHBvcnRzLmNvbnNvbGVMb2dnaW5nSW50ZWdyYXRpb24gPSBjb25zb2xlSW50ZWdyYXRpb24uY29uc29sZUxvZ2dpbmdJbnRlZ3JhdGlvbjtcbmV4cG9ydHMuYXBwbHlBZ2dyZWdhdGVFcnJvcnNUb0V2ZW50ID0gYWdncmVnYXRlRXJyb3JzLmFwcGx5QWdncmVnYXRlRXJyb3JzVG9FdmVudDtcbmV4cG9ydHMuZ2V0QnJlYWRjcnVtYkxvZ0xldmVsRnJvbUh0dHBTdGF0dXNDb2RlID0gYnJlYWRjcnVtYkxvZ0xldmVsLmdldEJyZWFkY3J1bWJMb2dMZXZlbEZyb21IdHRwU3RhdHVzQ29kZTtcbmV4cG9ydHMuZ2V0Q29tcG9uZW50TmFtZSA9IGJyb3dzZXIuZ2V0Q29tcG9uZW50TmFtZTtcbmV4cG9ydHMuZ2V0TG9jYXRpb25IcmVmID0gYnJvd3Nlci5nZXRMb2NhdGlvbkhyZWY7XG5leHBvcnRzLmh0bWxUcmVlQXNTdHJpbmcgPSBicm93c2VyLmh0bWxUcmVlQXNTdHJpbmc7XG5leHBvcnRzLmRzbkZyb21TdHJpbmcgPSBkc24uZHNuRnJvbVN0cmluZztcbmV4cG9ydHMuZHNuVG9TdHJpbmcgPSBkc24uZHNuVG9TdHJpbmc7XG5leHBvcnRzLm1ha2VEc24gPSBkc24ubWFrZURzbjtcbmV4cG9ydHMuU2VudHJ5RXJyb3IgPSBlcnJvci5TZW50cnlFcnJvcjtcbmV4cG9ydHMuR0xPQkFMX09CSiA9IHdvcmxkd2lkZS5HTE9CQUxfT0JKO1xuZXhwb3J0cy5hZGRDb25zb2xlSW5zdHJ1bWVudGF0aW9uSGFuZGxlciA9IGNvbnNvbGUkMS5hZGRDb25zb2xlSW5zdHJ1bWVudGF0aW9uSGFuZGxlcjtcbmV4cG9ydHMuYWRkRmV0Y2hFbmRJbnN0cnVtZW50YXRpb25IYW5kbGVyID0gZmV0Y2gkMS5hZGRGZXRjaEVuZEluc3RydW1lbnRhdGlvbkhhbmRsZXI7XG5leHBvcnRzLmFkZEZldGNoSW5zdHJ1bWVudGF0aW9uSGFuZGxlciA9IGZldGNoJDEuYWRkRmV0Y2hJbnN0cnVtZW50YXRpb25IYW5kbGVyO1xuZXhwb3J0cy5hZGRHbG9iYWxFcnJvckluc3RydW1lbnRhdGlvbkhhbmRsZXIgPSBnbG9iYWxFcnJvci5hZGRHbG9iYWxFcnJvckluc3RydW1lbnRhdGlvbkhhbmRsZXI7XG5leHBvcnRzLmFkZEdsb2JhbFVuaGFuZGxlZFJlamVjdGlvbkluc3RydW1lbnRhdGlvbkhhbmRsZXIgPSBnbG9iYWxVbmhhbmRsZWRSZWplY3Rpb24uYWRkR2xvYmFsVW5oYW5kbGVkUmVqZWN0aW9uSW5zdHJ1bWVudGF0aW9uSGFuZGxlcjtcbmV4cG9ydHMuYWRkSGFuZGxlciA9IGhhbmRsZXJzLmFkZEhhbmRsZXI7XG5leHBvcnRzLm1heWJlSW5zdHJ1bWVudCA9IGhhbmRsZXJzLm1heWJlSW5zdHJ1bWVudDtcbmV4cG9ydHMucmVzZXRJbnN0cnVtZW50YXRpb25IYW5kbGVycyA9IGhhbmRsZXJzLnJlc2V0SW5zdHJ1bWVudGF0aW9uSGFuZGxlcnM7XG5leHBvcnRzLnRyaWdnZXJIYW5kbGVycyA9IGhhbmRsZXJzLnRyaWdnZXJIYW5kbGVycztcbmV4cG9ydHMuaXNET01FcnJvciA9IGlzLmlzRE9NRXJyb3I7XG5leHBvcnRzLmlzRE9NRXhjZXB0aW9uID0gaXMuaXNET01FeGNlcHRpb247XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzLmlzRWxlbWVudDtcbmV4cG9ydHMuaXNFcnJvciA9IGlzLmlzRXJyb3I7XG5leHBvcnRzLmlzRXJyb3JFdmVudCA9IGlzLmlzRXJyb3JFdmVudDtcbmV4cG9ydHMuaXNFdmVudCA9IGlzLmlzRXZlbnQ7XG5leHBvcnRzLmlzSW5zdGFuY2VPZiA9IGlzLmlzSW5zdGFuY2VPZjtcbmV4cG9ydHMuaXNQYXJhbWV0ZXJpemVkU3RyaW5nID0gaXMuaXNQYXJhbWV0ZXJpemVkU3RyaW5nO1xuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXMuaXNQbGFpbk9iamVjdDtcbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpcy5pc1ByaW1pdGl2ZTtcbmV4cG9ydHMuaXNSZWdFeHAgPSBpcy5pc1JlZ0V4cDtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpcy5pc1N0cmluZztcbmV4cG9ydHMuaXNTeW50aGV0aWNFdmVudCA9IGlzLmlzU3ludGhldGljRXZlbnQ7XG5leHBvcnRzLmlzVGhlbmFibGUgPSBpcy5pc1RoZW5hYmxlO1xuZXhwb3J0cy5pc1Z1ZVZpZXdNb2RlbCA9IGlzLmlzVnVlVmlld01vZGVsO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXIuaXNCcm93c2VyO1xuZXhwb3J0cy5DT05TT0xFX0xFVkVMUyA9IGxvZ2dlci5DT05TT0xFX0xFVkVMUztcbmV4cG9ydHMuY29uc29sZVNhbmRib3ggPSBsb2dnZXIuY29uc29sZVNhbmRib3g7XG5leHBvcnRzLmxvZ2dlciA9IGxvZ2dlci5sb2dnZXI7XG5leHBvcnRzLm9yaWdpbmFsQ29uc29sZU1ldGhvZHMgPSBsb2dnZXIub3JpZ2luYWxDb25zb2xlTWV0aG9kcztcbmV4cG9ydHMuYWRkQ29udGV4dFRvRnJhbWUgPSBtaXNjLmFkZENvbnRleHRUb0ZyYW1lO1xuZXhwb3J0cy5hZGRFeGNlcHRpb25NZWNoYW5pc20gPSBtaXNjLmFkZEV4Y2VwdGlvbk1lY2hhbmlzbTtcbmV4cG9ydHMuYWRkRXhjZXB0aW9uVHlwZVZhbHVlID0gbWlzYy5hZGRFeGNlcHRpb25UeXBlVmFsdWU7XG5leHBvcnRzLmNoZWNrT3JTZXRBbHJlYWR5Q2F1Z2h0ID0gbWlzYy5jaGVja09yU2V0QWxyZWFkeUNhdWdodDtcbmV4cG9ydHMuZ2V0RXZlbnREZXNjcmlwdGlvbiA9IG1pc2MuZ2V0RXZlbnREZXNjcmlwdGlvbjtcbmV4cG9ydHMucGFyc2VTZW12ZXIgPSBtaXNjLnBhcnNlU2VtdmVyO1xuZXhwb3J0cy51dWlkNCA9IG1pc2MudXVpZDQ7XG5leHBvcnRzLmlzTm9kZUVudiA9IG5vZGUuaXNOb2RlRW52O1xuZXhwb3J0cy5sb2FkTW9kdWxlID0gbm9kZS5sb2FkTW9kdWxlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemUubm9ybWFsaXplO1xuZXhwb3J0cy5ub3JtYWxpemVUb1NpemUgPSBub3JtYWxpemUubm9ybWFsaXplVG9TaXplO1xuZXhwb3J0cy5ub3JtYWxpemVVcmxUb0Jhc2UgPSBub3JtYWxpemUubm9ybWFsaXplVXJsVG9CYXNlO1xuZXhwb3J0cy5hZGROb25FbnVtZXJhYmxlUHJvcGVydHkgPSBvYmplY3QuYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5O1xuZXhwb3J0cy5jb252ZXJ0VG9QbGFpbk9iamVjdCA9IG9iamVjdC5jb252ZXJ0VG9QbGFpbk9iamVjdDtcbmV4cG9ydHMuZHJvcFVuZGVmaW5lZEtleXMgPSBvYmplY3QuZHJvcFVuZGVmaW5lZEtleXM7XG5leHBvcnRzLmV4dHJhY3RFeGNlcHRpb25LZXlzRm9yTWVzc2FnZSA9IG9iamVjdC5leHRyYWN0RXhjZXB0aW9uS2V5c0Zvck1lc3NhZ2U7XG5leHBvcnRzLmZpbGwgPSBvYmplY3QuZmlsbDtcbmV4cG9ydHMuZ2V0T3JpZ2luYWxGdW5jdGlvbiA9IG9iamVjdC5nZXRPcmlnaW5hbEZ1bmN0aW9uO1xuZXhwb3J0cy5tYXJrRnVuY3Rpb25XcmFwcGVkID0gb2JqZWN0Lm1hcmtGdW5jdGlvbldyYXBwZWQ7XG5leHBvcnRzLm9iamVjdGlmeSA9IG9iamVjdC5vYmplY3RpZnk7XG5leHBvcnRzLmJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZTtcbmV4cG9ydHMuZGlybmFtZSA9IHBhdGguZGlybmFtZTtcbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IHBhdGguaXNBYnNvbHV0ZTtcbmV4cG9ydHMuam9pbiA9IHBhdGguam9pbjtcbmV4cG9ydHMubm9ybWFsaXplUGF0aCA9IHBhdGgubm9ybWFsaXplUGF0aDtcbmV4cG9ydHMucmVsYXRpdmUgPSBwYXRoLnJlbGF0aXZlO1xuZXhwb3J0cy5yZXNvbHZlID0gcGF0aC5yZXNvbHZlO1xuZXhwb3J0cy5TRU5UUllfQlVGRkVSX0ZVTExfRVJST1IgPSBwcm9taXNlYnVmZmVyLlNFTlRSWV9CVUZGRVJfRlVMTF9FUlJPUjtcbmV4cG9ydHMubWFrZVByb21pc2VCdWZmZXIgPSBwcm9taXNlYnVmZmVyLm1ha2VQcm9taXNlQnVmZmVyO1xuZXhwb3J0cy5zZXZlcml0eUxldmVsRnJvbVN0cmluZyA9IHNldmVyaXR5LnNldmVyaXR5TGV2ZWxGcm9tU3RyaW5nO1xuZXhwb3J0cy5VTktOT1dOX0ZVTkNUSU9OID0gc3RhY2t0cmFjZS5VTktOT1dOX0ZVTkNUSU9OO1xuZXhwb3J0cy5jcmVhdGVTdGFja1BhcnNlciA9IHN0YWNrdHJhY2UuY3JlYXRlU3RhY2tQYXJzZXI7XG5leHBvcnRzLmdldEZyYW1lc0Zyb21FdmVudCA9IHN0YWNrdHJhY2UuZ2V0RnJhbWVzRnJvbUV2ZW50O1xuZXhwb3J0cy5nZXRGdW5jdGlvbk5hbWUgPSBzdGFja3RyYWNlLmdldEZ1bmN0aW9uTmFtZTtcbmV4cG9ydHMuc3RhY2tQYXJzZXJGcm9tU3RhY2tQYXJzZXJPcHRpb25zID0gc3RhY2t0cmFjZS5zdGFja1BhcnNlckZyb21TdGFja1BhcnNlck9wdGlvbnM7XG5leHBvcnRzLnN0cmlwU2VudHJ5RnJhbWVzQW5kUmV2ZXJzZSA9IHN0YWNrdHJhY2Uuc3RyaXBTZW50cnlGcmFtZXNBbmRSZXZlcnNlO1xuZXhwb3J0cy5maWxlbmFtZUlzSW5BcHAgPSBub2RlU3RhY2tUcmFjZS5maWxlbmFtZUlzSW5BcHA7XG5leHBvcnRzLm5vZGUgPSBub2RlU3RhY2tUcmFjZS5ub2RlO1xuZXhwb3J0cy5ub2RlU3RhY2tMaW5lUGFyc2VyID0gbm9kZVN0YWNrVHJhY2Uubm9kZVN0YWNrTGluZVBhcnNlcjtcbmV4cG9ydHMuaXNNYXRjaGluZ1BhdHRlcm4gPSBzdHJpbmcuaXNNYXRjaGluZ1BhdHRlcm47XG5leHBvcnRzLnNhZmVKb2luID0gc3RyaW5nLnNhZmVKb2luO1xuZXhwb3J0cy5zbmlwTGluZSA9IHN0cmluZy5zbmlwTGluZTtcbmV4cG9ydHMuc3RyaW5nTWF0Y2hlc1NvbWVQYXR0ZXJuID0gc3RyaW5nLnN0cmluZ01hdGNoZXNTb21lUGF0dGVybjtcbmV4cG9ydHMudHJ1bmNhdGUgPSBzdHJpbmcudHJ1bmNhdGU7XG5leHBvcnRzLmlzTmF0aXZlRnVuY3Rpb24gPSBzdXBwb3J0cy5pc05hdGl2ZUZ1bmN0aW9uO1xuZXhwb3J0cy5zdXBwb3J0c0RPTUVycm9yID0gc3VwcG9ydHMuc3VwcG9ydHNET01FcnJvcjtcbmV4cG9ydHMuc3VwcG9ydHNET01FeGNlcHRpb24gPSBzdXBwb3J0cy5zdXBwb3J0c0RPTUV4Y2VwdGlvbjtcbmV4cG9ydHMuc3VwcG9ydHNFcnJvckV2ZW50ID0gc3VwcG9ydHMuc3VwcG9ydHNFcnJvckV2ZW50O1xuZXhwb3J0cy5zdXBwb3J0c0ZldGNoID0gc3VwcG9ydHMuc3VwcG9ydHNGZXRjaDtcbmV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gc3VwcG9ydHMuc3VwcG9ydHNIaXN0b3J5O1xuZXhwb3J0cy5zdXBwb3J0c05hdGl2ZUZldGNoID0gc3VwcG9ydHMuc3VwcG9ydHNOYXRpdmVGZXRjaDtcbmV4cG9ydHMuc3VwcG9ydHNSZWZlcnJlclBvbGljeSA9IHN1cHBvcnRzLnN1cHBvcnRzUmVmZXJyZXJQb2xpY3k7XG5leHBvcnRzLnN1cHBvcnRzUmVwb3J0aW5nT2JzZXJ2ZXIgPSBzdXBwb3J0cy5zdXBwb3J0c1JlcG9ydGluZ09ic2VydmVyO1xuZXhwb3J0cy5TeW5jUHJvbWlzZSA9IHN5bmNwcm9taXNlLlN5bmNQcm9taXNlO1xuZXhwb3J0cy5yZWplY3RlZFN5bmNQcm9taXNlID0gc3luY3Byb21pc2UucmVqZWN0ZWRTeW5jUHJvbWlzZTtcbmV4cG9ydHMucmVzb2x2ZWRTeW5jUHJvbWlzZSA9IHN5bmNwcm9taXNlLnJlc29sdmVkU3luY1Byb21pc2U7XG5leHBvcnRzLmJyb3dzZXJQZXJmb3JtYW5jZVRpbWVPcmlnaW4gPSB0aW1lLmJyb3dzZXJQZXJmb3JtYW5jZVRpbWVPcmlnaW47XG5leHBvcnRzLmRhdGVUaW1lc3RhbXBJblNlY29uZHMgPSB0aW1lLmRhdGVUaW1lc3RhbXBJblNlY29uZHM7XG5leHBvcnRzLnRpbWVzdGFtcEluU2Vjb25kcyA9IHRpbWUudGltZXN0YW1wSW5TZWNvbmRzO1xuZXhwb3J0cy5UUkFDRVBBUkVOVF9SRUdFWFAgPSB0cmFjaW5nLlRSQUNFUEFSRU5UX1JFR0VYUDtcbmV4cG9ydHMuZXh0cmFjdFRyYWNlcGFyZW50RGF0YSA9IHRyYWNpbmcuZXh0cmFjdFRyYWNlcGFyZW50RGF0YTtcbmV4cG9ydHMuZ2VuZXJhdGVTZW50cnlUcmFjZUhlYWRlciA9IHRyYWNpbmcuZ2VuZXJhdGVTZW50cnlUcmFjZUhlYWRlcjtcbmV4cG9ydHMucHJvcGFnYXRpb25Db250ZXh0RnJvbUhlYWRlcnMgPSB0cmFjaW5nLnByb3BhZ2F0aW9uQ29udGV4dEZyb21IZWFkZXJzO1xuZXhwb3J0cy5nZXRTREtTb3VyY2UgPSBlbnYuZ2V0U0RLU291cmNlO1xuZXhwb3J0cy5pc0Jyb3dzZXJCdW5kbGUgPSBlbnYuaXNCcm93c2VyQnVuZGxlO1xuZXhwb3J0cy5hZGRJdGVtVG9FbnZlbG9wZSA9IGVudmVsb3BlJDEuYWRkSXRlbVRvRW52ZWxvcGU7XG5leHBvcnRzLmNyZWF0ZUF0dGFjaG1lbnRFbnZlbG9wZUl0ZW0gPSBlbnZlbG9wZSQxLmNyZWF0ZUF0dGFjaG1lbnRFbnZlbG9wZUl0ZW07XG5leHBvcnRzLmNyZWF0ZUVudmVsb3BlID0gZW52ZWxvcGUkMS5jcmVhdGVFbnZlbG9wZTtcbmV4cG9ydHMuY3JlYXRlRXZlbnRFbnZlbG9wZUhlYWRlcnMgPSBlbnZlbG9wZSQxLmNyZWF0ZUV2ZW50RW52ZWxvcGVIZWFkZXJzO1xuZXhwb3J0cy5jcmVhdGVTcGFuRW52ZWxvcGVJdGVtID0gZW52ZWxvcGUkMS5jcmVhdGVTcGFuRW52ZWxvcGVJdGVtO1xuZXhwb3J0cy5lbnZlbG9wZUNvbnRhaW5zSXRlbVR5cGUgPSBlbnZlbG9wZSQxLmVudmVsb3BlQ29udGFpbnNJdGVtVHlwZTtcbmV4cG9ydHMuZW52ZWxvcGVJdGVtVHlwZVRvRGF0YUNhdGVnb3J5ID0gZW52ZWxvcGUkMS5lbnZlbG9wZUl0ZW1UeXBlVG9EYXRhQ2F0ZWdvcnk7XG5leHBvcnRzLmZvckVhY2hFbnZlbG9wZUl0ZW0gPSBlbnZlbG9wZSQxLmZvckVhY2hFbnZlbG9wZUl0ZW07XG5leHBvcnRzLmdldFNka01ldGFkYXRhRm9yRW52ZWxvcGVIZWFkZXIgPSBlbnZlbG9wZSQxLmdldFNka01ldGFkYXRhRm9yRW52ZWxvcGVIZWFkZXI7XG5leHBvcnRzLnBhcnNlRW52ZWxvcGUgPSBlbnZlbG9wZSQxLnBhcnNlRW52ZWxvcGU7XG5leHBvcnRzLnNlcmlhbGl6ZUVudmVsb3BlID0gZW52ZWxvcGUkMS5zZXJpYWxpemVFbnZlbG9wZTtcbmV4cG9ydHMuY3JlYXRlQ2xpZW50UmVwb3J0RW52ZWxvcGUgPSBjbGllbnRyZXBvcnQuY3JlYXRlQ2xpZW50UmVwb3J0RW52ZWxvcGU7XG5leHBvcnRzLkRFRkFVTFRfUkVUUllfQUZURVIgPSByYXRlbGltaXQuREVGQVVMVF9SRVRSWV9BRlRFUjtcbmV4cG9ydHMuZGlzYWJsZWRVbnRpbCA9IHJhdGVsaW1pdC5kaXNhYmxlZFVudGlsO1xuZXhwb3J0cy5pc1JhdGVMaW1pdGVkID0gcmF0ZWxpbWl0LmlzUmF0ZUxpbWl0ZWQ7XG5leHBvcnRzLnBhcnNlUmV0cnlBZnRlckhlYWRlciA9IHJhdGVsaW1pdC5wYXJzZVJldHJ5QWZ0ZXJIZWFkZXI7XG5leHBvcnRzLnVwZGF0ZVJhdGVMaW1pdHMgPSByYXRlbGltaXQudXBkYXRlUmF0ZUxpbWl0cztcbmV4cG9ydHMuTUFYX0JBR0dBR0VfU1RSSU5HX0xFTkdUSCA9IGJhZ2dhZ2UuTUFYX0JBR0dBR0VfU1RSSU5HX0xFTkdUSDtcbmV4cG9ydHMuU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWCA9IGJhZ2dhZ2UuU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWDtcbmV4cG9ydHMuU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWF9SRUdFWCA9IGJhZ2dhZ2UuU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWF9SRUdFWDtcbmV4cG9ydHMuYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IGJhZ2dhZ2UuYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dDtcbmV4cG9ydHMuZHluYW1pY1NhbXBsaW5nQ29udGV4dFRvU2VudHJ5QmFnZ2FnZUhlYWRlciA9IGJhZ2dhZ2UuZHluYW1pY1NhbXBsaW5nQ29udGV4dFRvU2VudHJ5QmFnZ2FnZUhlYWRlcjtcbmV4cG9ydHMub2JqZWN0VG9CYWdnYWdlSGVhZGVyID0gYmFnZ2FnZS5vYmplY3RUb0JhZ2dhZ2VIZWFkZXI7XG5leHBvcnRzLnBhcnNlQmFnZ2FnZUhlYWRlciA9IGJhZ2dhZ2UucGFyc2VCYWdnYWdlSGVhZGVyO1xuZXhwb3J0cy5nZXRIdHRwU3BhbkRldGFpbHNGcm9tVXJsT2JqZWN0ID0gdXJsLmdldEh0dHBTcGFuRGV0YWlsc0Zyb21VcmxPYmplY3Q7XG5leHBvcnRzLmdldFNhbml0aXplZFVybFN0cmluZyA9IHVybC5nZXRTYW5pdGl6ZWRVcmxTdHJpbmc7XG5leHBvcnRzLmdldFNhbml0aXplZFVybFN0cmluZ0Zyb21VcmxPYmplY3QgPSB1cmwuZ2V0U2FuaXRpemVkVXJsU3RyaW5nRnJvbVVybE9iamVjdDtcbmV4cG9ydHMuaXNVUkxPYmplY3RSZWxhdGl2ZSA9IHVybC5pc1VSTE9iamVjdFJlbGF0aXZlO1xuZXhwb3J0cy5wYXJzZVN0cmluZ1RvVVJMT2JqZWN0ID0gdXJsLnBhcnNlU3RyaW5nVG9VUkxPYmplY3Q7XG5leHBvcnRzLnBhcnNlVXJsID0gdXJsLnBhcnNlVXJsO1xuZXhwb3J0cy5zdHJpcFVybFF1ZXJ5QW5kRnJhZ21lbnQgPSB1cmwuc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50O1xuZXhwb3J0cy5ldmVudEZyb21NZXNzYWdlID0gZXZlbnRidWlsZGVyLmV2ZW50RnJvbU1lc3NhZ2U7XG5leHBvcnRzLmV2ZW50RnJvbVVua25vd25JbnB1dCA9IGV2ZW50YnVpbGRlci5ldmVudEZyb21Vbmtub3duSW5wdXQ7XG5leHBvcnRzLmV4Y2VwdGlvbkZyb21FcnJvciA9IGV2ZW50YnVpbGRlci5leGNlcHRpb25Gcm9tRXJyb3I7XG5leHBvcnRzLnBhcnNlU3RhY2tGcmFtZXMgPSBldmVudGJ1aWxkZXIucGFyc2VTdGFja0ZyYW1lcztcbmV4cG9ydHMuY2FsbEZyYW1lVG9TdGFja0ZyYW1lID0gYW5yLmNhbGxGcmFtZVRvU3RhY2tGcmFtZTtcbmV4cG9ydHMud2F0Y2hkb2dUaW1lciA9IGFuci53YXRjaGRvZ1RpbWVyO1xuZXhwb3J0cy5MUlVNYXAgPSBscnUuTFJVTWFwO1xuZXhwb3J0cy5nZW5lcmF0ZVNwYW5JZCA9IHByb3BhZ2F0aW9uQ29udGV4dC5nZW5lcmF0ZVNwYW5JZDtcbmV4cG9ydHMuZ2VuZXJhdGVUcmFjZUlkID0gcHJvcGFnYXRpb25Db250ZXh0LmdlbmVyYXRlVHJhY2VJZDtcbmV4cG9ydHMudmVyY2VsV2FpdFVudGlsID0gdmVyY2VsV2FpdFVudGlsLnZlcmNlbFdhaXRVbnRpbDtcbmV4cG9ydHMuU0RLX1ZFUlNJT04gPSB2ZXJzaW9uLlNES19WRVJTSU9OO1xuZXhwb3J0cy5nZXREZWJ1Z0ltYWdlc0ZvclJlc291cmNlcyA9IGRlYnVnSWRzLmdldERlYnVnSW1hZ2VzRm9yUmVzb3VyY2VzO1xuZXhwb3J0cy5nZXRGaWxlbmFtZVRvRGVidWdJZE1hcCA9IGRlYnVnSWRzLmdldEZpbGVuYW1lVG9EZWJ1Z0lkTWFwO1xuZXhwb3J0cy5lc2NhcGVTdHJpbmdGb3JSZWdleCA9IGVzY2FwZVN0cmluZ0ZvclJlZ2V4LmVzY2FwZVN0cmluZ0ZvclJlZ2V4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/index.js\n')},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\n\nconst installedIntegrations = [];\n\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preserve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations) {\n  const integrationsByName = {};\n\n  integrations.forEach((currentInstance) => {\n    const { name } = currentInstance;\n\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.values(integrationsByName);\n}\n\n/** Gets integrations to install */\nfunction getIntegrationsToSetup(options) {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach((integration) => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations;\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    const resolvedUserIntegrations = userIntegrations(defaultIntegrations);\n    integrations = Array.isArray(resolvedUserIntegrations) ? resolvedUserIntegrations : [resolvedUserIntegrations];\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  return filterDuplicates(integrations);\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nfunction setupIntegrations(client, integrations) {\n  const integrationIndex = {};\n\n  integrations.forEach((integration) => {\n    // guard against empty provided integrations\n    if (integration) {\n      setupIntegration(client, integration, integrationIndex);\n    }\n  });\n\n  return integrationIndex;\n}\n\n/**\n * Execute the `afterAllSetup` hooks of the given integrations.\n */\nfunction afterSetupIntegrations(client, integrations) {\n  for (const integration of integrations) {\n    // guard against empty provided integrations\n    if (integration?.afterAllSetup) {\n      integration.afterAllSetup(client);\n    }\n  }\n}\n\n/** Setup a single integration.  */\nfunction setupIntegration(client, integration, integrationIndex) {\n  if (integrationIndex[integration.name]) {\n    debugBuild.DEBUG_BUILD && logger.logger.log(`Integration skipped because it was already installed: ${integration.name}`);\n    return;\n  }\n  integrationIndex[integration.name] = integration;\n\n  // `setupOnce` is only called the first time\n  if (installedIntegrations.indexOf(integration.name) === -1 && typeof integration.setupOnce === 'function') {\n    integration.setupOnce();\n    installedIntegrations.push(integration.name);\n  }\n\n  // `setup` is run for each client\n  if (integration.setup && typeof integration.setup === 'function') {\n    integration.setup(client);\n  }\n\n  if (typeof integration.preprocessEvent === 'function') {\n    const callback = integration.preprocessEvent.bind(integration) ;\n    client.on('preprocessEvent', (event, hint) => callback(event, hint, client));\n  }\n\n  if (typeof integration.processEvent === 'function') {\n    const callback = integration.processEvent.bind(integration) ;\n\n    const processor = Object.assign((event, hint) => callback(event, hint, client), {\n      id: integration.name,\n    });\n\n    client.addEventProcessor(processor);\n  }\n\n  debugBuild.DEBUG_BUILD && logger.logger.log(`Integration installed: ${integration.name}`);\n}\n\n/** Add an integration to the current scope's client. */\nfunction addIntegration(integration) {\n  const client = currentScopes.getClient();\n\n  if (!client) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn(`Cannot add integration \"${integration.name}\" because no SDK Client is available.`);\n    return;\n  }\n\n  client.addIntegration(integration);\n}\n\n/**\n * Define an integration function that can be used to create an integration instance.\n * Note that this by design hides the implementation details of the integration, as they are considered internal.\n */\nfunction defineIntegration(fn) {\n  return fn;\n}\n\nexports.addIntegration = addIntegration;\nexports.afterSetupIntegrations = afterSetupIntegrations;\nexports.defineIntegration = defineIntegration;\nexports.getIntegrationsToSetup = getIntegrationsToSetup;\nexports.installedIntegrations = installedIntegrations;\nexports.setupIntegration = setupIntegration;\nexports.setupIntegrations = setupIntegrations;\n//# sourceMappingURL=integration.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLHNCQUFzQixtQkFBTyxDQUFDLDJIQUFvQjtBQUNsRCxtQkFBbUIsbUJBQU8sQ0FBQyx1SEFBa0I7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLHFJQUF5Qjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksT0FBTzs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLGlCQUFpQjtBQUMxSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsd0VBQXdFLGlCQUFpQjtBQUN6Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEUsaUJBQWlCO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsOEJBQThCO0FBQzlCLHlCQUF5QjtBQUN6Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcaW50ZWdyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuL2N1cnJlbnRTY29wZXMuanMnKTtcbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuXG5jb25zdCBpbnN0YWxsZWRJbnRlZ3JhdGlvbnMgPSBbXTtcblxuLyoqIE1hcCBvZiBpbnRlZ3JhdGlvbnMgYXNzaWduZWQgdG8gYSBjbGllbnQgKi9cblxuLyoqXG4gKiBSZW1vdmUgZHVwbGljYXRlcyBmcm9tIHRoZSBnaXZlbiBhcnJheSwgcHJlZmVycmluZyB0aGUgbGFzdCBpbnN0YW5jZSBvZiBhbnkgZHVwbGljYXRlLiBOb3QgZ3VhcmFudGVlZCB0b1xuICogcHJlc2VydmUgdGhlIG9yZGVyIG9mIGludGVncmF0aW9ucyBpbiB0aGUgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZmlsdGVyRHVwbGljYXRlcyhpbnRlZ3JhdGlvbnMpIHtcbiAgY29uc3QgaW50ZWdyYXRpb25zQnlOYW1lID0ge307XG5cbiAgaW50ZWdyYXRpb25zLmZvckVhY2goKGN1cnJlbnRJbnN0YW5jZSkgPT4ge1xuICAgIGNvbnN0IHsgbmFtZSB9ID0gY3VycmVudEluc3RhbmNlO1xuXG4gICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IGludGVncmF0aW9uc0J5TmFtZVtuYW1lXTtcblxuICAgIC8vIFdlIHdhbnQgaW50ZWdyYXRpb25zIGxhdGVyIGluIHRoZSBhcnJheSB0byBvdmVyd3JpdGUgZWFybGllciBvbmVzIG9mIHRoZSBzYW1lIHR5cGUsIGV4Y2VwdCB0aGF0IHdlIG5ldmVyIHdhbnQgYVxuICAgIC8vIGRlZmF1bHQgaW5zdGFuY2UgdG8gb3ZlcndyaXRlIGFuIGV4aXN0aW5nIHVzZXIgaW5zdGFuY2VcbiAgICBpZiAoZXhpc3RpbmdJbnN0YW5jZSAmJiAhZXhpc3RpbmdJbnN0YW5jZS5pc0RlZmF1bHRJbnN0YW5jZSAmJiBjdXJyZW50SW5zdGFuY2UuaXNEZWZhdWx0SW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlZ3JhdGlvbnNCeU5hbWVbbmFtZV0gPSBjdXJyZW50SW5zdGFuY2U7XG4gIH0pO1xuXG4gIHJldHVybiBPYmplY3QudmFsdWVzKGludGVncmF0aW9uc0J5TmFtZSk7XG59XG5cbi8qKiBHZXRzIGludGVncmF0aW9ucyB0byBpbnN0YWxsICovXG5mdW5jdGlvbiBnZXRJbnRlZ3JhdGlvbnNUb1NldHVwKG9wdGlvbnMpIHtcbiAgY29uc3QgZGVmYXVsdEludGVncmF0aW9ucyA9IG9wdGlvbnMuZGVmYXVsdEludGVncmF0aW9ucyB8fCBbXTtcbiAgY29uc3QgdXNlckludGVncmF0aW9ucyA9IG9wdGlvbnMuaW50ZWdyYXRpb25zO1xuXG4gIC8vIFdlIGZsYWcgZGVmYXVsdCBpbnN0YW5jZXMsIHNvIHRoYXQgbGF0ZXIgd2UgY2FuIHRlbGwgdGhlbSBhcGFydCBmcm9tIGFueSB1c2VyLWNyZWF0ZWQgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIGNsYXNzXG4gIGRlZmF1bHRJbnRlZ3JhdGlvbnMuZm9yRWFjaCgoaW50ZWdyYXRpb24pID0+IHtcbiAgICBpbnRlZ3JhdGlvbi5pc0RlZmF1bHRJbnN0YW5jZSA9IHRydWU7XG4gIH0pO1xuXG4gIGxldCBpbnRlZ3JhdGlvbnM7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodXNlckludGVncmF0aW9ucykpIHtcbiAgICBpbnRlZ3JhdGlvbnMgPSBbLi4uZGVmYXVsdEludGVncmF0aW9ucywgLi4udXNlckludGVncmF0aW9uc107XG4gIH0gZWxzZSBpZiAodHlwZW9mIHVzZXJJbnRlZ3JhdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCByZXNvbHZlZFVzZXJJbnRlZ3JhdGlvbnMgPSB1c2VySW50ZWdyYXRpb25zKGRlZmF1bHRJbnRlZ3JhdGlvbnMpO1xuICAgIGludGVncmF0aW9ucyA9IEFycmF5LmlzQXJyYXkocmVzb2x2ZWRVc2VySW50ZWdyYXRpb25zKSA/IHJlc29sdmVkVXNlckludGVncmF0aW9ucyA6IFtyZXNvbHZlZFVzZXJJbnRlZ3JhdGlvbnNdO1xuICB9IGVsc2Uge1xuICAgIGludGVncmF0aW9ucyA9IGRlZmF1bHRJbnRlZ3JhdGlvbnM7XG4gIH1cblxuICByZXR1cm4gZmlsdGVyRHVwbGljYXRlcyhpbnRlZ3JhdGlvbnMpO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgbGlzdCBvZiBpbnRlZ3JhdGlvbiBpbnN0YW5jZXMgdGhpcyBpbnN0YWxscyB0aGVtIGFsbC4gV2hlbiBgd2l0aERlZmF1bHRzYCBpcyBzZXQgdG8gYHRydWVgIHRoZW4gYWxsIGRlZmF1bHRcbiAqIGludGVncmF0aW9ucyBhcmUgYWRkZWQgdW5sZXNzIHRoZXkgd2VyZSBhbHJlYWR5IHByb3ZpZGVkIGJlZm9yZS5cbiAqIEBwYXJhbSBpbnRlZ3JhdGlvbnMgYXJyYXkgb2YgaW50ZWdyYXRpb24gaW5zdGFuY2VzXG4gKiBAcGFyYW0gd2l0aERlZmF1bHQgc2hvdWxkIGVuYWJsZSBkZWZhdWx0IGludGVncmF0aW9uc1xuICovXG5mdW5jdGlvbiBzZXR1cEludGVncmF0aW9ucyhjbGllbnQsIGludGVncmF0aW9ucykge1xuICBjb25zdCBpbnRlZ3JhdGlvbkluZGV4ID0ge307XG5cbiAgaW50ZWdyYXRpb25zLmZvckVhY2goKGludGVncmF0aW9uKSA9PiB7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCBlbXB0eSBwcm92aWRlZCBpbnRlZ3JhdGlvbnNcbiAgICBpZiAoaW50ZWdyYXRpb24pIHtcbiAgICAgIHNldHVwSW50ZWdyYXRpb24oY2xpZW50LCBpbnRlZ3JhdGlvbiwgaW50ZWdyYXRpb25JbmRleCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaW50ZWdyYXRpb25JbmRleDtcbn1cblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBgYWZ0ZXJBbGxTZXR1cGAgaG9va3Mgb2YgdGhlIGdpdmVuIGludGVncmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gYWZ0ZXJTZXR1cEludGVncmF0aW9ucyhjbGllbnQsIGludGVncmF0aW9ucykge1xuICBmb3IgKGNvbnN0IGludGVncmF0aW9uIG9mIGludGVncmF0aW9ucykge1xuICAgIC8vIGd1YXJkIGFnYWluc3QgZW1wdHkgcHJvdmlkZWQgaW50ZWdyYXRpb25zXG4gICAgaWYgKGludGVncmF0aW9uPy5hZnRlckFsbFNldHVwKSB7XG4gICAgICBpbnRlZ3JhdGlvbi5hZnRlckFsbFNldHVwKGNsaWVudCk7XG4gICAgfVxuICB9XG59XG5cbi8qKiBTZXR1cCBhIHNpbmdsZSBpbnRlZ3JhdGlvbi4gICovXG5mdW5jdGlvbiBzZXR1cEludGVncmF0aW9uKGNsaWVudCwgaW50ZWdyYXRpb24sIGludGVncmF0aW9uSW5kZXgpIHtcbiAgaWYgKGludGVncmF0aW9uSW5kZXhbaW50ZWdyYXRpb24ubmFtZV0pIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIubG9nKGBJbnRlZ3JhdGlvbiBza2lwcGVkIGJlY2F1c2UgaXQgd2FzIGFscmVhZHkgaW5zdGFsbGVkOiAke2ludGVncmF0aW9uLm5hbWV9YCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGludGVncmF0aW9uSW5kZXhbaW50ZWdyYXRpb24ubmFtZV0gPSBpbnRlZ3JhdGlvbjtcblxuICAvLyBgc2V0dXBPbmNlYCBpcyBvbmx5IGNhbGxlZCB0aGUgZmlyc3QgdGltZVxuICBpZiAoaW5zdGFsbGVkSW50ZWdyYXRpb25zLmluZGV4T2YoaW50ZWdyYXRpb24ubmFtZSkgPT09IC0xICYmIHR5cGVvZiBpbnRlZ3JhdGlvbi5zZXR1cE9uY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnRlZ3JhdGlvbi5zZXR1cE9uY2UoKTtcbiAgICBpbnN0YWxsZWRJbnRlZ3JhdGlvbnMucHVzaChpbnRlZ3JhdGlvbi5uYW1lKTtcbiAgfVxuXG4gIC8vIGBzZXR1cGAgaXMgcnVuIGZvciBlYWNoIGNsaWVudFxuICBpZiAoaW50ZWdyYXRpb24uc2V0dXAgJiYgdHlwZW9mIGludGVncmF0aW9uLnNldHVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW50ZWdyYXRpb24uc2V0dXAoY2xpZW50KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW50ZWdyYXRpb24ucHJlcHJvY2Vzc0V2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBpbnRlZ3JhdGlvbi5wcmVwcm9jZXNzRXZlbnQuYmluZChpbnRlZ3JhdGlvbikgO1xuICAgIGNsaWVudC5vbigncHJlcHJvY2Vzc0V2ZW50JywgKGV2ZW50LCBoaW50KSA9PiBjYWxsYmFjayhldmVudCwgaGludCwgY2xpZW50KSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGludGVncmF0aW9uLnByb2Nlc3NFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gaW50ZWdyYXRpb24ucHJvY2Vzc0V2ZW50LmJpbmQoaW50ZWdyYXRpb24pIDtcblxuICAgIGNvbnN0IHByb2Nlc3NvciA9IE9iamVjdC5hc3NpZ24oKGV2ZW50LCBoaW50KSA9PiBjYWxsYmFjayhldmVudCwgaGludCwgY2xpZW50KSwge1xuICAgICAgaWQ6IGludGVncmF0aW9uLm5hbWUsXG4gICAgfSk7XG5cbiAgICBjbGllbnQuYWRkRXZlbnRQcm9jZXNzb3IocHJvY2Vzc29yKTtcbiAgfVxuXG4gIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci5sb2coYEludGVncmF0aW9uIGluc3RhbGxlZDogJHtpbnRlZ3JhdGlvbi5uYW1lfWApO1xufVxuXG4vKiogQWRkIGFuIGludGVncmF0aW9uIHRvIHRoZSBjdXJyZW50IHNjb3BlJ3MgY2xpZW50LiAqL1xuZnVuY3Rpb24gYWRkSW50ZWdyYXRpb24oaW50ZWdyYXRpb24pIHtcbiAgY29uc3QgY2xpZW50ID0gY3VycmVudFNjb3Blcy5nZXRDbGllbnQoKTtcblxuICBpZiAoIWNsaWVudCkge1xuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKGBDYW5ub3QgYWRkIGludGVncmF0aW9uIFwiJHtpbnRlZ3JhdGlvbi5uYW1lfVwiIGJlY2F1c2Ugbm8gU0RLIENsaWVudCBpcyBhdmFpbGFibGUuYCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY2xpZW50LmFkZEludGVncmF0aW9uKGludGVncmF0aW9uKTtcbn1cblxuLyoqXG4gKiBEZWZpbmUgYW4gaW50ZWdyYXRpb24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gaW50ZWdyYXRpb24gaW5zdGFuY2UuXG4gKiBOb3RlIHRoYXQgdGhpcyBieSBkZXNpZ24gaGlkZXMgdGhlIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb2YgdGhlIGludGVncmF0aW9uLCBhcyB0aGV5IGFyZSBjb25zaWRlcmVkIGludGVybmFsLlxuICovXG5mdW5jdGlvbiBkZWZpbmVJbnRlZ3JhdGlvbihmbikge1xuICByZXR1cm4gZm47XG59XG5cbmV4cG9ydHMuYWRkSW50ZWdyYXRpb24gPSBhZGRJbnRlZ3JhdGlvbjtcbmV4cG9ydHMuYWZ0ZXJTZXR1cEludGVncmF0aW9ucyA9IGFmdGVyU2V0dXBJbnRlZ3JhdGlvbnM7XG5leHBvcnRzLmRlZmluZUludGVncmF0aW9uID0gZGVmaW5lSW50ZWdyYXRpb247XG5leHBvcnRzLmdldEludGVncmF0aW9uc1RvU2V0dXAgPSBnZXRJbnRlZ3JhdGlvbnNUb1NldHVwO1xuZXhwb3J0cy5pbnN0YWxsZWRJbnRlZ3JhdGlvbnMgPSBpbnN0YWxsZWRJbnRlZ3JhdGlvbnM7XG5leHBvcnRzLnNldHVwSW50ZWdyYXRpb24gPSBzZXR1cEludGVncmF0aW9uO1xuZXhwb3J0cy5zZXR1cEludGVncmF0aW9ucyA9IHNldHVwSW50ZWdyYXRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZWdyYXRpb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/captureconsole.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst exports$1 = __webpack_require__(/*! ../exports.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/exports.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js\");\nconst console = __webpack_require__(/*! ../utils-hoist/instrument/console.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/console.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst misc = __webpack_require__(/*! ../utils-hoist/misc.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js\");\nconst severity = __webpack_require__(/*! ../utils-hoist/severity.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/severity.js\");\nconst string = __webpack_require__(/*! ../utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\nconst worldwide = __webpack_require__(/*! ../utils-hoist/worldwide.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js\");\n\nconst INTEGRATION_NAME = 'CaptureConsole';\n\nconst _captureConsoleIntegration = ((options = {}) => {\n  const levels = options.levels || logger.CONSOLE_LEVELS;\n  const handled = options.handled ?? true;\n\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      if (!('console' in worldwide.GLOBAL_OBJ)) {\n        return;\n      }\n\n      console.addConsoleInstrumentationHandler(({ args, level }) => {\n        if (currentScopes.getClient() !== client || !levels.includes(level)) {\n          return;\n        }\n\n        consoleHandler(args, level, handled);\n      });\n    },\n  };\n}) ;\n\n/**\n * Send Console API calls as Sentry Events.\n */\nconst captureConsoleIntegration = integration.defineIntegration(_captureConsoleIntegration);\n\nfunction consoleHandler(args, level, handled) {\n  const captureContext = {\n    level: severity.severityLevelFromString(level),\n    extra: {\n      arguments: args,\n    },\n  };\n\n  currentScopes.withScope(scope => {\n    scope.addEventProcessor(event => {\n      event.logger = 'console';\n\n      misc.addExceptionMechanism(event, {\n        handled,\n        type: 'console',\n      });\n\n      return event;\n    });\n\n    if (level === 'assert') {\n      if (!args[0]) {\n        const message = `Assertion failed: ${string.safeJoin(args.slice(1), ' ') || 'console.assert'}`;\n        scope.setExtra('arguments', args.slice(1));\n        exports$1.captureMessage(message, captureContext);\n      }\n      return;\n    }\n\n    const error = args.find(arg => arg instanceof Error);\n    if (error) {\n      exports$1.captureException(error, captureContext);\n      return;\n    }\n\n    const message = string.safeJoin(args, ' ');\n    exports$1.captureMessage(message, captureContext);\n  });\n}\n\nexports.captureConsoleIntegration = captureConsoleIntegration;\n//# sourceMappingURL=captureconsole.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9ucy9jYXB0dXJlY29uc29sZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxzQkFBc0IsbUJBQU8sQ0FBQyw0SEFBcUI7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsZ0hBQWU7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsd0hBQW1CO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLDhKQUFzQztBQUM5RCxlQUFlLG1CQUFPLENBQUMsc0lBQTBCO0FBQ2pELGFBQWEsbUJBQU8sQ0FBQyxrSUFBd0I7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMsMElBQTRCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQyxzSUFBMEI7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMsNElBQTZCOztBQUV2RDs7QUFFQSxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDZDQUE2Qyx3REFBd0Q7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUNBQWlDO0FBQ2pDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGludGVncmF0aW9uc1xcY2FwdHVyZWNvbnNvbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBleHBvcnRzJDEgPSByZXF1aXJlKCcuLi9leHBvcnRzLmpzJyk7XG5jb25zdCBpbnRlZ3JhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVncmF0aW9uLmpzJyk7XG5jb25zdCBjb25zb2xlID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvaW5zdHJ1bWVudC9jb25zb2xlLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IG1pc2MgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9taXNjLmpzJyk7XG5jb25zdCBzZXZlcml0eSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3NldmVyaXR5LmpzJyk7XG5jb25zdCBzdHJpbmcgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9zdHJpbmcuanMnKTtcbmNvbnN0IHdvcmxkd2lkZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3dvcmxkd2lkZS5qcycpO1xuXG5jb25zdCBJTlRFR1JBVElPTl9OQU1FID0gJ0NhcHR1cmVDb25zb2xlJztcblxuY29uc3QgX2NhcHR1cmVDb25zb2xlSW50ZWdyYXRpb24gPSAoKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBsZXZlbHMgPSBvcHRpb25zLmxldmVscyB8fCBsb2dnZXIuQ09OU09MRV9MRVZFTFM7XG4gIGNvbnN0IGhhbmRsZWQgPSBvcHRpb25zLmhhbmRsZWQgPz8gdHJ1ZTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IElOVEVHUkFUSU9OX05BTUUsXG4gICAgc2V0dXAoY2xpZW50KSB7XG4gICAgICBpZiAoISgnY29uc29sZScgaW4gd29ybGR3aWRlLkdMT0JBTF9PQkopKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5hZGRDb25zb2xlSW5zdHJ1bWVudGF0aW9uSGFuZGxlcigoeyBhcmdzLCBsZXZlbCB9KSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50U2NvcGVzLmdldENsaWVudCgpICE9PSBjbGllbnQgfHwgIWxldmVscy5pbmNsdWRlcyhsZXZlbCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlSGFuZGxlcihhcmdzLCBsZXZlbCwgaGFuZGxlZCk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9O1xufSkgO1xuXG4vKipcbiAqIFNlbmQgQ29uc29sZSBBUEkgY2FsbHMgYXMgU2VudHJ5IEV2ZW50cy5cbiAqL1xuY29uc3QgY2FwdHVyZUNvbnNvbGVJbnRlZ3JhdGlvbiA9IGludGVncmF0aW9uLmRlZmluZUludGVncmF0aW9uKF9jYXB0dXJlQ29uc29sZUludGVncmF0aW9uKTtcblxuZnVuY3Rpb24gY29uc29sZUhhbmRsZXIoYXJncywgbGV2ZWwsIGhhbmRsZWQpIHtcbiAgY29uc3QgY2FwdHVyZUNvbnRleHQgPSB7XG4gICAgbGV2ZWw6IHNldmVyaXR5LnNldmVyaXR5TGV2ZWxGcm9tU3RyaW5nKGxldmVsKSxcbiAgICBleHRyYToge1xuICAgICAgYXJndW1lbnRzOiBhcmdzLFxuICAgIH0sXG4gIH07XG5cbiAgY3VycmVudFNjb3Blcy53aXRoU2NvcGUoc2NvcGUgPT4ge1xuICAgIHNjb3BlLmFkZEV2ZW50UHJvY2Vzc29yKGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LmxvZ2dlciA9ICdjb25zb2xlJztcblxuICAgICAgbWlzYy5hZGRFeGNlcHRpb25NZWNoYW5pc20oZXZlbnQsIHtcbiAgICAgICAgaGFuZGxlZCxcbiAgICAgICAgdHlwZTogJ2NvbnNvbGUnLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9KTtcblxuICAgIGlmIChsZXZlbCA9PT0gJ2Fzc2VydCcpIHtcbiAgICAgIGlmICghYXJnc1swXSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYEFzc2VydGlvbiBmYWlsZWQ6ICR7c3RyaW5nLnNhZmVKb2luKGFyZ3Muc2xpY2UoMSksICcgJykgfHwgJ2NvbnNvbGUuYXNzZXJ0J31gO1xuICAgICAgICBzY29wZS5zZXRFeHRyYSgnYXJndW1lbnRzJywgYXJncy5zbGljZSgxKSk7XG4gICAgICAgIGV4cG9ydHMkMS5jYXB0dXJlTWVzc2FnZShtZXNzYWdlLCBjYXB0dXJlQ29udGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3IgPSBhcmdzLmZpbmQoYXJnID0+IGFyZyBpbnN0YW5jZW9mIEVycm9yKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGV4cG9ydHMkMS5jYXB0dXJlRXhjZXB0aW9uKGVycm9yLCBjYXB0dXJlQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZSA9IHN0cmluZy5zYWZlSm9pbihhcmdzLCAnICcpO1xuICAgIGV4cG9ydHMkMS5jYXB0dXJlTWVzc2FnZShtZXNzYWdlLCBjYXB0dXJlQ29udGV4dCk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmNhcHR1cmVDb25zb2xlSW50ZWdyYXRpb24gPSBjYXB0dXJlQ29uc29sZUludGVncmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FwdHVyZWNvbnNvbGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/captureconsole.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/console.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst breadcrumbs = __webpack_require__(/*! ../breadcrumbs.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/breadcrumbs.js\");\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js\");\nconst console = __webpack_require__(/*! ../utils-hoist/instrument/console.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/console.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst severity = __webpack_require__(/*! ../utils-hoist/severity.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/severity.js\");\nconst string = __webpack_require__(/*! ../utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\nconst worldwide = __webpack_require__(/*! ../utils-hoist/worldwide.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js\");\n\nconst INTEGRATION_NAME = 'Console';\n\n/**\n * Captures calls to the `console` API as breadcrumbs in Sentry.\n *\n * By default the integration instruments `console.debug`, `console.info`, `console.warn`, `console.error`,\n * `console.log`, `console.trace`, and `console.assert`. You can use the `levels` option to customize which\n * levels are captured.\n *\n * @example\n *\n * ```js\n * Sentry.init({\n *   integrations: [Sentry.consoleIntegration({ levels: ['error', 'warn'] })],\n * });\n * ```\n */\nconst consoleIntegration = integration.defineIntegration((options = {}) => {\n  const levels = new Set(options.levels || logger.CONSOLE_LEVELS);\n\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      console.addConsoleInstrumentationHandler(({ args, level }) => {\n        if (currentScopes.getClient() !== client || !levels.has(level)) {\n          return;\n        }\n\n        addConsoleBreadcrumb(level, args);\n      });\n    },\n  };\n});\n\n/**\n * Capture a console breadcrumb.\n *\n * Exported just for tests.\n */\nfunction addConsoleBreadcrumb(level, args) {\n  const breadcrumb = {\n    category: 'console',\n    data: {\n      arguments: args,\n      logger: 'console',\n    },\n    level: severity.severityLevelFromString(level),\n    message: formatConsoleArgs(args),\n  };\n\n  if (level === 'assert') {\n    if (args[0] === false) {\n      const assertionArgs = args.slice(1);\n      breadcrumb.message =\n        assertionArgs.length > 0 ? `Assertion failed: ${formatConsoleArgs(assertionArgs)}` : 'Assertion failed';\n      breadcrumb.data.arguments = assertionArgs;\n    } else {\n      // Don't capture a breadcrumb for passed assertions\n      return;\n    }\n  }\n\n  breadcrumbs.addBreadcrumb(breadcrumb, {\n    input: args,\n    level,\n  });\n}\n\nfunction formatConsoleArgs(values) {\n  return 'util' in worldwide.GLOBAL_OBJ && typeof (worldwide.GLOBAL_OBJ ).util.format === 'function'\n    ? (worldwide.GLOBAL_OBJ ).util.format(...values)\n    : string.safeJoin(values, ' ');\n}\n\nexports.addConsoleBreadcrumb = addConsoleBreadcrumb;\nexports.consoleIntegration = consoleIntegration;\n//# sourceMappingURL=console.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9ucy9jb25zb2xlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLG9CQUFvQixtQkFBTyxDQUFDLHdIQUFtQjtBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQyw0SEFBcUI7QUFDbkQsb0JBQW9CLG1CQUFPLENBQUMsd0hBQW1CO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLDhKQUFzQztBQUM5RCxlQUFlLG1CQUFPLENBQUMsc0lBQTBCO0FBQ2pELGlCQUFpQixtQkFBTyxDQUFDLDBJQUE0QjtBQUNyRCxlQUFlLG1CQUFPLENBQUMsc0lBQTBCO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLDRJQUE2Qjs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwyQkFBMkI7QUFDM0UsSUFBSTtBQUNKO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsaUNBQWlDO0FBQ3pGO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcaW50ZWdyYXRpb25zXFxjb25zb2xlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBicmVhZGNydW1icyA9IHJlcXVpcmUoJy4uL2JyZWFkY3J1bWJzLmpzJyk7XG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi4vY3VycmVudFNjb3Blcy5qcycpO1xuY29uc3QgaW50ZWdyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlZ3JhdGlvbi5qcycpO1xuY29uc3QgY29uc29sZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2luc3RydW1lbnQvY29uc29sZS5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCBzZXZlcml0eSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3NldmVyaXR5LmpzJyk7XG5jb25zdCBzdHJpbmcgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9zdHJpbmcuanMnKTtcbmNvbnN0IHdvcmxkd2lkZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3dvcmxkd2lkZS5qcycpO1xuXG5jb25zdCBJTlRFR1JBVElPTl9OQU1FID0gJ0NvbnNvbGUnO1xuXG4vKipcbiAqIENhcHR1cmVzIGNhbGxzIHRvIHRoZSBgY29uc29sZWAgQVBJIGFzIGJyZWFkY3J1bWJzIGluIFNlbnRyeS5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoZSBpbnRlZ3JhdGlvbiBpbnN0cnVtZW50cyBgY29uc29sZS5kZWJ1Z2AsIGBjb25zb2xlLmluZm9gLCBgY29uc29sZS53YXJuYCwgYGNvbnNvbGUuZXJyb3JgLFxuICogYGNvbnNvbGUubG9nYCwgYGNvbnNvbGUudHJhY2VgLCBhbmQgYGNvbnNvbGUuYXNzZXJ0YC4gWW91IGNhbiB1c2UgdGhlIGBsZXZlbHNgIG9wdGlvbiB0byBjdXN0b21pemUgd2hpY2hcbiAqIGxldmVscyBhcmUgY2FwdHVyZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogU2VudHJ5LmluaXQoe1xuICogICBpbnRlZ3JhdGlvbnM6IFtTZW50cnkuY29uc29sZUludGVncmF0aW9uKHsgbGV2ZWxzOiBbJ2Vycm9yJywgJ3dhcm4nXSB9KV0sXG4gKiB9KTtcbiAqIGBgYFxuICovXG5jb25zdCBjb25zb2xlSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbigob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGxldmVscyA9IG5ldyBTZXQob3B0aW9ucy5sZXZlbHMgfHwgbG9nZ2VyLkNPTlNPTEVfTEVWRUxTKTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IElOVEVHUkFUSU9OX05BTUUsXG4gICAgc2V0dXAoY2xpZW50KSB7XG4gICAgICBjb25zb2xlLmFkZENvbnNvbGVJbnN0cnVtZW50YXRpb25IYW5kbGVyKCh7IGFyZ3MsIGxldmVsIH0pID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCkgIT09IGNsaWVudCB8fCAhbGV2ZWxzLmhhcyhsZXZlbCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhZGRDb25zb2xlQnJlYWRjcnVtYihsZXZlbCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9O1xufSk7XG5cbi8qKlxuICogQ2FwdHVyZSBhIGNvbnNvbGUgYnJlYWRjcnVtYi5cbiAqXG4gKiBFeHBvcnRlZCBqdXN0IGZvciB0ZXN0cy5cbiAqL1xuZnVuY3Rpb24gYWRkQ29uc29sZUJyZWFkY3J1bWIobGV2ZWwsIGFyZ3MpIHtcbiAgY29uc3QgYnJlYWRjcnVtYiA9IHtcbiAgICBjYXRlZ29yeTogJ2NvbnNvbGUnLFxuICAgIGRhdGE6IHtcbiAgICAgIGFyZ3VtZW50czogYXJncyxcbiAgICAgIGxvZ2dlcjogJ2NvbnNvbGUnLFxuICAgIH0sXG4gICAgbGV2ZWw6IHNldmVyaXR5LnNldmVyaXR5TGV2ZWxGcm9tU3RyaW5nKGxldmVsKSxcbiAgICBtZXNzYWdlOiBmb3JtYXRDb25zb2xlQXJncyhhcmdzKSxcbiAgfTtcblxuICBpZiAobGV2ZWwgPT09ICdhc3NlcnQnKSB7XG4gICAgaWYgKGFyZ3NbMF0gPT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBhc3NlcnRpb25BcmdzID0gYXJncy5zbGljZSgxKTtcbiAgICAgIGJyZWFkY3J1bWIubWVzc2FnZSA9XG4gICAgICAgIGFzc2VydGlvbkFyZ3MubGVuZ3RoID4gMCA/IGBBc3NlcnRpb24gZmFpbGVkOiAke2Zvcm1hdENvbnNvbGVBcmdzKGFzc2VydGlvbkFyZ3MpfWAgOiAnQXNzZXJ0aW9uIGZhaWxlZCc7XG4gICAgICBicmVhZGNydW1iLmRhdGEuYXJndW1lbnRzID0gYXNzZXJ0aW9uQXJncztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRG9uJ3QgY2FwdHVyZSBhIGJyZWFkY3J1bWIgZm9yIHBhc3NlZCBhc3NlcnRpb25zXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgYnJlYWRjcnVtYnMuYWRkQnJlYWRjcnVtYihicmVhZGNydW1iLCB7XG4gICAgaW5wdXQ6IGFyZ3MsXG4gICAgbGV2ZWwsXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRDb25zb2xlQXJncyh2YWx1ZXMpIHtcbiAgcmV0dXJuICd1dGlsJyBpbiB3b3JsZHdpZGUuR0xPQkFMX09CSiAmJiB0eXBlb2YgKHdvcmxkd2lkZS5HTE9CQUxfT0JKICkudXRpbC5mb3JtYXQgPT09ICdmdW5jdGlvbidcbiAgICA/ICh3b3JsZHdpZGUuR0xPQkFMX09CSiApLnV0aWwuZm9ybWF0KC4uLnZhbHVlcylcbiAgICA6IHN0cmluZy5zYWZlSm9pbih2YWx1ZXMsICcgJyk7XG59XG5cbmV4cG9ydHMuYWRkQ29uc29sZUJyZWFkY3J1bWIgPSBhZGRDb25zb2xlQnJlYWRjcnVtYjtcbmV4cG9ydHMuY29uc29sZUludGVncmF0aW9uID0gY29uc29sZUludGVncmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc29sZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/console.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/dedupe.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst stacktrace = __webpack_require__(/*! ../utils-hoist/stacktrace.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/stacktrace.js\");\n\nconst INTEGRATION_NAME = 'Dedupe';\n\nconst _dedupeIntegration = (() => {\n  let previousEvent;\n\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(currentEvent) {\n      // We want to ignore any non-error type events, e.g. transactions or replays\n      // These should never be deduped, and also not be compared against as _previousEvent.\n      if (currentEvent.type) {\n        return currentEvent;\n      }\n\n      // Juuust in case something goes wrong\n      try {\n        if (_shouldDropEvent(currentEvent, previousEvent)) {\n          debugBuild.DEBUG_BUILD && logger.logger.warn('Event dropped due to being a duplicate of previously captured event.');\n          return null;\n        }\n      } catch (_oO) {} // eslint-disable-line no-empty\n\n      return (previousEvent = currentEvent);\n    },\n  };\n}) ;\n\n/**\n * Deduplication filter.\n */\nconst dedupeIntegration = integration.defineIntegration(_dedupeIntegration);\n\n/** only exported for tests. */\nfunction _shouldDropEvent(currentEvent, previousEvent) {\n  if (!previousEvent) {\n    return false;\n  }\n\n  if (_isSameMessageEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  if (_isSameExceptionEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _isSameMessageEvent(currentEvent, previousEvent) {\n  const currentMessage = currentEvent.message;\n  const previousMessage = previousEvent.message;\n\n  // If neither event has a message property, they were both exceptions, so bail out\n  if (!currentMessage && !previousMessage) {\n    return false;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {\n    return false;\n  }\n\n  if (currentMessage !== previousMessage) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction _isSameExceptionEvent(currentEvent, previousEvent) {\n  const previousException = _getExceptionFromEvent(previousEvent);\n  const currentException = _getExceptionFromEvent(currentEvent);\n\n  if (!previousException || !currentException) {\n    return false;\n  }\n\n  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction _isSameStacktrace(currentEvent, previousEvent) {\n  let currentFrames = stacktrace.getFramesFromEvent(currentEvent);\n  let previousFrames = stacktrace.getFramesFromEvent(previousEvent);\n\n  // If neither event has a stacktrace, they are assumed to be the same\n  if (!currentFrames && !previousFrames) {\n    return true;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {\n    return false;\n  }\n\n  currentFrames = currentFrames ;\n  previousFrames = previousFrames ;\n\n  // If number of frames differ, they are not the same\n  if (previousFrames.length !== currentFrames.length) {\n    return false;\n  }\n\n  // Otherwise, compare the two\n  for (let i = 0; i < previousFrames.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const frameA = previousFrames[i];\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const frameB = currentFrames[i];\n\n    if (\n      frameA.filename !== frameB.filename ||\n      frameA.lineno !== frameB.lineno ||\n      frameA.colno !== frameB.colno ||\n      frameA.function !== frameB.function\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction _isSameFingerprint(currentEvent, previousEvent) {\n  let currentFingerprint = currentEvent.fingerprint;\n  let previousFingerprint = previousEvent.fingerprint;\n\n  // If neither event has a fingerprint, they are assumed to be the same\n  if (!currentFingerprint && !previousFingerprint) {\n    return true;\n  }\n\n  // If only one event has a fingerprint, but not the other one, they are not the same\n  if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {\n    return false;\n  }\n\n  currentFingerprint = currentFingerprint ;\n  previousFingerprint = previousFingerprint ;\n\n  // Otherwise, compare the two\n  try {\n    return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n  } catch (_oO) {\n    return false;\n  }\n}\n\nfunction _getExceptionFromEvent(event) {\n  return event.exception?.values && event.exception.values[0];\n}\n\nexports._shouldDropEvent = _shouldDropEvent;\nexports.dedupeIntegration = dedupeIntegration;\n//# sourceMappingURL=dedupe.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9ucy9kZWR1cGUuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsbUJBQW1CLG1CQUFPLENBQUMsd0hBQW1CO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLHdIQUFtQjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsc0lBQTBCO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLDhJQUE4Qjs7QUFFekQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZUFBZTs7QUFFdkI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxpbnRlZ3JhdGlvbnNcXGRlZHVwZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgZGVidWdCdWlsZCA9IHJlcXVpcmUoJy4uL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBpbnRlZ3JhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVncmF0aW9uLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IHN0YWNrdHJhY2UgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9zdGFja3RyYWNlLmpzJyk7XG5cbmNvbnN0IElOVEVHUkFUSU9OX05BTUUgPSAnRGVkdXBlJztcblxuY29uc3QgX2RlZHVwZUludGVncmF0aW9uID0gKCgpID0+IHtcbiAgbGV0IHByZXZpb3VzRXZlbnQ7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHByb2Nlc3NFdmVudChjdXJyZW50RXZlbnQpIHtcbiAgICAgIC8vIFdlIHdhbnQgdG8gaWdub3JlIGFueSBub24tZXJyb3IgdHlwZSBldmVudHMsIGUuZy4gdHJhbnNhY3Rpb25zIG9yIHJlcGxheXNcbiAgICAgIC8vIFRoZXNlIHNob3VsZCBuZXZlciBiZSBkZWR1cGVkLCBhbmQgYWxzbyBub3QgYmUgY29tcGFyZWQgYWdhaW5zdCBhcyBfcHJldmlvdXNFdmVudC5cbiAgICAgIGlmIChjdXJyZW50RXZlbnQudHlwZSkge1xuICAgICAgICByZXR1cm4gY3VycmVudEV2ZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBKdXV1c3QgaW4gY2FzZSBzb21ldGhpbmcgZ29lcyB3cm9uZ1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKF9zaG91bGREcm9wRXZlbnQoY3VycmVudEV2ZW50LCBwcmV2aW91c0V2ZW50KSkge1xuICAgICAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdFdmVudCBkcm9wcGVkIGR1ZSB0byBiZWluZyBhIGR1cGxpY2F0ZSBvZiBwcmV2aW91c2x5IGNhcHR1cmVkIGV2ZW50LicpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfb08pIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxuICAgICAgcmV0dXJuIChwcmV2aW91c0V2ZW50ID0gY3VycmVudEV2ZW50KTtcbiAgICB9LFxuICB9O1xufSkgO1xuXG4vKipcbiAqIERlZHVwbGljYXRpb24gZmlsdGVyLlxuICovXG5jb25zdCBkZWR1cGVJbnRlZ3JhdGlvbiA9IGludGVncmF0aW9uLmRlZmluZUludGVncmF0aW9uKF9kZWR1cGVJbnRlZ3JhdGlvbik7XG5cbi8qKiBvbmx5IGV4cG9ydGVkIGZvciB0ZXN0cy4gKi9cbmZ1bmN0aW9uIF9zaG91bGREcm9wRXZlbnQoY3VycmVudEV2ZW50LCBwcmV2aW91c0V2ZW50KSB7XG4gIGlmICghcHJldmlvdXNFdmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChfaXNTYW1lTWVzc2FnZUV2ZW50KGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChfaXNTYW1lRXhjZXB0aW9uRXZlbnQoY3VycmVudEV2ZW50LCBwcmV2aW91c0V2ZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfaXNTYW1lTWVzc2FnZUV2ZW50KGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkge1xuICBjb25zdCBjdXJyZW50TWVzc2FnZSA9IGN1cnJlbnRFdmVudC5tZXNzYWdlO1xuICBjb25zdCBwcmV2aW91c01lc3NhZ2UgPSBwcmV2aW91c0V2ZW50Lm1lc3NhZ2U7XG5cbiAgLy8gSWYgbmVpdGhlciBldmVudCBoYXMgYSBtZXNzYWdlIHByb3BlcnR5LCB0aGV5IHdlcmUgYm90aCBleGNlcHRpb25zLCBzbyBiYWlsIG91dFxuICBpZiAoIWN1cnJlbnRNZXNzYWdlICYmICFwcmV2aW91c01lc3NhZ2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBvbmx5IG9uZSBldmVudCBoYXMgYSBzdGFja3RyYWNlLCBidXQgbm90IHRoZSBvdGhlciBvbmUsIHRoZXkgYXJlIG5vdCB0aGUgc2FtZVxuICBpZiAoKGN1cnJlbnRNZXNzYWdlICYmICFwcmV2aW91c01lc3NhZ2UpIHx8ICghY3VycmVudE1lc3NhZ2UgJiYgcHJldmlvdXNNZXNzYWdlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjdXJyZW50TWVzc2FnZSAhPT0gcHJldmlvdXNNZXNzYWdlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFfaXNTYW1lRmluZ2VycHJpbnQoY3VycmVudEV2ZW50LCBwcmV2aW91c0V2ZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghX2lzU2FtZVN0YWNrdHJhY2UoY3VycmVudEV2ZW50LCBwcmV2aW91c0V2ZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBfaXNTYW1lRXhjZXB0aW9uRXZlbnQoY3VycmVudEV2ZW50LCBwcmV2aW91c0V2ZW50KSB7XG4gIGNvbnN0IHByZXZpb3VzRXhjZXB0aW9uID0gX2dldEV4Y2VwdGlvbkZyb21FdmVudChwcmV2aW91c0V2ZW50KTtcbiAgY29uc3QgY3VycmVudEV4Y2VwdGlvbiA9IF9nZXRFeGNlcHRpb25Gcm9tRXZlbnQoY3VycmVudEV2ZW50KTtcblxuICBpZiAoIXByZXZpb3VzRXhjZXB0aW9uIHx8ICFjdXJyZW50RXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByZXZpb3VzRXhjZXB0aW9uLnR5cGUgIT09IGN1cnJlbnRFeGNlcHRpb24udHlwZSB8fCBwcmV2aW91c0V4Y2VwdGlvbi52YWx1ZSAhPT0gY3VycmVudEV4Y2VwdGlvbi52YWx1ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghX2lzU2FtZUZpbmdlcnByaW50KGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIV9pc1NhbWVTdGFja3RyYWNlKGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX2lzU2FtZVN0YWNrdHJhY2UoY3VycmVudEV2ZW50LCBwcmV2aW91c0V2ZW50KSB7XG4gIGxldCBjdXJyZW50RnJhbWVzID0gc3RhY2t0cmFjZS5nZXRGcmFtZXNGcm9tRXZlbnQoY3VycmVudEV2ZW50KTtcbiAgbGV0IHByZXZpb3VzRnJhbWVzID0gc3RhY2t0cmFjZS5nZXRGcmFtZXNGcm9tRXZlbnQocHJldmlvdXNFdmVudCk7XG5cbiAgLy8gSWYgbmVpdGhlciBldmVudCBoYXMgYSBzdGFja3RyYWNlLCB0aGV5IGFyZSBhc3N1bWVkIHRvIGJlIHRoZSBzYW1lXG4gIGlmICghY3VycmVudEZyYW1lcyAmJiAhcHJldmlvdXNGcmFtZXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIElmIG9ubHkgb25lIGV2ZW50IGhhcyBhIHN0YWNrdHJhY2UsIGJ1dCBub3QgdGhlIG90aGVyIG9uZSwgdGhleSBhcmUgbm90IHRoZSBzYW1lXG4gIGlmICgoY3VycmVudEZyYW1lcyAmJiAhcHJldmlvdXNGcmFtZXMpIHx8ICghY3VycmVudEZyYW1lcyAmJiBwcmV2aW91c0ZyYW1lcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjdXJyZW50RnJhbWVzID0gY3VycmVudEZyYW1lcyA7XG4gIHByZXZpb3VzRnJhbWVzID0gcHJldmlvdXNGcmFtZXMgO1xuXG4gIC8vIElmIG51bWJlciBvZiBmcmFtZXMgZGlmZmVyLCB0aGV5IGFyZSBub3QgdGhlIHNhbWVcbiAgaWYgKHByZXZpb3VzRnJhbWVzLmxlbmd0aCAhPT0gY3VycmVudEZyYW1lcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGNvbXBhcmUgdGhlIHR3b1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZpb3VzRnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBjb25zdCBmcmFtZUEgPSBwcmV2aW91c0ZyYW1lc1tpXTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGNvbnN0IGZyYW1lQiA9IGN1cnJlbnRGcmFtZXNbaV07XG5cbiAgICBpZiAoXG4gICAgICBmcmFtZUEuZmlsZW5hbWUgIT09IGZyYW1lQi5maWxlbmFtZSB8fFxuICAgICAgZnJhbWVBLmxpbmVubyAhPT0gZnJhbWVCLmxpbmVubyB8fFxuICAgICAgZnJhbWVBLmNvbG5vICE9PSBmcmFtZUIuY29sbm8gfHxcbiAgICAgIGZyYW1lQS5mdW5jdGlvbiAhPT0gZnJhbWVCLmZ1bmN0aW9uXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIF9pc1NhbWVGaW5nZXJwcmludChjdXJyZW50RXZlbnQsIHByZXZpb3VzRXZlbnQpIHtcbiAgbGV0IGN1cnJlbnRGaW5nZXJwcmludCA9IGN1cnJlbnRFdmVudC5maW5nZXJwcmludDtcbiAgbGV0IHByZXZpb3VzRmluZ2VycHJpbnQgPSBwcmV2aW91c0V2ZW50LmZpbmdlcnByaW50O1xuXG4gIC8vIElmIG5laXRoZXIgZXZlbnQgaGFzIGEgZmluZ2VycHJpbnQsIHRoZXkgYXJlIGFzc3VtZWQgdG8gYmUgdGhlIHNhbWVcbiAgaWYgKCFjdXJyZW50RmluZ2VycHJpbnQgJiYgIXByZXZpb3VzRmluZ2VycHJpbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIElmIG9ubHkgb25lIGV2ZW50IGhhcyBhIGZpbmdlcnByaW50LCBidXQgbm90IHRoZSBvdGhlciBvbmUsIHRoZXkgYXJlIG5vdCB0aGUgc2FtZVxuICBpZiAoKGN1cnJlbnRGaW5nZXJwcmludCAmJiAhcHJldmlvdXNGaW5nZXJwcmludCkgfHwgKCFjdXJyZW50RmluZ2VycHJpbnQgJiYgcHJldmlvdXNGaW5nZXJwcmludCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjdXJyZW50RmluZ2VycHJpbnQgPSBjdXJyZW50RmluZ2VycHJpbnQgO1xuICBwcmV2aW91c0ZpbmdlcnByaW50ID0gcHJldmlvdXNGaW5nZXJwcmludCA7XG5cbiAgLy8gT3RoZXJ3aXNlLCBjb21wYXJlIHRoZSB0d29cbiAgdHJ5IHtcbiAgICByZXR1cm4gISEoY3VycmVudEZpbmdlcnByaW50LmpvaW4oJycpID09PSBwcmV2aW91c0ZpbmdlcnByaW50LmpvaW4oJycpKTtcbiAgfSBjYXRjaCAoX29PKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRFeGNlcHRpb25Gcm9tRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmV4Y2VwdGlvbj8udmFsdWVzICYmIGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXNbMF07XG59XG5cbmV4cG9ydHMuX3Nob3VsZERyb3BFdmVudCA9IF9zaG91bGREcm9wRXZlbnQ7XG5leHBvcnRzLmRlZHVwZUludGVncmF0aW9uID0gZGVkdXBlSW50ZWdyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWR1cGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/dedupe.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/eventFilters.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js\");\nconst eventUtils = __webpack_require__(/*! ../utils/eventUtils.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/eventUtils.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst misc = __webpack_require__(/*! ../utils-hoist/misc.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js\");\nconst string = __webpack_require__(/*! ../utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\n\n// \"Script error.\" is hard coded into browsers for errors that it can't read.\n// this is the result of a script being pulled in from an external domain and CORS.\nconst DEFAULT_IGNORE_ERRORS = [\n  /^Script error\\.?$/,\n  /^Javascript error: Script error\\.? on line 0$/,\n  /^ResizeObserver loop completed with undelivered notifications.$/, // The browser logs this when a ResizeObserver handler takes a bit longer. Usually this is not an actual issue though. It indicates slowness.\n  /^Cannot redefine property: googletag$/, // This is thrown when google tag manager is used in combination with an ad blocker\n  /^Can't find variable: gmo$/, // Error from Google Search App https://issuetracker.google.com/issues/396043331\n  /^undefined is not an object \\(evaluating 'a\\.[A-Z]'\\)$/, // Random error that happens but not actionable or noticeable to end-users.\n  'can\\'t redefine non-configurable property \"solana\"', // Probably a browser extension or custom browser (Brave) throwing this error\n  \"vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)\", // Error thrown by GTM, seemingly not affecting end-users\n  \"Can't find variable: _AutofillCallbackHandler\", // Unactionable error in instagram webview https://developers.facebook.com/community/threads/320013549791141/\n  /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\\d+, MethodName:simulateEvent, ParamCount:\\d+$/, // unactionable error from CEFSharp, a .NET library that embeds chromium in .NET apps\n  /^Java exception was raised during method invocation$/, // error from Facebook Mobile browser (https://github.com/getsentry/sentry-javascript/issues/15065)\n];\n\n/** Options for the EventFilters integration */\n\nconst INTEGRATION_NAME = 'EventFilters';\n\n/**\n * An integration that filters out events (errors and transactions) based on:\n *\n * - (Errors) A curated list of known low-value or irrelevant errors (see {@link DEFAULT_IGNORE_ERRORS})\n * - (Errors) A list of error messages or urls/filenames passed in via\n *   - Top level Sentry.init options (`ignoreErrors`, `denyUrls`, `allowUrls`)\n *   - The same options passed to the integration directly via @param options\n * - (Transactions/Spans) A list of root span (transaction) names passed in via\n *   - Top level Sentry.init option (`ignoreTransactions`)\n *   - The same option passed to the integration directly via @param options\n *\n * Events filtered by this integration will not be sent to Sentry.\n */\nconst eventFiltersIntegration = integration.defineIntegration((options = {}) => {\n  let mergedOptions;\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      const clientOptions = client.getOptions();\n      mergedOptions = _mergeOptions(options, clientOptions);\n    },\n    processEvent(event, _hint, client) {\n      if (!mergedOptions) {\n        const clientOptions = client.getOptions();\n        mergedOptions = _mergeOptions(options, clientOptions);\n      }\n      return _shouldDropEvent(event, mergedOptions) ? null : event;\n    },\n  };\n});\n\n/**\n * An integration that filters out events (errors and transactions) based on:\n *\n * - (Errors) A curated list of known low-value or irrelevant errors (see {@link DEFAULT_IGNORE_ERRORS})\n * - (Errors) A list of error messages or urls/filenames passed in via\n *   - Top level Sentry.init options (`ignoreErrors`, `denyUrls`, `allowUrls`)\n *   - The same options passed to the integration directly via @param options\n * - (Transactions/Spans) A list of root span (transaction) names passed in via\n *   - Top level Sentry.init option (`ignoreTransactions`)\n *   - The same option passed to the integration directly via @param options\n *\n * Events filtered by this integration will not be sent to Sentry.\n *\n * @deprecated this integration was renamed and will be removed in a future major version.\n * Use `eventFiltersIntegration` instead.\n */\nconst inboundFiltersIntegration = integration.defineIntegration(((options = {}) => {\n  return {\n    ...eventFiltersIntegration(options),\n    name: 'InboundFilters',\n  };\n}) );\n\nfunction _mergeOptions(\n  internalOptions = {},\n  clientOptions = {},\n) {\n  return {\n    allowUrls: [...(internalOptions.allowUrls || []), ...(clientOptions.allowUrls || [])],\n    denyUrls: [...(internalOptions.denyUrls || []), ...(clientOptions.denyUrls || [])],\n    ignoreErrors: [\n      ...(internalOptions.ignoreErrors || []),\n      ...(clientOptions.ignoreErrors || []),\n      ...(internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS),\n    ],\n    ignoreTransactions: [...(internalOptions.ignoreTransactions || []), ...(clientOptions.ignoreTransactions || [])],\n  };\n}\n\nfunction _shouldDropEvent(event, options) {\n  if (!event.type) {\n    // Filter errors\n    if (_isIgnoredError(event, options.ignoreErrors)) {\n      debugBuild.DEBUG_BUILD &&\n        logger.logger.warn(\n          `Event dropped due to being matched by \\`ignoreErrors\\` option.\\nEvent: ${misc.getEventDescription(event)}`,\n        );\n      return true;\n    }\n    if (_isUselessError(event)) {\n      debugBuild.DEBUG_BUILD &&\n        logger.logger.warn(\n          `Event dropped due to not having an error message, error type or stacktrace.\\nEvent: ${misc.getEventDescription(\n            event,\n          )}`,\n        );\n      return true;\n    }\n    if (_isDeniedUrl(event, options.denyUrls)) {\n      debugBuild.DEBUG_BUILD &&\n        logger.logger.warn(\n          `Event dropped due to being matched by \\`denyUrls\\` option.\\nEvent: ${misc.getEventDescription(\n            event,\n          )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n        );\n      return true;\n    }\n    if (!_isAllowedUrl(event, options.allowUrls)) {\n      debugBuild.DEBUG_BUILD &&\n        logger.logger.warn(\n          `Event dropped due to not being matched by \\`allowUrls\\` option.\\nEvent: ${misc.getEventDescription(\n            event,\n          )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n        );\n      return true;\n    }\n  } else if (event.type === 'transaction') {\n    // Filter transactions\n\n    if (_isIgnoredTransaction(event, options.ignoreTransactions)) {\n      debugBuild.DEBUG_BUILD &&\n        logger.logger.warn(\n          `Event dropped due to being matched by \\`ignoreTransactions\\` option.\\nEvent: ${misc.getEventDescription(event)}`,\n        );\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction _isIgnoredError(event, ignoreErrors) {\n  if (!ignoreErrors?.length) {\n    return false;\n  }\n\n  return eventUtils.getPossibleEventMessages(event).some(message => string.stringMatchesSomePattern(message, ignoreErrors));\n}\n\nfunction _isIgnoredTransaction(event, ignoreTransactions) {\n  if (!ignoreTransactions?.length) {\n    return false;\n  }\n\n  const name = event.transaction;\n  return name ? string.stringMatchesSomePattern(name, ignoreTransactions) : false;\n}\n\nfunction _isDeniedUrl(event, denyUrls) {\n  if (!denyUrls?.length) {\n    return false;\n  }\n  const url = _getEventFilterUrl(event);\n  return !url ? false : string.stringMatchesSomePattern(url, denyUrls);\n}\n\nfunction _isAllowedUrl(event, allowUrls) {\n  if (!allowUrls?.length) {\n    return true;\n  }\n  const url = _getEventFilterUrl(event);\n  return !url ? true : string.stringMatchesSomePattern(url, allowUrls);\n}\n\nfunction _getLastValidUrl(frames = []) {\n  for (let i = frames.length - 1; i >= 0; i--) {\n    const frame = frames[i];\n\n    if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {\n      return frame.filename || null;\n    }\n  }\n\n  return null;\n}\n\nfunction _getEventFilterUrl(event) {\n  try {\n    // If there are linked exceptions or exception aggregates we only want to match against the top frame of the \"root\" (the main exception)\n    // The root always comes last in linked exceptions\n    const rootException = [...(event.exception?.values ?? [])]\n      .reverse()\n      .find(value => value.mechanism?.parent_id === undefined && value.stacktrace?.frames?.length);\n    const frames = rootException?.stacktrace?.frames;\n    return frames ? _getLastValidUrl(frames) : null;\n  } catch (oO) {\n    debugBuild.DEBUG_BUILD && logger.logger.error(`Cannot extract url for event ${misc.getEventDescription(event)}`);\n    return null;\n  }\n}\n\nfunction _isUselessError(event) {\n  // We only want to consider events for dropping that actually have recorded exception values.\n  if (!event.exception?.values?.length) {\n    return false;\n  }\n\n  return (\n    // No top-level message\n    !event.message &&\n    // There are no exception values that have a stacktrace, a non-generic-Error type or value\n    !event.exception.values.some(value => value.stacktrace || (value.type && value.type !== 'Error') || value.value)\n  );\n}\n\nexports.eventFiltersIntegration = eventFiltersIntegration;\nexports.inboundFiltersIntegration = inboundFiltersIntegration;\n//# sourceMappingURL=eventFilters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9ucy9ldmVudEZpbHRlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsbUJBQW1CLG1CQUFPLENBQUMsd0hBQW1CO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLHdIQUFtQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyxrSUFBd0I7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLHNJQUEwQjtBQUNqRCxhQUFhLG1CQUFPLENBQUMsa0lBQXdCO0FBQzdDLGVBQWUsbUJBQU8sQ0FBQyxzSUFBMEI7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsNEJBQTRCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsNEJBQTRCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxzQkFBc0I7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsZ0NBQWdDO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRztBQUNqRztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQSxZQUFZLFVBQVUsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBLFlBQVksVUFBVSwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixnQ0FBZ0M7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0ZBQWtGLGdDQUFnQztBQUNsSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGludGVncmF0aW9uc1xcZXZlbnRGaWx0ZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IGludGVncmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZWdyYXRpb24uanMnKTtcbmNvbnN0IGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudFV0aWxzLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IG1pc2MgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9taXNjLmpzJyk7XG5jb25zdCBzdHJpbmcgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9zdHJpbmcuanMnKTtcblxuLy8gXCJTY3JpcHQgZXJyb3IuXCIgaXMgaGFyZCBjb2RlZCBpbnRvIGJyb3dzZXJzIGZvciBlcnJvcnMgdGhhdCBpdCBjYW4ndCByZWFkLlxuLy8gdGhpcyBpcyB0aGUgcmVzdWx0IG9mIGEgc2NyaXB0IGJlaW5nIHB1bGxlZCBpbiBmcm9tIGFuIGV4dGVybmFsIGRvbWFpbiBhbmQgQ09SUy5cbmNvbnN0IERFRkFVTFRfSUdOT1JFX0VSUk9SUyA9IFtcbiAgL15TY3JpcHQgZXJyb3JcXC4/JC8sXG4gIC9eSmF2YXNjcmlwdCBlcnJvcjogU2NyaXB0IGVycm9yXFwuPyBvbiBsaW5lIDAkLyxcbiAgL15SZXNpemVPYnNlcnZlciBsb29wIGNvbXBsZXRlZCB3aXRoIHVuZGVsaXZlcmVkIG5vdGlmaWNhdGlvbnMuJC8sIC8vIFRoZSBicm93c2VyIGxvZ3MgdGhpcyB3aGVuIGEgUmVzaXplT2JzZXJ2ZXIgaGFuZGxlciB0YWtlcyBhIGJpdCBsb25nZXIuIFVzdWFsbHkgdGhpcyBpcyBub3QgYW4gYWN0dWFsIGlzc3VlIHRob3VnaC4gSXQgaW5kaWNhdGVzIHNsb3duZXNzLlxuICAvXkNhbm5vdCByZWRlZmluZSBwcm9wZXJ0eTogZ29vZ2xldGFnJC8sIC8vIFRoaXMgaXMgdGhyb3duIHdoZW4gZ29vZ2xlIHRhZyBtYW5hZ2VyIGlzIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBhbiBhZCBibG9ja2VyXG4gIC9eQ2FuJ3QgZmluZCB2YXJpYWJsZTogZ21vJC8sIC8vIEVycm9yIGZyb20gR29vZ2xlIFNlYXJjaCBBcHAgaHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvMzk2MDQzMzMxXG4gIC9edW5kZWZpbmVkIGlzIG5vdCBhbiBvYmplY3QgXFwoZXZhbHVhdGluZyAnYVxcLltBLVpdJ1xcKSQvLCAvLyBSYW5kb20gZXJyb3IgdGhhdCBoYXBwZW5zIGJ1dCBub3QgYWN0aW9uYWJsZSBvciBub3RpY2VhYmxlIHRvIGVuZC11c2Vycy5cbiAgJ2NhblxcJ3QgcmVkZWZpbmUgbm9uLWNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSBcInNvbGFuYVwiJywgLy8gUHJvYmFibHkgYSBicm93c2VyIGV4dGVuc2lvbiBvciBjdXN0b20gYnJvd3NlciAoQnJhdmUpIHRocm93aW5nIHRoaXMgZXJyb3JcbiAgXCJ2digpLmdldFJlc3RyaWN0aW9ucyBpcyBub3QgYSBmdW5jdGlvbi4gKEluICd2digpLmdldFJlc3RyaWN0aW9ucygxLGEpJywgJ3Z2KCkuZ2V0UmVzdHJpY3Rpb25zJyBpcyB1bmRlZmluZWQpXCIsIC8vIEVycm9yIHRocm93biBieSBHVE0sIHNlZW1pbmdseSBub3QgYWZmZWN0aW5nIGVuZC11c2Vyc1xuICBcIkNhbid0IGZpbmQgdmFyaWFibGU6IF9BdXRvZmlsbENhbGxiYWNrSGFuZGxlclwiLCAvLyBVbmFjdGlvbmFibGUgZXJyb3IgaW4gaW5zdGFncmFtIHdlYnZpZXcgaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS9jb21tdW5pdHkvdGhyZWFkcy8zMjAwMTM1NDk3OTExNDEvXG4gIC9eTm9uLUVycm9yIHByb21pc2UgcmVqZWN0aW9uIGNhcHR1cmVkIHdpdGggdmFsdWU6IE9iamVjdCBOb3QgRm91bmQgTWF0Y2hpbmcgSWQ6XFxkKywgTWV0aG9kTmFtZTpzaW11bGF0ZUV2ZW50LCBQYXJhbUNvdW50OlxcZCskLywgLy8gdW5hY3Rpb25hYmxlIGVycm9yIGZyb20gQ0VGU2hhcnAsIGEgLk5FVCBsaWJyYXJ5IHRoYXQgZW1iZWRzIGNocm9taXVtIGluIC5ORVQgYXBwc1xuICAvXkphdmEgZXhjZXB0aW9uIHdhcyByYWlzZWQgZHVyaW5nIG1ldGhvZCBpbnZvY2F0aW9uJC8sIC8vIGVycm9yIGZyb20gRmFjZWJvb2sgTW9iaWxlIGJyb3dzZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzE1MDY1KVxuXTtcblxuLyoqIE9wdGlvbnMgZm9yIHRoZSBFdmVudEZpbHRlcnMgaW50ZWdyYXRpb24gKi9cblxuY29uc3QgSU5URUdSQVRJT05fTkFNRSA9ICdFdmVudEZpbHRlcnMnO1xuXG4vKipcbiAqIEFuIGludGVncmF0aW9uIHRoYXQgZmlsdGVycyBvdXQgZXZlbnRzIChlcnJvcnMgYW5kIHRyYW5zYWN0aW9ucykgYmFzZWQgb246XG4gKlxuICogLSAoRXJyb3JzKSBBIGN1cmF0ZWQgbGlzdCBvZiBrbm93biBsb3ctdmFsdWUgb3IgaXJyZWxldmFudCBlcnJvcnMgKHNlZSB7QGxpbmsgREVGQVVMVF9JR05PUkVfRVJST1JTfSlcbiAqIC0gKEVycm9ycykgQSBsaXN0IG9mIGVycm9yIG1lc3NhZ2VzIG9yIHVybHMvZmlsZW5hbWVzIHBhc3NlZCBpbiB2aWFcbiAqICAgLSBUb3AgbGV2ZWwgU2VudHJ5LmluaXQgb3B0aW9ucyAoYGlnbm9yZUVycm9yc2AsIGBkZW55VXJsc2AsIGBhbGxvd1VybHNgKVxuICogICAtIFRoZSBzYW1lIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBpbnRlZ3JhdGlvbiBkaXJlY3RseSB2aWEgQHBhcmFtIG9wdGlvbnNcbiAqIC0gKFRyYW5zYWN0aW9ucy9TcGFucykgQSBsaXN0IG9mIHJvb3Qgc3BhbiAodHJhbnNhY3Rpb24pIG5hbWVzIHBhc3NlZCBpbiB2aWFcbiAqICAgLSBUb3AgbGV2ZWwgU2VudHJ5LmluaXQgb3B0aW9uIChgaWdub3JlVHJhbnNhY3Rpb25zYClcbiAqICAgLSBUaGUgc2FtZSBvcHRpb24gcGFzc2VkIHRvIHRoZSBpbnRlZ3JhdGlvbiBkaXJlY3RseSB2aWEgQHBhcmFtIG9wdGlvbnNcbiAqXG4gKiBFdmVudHMgZmlsdGVyZWQgYnkgdGhpcyBpbnRlZ3JhdGlvbiB3aWxsIG5vdCBiZSBzZW50IHRvIFNlbnRyeS5cbiAqL1xuY29uc3QgZXZlbnRGaWx0ZXJzSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbigob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGxldCBtZXJnZWRPcHRpb25zO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IElOVEVHUkFUSU9OX05BTUUsXG4gICAgc2V0dXAoY2xpZW50KSB7XG4gICAgICBjb25zdCBjbGllbnRPcHRpb25zID0gY2xpZW50LmdldE9wdGlvbnMoKTtcbiAgICAgIG1lcmdlZE9wdGlvbnMgPSBfbWVyZ2VPcHRpb25zKG9wdGlvbnMsIGNsaWVudE9wdGlvbnMpO1xuICAgIH0sXG4gICAgcHJvY2Vzc0V2ZW50KGV2ZW50LCBfaGludCwgY2xpZW50KSB7XG4gICAgICBpZiAoIW1lcmdlZE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50T3B0aW9ucyA9IGNsaWVudC5nZXRPcHRpb25zKCk7XG4gICAgICAgIG1lcmdlZE9wdGlvbnMgPSBfbWVyZ2VPcHRpb25zKG9wdGlvbnMsIGNsaWVudE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9zaG91bGREcm9wRXZlbnQoZXZlbnQsIG1lcmdlZE9wdGlvbnMpID8gbnVsbCA6IGV2ZW50O1xuICAgIH0sXG4gIH07XG59KTtcblxuLyoqXG4gKiBBbiBpbnRlZ3JhdGlvbiB0aGF0IGZpbHRlcnMgb3V0IGV2ZW50cyAoZXJyb3JzIGFuZCB0cmFuc2FjdGlvbnMpIGJhc2VkIG9uOlxuICpcbiAqIC0gKEVycm9ycykgQSBjdXJhdGVkIGxpc3Qgb2Yga25vd24gbG93LXZhbHVlIG9yIGlycmVsZXZhbnQgZXJyb3JzIChzZWUge0BsaW5rIERFRkFVTFRfSUdOT1JFX0VSUk9SU30pXG4gKiAtIChFcnJvcnMpIEEgbGlzdCBvZiBlcnJvciBtZXNzYWdlcyBvciB1cmxzL2ZpbGVuYW1lcyBwYXNzZWQgaW4gdmlhXG4gKiAgIC0gVG9wIGxldmVsIFNlbnRyeS5pbml0IG9wdGlvbnMgKGBpZ25vcmVFcnJvcnNgLCBgZGVueVVybHNgLCBgYWxsb3dVcmxzYClcbiAqICAgLSBUaGUgc2FtZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgaW50ZWdyYXRpb24gZGlyZWN0bHkgdmlhIEBwYXJhbSBvcHRpb25zXG4gKiAtIChUcmFuc2FjdGlvbnMvU3BhbnMpIEEgbGlzdCBvZiByb290IHNwYW4gKHRyYW5zYWN0aW9uKSBuYW1lcyBwYXNzZWQgaW4gdmlhXG4gKiAgIC0gVG9wIGxldmVsIFNlbnRyeS5pbml0IG9wdGlvbiAoYGlnbm9yZVRyYW5zYWN0aW9uc2ApXG4gKiAgIC0gVGhlIHNhbWUgb3B0aW9uIHBhc3NlZCB0byB0aGUgaW50ZWdyYXRpb24gZGlyZWN0bHkgdmlhIEBwYXJhbSBvcHRpb25zXG4gKlxuICogRXZlbnRzIGZpbHRlcmVkIGJ5IHRoaXMgaW50ZWdyYXRpb24gd2lsbCBub3QgYmUgc2VudCB0byBTZW50cnkuXG4gKlxuICogQGRlcHJlY2F0ZWQgdGhpcyBpbnRlZ3JhdGlvbiB3YXMgcmVuYW1lZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHZlcnNpb24uXG4gKiBVc2UgYGV2ZW50RmlsdGVyc0ludGVncmF0aW9uYCBpbnN0ZWFkLlxuICovXG5jb25zdCBpbmJvdW5kRmlsdGVyc0ludGVncmF0aW9uID0gaW50ZWdyYXRpb24uZGVmaW5lSW50ZWdyYXRpb24oKChvcHRpb25zID0ge30pID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5ldmVudEZpbHRlcnNJbnRlZ3JhdGlvbihvcHRpb25zKSxcbiAgICBuYW1lOiAnSW5ib3VuZEZpbHRlcnMnLFxuICB9O1xufSkgKTtcblxuZnVuY3Rpb24gX21lcmdlT3B0aW9ucyhcbiAgaW50ZXJuYWxPcHRpb25zID0ge30sXG4gIGNsaWVudE9wdGlvbnMgPSB7fSxcbikge1xuICByZXR1cm4ge1xuICAgIGFsbG93VXJsczogWy4uLihpbnRlcm5hbE9wdGlvbnMuYWxsb3dVcmxzIHx8IFtdKSwgLi4uKGNsaWVudE9wdGlvbnMuYWxsb3dVcmxzIHx8IFtdKV0sXG4gICAgZGVueVVybHM6IFsuLi4oaW50ZXJuYWxPcHRpb25zLmRlbnlVcmxzIHx8IFtdKSwgLi4uKGNsaWVudE9wdGlvbnMuZGVueVVybHMgfHwgW10pXSxcbiAgICBpZ25vcmVFcnJvcnM6IFtcbiAgICAgIC4uLihpbnRlcm5hbE9wdGlvbnMuaWdub3JlRXJyb3JzIHx8IFtdKSxcbiAgICAgIC4uLihjbGllbnRPcHRpb25zLmlnbm9yZUVycm9ycyB8fCBbXSksXG4gICAgICAuLi4oaW50ZXJuYWxPcHRpb25zLmRpc2FibGVFcnJvckRlZmF1bHRzID8gW10gOiBERUZBVUxUX0lHTk9SRV9FUlJPUlMpLFxuICAgIF0sXG4gICAgaWdub3JlVHJhbnNhY3Rpb25zOiBbLi4uKGludGVybmFsT3B0aW9ucy5pZ25vcmVUcmFuc2FjdGlvbnMgfHwgW10pLCAuLi4oY2xpZW50T3B0aW9ucy5pZ25vcmVUcmFuc2FjdGlvbnMgfHwgW10pXSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Nob3VsZERyb3BFdmVudChldmVudCwgb3B0aW9ucykge1xuICBpZiAoIWV2ZW50LnR5cGUpIHtcbiAgICAvLyBGaWx0ZXIgZXJyb3JzXG4gICAgaWYgKF9pc0lnbm9yZWRFcnJvcihldmVudCwgb3B0aW9ucy5pZ25vcmVFcnJvcnMpKSB7XG4gICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmXG4gICAgICAgIGxvZ2dlci5sb2dnZXIud2FybihcbiAgICAgICAgICBgRXZlbnQgZHJvcHBlZCBkdWUgdG8gYmVpbmcgbWF0Y2hlZCBieSBcXGBpZ25vcmVFcnJvcnNcXGAgb3B0aW9uLlxcbkV2ZW50OiAke21pc2MuZ2V0RXZlbnREZXNjcmlwdGlvbihldmVudCl9YCxcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoX2lzVXNlbGVzc0Vycm9yKGV2ZW50KSkge1xuICAgICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJlxuICAgICAgICBsb2dnZXIubG9nZ2VyLndhcm4oXG4gICAgICAgICAgYEV2ZW50IGRyb3BwZWQgZHVlIHRvIG5vdCBoYXZpbmcgYW4gZXJyb3IgbWVzc2FnZSwgZXJyb3IgdHlwZSBvciBzdGFja3RyYWNlLlxcbkV2ZW50OiAke21pc2MuZ2V0RXZlbnREZXNjcmlwdGlvbihcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoX2lzRGVuaWVkVXJsKGV2ZW50LCBvcHRpb25zLmRlbnlVcmxzKSkge1xuICAgICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJlxuICAgICAgICBsb2dnZXIubG9nZ2VyLndhcm4oXG4gICAgICAgICAgYEV2ZW50IGRyb3BwZWQgZHVlIHRvIGJlaW5nIG1hdGNoZWQgYnkgXFxgZGVueVVybHNcXGAgb3B0aW9uLlxcbkV2ZW50OiAke21pc2MuZ2V0RXZlbnREZXNjcmlwdGlvbihcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICl9LlxcblVybDogJHtfZ2V0RXZlbnRGaWx0ZXJVcmwoZXZlbnQpfWAsXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFfaXNBbGxvd2VkVXJsKGV2ZW50LCBvcHRpb25zLmFsbG93VXJscykpIHtcbiAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiZcbiAgICAgICAgbG9nZ2VyLmxvZ2dlci53YXJuKFxuICAgICAgICAgIGBFdmVudCBkcm9wcGVkIGR1ZSB0byBub3QgYmVpbmcgbWF0Y2hlZCBieSBcXGBhbGxvd1VybHNcXGAgb3B0aW9uLlxcbkV2ZW50OiAke21pc2MuZ2V0RXZlbnREZXNjcmlwdGlvbihcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICl9LlxcblVybDogJHtfZ2V0RXZlbnRGaWx0ZXJVcmwoZXZlbnQpfWAsXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3RyYW5zYWN0aW9uJykge1xuICAgIC8vIEZpbHRlciB0cmFuc2FjdGlvbnNcblxuICAgIGlmIChfaXNJZ25vcmVkVHJhbnNhY3Rpb24oZXZlbnQsIG9wdGlvbnMuaWdub3JlVHJhbnNhY3Rpb25zKSkge1xuICAgICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJlxuICAgICAgICBsb2dnZXIubG9nZ2VyLndhcm4oXG4gICAgICAgICAgYEV2ZW50IGRyb3BwZWQgZHVlIHRvIGJlaW5nIG1hdGNoZWQgYnkgXFxgaWdub3JlVHJhbnNhY3Rpb25zXFxgIG9wdGlvbi5cXG5FdmVudDogJHttaXNjLmdldEV2ZW50RGVzY3JpcHRpb24oZXZlbnQpfWAsXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfaXNJZ25vcmVkRXJyb3IoZXZlbnQsIGlnbm9yZUVycm9ycykge1xuICBpZiAoIWlnbm9yZUVycm9ycz8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50VXRpbHMuZ2V0UG9zc2libGVFdmVudE1lc3NhZ2VzKGV2ZW50KS5zb21lKG1lc3NhZ2UgPT4gc3RyaW5nLnN0cmluZ01hdGNoZXNTb21lUGF0dGVybihtZXNzYWdlLCBpZ25vcmVFcnJvcnMpKTtcbn1cblxuZnVuY3Rpb24gX2lzSWdub3JlZFRyYW5zYWN0aW9uKGV2ZW50LCBpZ25vcmVUcmFuc2FjdGlvbnMpIHtcbiAgaWYgKCFpZ25vcmVUcmFuc2FjdGlvbnM/Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSBldmVudC50cmFuc2FjdGlvbjtcbiAgcmV0dXJuIG5hbWUgPyBzdHJpbmcuc3RyaW5nTWF0Y2hlc1NvbWVQYXR0ZXJuKG5hbWUsIGlnbm9yZVRyYW5zYWN0aW9ucykgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX2lzRGVuaWVkVXJsKGV2ZW50LCBkZW55VXJscykge1xuICBpZiAoIWRlbnlVcmxzPy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdXJsID0gX2dldEV2ZW50RmlsdGVyVXJsKGV2ZW50KTtcbiAgcmV0dXJuICF1cmwgPyBmYWxzZSA6IHN0cmluZy5zdHJpbmdNYXRjaGVzU29tZVBhdHRlcm4odXJsLCBkZW55VXJscyk7XG59XG5cbmZ1bmN0aW9uIF9pc0FsbG93ZWRVcmwoZXZlbnQsIGFsbG93VXJscykge1xuICBpZiAoIWFsbG93VXJscz8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgdXJsID0gX2dldEV2ZW50RmlsdGVyVXJsKGV2ZW50KTtcbiAgcmV0dXJuICF1cmwgPyB0cnVlIDogc3RyaW5nLnN0cmluZ01hdGNoZXNTb21lUGF0dGVybih1cmwsIGFsbG93VXJscyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRMYXN0VmFsaWRVcmwoZnJhbWVzID0gW10pIHtcbiAgZm9yIChsZXQgaSA9IGZyYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzW2ldO1xuXG4gICAgaWYgKGZyYW1lICYmIGZyYW1lLmZpbGVuYW1lICE9PSAnPGFub255bW91cz4nICYmIGZyYW1lLmZpbGVuYW1lICE9PSAnW25hdGl2ZSBjb2RlXScpIHtcbiAgICAgIHJldHVybiBmcmFtZS5maWxlbmFtZSB8fCBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBfZ2V0RXZlbnRGaWx0ZXJVcmwoZXZlbnQpIHtcbiAgdHJ5IHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbGlua2VkIGV4Y2VwdGlvbnMgb3IgZXhjZXB0aW9uIGFnZ3JlZ2F0ZXMgd2Ugb25seSB3YW50IHRvIG1hdGNoIGFnYWluc3QgdGhlIHRvcCBmcmFtZSBvZiB0aGUgXCJyb290XCIgKHRoZSBtYWluIGV4Y2VwdGlvbilcbiAgICAvLyBUaGUgcm9vdCBhbHdheXMgY29tZXMgbGFzdCBpbiBsaW5rZWQgZXhjZXB0aW9uc1xuICAgIGNvbnN0IHJvb3RFeGNlcHRpb24gPSBbLi4uKGV2ZW50LmV4Y2VwdGlvbj8udmFsdWVzID8/IFtdKV1cbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maW5kKHZhbHVlID0+IHZhbHVlLm1lY2hhbmlzbT8ucGFyZW50X2lkID09PSB1bmRlZmluZWQgJiYgdmFsdWUuc3RhY2t0cmFjZT8uZnJhbWVzPy5sZW5ndGgpO1xuICAgIGNvbnN0IGZyYW1lcyA9IHJvb3RFeGNlcHRpb24/LnN0YWNrdHJhY2U/LmZyYW1lcztcbiAgICByZXR1cm4gZnJhbWVzID8gX2dldExhc3RWYWxpZFVybChmcmFtZXMpIDogbnVsbDtcbiAgfSBjYXRjaCAob08pIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIuZXJyb3IoYENhbm5vdCBleHRyYWN0IHVybCBmb3IgZXZlbnQgJHttaXNjLmdldEV2ZW50RGVzY3JpcHRpb24oZXZlbnQpfWApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pc1VzZWxlc3NFcnJvcihldmVudCkge1xuICAvLyBXZSBvbmx5IHdhbnQgdG8gY29uc2lkZXIgZXZlbnRzIGZvciBkcm9wcGluZyB0aGF0IGFjdHVhbGx5IGhhdmUgcmVjb3JkZWQgZXhjZXB0aW9uIHZhbHVlcy5cbiAgaWYgKCFldmVudC5leGNlcHRpb24/LnZhbHVlcz8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICAvLyBObyB0b3AtbGV2ZWwgbWVzc2FnZVxuICAgICFldmVudC5tZXNzYWdlICYmXG4gICAgLy8gVGhlcmUgYXJlIG5vIGV4Y2VwdGlvbiB2YWx1ZXMgdGhhdCBoYXZlIGEgc3RhY2t0cmFjZSwgYSBub24tZ2VuZXJpYy1FcnJvciB0eXBlIG9yIHZhbHVlXG4gICAgIWV2ZW50LmV4Y2VwdGlvbi52YWx1ZXMuc29tZSh2YWx1ZSA9PiB2YWx1ZS5zdGFja3RyYWNlIHx8ICh2YWx1ZS50eXBlICYmIHZhbHVlLnR5cGUgIT09ICdFcnJvcicpIHx8IHZhbHVlLnZhbHVlKVxuICApO1xufVxuXG5leHBvcnRzLmV2ZW50RmlsdGVyc0ludGVncmF0aW9uID0gZXZlbnRGaWx0ZXJzSW50ZWdyYXRpb247XG5leHBvcnRzLmluYm91bmRGaWx0ZXJzSW50ZWdyYXRpb24gPSBpbmJvdW5kRmlsdGVyc0ludGVncmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRGaWx0ZXJzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/eventFilters.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/extraerrordata.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js\");\nconst is = __webpack_require__(/*! ../utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst normalize = __webpack_require__(/*! ../utils-hoist/normalize.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/normalize.js\");\nconst object = __webpack_require__(/*! ../utils-hoist/object.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/object.js\");\nconst string = __webpack_require__(/*! ../utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\n\nconst INTEGRATION_NAME = 'ExtraErrorData';\n\n/**\n * Extract additional data for from original exceptions.\n */\nconst _extraErrorDataIntegration = ((options = {}) => {\n  const { depth = 3, captureErrorCause = true } = options;\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(event, hint, client) {\n      const { maxValueLength = 250 } = client.getOptions();\n      return _enhanceEventWithErrorData(event, hint, depth, captureErrorCause, maxValueLength);\n    },\n  };\n}) ;\n\nconst extraErrorDataIntegration = integration.defineIntegration(_extraErrorDataIntegration);\n\nfunction _enhanceEventWithErrorData(\n  event,\n  hint = {},\n  depth,\n  captureErrorCause,\n  maxValueLength,\n) {\n  if (!hint.originalException || !is.isError(hint.originalException)) {\n    return event;\n  }\n  const exceptionName = (hint.originalException ).name || hint.originalException.constructor.name;\n\n  const errorData = _extractErrorData(hint.originalException , captureErrorCause, maxValueLength);\n\n  if (errorData) {\n    const contexts = {\n      ...event.contexts,\n    };\n\n    const normalizedErrorData = normalize.normalize(errorData, depth);\n\n    if (is.isPlainObject(normalizedErrorData)) {\n      // We mark the error data as \"already normalized\" here, because we don't want other normalization procedures to\n      // potentially truncate the data we just already normalized, with a certain depth setting.\n      object.addNonEnumerableProperty(normalizedErrorData, '__sentry_skip_normalization__', true);\n      contexts[exceptionName] = normalizedErrorData;\n    }\n\n    return {\n      ...event,\n      contexts,\n    };\n  }\n\n  return event;\n}\n\n/**\n * Extract extra information from the Error object\n */\nfunction _extractErrorData(\n  error,\n  captureErrorCause,\n  maxValueLength,\n) {\n  // We are trying to enhance already existing event, so no harm done if it won't succeed\n  try {\n    const nativeKeys = [\n      'name',\n      'message',\n      'stack',\n      'line',\n      'column',\n      'fileName',\n      'lineNumber',\n      'columnNumber',\n      'toJSON',\n    ];\n\n    const extraErrorInfo = {};\n\n    // We want only enumerable properties, thus `getOwnPropertyNames` is redundant here, as we filter keys anyway.\n    for (const key of Object.keys(error)) {\n      if (nativeKeys.indexOf(key) !== -1) {\n        continue;\n      }\n      const value = error[key];\n      extraErrorInfo[key] = is.isError(value) || typeof value === 'string' ? string.truncate(`${value}`, maxValueLength) : value;\n    }\n\n    // Error.cause is a standard property that is non enumerable, we therefore need to access it separately.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause\n    if (captureErrorCause && error.cause !== undefined) {\n      extraErrorInfo.cause = is.isError(error.cause) ? error.cause.toString() : error.cause;\n    }\n\n    // Check if someone attached `toJSON` method to grab even more properties (eg. axios is doing that)\n    if (typeof error.toJSON === 'function') {\n      const serializedError = error.toJSON() ;\n\n      for (const key of Object.keys(serializedError)) {\n        const value = serializedError[key];\n        extraErrorInfo[key] = is.isError(value) ? value.toString() : value;\n      }\n    }\n\n    return extraErrorInfo;\n  } catch (oO) {\n    debugBuild.DEBUG_BUILD && logger.logger.error('Unable to extract extra data from the Error object:', oO);\n  }\n\n  return null;\n}\n\nexports.extraErrorDataIntegration = extraErrorDataIntegration;\n//# sourceMappingURL=extraerrordata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9ucy9leHRyYWVycm9yZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxtQkFBbUIsbUJBQU8sQ0FBQyx3SEFBbUI7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsd0hBQW1CO0FBQy9DLFdBQVcsbUJBQU8sQ0FBQyw4SEFBc0I7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHNJQUEwQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyw0SUFBNkI7QUFDdkQsZUFBZSxtQkFBTyxDQUFDLHNJQUEwQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsc0lBQTBCOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsVUFBVSxzQ0FBc0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csTUFBTTtBQUN0Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcaW50ZWdyYXRpb25zXFxleHRyYWVycm9yZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgZGVidWdCdWlsZCA9IHJlcXVpcmUoJy4uL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBpbnRlZ3JhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVncmF0aW9uLmpzJyk7XG5jb25zdCBpcyA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2lzLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IG5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L25vcm1hbGl6ZS5qcycpO1xuY29uc3Qgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvb2JqZWN0LmpzJyk7XG5jb25zdCBzdHJpbmcgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9zdHJpbmcuanMnKTtcblxuY29uc3QgSU5URUdSQVRJT05fTkFNRSA9ICdFeHRyYUVycm9yRGF0YSc7XG5cbi8qKlxuICogRXh0cmFjdCBhZGRpdGlvbmFsIGRhdGEgZm9yIGZyb20gb3JpZ2luYWwgZXhjZXB0aW9ucy5cbiAqL1xuY29uc3QgX2V4dHJhRXJyb3JEYXRhSW50ZWdyYXRpb24gPSAoKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7IGRlcHRoID0gMywgY2FwdHVyZUVycm9yQ2F1c2UgPSB0cnVlIH0gPSBvcHRpb25zO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IElOVEVHUkFUSU9OX05BTUUsXG4gICAgcHJvY2Vzc0V2ZW50KGV2ZW50LCBoaW50LCBjbGllbnQpIHtcbiAgICAgIGNvbnN0IHsgbWF4VmFsdWVMZW5ndGggPSAyNTAgfSA9IGNsaWVudC5nZXRPcHRpb25zKCk7XG4gICAgICByZXR1cm4gX2VuaGFuY2VFdmVudFdpdGhFcnJvckRhdGEoZXZlbnQsIGhpbnQsIGRlcHRoLCBjYXB0dXJlRXJyb3JDYXVzZSwgbWF4VmFsdWVMZW5ndGgpO1xuICAgIH0sXG4gIH07XG59KSA7XG5cbmNvbnN0IGV4dHJhRXJyb3JEYXRhSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbihfZXh0cmFFcnJvckRhdGFJbnRlZ3JhdGlvbik7XG5cbmZ1bmN0aW9uIF9lbmhhbmNlRXZlbnRXaXRoRXJyb3JEYXRhKFxuICBldmVudCxcbiAgaGludCA9IHt9LFxuICBkZXB0aCxcbiAgY2FwdHVyZUVycm9yQ2F1c2UsXG4gIG1heFZhbHVlTGVuZ3RoLFxuKSB7XG4gIGlmICghaGludC5vcmlnaW5hbEV4Y2VwdGlvbiB8fCAhaXMuaXNFcnJvcihoaW50Lm9yaWdpbmFsRXhjZXB0aW9uKSkge1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBjb25zdCBleGNlcHRpb25OYW1lID0gKGhpbnQub3JpZ2luYWxFeGNlcHRpb24gKS5uYW1lIHx8IGhpbnQub3JpZ2luYWxFeGNlcHRpb24uY29uc3RydWN0b3IubmFtZTtcblxuICBjb25zdCBlcnJvckRhdGEgPSBfZXh0cmFjdEVycm9yRGF0YShoaW50Lm9yaWdpbmFsRXhjZXB0aW9uICwgY2FwdHVyZUVycm9yQ2F1c2UsIG1heFZhbHVlTGVuZ3RoKTtcblxuICBpZiAoZXJyb3JEYXRhKSB7XG4gICAgY29uc3QgY29udGV4dHMgPSB7XG4gICAgICAuLi5ldmVudC5jb250ZXh0cyxcbiAgICB9O1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZEVycm9yRGF0YSA9IG5vcm1hbGl6ZS5ub3JtYWxpemUoZXJyb3JEYXRhLCBkZXB0aCk7XG5cbiAgICBpZiAoaXMuaXNQbGFpbk9iamVjdChub3JtYWxpemVkRXJyb3JEYXRhKSkge1xuICAgICAgLy8gV2UgbWFyayB0aGUgZXJyb3IgZGF0YSBhcyBcImFscmVhZHkgbm9ybWFsaXplZFwiIGhlcmUsIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBvdGhlciBub3JtYWxpemF0aW9uIHByb2NlZHVyZXMgdG9cbiAgICAgIC8vIHBvdGVudGlhbGx5IHRydW5jYXRlIHRoZSBkYXRhIHdlIGp1c3QgYWxyZWFkeSBub3JtYWxpemVkLCB3aXRoIGEgY2VydGFpbiBkZXB0aCBzZXR0aW5nLlxuICAgICAgb2JqZWN0LmFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eShub3JtYWxpemVkRXJyb3JEYXRhLCAnX19zZW50cnlfc2tpcF9ub3JtYWxpemF0aW9uX18nLCB0cnVlKTtcbiAgICAgIGNvbnRleHRzW2V4Y2VwdGlvbk5hbWVdID0gbm9ybWFsaXplZEVycm9yRGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZXZlbnQsXG4gICAgICBjb250ZXh0cyxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEV4dHJhY3QgZXh0cmEgaW5mb3JtYXRpb24gZnJvbSB0aGUgRXJyb3Igb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIF9leHRyYWN0RXJyb3JEYXRhKFxuICBlcnJvcixcbiAgY2FwdHVyZUVycm9yQ2F1c2UsXG4gIG1heFZhbHVlTGVuZ3RoLFxuKSB7XG4gIC8vIFdlIGFyZSB0cnlpbmcgdG8gZW5oYW5jZSBhbHJlYWR5IGV4aXN0aW5nIGV2ZW50LCBzbyBubyBoYXJtIGRvbmUgaWYgaXQgd29uJ3Qgc3VjY2VlZFxuICB0cnkge1xuICAgIGNvbnN0IG5hdGl2ZUtleXMgPSBbXG4gICAgICAnbmFtZScsXG4gICAgICAnbWVzc2FnZScsXG4gICAgICAnc3RhY2snLFxuICAgICAgJ2xpbmUnLFxuICAgICAgJ2NvbHVtbicsXG4gICAgICAnZmlsZU5hbWUnLFxuICAgICAgJ2xpbmVOdW1iZXInLFxuICAgICAgJ2NvbHVtbk51bWJlcicsXG4gICAgICAndG9KU09OJyxcbiAgICBdO1xuXG4gICAgY29uc3QgZXh0cmFFcnJvckluZm8gPSB7fTtcblxuICAgIC8vIFdlIHdhbnQgb25seSBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIHRodXMgYGdldE93blByb3BlcnR5TmFtZXNgIGlzIHJlZHVuZGFudCBoZXJlLCBhcyB3ZSBmaWx0ZXIga2V5cyBhbnl3YXkuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZXJyb3IpKSB7XG4gICAgICBpZiAobmF0aXZlS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBlcnJvcltrZXldO1xuICAgICAgZXh0cmFFcnJvckluZm9ba2V5XSA9IGlzLmlzRXJyb3IodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBzdHJpbmcudHJ1bmNhdGUoYCR7dmFsdWV9YCwgbWF4VmFsdWVMZW5ndGgpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gRXJyb3IuY2F1c2UgaXMgYSBzdGFuZGFyZCBwcm9wZXJ0eSB0aGF0IGlzIG5vbiBlbnVtZXJhYmxlLCB3ZSB0aGVyZWZvcmUgbmVlZCB0byBhY2Nlc3MgaXQgc2VwYXJhdGVseS5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvci9jYXVzZVxuICAgIGlmIChjYXB0dXJlRXJyb3JDYXVzZSAmJiBlcnJvci5jYXVzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBleHRyYUVycm9ySW5mby5jYXVzZSA9IGlzLmlzRXJyb3IoZXJyb3IuY2F1c2UpID8gZXJyb3IuY2F1c2UudG9TdHJpbmcoKSA6IGVycm9yLmNhdXNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHNvbWVvbmUgYXR0YWNoZWQgYHRvSlNPTmAgbWV0aG9kIHRvIGdyYWIgZXZlbiBtb3JlIHByb3BlcnRpZXMgKGVnLiBheGlvcyBpcyBkb2luZyB0aGF0KVxuICAgIGlmICh0eXBlb2YgZXJyb3IudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkRXJyb3IgPSBlcnJvci50b0pTT04oKSA7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNlcmlhbGl6ZWRFcnJvcikpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzZXJpYWxpemVkRXJyb3Jba2V5XTtcbiAgICAgICAgZXh0cmFFcnJvckluZm9ba2V5XSA9IGlzLmlzRXJyb3IodmFsdWUpID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHRyYUVycm9ySW5mbztcbiAgfSBjYXRjaCAob08pIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIuZXJyb3IoJ1VuYWJsZSB0byBleHRyYWN0IGV4dHJhIGRhdGEgZnJvbSB0aGUgRXJyb3Igb2JqZWN0OicsIG9PKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLmV4dHJhRXJyb3JEYXRhSW50ZWdyYXRpb24gPSBleHRyYUVycm9yRGF0YUludGVncmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFlcnJvcmRhdGEuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/extraerrordata.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/functiontostring.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js");\nconst integration = __webpack_require__(/*! ../integration.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js");\nconst object = __webpack_require__(/*! ../utils-hoist/object.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/object.js");\n\nlet originalFunctionToString;\n\nconst INTEGRATION_NAME = \'FunctionToString\';\n\nconst SETUP_CLIENTS = new WeakMap();\n\nconst _functionToStringIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      originalFunctionToString = Function.prototype.toString;\n\n      // intrinsics (like Function.prototype) might be immutable in some environments\n      // e.g. Node with --frozen-intrinsics, XS (an embedded JavaScript engine) or SES (a JavaScript proposal)\n      try {\n        Function.prototype.toString = function ( ...args) {\n          const originalFunction = object.getOriginalFunction(this);\n          const context =\n            SETUP_CLIENTS.has(currentScopes.getClient() ) && originalFunction !== undefined ? originalFunction : this;\n          return originalFunctionToString.apply(context, args);\n        };\n      } catch {\n        // ignore errors here, just don\'t patch this\n      }\n    },\n    setup(client) {\n      SETUP_CLIENTS.set(client, true);\n    },\n  };\n}) ;\n\n/**\n * Patch toString calls to return proper name for wrapped functions.\n *\n * ```js\n * Sentry.init({\n *   integrations: [\n *     functionToStringIntegration(),\n *   ],\n * });\n * ```\n */\nconst functionToStringIntegration = integration.defineIntegration(_functionToStringIntegration);\n\nexports.functionToStringIntegration = functionToStringIntegration;\n//# sourceMappingURL=functiontostring.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9ucy9mdW5jdGlvbnRvc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLHNCQUFzQixtQkFBTyxDQUFDLDRIQUFxQjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyx3SEFBbUI7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLHNJQUEwQjs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxpbnRlZ3JhdGlvbnNcXGZ1bmN0aW9udG9zdHJpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBpbnRlZ3JhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVncmF0aW9uLmpzJyk7XG5jb25zdCBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9vYmplY3QuanMnKTtcblxubGV0IG9yaWdpbmFsRnVuY3Rpb25Ub1N0cmluZztcblxuY29uc3QgSU5URUdSQVRJT05fTkFNRSA9ICdGdW5jdGlvblRvU3RyaW5nJztcblxuY29uc3QgU0VUVVBfQ0xJRU5UUyA9IG5ldyBXZWFrTWFwKCk7XG5cbmNvbnN0IF9mdW5jdGlvblRvU3RyaW5nSW50ZWdyYXRpb24gPSAoKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IElOVEVHUkFUSU9OX05BTUUsXG4gICAgc2V0dXBPbmNlKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgb3JpZ2luYWxGdW5jdGlvblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgICAvLyBpbnRyaW5zaWNzIChsaWtlIEZ1bmN0aW9uLnByb3RvdHlwZSkgbWlnaHQgYmUgaW1tdXRhYmxlIGluIHNvbWUgZW52aXJvbm1lbnRzXG4gICAgICAvLyBlLmcuIE5vZGUgd2l0aCAtLWZyb3plbi1pbnRyaW5zaWNzLCBYUyAoYW4gZW1iZWRkZWQgSmF2YVNjcmlwdCBlbmdpbmUpIG9yIFNFUyAoYSBKYXZhU2NyaXB0IHByb3Bvc2FsKVxuICAgICAgdHJ5IHtcbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCAuLi5hcmdzKSB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxGdW5jdGlvbiA9IG9iamVjdC5nZXRPcmlnaW5hbEZ1bmN0aW9uKHRoaXMpO1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPVxuICAgICAgICAgICAgU0VUVVBfQ0xJRU5UUy5oYXMoY3VycmVudFNjb3Blcy5nZXRDbGllbnQoKSApICYmIG9yaWdpbmFsRnVuY3Rpb24gIT09IHVuZGVmaW5lZCA/IG9yaWdpbmFsRnVuY3Rpb24gOiB0aGlzO1xuICAgICAgICAgIHJldHVybiBvcmlnaW5hbEZ1bmN0aW9uVG9TdHJpbmcuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gaWdub3JlIGVycm9ycyBoZXJlLCBqdXN0IGRvbid0IHBhdGNoIHRoaXNcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldHVwKGNsaWVudCkge1xuICAgICAgU0VUVVBfQ0xJRU5UUy5zZXQoY2xpZW50LCB0cnVlKTtcbiAgICB9LFxuICB9O1xufSkgO1xuXG4vKipcbiAqIFBhdGNoIHRvU3RyaW5nIGNhbGxzIHRvIHJldHVybiBwcm9wZXIgbmFtZSBmb3Igd3JhcHBlZCBmdW5jdGlvbnMuXG4gKlxuICogYGBganNcbiAqIFNlbnRyeS5pbml0KHtcbiAqICAgaW50ZWdyYXRpb25zOiBbXG4gKiAgICAgZnVuY3Rpb25Ub1N0cmluZ0ludGVncmF0aW9uKCksXG4gKiAgIF0sXG4gKiB9KTtcbiAqIGBgYFxuICovXG5jb25zdCBmdW5jdGlvblRvU3RyaW5nSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbihfZnVuY3Rpb25Ub1N0cmluZ0ludGVncmF0aW9uKTtcblxuZXhwb3J0cy5mdW5jdGlvblRvU3RyaW5nSW50ZWdyYXRpb24gPSBmdW5jdGlvblRvU3RyaW5nSW50ZWdyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbnRvc3RyaW5nLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/functiontostring.js\n')},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/linkederrors.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js\");\nconst aggregateErrors = __webpack_require__(/*! ../utils-hoist/aggregate-errors.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/aggregate-errors.js\");\nconst eventbuilder = __webpack_require__(/*! ../utils-hoist/eventbuilder.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/eventbuilder.js\");\n\nconst DEFAULT_KEY = 'cause';\nconst DEFAULT_LIMIT = 5;\n\nconst INTEGRATION_NAME = 'LinkedErrors';\n\nconst _linkedErrorsIntegration = ((options = {}) => {\n  const limit = options.limit || DEFAULT_LIMIT;\n  const key = options.key || DEFAULT_KEY;\n\n  return {\n    name: INTEGRATION_NAME,\n    preprocessEvent(event, hint, client) {\n      const options = client.getOptions();\n\n      aggregateErrors.applyAggregateErrorsToEvent(eventbuilder.exceptionFromError, options.stackParser, key, limit, event, hint);\n    },\n  };\n}) ;\n\nconst linkedErrorsIntegration = integration.defineIntegration(_linkedErrorsIntegration);\n\nexports.linkedErrorsIntegration = linkedErrorsIntegration;\n//# sourceMappingURL=linkederrors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9ucy9saW5rZWRlcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsb0JBQW9CLG1CQUFPLENBQUMsd0hBQW1CO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLDBKQUFvQztBQUNwRSxxQkFBcUIsbUJBQU8sQ0FBQyxrSkFBZ0M7O0FBRTdEO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEOztBQUVBLCtCQUErQjtBQUMvQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxpbnRlZ3JhdGlvbnNcXGxpbmtlZGVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgaW50ZWdyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlZ3JhdGlvbi5qcycpO1xuY29uc3QgYWdncmVnYXRlRXJyb3JzID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvYWdncmVnYXRlLWVycm9ycy5qcycpO1xuY29uc3QgZXZlbnRidWlsZGVyID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvZXZlbnRidWlsZGVyLmpzJyk7XG5cbmNvbnN0IERFRkFVTFRfS0VZID0gJ2NhdXNlJztcbmNvbnN0IERFRkFVTFRfTElNSVQgPSA1O1xuXG5jb25zdCBJTlRFR1JBVElPTl9OQU1FID0gJ0xpbmtlZEVycm9ycyc7XG5cbmNvbnN0IF9saW5rZWRFcnJvcnNJbnRlZ3JhdGlvbiA9ICgob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5saW1pdCB8fCBERUZBVUxUX0xJTUlUO1xuICBjb25zdCBrZXkgPSBvcHRpb25zLmtleSB8fCBERUZBVUxUX0tFWTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IElOVEVHUkFUSU9OX05BTUUsXG4gICAgcHJlcHJvY2Vzc0V2ZW50KGV2ZW50LCBoaW50LCBjbGllbnQpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBjbGllbnQuZ2V0T3B0aW9ucygpO1xuXG4gICAgICBhZ2dyZWdhdGVFcnJvcnMuYXBwbHlBZ2dyZWdhdGVFcnJvcnNUb0V2ZW50KGV2ZW50YnVpbGRlci5leGNlcHRpb25Gcm9tRXJyb3IsIG9wdGlvbnMuc3RhY2tQYXJzZXIsIGtleSwgbGltaXQsIGV2ZW50LCBoaW50KTtcbiAgICB9LFxuICB9O1xufSkgO1xuXG5jb25zdCBsaW5rZWRFcnJvcnNJbnRlZ3JhdGlvbiA9IGludGVncmF0aW9uLmRlZmluZUludGVncmF0aW9uKF9saW5rZWRFcnJvcnNJbnRlZ3JhdGlvbik7XG5cbmV4cG9ydHMubGlua2VkRXJyb3JzSW50ZWdyYXRpb24gPSBsaW5rZWRFcnJvcnNJbnRlZ3JhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmtlZGVycm9ycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/linkederrors.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/metadata.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js\");\nconst metadata = __webpack_require__(/*! ../metadata.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/metadata.js\");\nconst envelope = __webpack_require__(/*! ../utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\n\n/**\n * Adds module metadata to stack frames.\n *\n * Metadata can be injected by the Sentry bundler plugins using the `moduleMetadata` config option.\n *\n * When this integration is added, the metadata passed to the bundler plugin is added to the stack frames of all events\n * under the `module_metadata` property. This can be used to help in tagging or routing of events from different teams\n * our sources\n */\nconst moduleMetadataIntegration = integration.defineIntegration(() => {\n  return {\n    name: 'ModuleMetadata',\n    setup(client) {\n      // We need to strip metadata from stack frames before sending them to Sentry since these are client side only.\n      client.on('beforeEnvelope', envelope$1 => {\n        envelope.forEachEnvelopeItem(envelope$1, (item, type) => {\n          if (type === 'event') {\n            const event = Array.isArray(item) ? (item )[1] : undefined;\n\n            if (event) {\n              metadata.stripMetadataFromStackFrames(event);\n              item[1] = event;\n            }\n          }\n        });\n      });\n\n      client.on('applyFrameMetadata', event => {\n        // Only apply stack frame metadata to error events\n        if (event.type) {\n          return;\n        }\n\n        const stackParser = client.getOptions().stackParser;\n        metadata.addMetadataToStackFrames(stackParser, event);\n      });\n    },\n  };\n});\n\nexports.moduleMetadataIntegration = moduleMetadataIntegration;\n//# sourceMappingURL=metadata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9ucy9tZXRhZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxvQkFBb0IsbUJBQU8sQ0FBQyx3SEFBbUI7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsa0hBQWdCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDBJQUE0Qjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRCxpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcaW50ZWdyYXRpb25zXFxtZXRhZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgaW50ZWdyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlZ3JhdGlvbi5qcycpO1xuY29uc3QgbWV0YWRhdGEgPSByZXF1aXJlKCcuLi9tZXRhZGF0YS5qcycpO1xuY29uc3QgZW52ZWxvcGUgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9lbnZlbG9wZS5qcycpO1xuXG4vKipcbiAqIEFkZHMgbW9kdWxlIG1ldGFkYXRhIHRvIHN0YWNrIGZyYW1lcy5cbiAqXG4gKiBNZXRhZGF0YSBjYW4gYmUgaW5qZWN0ZWQgYnkgdGhlIFNlbnRyeSBidW5kbGVyIHBsdWdpbnMgdXNpbmcgdGhlIGBtb2R1bGVNZXRhZGF0YWAgY29uZmlnIG9wdGlvbi5cbiAqXG4gKiBXaGVuIHRoaXMgaW50ZWdyYXRpb24gaXMgYWRkZWQsIHRoZSBtZXRhZGF0YSBwYXNzZWQgdG8gdGhlIGJ1bmRsZXIgcGx1Z2luIGlzIGFkZGVkIHRvIHRoZSBzdGFjayBmcmFtZXMgb2YgYWxsIGV2ZW50c1xuICogdW5kZXIgdGhlIGBtb2R1bGVfbWV0YWRhdGFgIHByb3BlcnR5LiBUaGlzIGNhbiBiZSB1c2VkIHRvIGhlbHAgaW4gdGFnZ2luZyBvciByb3V0aW5nIG9mIGV2ZW50cyBmcm9tIGRpZmZlcmVudCB0ZWFtc1xuICogb3VyIHNvdXJjZXNcbiAqL1xuY29uc3QgbW9kdWxlTWV0YWRhdGFJbnRlZ3JhdGlvbiA9IGludGVncmF0aW9uLmRlZmluZUludGVncmF0aW9uKCgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnTW9kdWxlTWV0YWRhdGEnLFxuICAgIHNldHVwKGNsaWVudCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBzdHJpcCBtZXRhZGF0YSBmcm9tIHN0YWNrIGZyYW1lcyBiZWZvcmUgc2VuZGluZyB0aGVtIHRvIFNlbnRyeSBzaW5jZSB0aGVzZSBhcmUgY2xpZW50IHNpZGUgb25seS5cbiAgICAgIGNsaWVudC5vbignYmVmb3JlRW52ZWxvcGUnLCBlbnZlbG9wZSQxID0+IHtcbiAgICAgICAgZW52ZWxvcGUuZm9yRWFjaEVudmVsb3BlSXRlbShlbnZlbG9wZSQxLCAoaXRlbSwgdHlwZSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnZXZlbnQnKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyAoaXRlbSApWzFdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgbWV0YWRhdGEuc3RyaXBNZXRhZGF0YUZyb21TdGFja0ZyYW1lcyhldmVudCk7XG4gICAgICAgICAgICAgIGl0ZW1bMV0gPSBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNsaWVudC5vbignYXBwbHlGcmFtZU1ldGFkYXRhJywgZXZlbnQgPT4ge1xuICAgICAgICAvLyBPbmx5IGFwcGx5IHN0YWNrIGZyYW1lIG1ldGFkYXRhIHRvIGVycm9yIGV2ZW50c1xuICAgICAgICBpZiAoZXZlbnQudHlwZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YWNrUGFyc2VyID0gY2xpZW50LmdldE9wdGlvbnMoKS5zdGFja1BhcnNlcjtcbiAgICAgICAgbWV0YWRhdGEuYWRkTWV0YWRhdGFUb1N0YWNrRnJhbWVzKHN0YWNrUGFyc2VyLCBldmVudCk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9O1xufSk7XG5cbmV4cG9ydHMubW9kdWxlTWV0YWRhdGFJbnRlZ3JhdGlvbiA9IG1vZHVsZU1ldGFkYXRhSW50ZWdyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/metadata.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/requestdata.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst integration = __webpack_require__(/*! ../integration.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js");\nconst cookie = __webpack_require__(/*! ../utils/cookie.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/cookie.js");\nconst getIpAddress = __webpack_require__(/*! ../vendor/getIpAddress.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/vendor/getIpAddress.js");\n\n// TODO(v10): Change defaults based on `sendDefaultPii`\nconst DEFAULT_INCLUDE = {\n  cookies: true,\n  data: true,\n  headers: true,\n  query_string: true,\n  url: true,\n};\n\nconst INTEGRATION_NAME = \'RequestData\';\n\nconst _requestDataIntegration = ((options = {}) => {\n  const include = {\n    ...DEFAULT_INCLUDE,\n    ...options.include,\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(event, _hint, client) {\n      const { sdkProcessingMetadata = {} } = event;\n      const { normalizedRequest, ipAddress } = sdkProcessingMetadata;\n\n      const includeWithDefaultPiiApplied = {\n        ...include,\n        ip: include.ip ?? client.getOptions().sendDefaultPii,\n      };\n\n      if (normalizedRequest) {\n        addNormalizedRequestDataToEvent(event, normalizedRequest, { ipAddress }, includeWithDefaultPiiApplied);\n      }\n\n      return event;\n    },\n  };\n}) ;\n\n/**\n * Add data about a request to an event. Primarily for use in Node-based SDKs, but included in `@sentry/core`\n * so it can be used in cross-platform SDKs like `@sentry/nextjs`.\n */\nconst requestDataIntegration = integration.defineIntegration(_requestDataIntegration);\n\n/**\n * Add already normalized request data to an event.\n * This mutates the passed in event.\n */\nfunction addNormalizedRequestDataToEvent(\n  event,\n  req,\n  // Data that should not go into `event.request` but is somehow related to requests\n  additionalData,\n  include,\n) {\n  event.request = {\n    ...event.request,\n    ...extractNormalizedRequestData(req, include),\n  };\n\n  if (include.ip) {\n    const ip = (req.headers && getIpAddress.getClientIPAddress(req.headers)) || additionalData.ipAddress;\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip,\n      };\n    }\n  }\n}\n\nfunction extractNormalizedRequestData(\n  normalizedRequest,\n  include,\n) {\n  const requestData = {};\n  const headers = { ...normalizedRequest.headers };\n\n  if (include.headers) {\n    requestData.headers = headers;\n\n    // Remove the Cookie header in case cookie data should not be included in the event\n    if (!include.cookies) {\n      delete (headers ).cookie;\n    }\n\n    // Remove IP headers in case IP data should not be included in the event\n    if (!include.ip) {\n      getIpAddress.ipHeaderNames.forEach(ipHeaderName => {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete (headers )[ipHeaderName];\n      });\n    }\n  }\n\n  requestData.method = normalizedRequest.method;\n\n  if (include.url) {\n    requestData.url = normalizedRequest.url;\n  }\n\n  if (include.cookies) {\n    const cookies = normalizedRequest.cookies || (headers?.cookie ? cookie.parseCookie(headers.cookie) : undefined);\n    requestData.cookies = cookies || {};\n  }\n\n  if (include.query_string) {\n    requestData.query_string = normalizedRequest.query_string;\n  }\n\n  if (include.data) {\n    requestData.data = normalizedRequest.data;\n  }\n\n  return requestData;\n}\n\nexports.requestDataIntegration = requestDataIntegration;\n//# sourceMappingURL=requestdata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9ucy9yZXF1ZXN0ZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxvQkFBb0IsbUJBQU8sQ0FBQyx3SEFBbUI7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLDBIQUFvQjtBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyx3SUFBMkI7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDLGNBQWMsK0JBQStCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxpbnRlZ3JhdGlvbnNcXHJlcXVlc3RkYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBpbnRlZ3JhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVncmF0aW9uLmpzJyk7XG5jb25zdCBjb29raWUgPSByZXF1aXJlKCcuLi91dGlscy9jb29raWUuanMnKTtcbmNvbnN0IGdldElwQWRkcmVzcyA9IHJlcXVpcmUoJy4uL3ZlbmRvci9nZXRJcEFkZHJlc3MuanMnKTtcblxuLy8gVE9ETyh2MTApOiBDaGFuZ2UgZGVmYXVsdHMgYmFzZWQgb24gYHNlbmREZWZhdWx0UGlpYFxuY29uc3QgREVGQVVMVF9JTkNMVURFID0ge1xuICBjb29raWVzOiB0cnVlLFxuICBkYXRhOiB0cnVlLFxuICBoZWFkZXJzOiB0cnVlLFxuICBxdWVyeV9zdHJpbmc6IHRydWUsXG4gIHVybDogdHJ1ZSxcbn07XG5cbmNvbnN0IElOVEVHUkFUSU9OX05BTUUgPSAnUmVxdWVzdERhdGEnO1xuXG5jb25zdCBfcmVxdWVzdERhdGFJbnRlZ3JhdGlvbiA9ICgob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGluY2x1ZGUgPSB7XG4gICAgLi4uREVGQVVMVF9JTkNMVURFLFxuICAgIC4uLm9wdGlvbnMuaW5jbHVkZSxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IElOVEVHUkFUSU9OX05BTUUsXG4gICAgcHJvY2Vzc0V2ZW50KGV2ZW50LCBfaGludCwgY2xpZW50KSB7XG4gICAgICBjb25zdCB7IHNka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IHt9IH0gPSBldmVudDtcbiAgICAgIGNvbnN0IHsgbm9ybWFsaXplZFJlcXVlc3QsIGlwQWRkcmVzcyB9ID0gc2RrUHJvY2Vzc2luZ01ldGFkYXRhO1xuXG4gICAgICBjb25zdCBpbmNsdWRlV2l0aERlZmF1bHRQaWlBcHBsaWVkID0ge1xuICAgICAgICAuLi5pbmNsdWRlLFxuICAgICAgICBpcDogaW5jbHVkZS5pcCA/PyBjbGllbnQuZ2V0T3B0aW9ucygpLnNlbmREZWZhdWx0UGlpLFxuICAgICAgfTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWRSZXF1ZXN0KSB7XG4gICAgICAgIGFkZE5vcm1hbGl6ZWRSZXF1ZXN0RGF0YVRvRXZlbnQoZXZlbnQsIG5vcm1hbGl6ZWRSZXF1ZXN0LCB7IGlwQWRkcmVzcyB9LCBpbmNsdWRlV2l0aERlZmF1bHRQaWlBcHBsaWVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH0sXG4gIH07XG59KSA7XG5cbi8qKlxuICogQWRkIGRhdGEgYWJvdXQgYSByZXF1ZXN0IHRvIGFuIGV2ZW50LiBQcmltYXJpbHkgZm9yIHVzZSBpbiBOb2RlLWJhc2VkIFNES3MsIGJ1dCBpbmNsdWRlZCBpbiBgQHNlbnRyeS9jb3JlYFxuICogc28gaXQgY2FuIGJlIHVzZWQgaW4gY3Jvc3MtcGxhdGZvcm0gU0RLcyBsaWtlIGBAc2VudHJ5L25leHRqc2AuXG4gKi9cbmNvbnN0IHJlcXVlc3REYXRhSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbihfcmVxdWVzdERhdGFJbnRlZ3JhdGlvbik7XG5cbi8qKlxuICogQWRkIGFscmVhZHkgbm9ybWFsaXplZCByZXF1ZXN0IGRhdGEgdG8gYW4gZXZlbnQuXG4gKiBUaGlzIG11dGF0ZXMgdGhlIHBhc3NlZCBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gYWRkTm9ybWFsaXplZFJlcXVlc3REYXRhVG9FdmVudChcbiAgZXZlbnQsXG4gIHJlcSxcbiAgLy8gRGF0YSB0aGF0IHNob3VsZCBub3QgZ28gaW50byBgZXZlbnQucmVxdWVzdGAgYnV0IGlzIHNvbWVob3cgcmVsYXRlZCB0byByZXF1ZXN0c1xuICBhZGRpdGlvbmFsRGF0YSxcbiAgaW5jbHVkZSxcbikge1xuICBldmVudC5yZXF1ZXN0ID0ge1xuICAgIC4uLmV2ZW50LnJlcXVlc3QsXG4gICAgLi4uZXh0cmFjdE5vcm1hbGl6ZWRSZXF1ZXN0RGF0YShyZXEsIGluY2x1ZGUpLFxuICB9O1xuXG4gIGlmIChpbmNsdWRlLmlwKSB7XG4gICAgY29uc3QgaXAgPSAocmVxLmhlYWRlcnMgJiYgZ2V0SXBBZGRyZXNzLmdldENsaWVudElQQWRkcmVzcyhyZXEuaGVhZGVycykpIHx8IGFkZGl0aW9uYWxEYXRhLmlwQWRkcmVzcztcbiAgICBpZiAoaXApIHtcbiAgICAgIGV2ZW50LnVzZXIgPSB7XG4gICAgICAgIC4uLmV2ZW50LnVzZXIsXG4gICAgICAgIGlwX2FkZHJlc3M6IGlwLFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdE5vcm1hbGl6ZWRSZXF1ZXN0RGF0YShcbiAgbm9ybWFsaXplZFJlcXVlc3QsXG4gIGluY2x1ZGUsXG4pIHtcbiAgY29uc3QgcmVxdWVzdERhdGEgPSB7fTtcbiAgY29uc3QgaGVhZGVycyA9IHsgLi4ubm9ybWFsaXplZFJlcXVlc3QuaGVhZGVycyB9O1xuXG4gIGlmIChpbmNsdWRlLmhlYWRlcnMpIHtcbiAgICByZXF1ZXN0RGF0YS5oZWFkZXJzID0gaGVhZGVycztcblxuICAgIC8vIFJlbW92ZSB0aGUgQ29va2llIGhlYWRlciBpbiBjYXNlIGNvb2tpZSBkYXRhIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIGV2ZW50XG4gICAgaWYgKCFpbmNsdWRlLmNvb2tpZXMpIHtcbiAgICAgIGRlbGV0ZSAoaGVhZGVycyApLmNvb2tpZTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgSVAgaGVhZGVycyBpbiBjYXNlIElQIGRhdGEgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgZXZlbnRcbiAgICBpZiAoIWluY2x1ZGUuaXApIHtcbiAgICAgIGdldElwQWRkcmVzcy5pcEhlYWRlck5hbWVzLmZvckVhY2goaXBIZWFkZXJOYW1lID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZVxuICAgICAgICBkZWxldGUgKGhlYWRlcnMgKVtpcEhlYWRlck5hbWVdO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdERhdGEubWV0aG9kID0gbm9ybWFsaXplZFJlcXVlc3QubWV0aG9kO1xuXG4gIGlmIChpbmNsdWRlLnVybCkge1xuICAgIHJlcXVlc3REYXRhLnVybCA9IG5vcm1hbGl6ZWRSZXF1ZXN0LnVybDtcbiAgfVxuXG4gIGlmIChpbmNsdWRlLmNvb2tpZXMpIHtcbiAgICBjb25zdCBjb29raWVzID0gbm9ybWFsaXplZFJlcXVlc3QuY29va2llcyB8fCAoaGVhZGVycz8uY29va2llID8gY29va2llLnBhcnNlQ29va2llKGhlYWRlcnMuY29va2llKSA6IHVuZGVmaW5lZCk7XG4gICAgcmVxdWVzdERhdGEuY29va2llcyA9IGNvb2tpZXMgfHwge307XG4gIH1cblxuICBpZiAoaW5jbHVkZS5xdWVyeV9zdHJpbmcpIHtcbiAgICByZXF1ZXN0RGF0YS5xdWVyeV9zdHJpbmcgPSBub3JtYWxpemVkUmVxdWVzdC5xdWVyeV9zdHJpbmc7XG4gIH1cblxuICBpZiAoaW5jbHVkZS5kYXRhKSB7XG4gICAgcmVxdWVzdERhdGEuZGF0YSA9IG5vcm1hbGl6ZWRSZXF1ZXN0LmRhdGE7XG4gIH1cblxuICByZXR1cm4gcmVxdWVzdERhdGE7XG59XG5cbmV4cG9ydHMucmVxdWVzdERhdGFJbnRlZ3JhdGlvbiA9IHJlcXVlc3REYXRhSW50ZWdyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0ZGF0YS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/requestdata.js\n')},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/rewriteframes.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js\");\nconst path = __webpack_require__(/*! ../utils-hoist/path.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/path.js\");\nconst worldwide = __webpack_require__(/*! ../utils-hoist/worldwide.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js\");\n\nconst INTEGRATION_NAME = 'RewriteFrames';\n\n/**\n * Rewrite event frames paths.\n */\nconst rewriteFramesIntegration = integration.defineIntegration((options = {}) => {\n  const root = options.root;\n  const prefix = options.prefix || 'app:///';\n\n  const isBrowser = 'window' in worldwide.GLOBAL_OBJ && !!worldwide.GLOBAL_OBJ.window;\n\n  const iteratee = options.iteratee || generateIteratee({ isBrowser, root, prefix });\n\n  /** Process an exception event. */\n  function _processExceptionsEvent(event) {\n    try {\n      return {\n        ...event,\n        exception: {\n          ...event.exception,\n          // The check for this is performed inside `process` call itself, safe to skip here\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          values: event.exception.values.map(value => ({\n            ...value,\n            ...(value.stacktrace && { stacktrace: _processStacktrace(value.stacktrace) }),\n          })),\n        },\n      };\n    } catch (_oO) {\n      return event;\n    }\n  }\n\n  /** Process a stack trace. */\n  function _processStacktrace(stacktrace) {\n    return {\n      ...stacktrace,\n      frames: stacktrace?.frames && stacktrace.frames.map(f => iteratee(f)),\n    };\n  }\n\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(originalEvent) {\n      let processedEvent = originalEvent;\n\n      if (originalEvent.exception && Array.isArray(originalEvent.exception.values)) {\n        processedEvent = _processExceptionsEvent(processedEvent);\n      }\n\n      return processedEvent;\n    },\n  };\n});\n\n/**\n * Exported only for tests.\n */\nfunction generateIteratee({\n  isBrowser,\n  root,\n  prefix,\n}\n\n) {\n  return (frame) => {\n    if (!frame.filename) {\n      return frame;\n    }\n\n    // Determine if this is a Windows frame by checking for a Windows-style prefix such as `C:\\`\n    const isWindowsFrame =\n      /^[a-zA-Z]:\\\\/.test(frame.filename) ||\n      // or the presence of a backslash without a forward slash (which are not allowed on Windows)\n      (frame.filename.includes('\\\\') && !frame.filename.includes('/'));\n\n    // Check if the frame filename begins with `/`\n    const startsWithSlash = /^\\//.test(frame.filename);\n\n    if (isBrowser) {\n      if (root) {\n        const oldFilename = frame.filename;\n        if (oldFilename.indexOf(root) === 0) {\n          frame.filename = oldFilename.replace(root, prefix);\n        }\n      }\n    } else {\n      if (isWindowsFrame || startsWithSlash) {\n        const filename = isWindowsFrame\n          ? frame.filename\n              .replace(/^[a-zA-Z]:/, '') // remove Windows-style prefix\n              .replace(/\\\\/g, '/') // replace all `\\\\` instances with `/`\n          : frame.filename;\n        const base = root ? path.relative(root, filename) : path.basename(filename);\n        frame.filename = `${prefix}${base}`;\n      }\n    }\n\n    return frame;\n  };\n}\n\nexports.generateIteratee = generateIteratee;\nexports.rewriteFramesIntegration = rewriteFramesIntegration;\n//# sourceMappingURL=rewriteframes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9ucy9yZXdyaXRlZnJhbWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLG9CQUFvQixtQkFBTyxDQUFDLHdIQUFtQjtBQUMvQyxhQUFhLG1CQUFPLENBQUMsa0lBQXdCO0FBQzdDLGtCQUFrQixtQkFBTyxDQUFDLDRJQUE2Qjs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7O0FBRUE7O0FBRUEsMERBQTBELHlCQUF5Qjs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrREFBa0Q7QUFDeEYsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU8sRUFBRSxLQUFLO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QixnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcaW50ZWdyYXRpb25zXFxyZXdyaXRlZnJhbWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBpbnRlZ3JhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVncmF0aW9uLmpzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvcGF0aC5qcycpO1xuY29uc3Qgd29ybGR3aWRlID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvd29ybGR3aWRlLmpzJyk7XG5cbmNvbnN0IElOVEVHUkFUSU9OX05BTUUgPSAnUmV3cml0ZUZyYW1lcyc7XG5cbi8qKlxuICogUmV3cml0ZSBldmVudCBmcmFtZXMgcGF0aHMuXG4gKi9cbmNvbnN0IHJld3JpdGVGcmFtZXNJbnRlZ3JhdGlvbiA9IGludGVncmF0aW9uLmRlZmluZUludGVncmF0aW9uKChvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3Qgcm9vdCA9IG9wdGlvbnMucm9vdDtcbiAgY29uc3QgcHJlZml4ID0gb3B0aW9ucy5wcmVmaXggfHwgJ2FwcDovLy8nO1xuXG4gIGNvbnN0IGlzQnJvd3NlciA9ICd3aW5kb3cnIGluIHdvcmxkd2lkZS5HTE9CQUxfT0JKICYmICEhd29ybGR3aWRlLkdMT0JBTF9PQkoud2luZG93O1xuXG4gIGNvbnN0IGl0ZXJhdGVlID0gb3B0aW9ucy5pdGVyYXRlZSB8fCBnZW5lcmF0ZUl0ZXJhdGVlKHsgaXNCcm93c2VyLCByb290LCBwcmVmaXggfSk7XG5cbiAgLyoqIFByb2Nlc3MgYW4gZXhjZXB0aW9uIGV2ZW50LiAqL1xuICBmdW5jdGlvbiBfcHJvY2Vzc0V4Y2VwdGlvbnNFdmVudChldmVudCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgZXhjZXB0aW9uOiB7XG4gICAgICAgICAgLi4uZXZlbnQuZXhjZXB0aW9uLFxuICAgICAgICAgIC8vIFRoZSBjaGVjayBmb3IgdGhpcyBpcyBwZXJmb3JtZWQgaW5zaWRlIGBwcm9jZXNzYCBjYWxsIGl0c2VsZiwgc2FmZSB0byBza2lwIGhlcmVcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgIHZhbHVlczogZXZlbnQuZXhjZXB0aW9uLnZhbHVlcy5tYXAodmFsdWUgPT4gKHtcbiAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgLi4uKHZhbHVlLnN0YWNrdHJhY2UgJiYgeyBzdGFja3RyYWNlOiBfcHJvY2Vzc1N0YWNrdHJhY2UodmFsdWUuc3RhY2t0cmFjZSkgfSksXG4gICAgICAgICAgfSkpLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChfb08pIHtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gIH1cblxuICAvKiogUHJvY2VzcyBhIHN0YWNrIHRyYWNlLiAqL1xuICBmdW5jdGlvbiBfcHJvY2Vzc1N0YWNrdHJhY2Uoc3RhY2t0cmFjZSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGFja3RyYWNlLFxuICAgICAgZnJhbWVzOiBzdGFja3RyYWNlPy5mcmFtZXMgJiYgc3RhY2t0cmFjZS5mcmFtZXMubWFwKGYgPT4gaXRlcmF0ZWUoZikpLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IElOVEVHUkFUSU9OX05BTUUsXG4gICAgcHJvY2Vzc0V2ZW50KG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgIGxldCBwcm9jZXNzZWRFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgIGlmIChvcmlnaW5hbEV2ZW50LmV4Y2VwdGlvbiAmJiBBcnJheS5pc0FycmF5KG9yaWdpbmFsRXZlbnQuZXhjZXB0aW9uLnZhbHVlcykpIHtcbiAgICAgICAgcHJvY2Vzc2VkRXZlbnQgPSBfcHJvY2Vzc0V4Y2VwdGlvbnNFdmVudChwcm9jZXNzZWRFdmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9jZXNzZWRFdmVudDtcbiAgICB9LFxuICB9O1xufSk7XG5cbi8qKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdHMuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlSXRlcmF0ZWUoe1xuICBpc0Jyb3dzZXIsXG4gIHJvb3QsXG4gIHByZWZpeCxcbn1cblxuKSB7XG4gIHJldHVybiAoZnJhbWUpID0+IHtcbiAgICBpZiAoIWZyYW1lLmZpbGVuYW1lKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBXaW5kb3dzIGZyYW1lIGJ5IGNoZWNraW5nIGZvciBhIFdpbmRvd3Mtc3R5bGUgcHJlZml4IHN1Y2ggYXMgYEM6XFxgXG4gICAgY29uc3QgaXNXaW5kb3dzRnJhbWUgPVxuICAgICAgL15bYS16QS1aXTpcXFxcLy50ZXN0KGZyYW1lLmZpbGVuYW1lKSB8fFxuICAgICAgLy8gb3IgdGhlIHByZXNlbmNlIG9mIGEgYmFja3NsYXNoIHdpdGhvdXQgYSBmb3J3YXJkIHNsYXNoICh3aGljaCBhcmUgbm90IGFsbG93ZWQgb24gV2luZG93cylcbiAgICAgIChmcmFtZS5maWxlbmFtZS5pbmNsdWRlcygnXFxcXCcpICYmICFmcmFtZS5maWxlbmFtZS5pbmNsdWRlcygnLycpKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBmcmFtZSBmaWxlbmFtZSBiZWdpbnMgd2l0aCBgL2BcbiAgICBjb25zdCBzdGFydHNXaXRoU2xhc2ggPSAvXlxcLy8udGVzdChmcmFtZS5maWxlbmFtZSk7XG5cbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICBpZiAocm9vdCkge1xuICAgICAgICBjb25zdCBvbGRGaWxlbmFtZSA9IGZyYW1lLmZpbGVuYW1lO1xuICAgICAgICBpZiAob2xkRmlsZW5hbWUuaW5kZXhPZihyb290KSA9PT0gMCkge1xuICAgICAgICAgIGZyYW1lLmZpbGVuYW1lID0gb2xkRmlsZW5hbWUucmVwbGFjZShyb290LCBwcmVmaXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1dpbmRvd3NGcmFtZSB8fCBzdGFydHNXaXRoU2xhc2gpIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBpc1dpbmRvd3NGcmFtZVxuICAgICAgICAgID8gZnJhbWUuZmlsZW5hbWVcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL15bYS16QS1aXTovLCAnJykgLy8gcmVtb3ZlIFdpbmRvd3Mtc3R5bGUgcHJlZml4XG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcL2csICcvJykgLy8gcmVwbGFjZSBhbGwgYFxcXFxgIGluc3RhbmNlcyB3aXRoIGAvYFxuICAgICAgICAgIDogZnJhbWUuZmlsZW5hbWU7XG4gICAgICAgIGNvbnN0IGJhc2UgPSByb290ID8gcGF0aC5yZWxhdGl2ZShyb290LCBmaWxlbmFtZSkgOiBwYXRoLmJhc2VuYW1lKGZpbGVuYW1lKTtcbiAgICAgICAgZnJhbWUuZmlsZW5hbWUgPSBgJHtwcmVmaXh9JHtiYXNlfWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYW1lO1xuICB9O1xufVxuXG5leHBvcnRzLmdlbmVyYXRlSXRlcmF0ZWUgPSBnZW5lcmF0ZUl0ZXJhdGVlO1xuZXhwb3J0cy5yZXdyaXRlRnJhbWVzSW50ZWdyYXRpb24gPSByZXdyaXRlRnJhbWVzSW50ZWdyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXdyaXRlZnJhbWVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/rewriteframes.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/supabase.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst breadcrumbs = __webpack_require__(/*! ../breadcrumbs.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/breadcrumbs.js\");\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst exports$1 = __webpack_require__(/*! ../exports.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/exports.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js\");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\n__webpack_require__(/*! ../tracing/errors.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/errors.js\");\nconst is = __webpack_require__(/*! ../utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\n__webpack_require__(/*! ../utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst spanstatus = __webpack_require__(/*! ../tracing/spanstatus.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js\");\nconst trace = __webpack_require__(/*! ../tracing/trace.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/trace.js\");\n\n// Based on Kamil Og\xf3rek's work on:\n// https://github.com/supabase-community/sentry-integration-js\n\n\nconst AUTH_OPERATIONS_TO_INSTRUMENT = [\n  'reauthenticate',\n  'signInAnonymously',\n  'signInWithOAuth',\n  'signInWithIdToken',\n  'signInWithOtp',\n  'signInWithPassword',\n  'signInWithSSO',\n  'signOut',\n  'signUp',\n  'verifyOtp',\n];\n\nconst AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT = [\n  'createUser',\n  'deleteUser',\n  'listUsers',\n  'getUserById',\n  'updateUserById',\n  'inviteUserByEmail',\n];\n\nconst FILTER_MAPPINGS = {\n  eq: 'eq',\n  neq: 'neq',\n  gt: 'gt',\n  gte: 'gte',\n  lt: 'lt',\n  lte: 'lte',\n  like: 'like',\n  'like(all)': 'likeAllOf',\n  'like(any)': 'likeAnyOf',\n  ilike: 'ilike',\n  'ilike(all)': 'ilikeAllOf',\n  'ilike(any)': 'ilikeAnyOf',\n  is: 'is',\n  in: 'in',\n  cs: 'contains',\n  cd: 'containedBy',\n  sr: 'rangeGt',\n  nxl: 'rangeGte',\n  sl: 'rangeLt',\n  nxr: 'rangeLte',\n  adj: 'rangeAdjacent',\n  ov: 'overlaps',\n  fts: '',\n  plfts: 'plain',\n  phfts: 'phrase',\n  wfts: 'websearch',\n  not: 'not',\n};\n\nconst DB_OPERATIONS_TO_INSTRUMENT = ['select', 'insert', 'upsert', 'update', 'delete'];\n\nfunction markAsInstrumented(fn) {\n  try {\n    (fn ).__SENTRY_INSTRUMENTED__ = true;\n  } catch {\n    // ignore errors here\n  }\n}\n\nfunction isInstrumented(fn) {\n  try {\n    return (fn ).__SENTRY_INSTRUMENTED__;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Extracts the database operation type from the HTTP method and headers\n * @param method - The HTTP method of the request\n * @param headers - The request headers\n * @returns The database operation type ('select', 'insert', 'upsert', 'update', or 'delete')\n */\nfunction extractOperation(method, headers = {}) {\n  switch (method) {\n    case 'GET': {\n      return 'select';\n    }\n    case 'POST': {\n      if (headers['Prefer']?.includes('resolution=')) {\n        return 'upsert';\n      } else {\n        return 'insert';\n      }\n    }\n    case 'PATCH': {\n      return 'update';\n    }\n    case 'DELETE': {\n      return 'delete';\n    }\n    default: {\n      return '<unknown-op>';\n    }\n  }\n}\n\n/**\n * Translates Supabase filter parameters into readable method names for tracing\n * @param key - The filter key from the URL search parameters\n * @param query - The filter value from the URL search parameters\n * @returns A string representation of the filter as a method call\n */\nfunction translateFiltersIntoMethods(key, query) {\n  if (query === '' || query === '*') {\n    return 'select(*)';\n  }\n\n  if (key === 'select') {\n    return `select(${query})`;\n  }\n\n  if (key === 'or' || key.endsWith('.or')) {\n    return `${key}${query}`;\n  }\n\n  const [filter, ...value] = query.split('.');\n\n  let method;\n  // Handle optional `configPart` of the filter\n  if (filter?.startsWith('fts')) {\n    method = 'textSearch';\n  } else if (filter?.startsWith('plfts')) {\n    method = 'textSearch[plain]';\n  } else if (filter?.startsWith('phfts')) {\n    method = 'textSearch[phrase]';\n  } else if (filter?.startsWith('wfts')) {\n    method = 'textSearch[websearch]';\n  } else {\n    method = (filter && FILTER_MAPPINGS[filter ]) || 'filter';\n  }\n\n  return `${method}(${key}, ${value.join('.')})`;\n}\n\nfunction instrumentAuthOperation(operation, isAdmin = false) {\n  return new Proxy(operation, {\n    apply(target, thisArg, argumentsList) {\n      return trace.startSpan(\n        {\n          name: `auth ${isAdmin ? '(admin) ' : ''}${operation.name}`,\n          attributes: {\n            [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',\n            [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db',\n            'db.system': 'postgresql',\n            'db.operation': `auth.${isAdmin ? 'admin.' : ''}${operation.name}`,\n          },\n        },\n        span => {\n          return Reflect.apply(target, thisArg, argumentsList)\n            .then((res) => {\n              if (res && typeof res === 'object' && 'error' in res && res.error) {\n                span.setStatus({ code: spanstatus.SPAN_STATUS_ERROR });\n\n                exports$1.captureException(res.error, {\n                  mechanism: {\n                    handled: false,\n                  },\n                });\n              } else {\n                span.setStatus({ code: spanstatus.SPAN_STATUS_OK });\n              }\n\n              span.end();\n              return res;\n            })\n            .catch((err) => {\n              span.setStatus({ code: spanstatus.SPAN_STATUS_ERROR });\n              span.end();\n\n              exports$1.captureException(err, {\n                mechanism: {\n                  handled: false,\n                },\n              });\n\n              throw err;\n            })\n            .then(...argumentsList);\n        },\n      );\n    },\n  });\n}\n\nfunction instrumentSupabaseAuthClient(supabaseClientInstance) {\n  const auth = supabaseClientInstance.auth;\n\n  if (!auth || isInstrumented(supabaseClientInstance.auth)) {\n    return;\n  }\n\n  for (const operation of AUTH_OPERATIONS_TO_INSTRUMENT) {\n    const authOperation = auth[operation];\n\n    if (!authOperation) {\n      continue;\n    }\n\n    if (typeof supabaseClientInstance.auth[operation] === 'function') {\n      supabaseClientInstance.auth[operation] = instrumentAuthOperation(authOperation);\n    }\n  }\n\n  for (const operation of AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT) {\n    const authOperation = auth.admin[operation];\n\n    if (!authOperation) {\n      continue;\n    }\n\n    if (typeof supabaseClientInstance.auth.admin[operation] === 'function') {\n      supabaseClientInstance.auth.admin[operation] = instrumentAuthOperation(authOperation, true);\n    }\n  }\n\n  markAsInstrumented(supabaseClientInstance.auth);\n}\n\nfunction instrumentSupabaseClientConstructor(SupabaseClient) {\n  if (isInstrumented((SupabaseClient ).prototype.from)) {\n    return;\n  }\n\n  (SupabaseClient ).prototype.from = new Proxy(\n    (SupabaseClient ).prototype.from,\n    {\n      apply(target, thisArg, argumentsList) {\n        const rv = Reflect.apply(target, thisArg, argumentsList);\n        const PostgRESTQueryBuilder = (rv ).constructor;\n\n        instrumentPostgRESTQueryBuilder(PostgRESTQueryBuilder );\n\n        return rv;\n      },\n    },\n  );\n\n  markAsInstrumented((SupabaseClient ).prototype.from);\n}\n\nfunction instrumentPostgRESTFilterBuilder(PostgRESTFilterBuilder) {\n  if (isInstrumented((PostgRESTFilterBuilder.prototype ).then)) {\n    return;\n  }\n\n  (PostgRESTFilterBuilder.prototype ).then = new Proxy(\n    (PostgRESTFilterBuilder.prototype ).then,\n    {\n      apply(target, thisArg, argumentsList) {\n        const operations = DB_OPERATIONS_TO_INSTRUMENT;\n        const typedThis = thisArg ;\n        const operation = extractOperation(typedThis.method, typedThis.headers);\n\n        if (!operations.includes(operation)) {\n          return Reflect.apply(target, thisArg, argumentsList);\n        }\n\n        if (!typedThis?.url?.pathname || typeof typedThis.url.pathname !== 'string') {\n          return Reflect.apply(target, thisArg, argumentsList);\n        }\n\n        const pathParts = typedThis.url.pathname.split('/');\n        const table = pathParts.length > 0 ? pathParts[pathParts.length - 1] : '';\n\n        const queryItems = [];\n        for (const [key, value] of typedThis.url.searchParams.entries()) {\n          // It's possible to have multiple entries for the same key, eg. `id=eq.7&id=eq.3`,\n          // so we need to use array instead of object to collect them.\n          queryItems.push(translateFiltersIntoMethods(key, value));\n        }\n        const body = Object.create(null);\n        if (is.isPlainObject(typedThis.body)) {\n          for (const [key, value] of Object.entries(typedThis.body)) {\n            body[key] = value;\n          }\n        }\n\n        // Adding operation to the beginning of the description if it's not a `select` operation\n        // For example, it can be an `insert` or `update` operation but the query can be `select(...)`\n        // For `select` operations, we don't need repeat it in the description\n        const description = `${operation === 'select' ? '' : `${operation}${body ? '(...) ' : ''}`}${queryItems.join(\n          ' ',\n        )} from(${table})`;\n\n        const attributes = {\n          'db.table': table,\n          'db.schema': typedThis.schema,\n          'db.url': typedThis.url.origin,\n          'db.sdk': typedThis.headers['X-Client-Info'],\n          'db.system': 'postgresql',\n          'db.operation': operation,\n          [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',\n          [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db',\n        };\n\n        if (queryItems.length) {\n          attributes['db.query'] = queryItems;\n        }\n\n        if (Object.keys(body).length) {\n          attributes['db.body'] = body;\n        }\n\n        return trace.startSpan(\n          {\n            name: description,\n            attributes,\n          },\n          span => {\n            return (Reflect.apply(target, thisArg, []) )\n              .then(\n                (res) => {\n                  if (span) {\n                    if (res && typeof res === 'object' && 'status' in res) {\n                      spanstatus.setHttpStatus(span, res.status || 500);\n                    }\n                    span.end();\n                  }\n\n                  if (res.error) {\n                    const err = new Error(res.error.message) ;\n                    if (res.error.code) {\n                      err.code = res.error.code;\n                    }\n                    if (res.error.details) {\n                      err.details = res.error.details;\n                    }\n\n                    const supabaseContext = {};\n                    if (queryItems.length) {\n                      supabaseContext.query = queryItems;\n                    }\n                    if (Object.keys(body).length) {\n                      supabaseContext.body = body;\n                    }\n\n                    exports$1.captureException(err, {\n                      contexts: {\n                        supabase: supabaseContext,\n                      },\n                    });\n                  }\n\n                  const breadcrumb = {\n                    type: 'supabase',\n                    category: `db.${operation}`,\n                    message: description,\n                  };\n\n                  const data = {};\n\n                  if (queryItems.length) {\n                    data.query = queryItems;\n                  }\n\n                  if (Object.keys(body).length) {\n                    data.body = body;\n                  }\n\n                  if (Object.keys(data).length) {\n                    breadcrumb.data = data;\n                  }\n\n                  breadcrumbs.addBreadcrumb(breadcrumb);\n\n                  return res;\n                },\n                (err) => {\n                  if (span) {\n                    spanstatus.setHttpStatus(span, 500);\n                    span.end();\n                  }\n                  throw err;\n                },\n              )\n              .then(...argumentsList);\n          },\n        );\n      },\n    },\n  );\n\n  markAsInstrumented((PostgRESTFilterBuilder.prototype ).then);\n}\n\nfunction instrumentPostgRESTQueryBuilder(PostgRESTQueryBuilder) {\n  // We need to wrap _all_ operations despite them sharing the same `PostgRESTFilterBuilder`\n  // constructor, as we don't know which method will be called first, and we don't want to miss any calls.\n  for (const operation of DB_OPERATIONS_TO_INSTRUMENT) {\n    if (isInstrumented((PostgRESTQueryBuilder.prototype )[operation])) {\n      continue;\n    }\n\n    (PostgRESTQueryBuilder.prototype )[operation ] = new Proxy(\n      (PostgRESTQueryBuilder.prototype )[operation ],\n      {\n        apply(target, thisArg, argumentsList) {\n          const rv = Reflect.apply(target, thisArg, argumentsList);\n          const PostgRESTFilterBuilder = (rv ).constructor;\n\n          debugBuild.DEBUG_BUILD && logger.logger.log(`Instrumenting ${operation} operation's PostgRESTFilterBuilder`);\n\n          instrumentPostgRESTFilterBuilder(PostgRESTFilterBuilder);\n\n          return rv;\n        },\n      },\n    );\n\n    markAsInstrumented((PostgRESTQueryBuilder.prototype )[operation]);\n  }\n}\n\nconst instrumentSupabaseClient = (supabaseClient) => {\n  if (!supabaseClient) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('Supabase integration was not installed because no Supabase client was provided.');\n    return;\n  }\n  const SupabaseClientConstructor =\n    supabaseClient.constructor === Function ? supabaseClient : supabaseClient.constructor;\n\n  instrumentSupabaseClientConstructor(SupabaseClientConstructor);\n  instrumentSupabaseAuthClient(supabaseClient );\n};\n\nconst INTEGRATION_NAME = 'Supabase';\n\nconst _supabaseIntegration = ((supabaseClient) => {\n  return {\n    setupOnce() {\n      instrumentSupabaseClient(supabaseClient);\n    },\n    name: INTEGRATION_NAME,\n  };\n}) ;\n\nconst supabaseIntegration = integration.defineIntegration((options) => {\n  return _supabaseIntegration(options.supabaseClient);\n}) ;\n\nexports.DB_OPERATIONS_TO_INSTRUMENT = DB_OPERATIONS_TO_INSTRUMENT;\nexports.FILTER_MAPPINGS = FILTER_MAPPINGS;\nexports.extractOperation = extractOperation;\nexports.instrumentSupabaseClient = instrumentSupabaseClient;\nexports.supabaseIntegration = supabaseIntegration;\nexports.translateFiltersIntoMethods = translateFiltersIntoMethods;\n//# sourceMappingURL=supabase.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9ucy9zdXBhYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxvQkFBb0IsbUJBQU8sQ0FBQyx3SEFBbUI7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsd0hBQW1CO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLGdIQUFlO0FBQ3pDLG9CQUFvQixtQkFBTyxDQUFDLHdIQUFtQjtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyxzSUFBMEI7QUFDN0QsbUJBQU8sQ0FBQyw4SEFBc0I7QUFDOUIsV0FBVyxtQkFBTyxDQUFDLDhIQUFzQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMsc0lBQTBCO0FBQ2pELG1CQUFPLENBQUMsa0lBQXdCO0FBQ2hDLG1CQUFtQixtQkFBTyxDQUFDLHNJQUEwQjtBQUNyRCxjQUFjLG1CQUFPLENBQUMsNEhBQXFCOztBQUUzQztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCOztBQUVBO0FBQ0EsY0FBYyxJQUFJLEVBQUUsTUFBTTtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLFlBQVksT0FBTyxHQUFHLElBQUksSUFBSSxnQkFBZ0I7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEIsRUFBRSxlQUFlO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdCQUF3QixFQUFFLGVBQWU7QUFDN0UsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvQ0FBb0M7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGlDQUFpQyxpQ0FBaUM7QUFDbEU7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLCtCQUErQixvQ0FBb0M7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7O0FBRWY7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlDQUFpQyxVQUFVLEVBQUUscUJBQXFCLEVBQUUsRUFBRTtBQUNyRztBQUNBLFdBQVcsT0FBTyxNQUFNOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUVBQXVFLFdBQVc7O0FBRWxGOztBQUVBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVELG1DQUFtQztBQUNuQyx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQywyQkFBMkI7QUFDM0IsbUNBQW1DO0FBQ25DIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGludGVncmF0aW9uc1xcc3VwYWJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGJyZWFkY3J1bWJzID0gcmVxdWlyZSgnLi4vYnJlYWRjcnVtYnMuanMnKTtcbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3QgZXhwb3J0cyQxID0gcmVxdWlyZSgnLi4vZXhwb3J0cy5qcycpO1xuY29uc3QgaW50ZWdyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlZ3JhdGlvbi5qcycpO1xuY29uc3Qgc2VtYW50aWNBdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi4vc2VtYW50aWNBdHRyaWJ1dGVzLmpzJyk7XG5yZXF1aXJlKCcuLi90cmFjaW5nL2Vycm9ycy5qcycpO1xuY29uc3QgaXMgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9pcy5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5yZXF1aXJlKCcuLi91dGlscy1ob2lzdC90aW1lLmpzJyk7XG5jb25zdCBzcGFuc3RhdHVzID0gcmVxdWlyZSgnLi4vdHJhY2luZy9zcGFuc3RhdHVzLmpzJyk7XG5jb25zdCB0cmFjZSA9IHJlcXVpcmUoJy4uL3RyYWNpbmcvdHJhY2UuanMnKTtcblxuLy8gQmFzZWQgb24gS2FtaWwgT2fDs3JlaydzIHdvcmsgb246XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UtY29tbXVuaXR5L3NlbnRyeS1pbnRlZ3JhdGlvbi1qc1xuXG5cbmNvbnN0IEFVVEhfT1BFUkFUSU9OU19UT19JTlNUUlVNRU5UID0gW1xuICAncmVhdXRoZW50aWNhdGUnLFxuICAnc2lnbkluQW5vbnltb3VzbHknLFxuICAnc2lnbkluV2l0aE9BdXRoJyxcbiAgJ3NpZ25JbldpdGhJZFRva2VuJyxcbiAgJ3NpZ25JbldpdGhPdHAnLFxuICAnc2lnbkluV2l0aFBhc3N3b3JkJyxcbiAgJ3NpZ25JbldpdGhTU08nLFxuICAnc2lnbk91dCcsXG4gICdzaWduVXAnLFxuICAndmVyaWZ5T3RwJyxcbl07XG5cbmNvbnN0IEFVVEhfQURNSU5fT1BFUkFUSU9OU19UT19JTlNUUlVNRU5UID0gW1xuICAnY3JlYXRlVXNlcicsXG4gICdkZWxldGVVc2VyJyxcbiAgJ2xpc3RVc2VycycsXG4gICdnZXRVc2VyQnlJZCcsXG4gICd1cGRhdGVVc2VyQnlJZCcsXG4gICdpbnZpdGVVc2VyQnlFbWFpbCcsXG5dO1xuXG5jb25zdCBGSUxURVJfTUFQUElOR1MgPSB7XG4gIGVxOiAnZXEnLFxuICBuZXE6ICduZXEnLFxuICBndDogJ2d0JyxcbiAgZ3RlOiAnZ3RlJyxcbiAgbHQ6ICdsdCcsXG4gIGx0ZTogJ2x0ZScsXG4gIGxpa2U6ICdsaWtlJyxcbiAgJ2xpa2UoYWxsKSc6ICdsaWtlQWxsT2YnLFxuICAnbGlrZShhbnkpJzogJ2xpa2VBbnlPZicsXG4gIGlsaWtlOiAnaWxpa2UnLFxuICAnaWxpa2UoYWxsKSc6ICdpbGlrZUFsbE9mJyxcbiAgJ2lsaWtlKGFueSknOiAnaWxpa2VBbnlPZicsXG4gIGlzOiAnaXMnLFxuICBpbjogJ2luJyxcbiAgY3M6ICdjb250YWlucycsXG4gIGNkOiAnY29udGFpbmVkQnknLFxuICBzcjogJ3JhbmdlR3QnLFxuICBueGw6ICdyYW5nZUd0ZScsXG4gIHNsOiAncmFuZ2VMdCcsXG4gIG54cjogJ3JhbmdlTHRlJyxcbiAgYWRqOiAncmFuZ2VBZGphY2VudCcsXG4gIG92OiAnb3ZlcmxhcHMnLFxuICBmdHM6ICcnLFxuICBwbGZ0czogJ3BsYWluJyxcbiAgcGhmdHM6ICdwaHJhc2UnLFxuICB3ZnRzOiAnd2Vic2VhcmNoJyxcbiAgbm90OiAnbm90Jyxcbn07XG5cbmNvbnN0IERCX09QRVJBVElPTlNfVE9fSU5TVFJVTUVOVCA9IFsnc2VsZWN0JywgJ2luc2VydCcsICd1cHNlcnQnLCAndXBkYXRlJywgJ2RlbGV0ZSddO1xuXG5mdW5jdGlvbiBtYXJrQXNJbnN0cnVtZW50ZWQoZm4pIHtcbiAgdHJ5IHtcbiAgICAoZm4gKS5fX1NFTlRSWV9JTlNUUlVNRU5URURfXyA9IHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIC8vIGlnbm9yZSBlcnJvcnMgaGVyZVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5zdHJ1bWVudGVkKGZuKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIChmbiApLl9fU0VOVFJZX0lOU1RSVU1FTlRFRF9fO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgZGF0YWJhc2Ugb3BlcmF0aW9uIHR5cGUgZnJvbSB0aGUgSFRUUCBtZXRob2QgYW5kIGhlYWRlcnNcbiAqIEBwYXJhbSBtZXRob2QgLSBUaGUgSFRUUCBtZXRob2Qgb2YgdGhlIHJlcXVlc3RcbiAqIEBwYXJhbSBoZWFkZXJzIC0gVGhlIHJlcXVlc3QgaGVhZGVyc1xuICogQHJldHVybnMgVGhlIGRhdGFiYXNlIG9wZXJhdGlvbiB0eXBlICgnc2VsZWN0JywgJ2luc2VydCcsICd1cHNlcnQnLCAndXBkYXRlJywgb3IgJ2RlbGV0ZScpXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RPcGVyYXRpb24obWV0aG9kLCBoZWFkZXJzID0ge30pIHtcbiAgc3dpdGNoIChtZXRob2QpIHtcbiAgICBjYXNlICdHRVQnOiB7XG4gICAgICByZXR1cm4gJ3NlbGVjdCc7XG4gICAgfVxuICAgIGNhc2UgJ1BPU1QnOiB7XG4gICAgICBpZiAoaGVhZGVyc1snUHJlZmVyJ10/LmluY2x1ZGVzKCdyZXNvbHV0aW9uPScpKSB7XG4gICAgICAgIHJldHVybiAndXBzZXJ0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnaW5zZXJ0JztcbiAgICAgIH1cbiAgICB9XG4gICAgY2FzZSAnUEFUQ0gnOiB7XG4gICAgICByZXR1cm4gJ3VwZGF0ZSc7XG4gICAgfVxuICAgIGNhc2UgJ0RFTEVURSc6IHtcbiAgICAgIHJldHVybiAnZGVsZXRlJztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuICc8dW5rbm93bi1vcD4nO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgU3VwYWJhc2UgZmlsdGVyIHBhcmFtZXRlcnMgaW50byByZWFkYWJsZSBtZXRob2QgbmFtZXMgZm9yIHRyYWNpbmdcbiAqIEBwYXJhbSBrZXkgLSBUaGUgZmlsdGVyIGtleSBmcm9tIHRoZSBVUkwgc2VhcmNoIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBmaWx0ZXIgdmFsdWUgZnJvbSB0aGUgVVJMIHNlYXJjaCBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZmlsdGVyIGFzIGEgbWV0aG9kIGNhbGxcbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlRmlsdGVyc0ludG9NZXRob2RzKGtleSwgcXVlcnkpIHtcbiAgaWYgKHF1ZXJ5ID09PSAnJyB8fCBxdWVyeSA9PT0gJyonKSB7XG4gICAgcmV0dXJuICdzZWxlY3QoKiknO1xuICB9XG5cbiAgaWYgKGtleSA9PT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gYHNlbGVjdCgke3F1ZXJ5fSlgO1xuICB9XG5cbiAgaWYgKGtleSA9PT0gJ29yJyB8fCBrZXkuZW5kc1dpdGgoJy5vcicpKSB7XG4gICAgcmV0dXJuIGAke2tleX0ke3F1ZXJ5fWA7XG4gIH1cblxuICBjb25zdCBbZmlsdGVyLCAuLi52YWx1ZV0gPSBxdWVyeS5zcGxpdCgnLicpO1xuXG4gIGxldCBtZXRob2Q7XG4gIC8vIEhhbmRsZSBvcHRpb25hbCBgY29uZmlnUGFydGAgb2YgdGhlIGZpbHRlclxuICBpZiAoZmlsdGVyPy5zdGFydHNXaXRoKCdmdHMnKSkge1xuICAgIG1ldGhvZCA9ICd0ZXh0U2VhcmNoJztcbiAgfSBlbHNlIGlmIChmaWx0ZXI/LnN0YXJ0c1dpdGgoJ3BsZnRzJykpIHtcbiAgICBtZXRob2QgPSAndGV4dFNlYXJjaFtwbGFpbl0nO1xuICB9IGVsc2UgaWYgKGZpbHRlcj8uc3RhcnRzV2l0aCgncGhmdHMnKSkge1xuICAgIG1ldGhvZCA9ICd0ZXh0U2VhcmNoW3BocmFzZV0nO1xuICB9IGVsc2UgaWYgKGZpbHRlcj8uc3RhcnRzV2l0aCgnd2Z0cycpKSB7XG4gICAgbWV0aG9kID0gJ3RleHRTZWFyY2hbd2Vic2VhcmNoXSc7XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gKGZpbHRlciAmJiBGSUxURVJfTUFQUElOR1NbZmlsdGVyIF0pIHx8ICdmaWx0ZXInO1xuICB9XG5cbiAgcmV0dXJuIGAke21ldGhvZH0oJHtrZXl9LCAke3ZhbHVlLmpvaW4oJy4nKX0pYDtcbn1cblxuZnVuY3Rpb24gaW5zdHJ1bWVudEF1dGhPcGVyYXRpb24ob3BlcmF0aW9uLCBpc0FkbWluID0gZmFsc2UpIHtcbiAgcmV0dXJuIG5ldyBQcm94eShvcGVyYXRpb24sIHtcbiAgICBhcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgIHJldHVybiB0cmFjZS5zdGFydFNwYW4oXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBgYXV0aCAke2lzQWRtaW4gPyAnKGFkbWluKSAnIDogJyd9JHtvcGVyYXRpb24ubmFtZX1gLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnYXV0by5kYi5zdXBhYmFzZScsXG4gICAgICAgICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdOiAnZGInLFxuICAgICAgICAgICAgJ2RiLnN5c3RlbSc6ICdwb3N0Z3Jlc3FsJyxcbiAgICAgICAgICAgICdkYi5vcGVyYXRpb24nOiBgYXV0aC4ke2lzQWRtaW4gPyAnYWRtaW4uJyA6ICcnfSR7b3BlcmF0aW9uLm5hbWV9YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBzcGFuID0+IHtcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgJ2Vycm9yJyBpbiByZXMgJiYgcmVzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBzcGFuc3RhdHVzLlNQQU5fU1RBVFVTX0VSUk9SIH0pO1xuXG4gICAgICAgICAgICAgICAgZXhwb3J0cyQxLmNhcHR1cmVFeGNlcHRpb24ocmVzLmVycm9yLCB7XG4gICAgICAgICAgICAgICAgICBtZWNoYW5pc206IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogc3BhbnN0YXR1cy5TUEFOX1NUQVRVU19PSyB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBzcGFuc3RhdHVzLlNQQU5fU1RBVFVTX0VSUk9SIH0pO1xuICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuXG4gICAgICAgICAgICAgIGV4cG9ydHMkMS5jYXB0dXJlRXhjZXB0aW9uKGVyciwge1xuICAgICAgICAgICAgICAgIG1lY2hhbmlzbToge1xuICAgICAgICAgICAgICAgICAgaGFuZGxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKC4uLmFyZ3VtZW50c0xpc3QpO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9LFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5zdHJ1bWVudFN1cGFiYXNlQXV0aENsaWVudChzdXBhYmFzZUNsaWVudEluc3RhbmNlKSB7XG4gIGNvbnN0IGF1dGggPSBzdXBhYmFzZUNsaWVudEluc3RhbmNlLmF1dGg7XG5cbiAgaWYgKCFhdXRoIHx8IGlzSW5zdHJ1bWVudGVkKHN1cGFiYXNlQ2xpZW50SW5zdGFuY2UuYXV0aCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiBBVVRIX09QRVJBVElPTlNfVE9fSU5TVFJVTUVOVCkge1xuICAgIGNvbnN0IGF1dGhPcGVyYXRpb24gPSBhdXRoW29wZXJhdGlvbl07XG5cbiAgICBpZiAoIWF1dGhPcGVyYXRpb24pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3VwYWJhc2VDbGllbnRJbnN0YW5jZS5hdXRoW29wZXJhdGlvbl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN1cGFiYXNlQ2xpZW50SW5zdGFuY2UuYXV0aFtvcGVyYXRpb25dID0gaW5zdHJ1bWVudEF1dGhPcGVyYXRpb24oYXV0aE9wZXJhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBvcGVyYXRpb24gb2YgQVVUSF9BRE1JTl9PUEVSQVRJT05TX1RPX0lOU1RSVU1FTlQpIHtcbiAgICBjb25zdCBhdXRoT3BlcmF0aW9uID0gYXV0aC5hZG1pbltvcGVyYXRpb25dO1xuXG4gICAgaWYgKCFhdXRoT3BlcmF0aW9uKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHN1cGFiYXNlQ2xpZW50SW5zdGFuY2UuYXV0aC5hZG1pbltvcGVyYXRpb25dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdXBhYmFzZUNsaWVudEluc3RhbmNlLmF1dGguYWRtaW5bb3BlcmF0aW9uXSA9IGluc3RydW1lbnRBdXRoT3BlcmF0aW9uKGF1dGhPcGVyYXRpb24sIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIG1hcmtBc0luc3RydW1lbnRlZChzdXBhYmFzZUNsaWVudEluc3RhbmNlLmF1dGgpO1xufVxuXG5mdW5jdGlvbiBpbnN0cnVtZW50U3VwYWJhc2VDbGllbnRDb25zdHJ1Y3RvcihTdXBhYmFzZUNsaWVudCkge1xuICBpZiAoaXNJbnN0cnVtZW50ZWQoKFN1cGFiYXNlQ2xpZW50ICkucHJvdG90eXBlLmZyb20pKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgKFN1cGFiYXNlQ2xpZW50ICkucHJvdG90eXBlLmZyb20gPSBuZXcgUHJveHkoXG4gICAgKFN1cGFiYXNlQ2xpZW50ICkucHJvdG90eXBlLmZyb20sXG4gICAge1xuICAgICAgYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICBjb25zdCBQb3N0Z1JFU1RRdWVyeUJ1aWxkZXIgPSAocnYgKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgICBpbnN0cnVtZW50UG9zdGdSRVNUUXVlcnlCdWlsZGVyKFBvc3RnUkVTVFF1ZXJ5QnVpbGRlciApO1xuXG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0sXG4gICAgfSxcbiAgKTtcblxuICBtYXJrQXNJbnN0cnVtZW50ZWQoKFN1cGFiYXNlQ2xpZW50ICkucHJvdG90eXBlLmZyb20pO1xufVxuXG5mdW5jdGlvbiBpbnN0cnVtZW50UG9zdGdSRVNURmlsdGVyQnVpbGRlcihQb3N0Z1JFU1RGaWx0ZXJCdWlsZGVyKSB7XG4gIGlmIChpc0luc3RydW1lbnRlZCgoUG9zdGdSRVNURmlsdGVyQnVpbGRlci5wcm90b3R5cGUgKS50aGVuKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIChQb3N0Z1JFU1RGaWx0ZXJCdWlsZGVyLnByb3RvdHlwZSApLnRoZW4gPSBuZXcgUHJveHkoXG4gICAgKFBvc3RnUkVTVEZpbHRlckJ1aWxkZXIucHJvdG90eXBlICkudGhlbixcbiAgICB7XG4gICAgICBhcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9IERCX09QRVJBVElPTlNfVE9fSU5TVFJVTUVOVDtcbiAgICAgICAgY29uc3QgdHlwZWRUaGlzID0gdGhpc0FyZyA7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IGV4dHJhY3RPcGVyYXRpb24odHlwZWRUaGlzLm1ldGhvZCwgdHlwZWRUaGlzLmhlYWRlcnMpO1xuXG4gICAgICAgIGlmICghb3BlcmF0aW9ucy5pbmNsdWRlcyhvcGVyYXRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHlwZWRUaGlzPy51cmw/LnBhdGhuYW1lIHx8IHR5cGVvZiB0eXBlZFRoaXMudXJsLnBhdGhuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXRoUGFydHMgPSB0eXBlZFRoaXMudXJsLnBhdGhuYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gcGF0aFBhcnRzLmxlbmd0aCA+IDAgPyBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIDFdIDogJyc7XG5cbiAgICAgICAgY29uc3QgcXVlcnlJdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0eXBlZFRoaXMudXJsLnNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgZW50cmllcyBmb3IgdGhlIHNhbWUga2V5LCBlZy4gYGlkPWVxLjcmaWQ9ZXEuM2AsXG4gICAgICAgICAgLy8gc28gd2UgbmVlZCB0byB1c2UgYXJyYXkgaW5zdGVhZCBvZiBvYmplY3QgdG8gY29sbGVjdCB0aGVtLlxuICAgICAgICAgIHF1ZXJ5SXRlbXMucHVzaCh0cmFuc2xhdGVGaWx0ZXJzSW50b01ldGhvZHMoa2V5LCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAoaXMuaXNQbGFpbk9iamVjdCh0eXBlZFRoaXMuYm9keSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0eXBlZFRoaXMuYm9keSkpIHtcbiAgICAgICAgICAgIGJvZHlba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZGluZyBvcGVyYXRpb24gdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZGVzY3JpcHRpb24gaWYgaXQncyBub3QgYSBgc2VsZWN0YCBvcGVyYXRpb25cbiAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGl0IGNhbiBiZSBhbiBgaW5zZXJ0YCBvciBgdXBkYXRlYCBvcGVyYXRpb24gYnV0IHRoZSBxdWVyeSBjYW4gYmUgYHNlbGVjdCguLi4pYFxuICAgICAgICAvLyBGb3IgYHNlbGVjdGAgb3BlcmF0aW9ucywgd2UgZG9uJ3QgbmVlZCByZXBlYXQgaXQgaW4gdGhlIGRlc2NyaXB0aW9uXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gYCR7b3BlcmF0aW9uID09PSAnc2VsZWN0JyA/ICcnIDogYCR7b3BlcmF0aW9ufSR7Ym9keSA/ICcoLi4uKSAnIDogJyd9YH0ke3F1ZXJ5SXRlbXMuam9pbihcbiAgICAgICAgICAnICcsXG4gICAgICAgICl9IGZyb20oJHt0YWJsZX0pYDtcblxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICdkYi50YWJsZSc6IHRhYmxlLFxuICAgICAgICAgICdkYi5zY2hlbWEnOiB0eXBlZFRoaXMuc2NoZW1hLFxuICAgICAgICAgICdkYi51cmwnOiB0eXBlZFRoaXMudXJsLm9yaWdpbixcbiAgICAgICAgICAnZGIuc2RrJzogdHlwZWRUaGlzLmhlYWRlcnNbJ1gtQ2xpZW50LUluZm8nXSxcbiAgICAgICAgICAnZGIuc3lzdGVtJzogJ3Bvc3RncmVzcWwnLFxuICAgICAgICAgICdkYi5vcGVyYXRpb24nOiBvcGVyYXRpb24sXG4gICAgICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06ICdhdXRvLmRiLnN1cGFiYXNlJyxcbiAgICAgICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdOiAnZGInLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChxdWVyeUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXNbJ2RiLnF1ZXJ5J10gPSBxdWVyeUl0ZW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGJvZHkpLmxlbmd0aCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXNbJ2RiLmJvZHknXSA9IGJvZHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJhY2Uuc3RhcnRTcGFuKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNwYW4gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgW10pIClcbiAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzID09PSAnb2JqZWN0JyAmJiAnc3RhdHVzJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzcGFuc3RhdHVzLnNldEh0dHBTdGF0dXMoc3BhbiwgcmVzLnN0YXR1cyB8fCA1MDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKHJlcy5lcnJvci5tZXNzYWdlKSA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMuZXJyb3IuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gcmVzLmVycm9yLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5lcnJvci5kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyLmRldGFpbHMgPSByZXMuZXJyb3IuZGV0YWlscztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlQ29udGV4dCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdXBhYmFzZUNvbnRleHQucXVlcnkgPSBxdWVyeUl0ZW1zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhib2R5KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdXBhYmFzZUNvbnRleHQuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzJDEuY2FwdHVyZUV4Y2VwdGlvbihlcnIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VwYWJhc2U6IHN1cGFiYXNlQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgY29uc3QgYnJlYWRjcnVtYiA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N1cGFiYXNlJyxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGBkYi4ke29wZXJhdGlvbn1gLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5SXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucXVlcnkgPSBxdWVyeUl0ZW1zO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYm9keSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWRjcnVtYi5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnJlYWRjcnVtYnMuYWRkQnJlYWRjcnVtYihicmVhZGNydW1iKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW5zdGF0dXMuc2V0SHR0cFN0YXR1cyhzcGFuLCA1MDApO1xuICAgICAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLnRoZW4oLi4uYXJndW1lbnRzTGlzdCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgKTtcblxuICBtYXJrQXNJbnN0cnVtZW50ZWQoKFBvc3RnUkVTVEZpbHRlckJ1aWxkZXIucHJvdG90eXBlICkudGhlbik7XG59XG5cbmZ1bmN0aW9uIGluc3RydW1lbnRQb3N0Z1JFU1RRdWVyeUJ1aWxkZXIoUG9zdGdSRVNUUXVlcnlCdWlsZGVyKSB7XG4gIC8vIFdlIG5lZWQgdG8gd3JhcCBfYWxsXyBvcGVyYXRpb25zIGRlc3BpdGUgdGhlbSBzaGFyaW5nIHRoZSBzYW1lIGBQb3N0Z1JFU1RGaWx0ZXJCdWlsZGVyYFxuICAvLyBjb25zdHJ1Y3RvciwgYXMgd2UgZG9uJ3Qga25vdyB3aGljaCBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgZmlyc3QsIGFuZCB3ZSBkb24ndCB3YW50IHRvIG1pc3MgYW55IGNhbGxzLlxuICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiBEQl9PUEVSQVRJT05TX1RPX0lOU1RSVU1FTlQpIHtcbiAgICBpZiAoaXNJbnN0cnVtZW50ZWQoKFBvc3RnUkVTVFF1ZXJ5QnVpbGRlci5wcm90b3R5cGUgKVtvcGVyYXRpb25dKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgKFBvc3RnUkVTVFF1ZXJ5QnVpbGRlci5wcm90b3R5cGUgKVtvcGVyYXRpb24gXSA9IG5ldyBQcm94eShcbiAgICAgIChQb3N0Z1JFU1RRdWVyeUJ1aWxkZXIucHJvdG90eXBlIClbb3BlcmF0aW9uIF0sXG4gICAgICB7XG4gICAgICAgIGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICAgIGNvbnN0IHJ2ID0gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICAgIGNvbnN0IFBvc3RnUkVTVEZpbHRlckJ1aWxkZXIgPSAocnYgKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci5sb2coYEluc3RydW1lbnRpbmcgJHtvcGVyYXRpb259IG9wZXJhdGlvbidzIFBvc3RnUkVTVEZpbHRlckJ1aWxkZXJgKTtcblxuICAgICAgICAgIGluc3RydW1lbnRQb3N0Z1JFU1RGaWx0ZXJCdWlsZGVyKFBvc3RnUkVTVEZpbHRlckJ1aWxkZXIpO1xuXG4gICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgbWFya0FzSW5zdHJ1bWVudGVkKChQb3N0Z1JFU1RRdWVyeUJ1aWxkZXIucHJvdG90eXBlIClbb3BlcmF0aW9uXSk7XG4gIH1cbn1cblxuY29uc3QgaW5zdHJ1bWVudFN1cGFiYXNlQ2xpZW50ID0gKHN1cGFiYXNlQ2xpZW50KSA9PiB7XG4gIGlmICghc3VwYWJhc2VDbGllbnQpIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybignU3VwYWJhc2UgaW50ZWdyYXRpb24gd2FzIG5vdCBpbnN0YWxsZWQgYmVjYXVzZSBubyBTdXBhYmFzZSBjbGllbnQgd2FzIHByb3ZpZGVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBTdXBhYmFzZUNsaWVudENvbnN0cnVjdG9yID1cbiAgICBzdXBhYmFzZUNsaWVudC5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24gPyBzdXBhYmFzZUNsaWVudCA6IHN1cGFiYXNlQ2xpZW50LmNvbnN0cnVjdG9yO1xuXG4gIGluc3RydW1lbnRTdXBhYmFzZUNsaWVudENvbnN0cnVjdG9yKFN1cGFiYXNlQ2xpZW50Q29uc3RydWN0b3IpO1xuICBpbnN0cnVtZW50U3VwYWJhc2VBdXRoQ2xpZW50KHN1cGFiYXNlQ2xpZW50ICk7XG59O1xuXG5jb25zdCBJTlRFR1JBVElPTl9OQU1FID0gJ1N1cGFiYXNlJztcblxuY29uc3QgX3N1cGFiYXNlSW50ZWdyYXRpb24gPSAoKHN1cGFiYXNlQ2xpZW50KSA9PiB7XG4gIHJldHVybiB7XG4gICAgc2V0dXBPbmNlKCkge1xuICAgICAgaW5zdHJ1bWVudFN1cGFiYXNlQ2xpZW50KHN1cGFiYXNlQ2xpZW50KTtcbiAgICB9LFxuICAgIG5hbWU6IElOVEVHUkFUSU9OX05BTUUsXG4gIH07XG59KSA7XG5cbmNvbnN0IHN1cGFiYXNlSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbigob3B0aW9ucykgPT4ge1xuICByZXR1cm4gX3N1cGFiYXNlSW50ZWdyYXRpb24ob3B0aW9ucy5zdXBhYmFzZUNsaWVudCk7XG59KSA7XG5cbmV4cG9ydHMuREJfT1BFUkFUSU9OU19UT19JTlNUUlVNRU5UID0gREJfT1BFUkFUSU9OU19UT19JTlNUUlVNRU5UO1xuZXhwb3J0cy5GSUxURVJfTUFQUElOR1MgPSBGSUxURVJfTUFQUElOR1M7XG5leHBvcnRzLmV4dHJhY3RPcGVyYXRpb24gPSBleHRyYWN0T3BlcmF0aW9uO1xuZXhwb3J0cy5pbnN0cnVtZW50U3VwYWJhc2VDbGllbnQgPSBpbnN0cnVtZW50U3VwYWJhc2VDbGllbnQ7XG5leHBvcnRzLnN1cGFiYXNlSW50ZWdyYXRpb24gPSBzdXBhYmFzZUludGVncmF0aW9uO1xuZXhwb3J0cy50cmFuc2xhdGVGaWx0ZXJzSW50b01ldGhvZHMgPSB0cmFuc2xhdGVGaWx0ZXJzSW50b01ldGhvZHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdXBhYmFzZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/supabase.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/third-party-errors-filter.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js\");\nconst metadata = __webpack_require__(/*! ../metadata.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/metadata.js\");\nconst envelope = __webpack_require__(/*! ../utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\nconst stacktrace = __webpack_require__(/*! ../utils-hoist/stacktrace.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/stacktrace.js\");\n\n/**\n * This integration allows you to filter out, or tag error events that do not come from user code marked with a bundle key via the Sentry bundler plugins.\n */\nconst thirdPartyErrorFilterIntegration = integration.defineIntegration((options) => {\n  return {\n    name: 'ThirdPartyErrorsFilter',\n    setup(client) {\n      // We need to strip metadata from stack frames before sending them to Sentry since these are client side only.\n      // TODO(lforst): Move this cleanup logic into a more central place in the SDK.\n      client.on('beforeEnvelope', envelope$1 => {\n        envelope.forEachEnvelopeItem(envelope$1, (item, type) => {\n          if (type === 'event') {\n            const event = Array.isArray(item) ? (item )[1] : undefined;\n\n            if (event) {\n              metadata.stripMetadataFromStackFrames(event);\n              item[1] = event;\n            }\n          }\n        });\n      });\n\n      client.on('applyFrameMetadata', event => {\n        // Only apply stack frame metadata to error events\n        if (event.type) {\n          return;\n        }\n\n        const stackParser = client.getOptions().stackParser;\n        metadata.addMetadataToStackFrames(stackParser, event);\n      });\n    },\n\n    processEvent(event) {\n      const frameKeys = getBundleKeysForAllFramesWithFilenames(event);\n\n      if (frameKeys) {\n        const arrayMethod =\n          options.behaviour === 'drop-error-if-contains-third-party-frames' ||\n          options.behaviour === 'apply-tag-if-contains-third-party-frames'\n            ? 'some'\n            : 'every';\n\n        const behaviourApplies = frameKeys[arrayMethod](keys => !keys.some(key => options.filterKeys.includes(key)));\n\n        if (behaviourApplies) {\n          const shouldDrop =\n            options.behaviour === 'drop-error-if-contains-third-party-frames' ||\n            options.behaviour === 'drop-error-if-exclusively-contains-third-party-frames';\n          if (shouldDrop) {\n            return null;\n          } else {\n            event.tags = {\n              ...event.tags,\n              third_party_code: true,\n            };\n          }\n        }\n      }\n\n      return event;\n    },\n  };\n});\n\nfunction getBundleKeysForAllFramesWithFilenames(event) {\n  const frames = stacktrace.getFramesFromEvent(event);\n\n  if (!frames) {\n    return undefined;\n  }\n\n  return (\n    frames\n      // Exclude frames without a filename since these are likely native code or built-ins\n      .filter(frame => !!frame.filename)\n      .map(frame => {\n        if (frame.module_metadata) {\n          return Object.keys(frame.module_metadata)\n            .filter(key => key.startsWith(BUNDLER_PLUGIN_APP_KEY_PREFIX))\n            .map(key => key.slice(BUNDLER_PLUGIN_APP_KEY_PREFIX.length));\n        }\n        return [];\n      })\n  );\n}\n\nconst BUNDLER_PLUGIN_APP_KEY_PREFIX = '_sentryBundlerPluginAppKey:';\n\nexports.thirdPartyErrorFilterIntegration = thirdPartyErrorFilterIntegration;\n//# sourceMappingURL=third-party-errors-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9ucy90aGlyZC1wYXJ0eS1lcnJvcnMtZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLG9CQUFvQixtQkFBTyxDQUFDLHdIQUFtQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyxrSEFBZ0I7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsMElBQTRCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLDhJQUE4Qjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLHdDQUF3QztBQUN4QyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxpbnRlZ3JhdGlvbnNcXHRoaXJkLXBhcnR5LWVycm9ycy1maWx0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGludGVncmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZWdyYXRpb24uanMnKTtcbmNvbnN0IG1ldGFkYXRhID0gcmVxdWlyZSgnLi4vbWV0YWRhdGEuanMnKTtcbmNvbnN0IGVudmVsb3BlID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvZW52ZWxvcGUuanMnKTtcbmNvbnN0IHN0YWNrdHJhY2UgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9zdGFja3RyYWNlLmpzJyk7XG5cbi8qKlxuICogVGhpcyBpbnRlZ3JhdGlvbiBhbGxvd3MgeW91IHRvIGZpbHRlciBvdXQsIG9yIHRhZyBlcnJvciBldmVudHMgdGhhdCBkbyBub3QgY29tZSBmcm9tIHVzZXIgY29kZSBtYXJrZWQgd2l0aCBhIGJ1bmRsZSBrZXkgdmlhIHRoZSBTZW50cnkgYnVuZGxlciBwbHVnaW5zLlxuICovXG5jb25zdCB0aGlyZFBhcnR5RXJyb3JGaWx0ZXJJbnRlZ3JhdGlvbiA9IGludGVncmF0aW9uLmRlZmluZUludGVncmF0aW9uKChvcHRpb25zKSA9PiB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1RoaXJkUGFydHlFcnJvcnNGaWx0ZXInLFxuICAgIHNldHVwKGNsaWVudCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBzdHJpcCBtZXRhZGF0YSBmcm9tIHN0YWNrIGZyYW1lcyBiZWZvcmUgc2VuZGluZyB0aGVtIHRvIFNlbnRyeSBzaW5jZSB0aGVzZSBhcmUgY2xpZW50IHNpZGUgb25seS5cbiAgICAgIC8vIFRPRE8obGZvcnN0KTogTW92ZSB0aGlzIGNsZWFudXAgbG9naWMgaW50byBhIG1vcmUgY2VudHJhbCBwbGFjZSBpbiB0aGUgU0RLLlxuICAgICAgY2xpZW50Lm9uKCdiZWZvcmVFbnZlbG9wZScsIGVudmVsb3BlJDEgPT4ge1xuICAgICAgICBlbnZlbG9wZS5mb3JFYWNoRW52ZWxvcGVJdGVtKGVudmVsb3BlJDEsIChpdGVtLCB0eXBlKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdldmVudCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gQXJyYXkuaXNBcnJheShpdGVtKSA/IChpdGVtIClbMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICBtZXRhZGF0YS5zdHJpcE1ldGFkYXRhRnJvbVN0YWNrRnJhbWVzKGV2ZW50KTtcbiAgICAgICAgICAgICAgaXRlbVsxXSA9IGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgY2xpZW50Lm9uKCdhcHBseUZyYW1lTWV0YWRhdGEnLCBldmVudCA9PiB7XG4gICAgICAgIC8vIE9ubHkgYXBwbHkgc3RhY2sgZnJhbWUgbWV0YWRhdGEgdG8gZXJyb3IgZXZlbnRzXG4gICAgICAgIGlmIChldmVudC50eXBlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhY2tQYXJzZXIgPSBjbGllbnQuZ2V0T3B0aW9ucygpLnN0YWNrUGFyc2VyO1xuICAgICAgICBtZXRhZGF0YS5hZGRNZXRhZGF0YVRvU3RhY2tGcmFtZXMoc3RhY2tQYXJzZXIsIGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzRXZlbnQoZXZlbnQpIHtcbiAgICAgIGNvbnN0IGZyYW1lS2V5cyA9IGdldEJ1bmRsZUtleXNGb3JBbGxGcmFtZXNXaXRoRmlsZW5hbWVzKGV2ZW50KTtcblxuICAgICAgaWYgKGZyYW1lS2V5cykge1xuICAgICAgICBjb25zdCBhcnJheU1ldGhvZCA9XG4gICAgICAgICAgb3B0aW9ucy5iZWhhdmlvdXIgPT09ICdkcm9wLWVycm9yLWlmLWNvbnRhaW5zLXRoaXJkLXBhcnR5LWZyYW1lcycgfHxcbiAgICAgICAgICBvcHRpb25zLmJlaGF2aW91ciA9PT0gJ2FwcGx5LXRhZy1pZi1jb250YWlucy10aGlyZC1wYXJ0eS1mcmFtZXMnXG4gICAgICAgICAgICA/ICdzb21lJ1xuICAgICAgICAgICAgOiAnZXZlcnknO1xuXG4gICAgICAgIGNvbnN0IGJlaGF2aW91ckFwcGxpZXMgPSBmcmFtZUtleXNbYXJyYXlNZXRob2RdKGtleXMgPT4gIWtleXMuc29tZShrZXkgPT4gb3B0aW9ucy5maWx0ZXJLZXlzLmluY2x1ZGVzKGtleSkpKTtcblxuICAgICAgICBpZiAoYmVoYXZpb3VyQXBwbGllcykge1xuICAgICAgICAgIGNvbnN0IHNob3VsZERyb3AgPVxuICAgICAgICAgICAgb3B0aW9ucy5iZWhhdmlvdXIgPT09ICdkcm9wLWVycm9yLWlmLWNvbnRhaW5zLXRoaXJkLXBhcnR5LWZyYW1lcycgfHxcbiAgICAgICAgICAgIG9wdGlvbnMuYmVoYXZpb3VyID09PSAnZHJvcC1lcnJvci1pZi1leGNsdXNpdmVseS1jb250YWlucy10aGlyZC1wYXJ0eS1mcmFtZXMnO1xuICAgICAgICAgIGlmIChzaG91bGREcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnQudGFncyA9IHtcbiAgICAgICAgICAgICAgLi4uZXZlbnQudGFncyxcbiAgICAgICAgICAgICAgdGhpcmRfcGFydHlfY29kZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9LFxuICB9O1xufSk7XG5cbmZ1bmN0aW9uIGdldEJ1bmRsZUtleXNGb3JBbGxGcmFtZXNXaXRoRmlsZW5hbWVzKGV2ZW50KSB7XG4gIGNvbnN0IGZyYW1lcyA9IHN0YWNrdHJhY2UuZ2V0RnJhbWVzRnJvbUV2ZW50KGV2ZW50KTtcblxuICBpZiAoIWZyYW1lcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIGZyYW1lc1xuICAgICAgLy8gRXhjbHVkZSBmcmFtZXMgd2l0aG91dCBhIGZpbGVuYW1lIHNpbmNlIHRoZXNlIGFyZSBsaWtlbHkgbmF0aXZlIGNvZGUgb3IgYnVpbHQtaW5zXG4gICAgICAuZmlsdGVyKGZyYW1lID0+ICEhZnJhbWUuZmlsZW5hbWUpXG4gICAgICAubWFwKGZyYW1lID0+IHtcbiAgICAgICAgaWYgKGZyYW1lLm1vZHVsZV9tZXRhZGF0YSkge1xuICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhmcmFtZS5tb2R1bGVfbWV0YWRhdGEpXG4gICAgICAgICAgICAuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aChCVU5ETEVSX1BMVUdJTl9BUFBfS0VZX1BSRUZJWCkpXG4gICAgICAgICAgICAubWFwKGtleSA9PiBrZXkuc2xpY2UoQlVORExFUl9QTFVHSU5fQVBQX0tFWV9QUkVGSVgubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSlcbiAgKTtcbn1cblxuY29uc3QgQlVORExFUl9QTFVHSU5fQVBQX0tFWV9QUkVGSVggPSAnX3NlbnRyeUJ1bmRsZXJQbHVnaW5BcHBLZXk6JztcblxuZXhwb3J0cy50aGlyZFBhcnR5RXJyb3JGaWx0ZXJJbnRlZ3JhdGlvbiA9IHRoaXJkUGFydHlFcnJvckZpbHRlckludGVncmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhpcmQtcGFydHktZXJyb3JzLWZpbHRlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/third-party-errors-filter.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/zoderrors.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js\");\nconst is = __webpack_require__(/*! ../utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst string = __webpack_require__(/*! ../utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\n\nconst DEFAULT_LIMIT = 10;\nconst INTEGRATION_NAME = 'ZodErrors';\n\n/**\n * Simplified ZodIssue type definition\n */\n\nfunction originalExceptionIsZodError(originalException) {\n  return (\n    is.isError(originalException) &&\n    originalException.name === 'ZodError' &&\n    Array.isArray((originalException ).issues)\n  );\n}\n\n/**\n * Formats child objects or arrays to a string\n * that is preserved when sent to Sentry.\n *\n * Without this, we end up with something like this in Sentry:\n *\n * [\n *  [Object],\n *  [Object],\n *  [Object],\n *  [Object]\n * ]\n */\nfunction flattenIssue(issue) {\n  return {\n    ...issue,\n    path: 'path' in issue && Array.isArray(issue.path) ? issue.path.join('.') : undefined,\n    keys: 'keys' in issue ? JSON.stringify(issue.keys) : undefined,\n    unionErrors: 'unionErrors' in issue ? JSON.stringify(issue.unionErrors) : undefined,\n  };\n}\n\n/**\n * Takes ZodError issue path array and returns a flattened version as a string.\n * This makes it easier to display paths within a Sentry error message.\n *\n * Array indexes are normalized to reduce duplicate entries\n *\n * @param path ZodError issue path\n * @returns flattened path\n *\n * @example\n * flattenIssuePath([0, 'foo', 1, 'bar']) // -> '<array>.foo.<array>.bar'\n */\nfunction flattenIssuePath(path) {\n  return path\n    .map(p => {\n      if (typeof p === 'number') {\n        return '<array>';\n      } else {\n        return p;\n      }\n    })\n    .join('.');\n}\n\n/**\n * Zod error message is a stringified version of ZodError.issues\n * This doesn't display well in the Sentry UI. Replace it with something shorter.\n */\nfunction formatIssueMessage(zodError) {\n  const errorKeyMap = new Set();\n  for (const iss of zodError.issues) {\n    const issuePath = flattenIssuePath(iss.path);\n    if (issuePath.length > 0) {\n      errorKeyMap.add(issuePath);\n    }\n  }\n\n  const errorKeys = Array.from(errorKeyMap);\n  if (errorKeys.length === 0) {\n    // If there are no keys, then we're likely validating the root\n    // variable rather than a key within an object. This attempts\n    // to extract what type it was that failed to validate.\n    // For example, z.string().parse(123) would return \"string\" here.\n    let rootExpectedType = 'variable';\n    if (zodError.issues.length > 0) {\n      const iss = zodError.issues[0];\n      if (iss !== undefined && 'expected' in iss && typeof iss.expected === 'string') {\n        rootExpectedType = iss.expected;\n      }\n    }\n    return `Failed to validate ${rootExpectedType}`;\n  }\n  return `Failed to validate keys: ${string.truncate(errorKeys.join(', '), 100)}`;\n}\n\n/**\n * Applies ZodError issues to an event extra and replaces the error message\n */\nfunction applyZodErrorsToEvent(\n  limit,\n  saveZodIssuesAsAttachment = false,\n  event,\n  hint,\n) {\n  if (\n    !event.exception?.values ||\n    !hint.originalException ||\n    !originalExceptionIsZodError(hint.originalException) ||\n    hint.originalException.issues.length === 0\n  ) {\n    return event;\n  }\n\n  try {\n    const issuesToFlatten = saveZodIssuesAsAttachment\n      ? hint.originalException.issues\n      : hint.originalException.issues.slice(0, limit);\n    const flattenedIssues = issuesToFlatten.map(flattenIssue);\n\n    if (saveZodIssuesAsAttachment) {\n      // Sometimes having the full error details can be helpful.\n      // Attachments have much higher limits, so we can include the full list of issues.\n      if (!Array.isArray(hint.attachments)) {\n        hint.attachments = [];\n      }\n      hint.attachments.push({\n        filename: 'zod_issues.json',\n        data: JSON.stringify({\n          issues: flattenedIssues,\n        }),\n      });\n    }\n\n    return {\n      ...event,\n      exception: {\n        ...event.exception,\n        values: [\n          {\n            ...event.exception.values[0],\n            value: formatIssueMessage(hint.originalException),\n          },\n          ...event.exception.values.slice(1),\n        ],\n      },\n      extra: {\n        ...event.extra,\n        'zoderror.issues': flattenedIssues.slice(0, limit),\n      },\n    };\n  } catch (e) {\n    // Hopefully we never throw errors here, but record it\n    // with the event just in case.\n    return {\n      ...event,\n      extra: {\n        ...event.extra,\n        'zoderrors sentry integration parse error': {\n          message: 'an exception was thrown while processing ZodError within applyZodErrorsToEvent()',\n          error: e instanceof Error ? `${e.name}: ${e.message}\\n${e.stack}` : 'unknown',\n        },\n      },\n    };\n  }\n}\n\nconst _zodErrorsIntegration = ((options = {}) => {\n  const limit = options.limit ?? DEFAULT_LIMIT;\n\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(originalEvent, hint) {\n      const processedEvent = applyZodErrorsToEvent(limit, options.saveZodIssuesAsAttachment, originalEvent, hint);\n      return processedEvent;\n    },\n  };\n}) ;\n\n/**\n * Sentry integration to process Zod errors, making them easier to work with in Sentry.\n */\nconst zodErrorsIntegration = integration.defineIntegration(_zodErrorsIntegration);\n\nexports.applyZodErrorsToEvent = applyZodErrorsToEvent;\nexports.flattenIssue = flattenIssue;\nexports.flattenIssuePath = flattenIssuePath;\nexports.formatIssueMessage = formatIssueMessage;\nexports.zodErrorsIntegration = zodErrorsIntegration;\n//# sourceMappingURL=zoderrors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2ludGVncmF0aW9ucy96b2RlcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsb0JBQW9CLG1CQUFPLENBQUMsd0hBQW1CO0FBQy9DLFdBQVcsbUJBQU8sQ0FBQyw4SEFBc0I7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHNJQUEwQjs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQSxxQ0FBcUMsMkNBQTJDO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU8sSUFBSSxVQUFVLElBQUksUUFBUTtBQUMxRSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxpbnRlZ3JhdGlvbnNcXHpvZGVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgaW50ZWdyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlZ3JhdGlvbi5qcycpO1xuY29uc3QgaXMgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9pcy5qcycpO1xuY29uc3Qgc3RyaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvc3RyaW5nLmpzJyk7XG5cbmNvbnN0IERFRkFVTFRfTElNSVQgPSAxMDtcbmNvbnN0IElOVEVHUkFUSU9OX05BTUUgPSAnWm9kRXJyb3JzJztcblxuLyoqXG4gKiBTaW1wbGlmaWVkIFpvZElzc3VlIHR5cGUgZGVmaW5pdGlvblxuICovXG5cbmZ1bmN0aW9uIG9yaWdpbmFsRXhjZXB0aW9uSXNab2RFcnJvcihvcmlnaW5hbEV4Y2VwdGlvbikge1xuICByZXR1cm4gKFxuICAgIGlzLmlzRXJyb3Iob3JpZ2luYWxFeGNlcHRpb24pICYmXG4gICAgb3JpZ2luYWxFeGNlcHRpb24ubmFtZSA9PT0gJ1pvZEVycm9yJyAmJlxuICAgIEFycmF5LmlzQXJyYXkoKG9yaWdpbmFsRXhjZXB0aW9uICkuaXNzdWVzKVxuICApO1xufVxuXG4vKipcbiAqIEZvcm1hdHMgY2hpbGQgb2JqZWN0cyBvciBhcnJheXMgdG8gYSBzdHJpbmdcbiAqIHRoYXQgaXMgcHJlc2VydmVkIHdoZW4gc2VudCB0byBTZW50cnkuXG4gKlxuICogV2l0aG91dCB0aGlzLCB3ZSBlbmQgdXAgd2l0aCBzb21ldGhpbmcgbGlrZSB0aGlzIGluIFNlbnRyeTpcbiAqXG4gKiBbXG4gKiAgW09iamVjdF0sXG4gKiAgW09iamVjdF0sXG4gKiAgW09iamVjdF0sXG4gKiAgW09iamVjdF1cbiAqIF1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbklzc3VlKGlzc3VlKSB7XG4gIHJldHVybiB7XG4gICAgLi4uaXNzdWUsXG4gICAgcGF0aDogJ3BhdGgnIGluIGlzc3VlICYmIEFycmF5LmlzQXJyYXkoaXNzdWUucGF0aCkgPyBpc3N1ZS5wYXRoLmpvaW4oJy4nKSA6IHVuZGVmaW5lZCxcbiAgICBrZXlzOiAna2V5cycgaW4gaXNzdWUgPyBKU09OLnN0cmluZ2lmeShpc3N1ZS5rZXlzKSA6IHVuZGVmaW5lZCxcbiAgICB1bmlvbkVycm9yczogJ3VuaW9uRXJyb3JzJyBpbiBpc3N1ZSA/IEpTT04uc3RyaW5naWZ5KGlzc3VlLnVuaW9uRXJyb3JzKSA6IHVuZGVmaW5lZCxcbiAgfTtcbn1cblxuLyoqXG4gKiBUYWtlcyBab2RFcnJvciBpc3N1ZSBwYXRoIGFycmF5IGFuZCByZXR1cm5zIGEgZmxhdHRlbmVkIHZlcnNpb24gYXMgYSBzdHJpbmcuXG4gKiBUaGlzIG1ha2VzIGl0IGVhc2llciB0byBkaXNwbGF5IHBhdGhzIHdpdGhpbiBhIFNlbnRyeSBlcnJvciBtZXNzYWdlLlxuICpcbiAqIEFycmF5IGluZGV4ZXMgYXJlIG5vcm1hbGl6ZWQgdG8gcmVkdWNlIGR1cGxpY2F0ZSBlbnRyaWVzXG4gKlxuICogQHBhcmFtIHBhdGggWm9kRXJyb3IgaXNzdWUgcGF0aFxuICogQHJldHVybnMgZmxhdHRlbmVkIHBhdGhcbiAqXG4gKiBAZXhhbXBsZVxuICogZmxhdHRlbklzc3VlUGF0aChbMCwgJ2ZvbycsIDEsICdiYXInXSkgLy8gLT4gJzxhcnJheT4uZm9vLjxhcnJheT4uYmFyJ1xuICovXG5mdW5jdGlvbiBmbGF0dGVuSXNzdWVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGhcbiAgICAubWFwKHAgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gJzxhcnJheT4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG4gICAgfSlcbiAgICAuam9pbignLicpO1xufVxuXG4vKipcbiAqIFpvZCBlcnJvciBtZXNzYWdlIGlzIGEgc3RyaW5naWZpZWQgdmVyc2lvbiBvZiBab2RFcnJvci5pc3N1ZXNcbiAqIFRoaXMgZG9lc24ndCBkaXNwbGF5IHdlbGwgaW4gdGhlIFNlbnRyeSBVSS4gUmVwbGFjZSBpdCB3aXRoIHNvbWV0aGluZyBzaG9ydGVyLlxuICovXG5mdW5jdGlvbiBmb3JtYXRJc3N1ZU1lc3NhZ2Uoem9kRXJyb3IpIHtcbiAgY29uc3QgZXJyb3JLZXlNYXAgPSBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgaXNzIG9mIHpvZEVycm9yLmlzc3Vlcykge1xuICAgIGNvbnN0IGlzc3VlUGF0aCA9IGZsYXR0ZW5Jc3N1ZVBhdGgoaXNzLnBhdGgpO1xuICAgIGlmIChpc3N1ZVBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgZXJyb3JLZXlNYXAuYWRkKGlzc3VlUGF0aCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZXJyb3JLZXlzID0gQXJyYXkuZnJvbShlcnJvcktleU1hcCk7XG4gIGlmIChlcnJvcktleXMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGtleXMsIHRoZW4gd2UncmUgbGlrZWx5IHZhbGlkYXRpbmcgdGhlIHJvb3RcbiAgICAvLyB2YXJpYWJsZSByYXRoZXIgdGhhbiBhIGtleSB3aXRoaW4gYW4gb2JqZWN0LiBUaGlzIGF0dGVtcHRzXG4gICAgLy8gdG8gZXh0cmFjdCB3aGF0IHR5cGUgaXQgd2FzIHRoYXQgZmFpbGVkIHRvIHZhbGlkYXRlLlxuICAgIC8vIEZvciBleGFtcGxlLCB6LnN0cmluZygpLnBhcnNlKDEyMykgd291bGQgcmV0dXJuIFwic3RyaW5nXCIgaGVyZS5cbiAgICBsZXQgcm9vdEV4cGVjdGVkVHlwZSA9ICd2YXJpYWJsZSc7XG4gICAgaWYgKHpvZEVycm9yLmlzc3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBpc3MgPSB6b2RFcnJvci5pc3N1ZXNbMF07XG4gICAgICBpZiAoaXNzICE9PSB1bmRlZmluZWQgJiYgJ2V4cGVjdGVkJyBpbiBpc3MgJiYgdHlwZW9mIGlzcy5leHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcm9vdEV4cGVjdGVkVHlwZSA9IGlzcy5leHBlY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGBGYWlsZWQgdG8gdmFsaWRhdGUgJHtyb290RXhwZWN0ZWRUeXBlfWA7XG4gIH1cbiAgcmV0dXJuIGBGYWlsZWQgdG8gdmFsaWRhdGUga2V5czogJHtzdHJpbmcudHJ1bmNhdGUoZXJyb3JLZXlzLmpvaW4oJywgJyksIDEwMCl9YDtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIFpvZEVycm9yIGlzc3VlcyB0byBhbiBldmVudCBleHRyYSBhbmQgcmVwbGFjZXMgdGhlIGVycm9yIG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gYXBwbHlab2RFcnJvcnNUb0V2ZW50KFxuICBsaW1pdCxcbiAgc2F2ZVpvZElzc3Vlc0FzQXR0YWNobWVudCA9IGZhbHNlLFxuICBldmVudCxcbiAgaGludCxcbikge1xuICBpZiAoXG4gICAgIWV2ZW50LmV4Y2VwdGlvbj8udmFsdWVzIHx8XG4gICAgIWhpbnQub3JpZ2luYWxFeGNlcHRpb24gfHxcbiAgICAhb3JpZ2luYWxFeGNlcHRpb25Jc1pvZEVycm9yKGhpbnQub3JpZ2luYWxFeGNlcHRpb24pIHx8XG4gICAgaGludC5vcmlnaW5hbEV4Y2VwdGlvbi5pc3N1ZXMubGVuZ3RoID09PSAwXG4gICkge1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgaXNzdWVzVG9GbGF0dGVuID0gc2F2ZVpvZElzc3Vlc0FzQXR0YWNobWVudFxuICAgICAgPyBoaW50Lm9yaWdpbmFsRXhjZXB0aW9uLmlzc3Vlc1xuICAgICAgOiBoaW50Lm9yaWdpbmFsRXhjZXB0aW9uLmlzc3Vlcy5zbGljZSgwLCBsaW1pdCk7XG4gICAgY29uc3QgZmxhdHRlbmVkSXNzdWVzID0gaXNzdWVzVG9GbGF0dGVuLm1hcChmbGF0dGVuSXNzdWUpO1xuXG4gICAgaWYgKHNhdmVab2RJc3N1ZXNBc0F0dGFjaG1lbnQpIHtcbiAgICAgIC8vIFNvbWV0aW1lcyBoYXZpbmcgdGhlIGZ1bGwgZXJyb3IgZGV0YWlscyBjYW4gYmUgaGVscGZ1bC5cbiAgICAgIC8vIEF0dGFjaG1lbnRzIGhhdmUgbXVjaCBoaWdoZXIgbGltaXRzLCBzbyB3ZSBjYW4gaW5jbHVkZSB0aGUgZnVsbCBsaXN0IG9mIGlzc3Vlcy5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShoaW50LmF0dGFjaG1lbnRzKSkge1xuICAgICAgICBoaW50LmF0dGFjaG1lbnRzID0gW107XG4gICAgICB9XG4gICAgICBoaW50LmF0dGFjaG1lbnRzLnB1c2goe1xuICAgICAgICBmaWxlbmFtZTogJ3pvZF9pc3N1ZXMuanNvbicsXG4gICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpc3N1ZXM6IGZsYXR0ZW5lZElzc3VlcyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZXZlbnQsXG4gICAgICBleGNlcHRpb246IHtcbiAgICAgICAgLi4uZXZlbnQuZXhjZXB0aW9uLFxuICAgICAgICB2YWx1ZXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5ldmVudC5leGNlcHRpb24udmFsdWVzWzBdLFxuICAgICAgICAgICAgdmFsdWU6IGZvcm1hdElzc3VlTWVzc2FnZShoaW50Lm9yaWdpbmFsRXhjZXB0aW9uKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIC4uLmV2ZW50LmV4Y2VwdGlvbi52YWx1ZXMuc2xpY2UoMSksXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAgZXh0cmE6IHtcbiAgICAgICAgLi4uZXZlbnQuZXh0cmEsXG4gICAgICAgICd6b2RlcnJvci5pc3N1ZXMnOiBmbGF0dGVuZWRJc3N1ZXMuc2xpY2UoMCwgbGltaXQpLFxuICAgICAgfSxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSG9wZWZ1bGx5IHdlIG5ldmVyIHRocm93IGVycm9ycyBoZXJlLCBidXQgcmVjb3JkIGl0XG4gICAgLy8gd2l0aCB0aGUgZXZlbnQganVzdCBpbiBjYXNlLlxuICAgIHJldHVybiB7XG4gICAgICAuLi5ldmVudCxcbiAgICAgIGV4dHJhOiB7XG4gICAgICAgIC4uLmV2ZW50LmV4dHJhLFxuICAgICAgICAnem9kZXJyb3JzIHNlbnRyeSBpbnRlZ3JhdGlvbiBwYXJzZSBlcnJvcic6IHtcbiAgICAgICAgICBtZXNzYWdlOiAnYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24gd2hpbGUgcHJvY2Vzc2luZyBab2RFcnJvciB3aXRoaW4gYXBwbHlab2RFcnJvcnNUb0V2ZW50KCknLFxuICAgICAgICAgIGVycm9yOiBlIGluc3RhbmNlb2YgRXJyb3IgPyBgJHtlLm5hbWV9OiAke2UubWVzc2FnZX1cXG4ke2Uuc3RhY2t9YCA6ICd1bmtub3duJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuXG5jb25zdCBfem9kRXJyb3JzSW50ZWdyYXRpb24gPSAoKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBsaW1pdCA9IG9wdGlvbnMubGltaXQgPz8gREVGQVVMVF9MSU1JVDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IElOVEVHUkFUSU9OX05BTUUsXG4gICAgcHJvY2Vzc0V2ZW50KG9yaWdpbmFsRXZlbnQsIGhpbnQpIHtcbiAgICAgIGNvbnN0IHByb2Nlc3NlZEV2ZW50ID0gYXBwbHlab2RFcnJvcnNUb0V2ZW50KGxpbWl0LCBvcHRpb25zLnNhdmVab2RJc3N1ZXNBc0F0dGFjaG1lbnQsIG9yaWdpbmFsRXZlbnQsIGhpbnQpO1xuICAgICAgcmV0dXJuIHByb2Nlc3NlZEV2ZW50O1xuICAgIH0sXG4gIH07XG59KSA7XG5cbi8qKlxuICogU2VudHJ5IGludGVncmF0aW9uIHRvIHByb2Nlc3MgWm9kIGVycm9ycywgbWFraW5nIHRoZW0gZWFzaWVyIHRvIHdvcmsgd2l0aCBpbiBTZW50cnkuXG4gKi9cbmNvbnN0IHpvZEVycm9yc0ludGVncmF0aW9uID0gaW50ZWdyYXRpb24uZGVmaW5lSW50ZWdyYXRpb24oX3pvZEVycm9yc0ludGVncmF0aW9uKTtcblxuZXhwb3J0cy5hcHBseVpvZEVycm9yc1RvRXZlbnQgPSBhcHBseVpvZEVycm9yc1RvRXZlbnQ7XG5leHBvcnRzLmZsYXR0ZW5Jc3N1ZSA9IGZsYXR0ZW5Jc3N1ZTtcbmV4cG9ydHMuZmxhdHRlbklzc3VlUGF0aCA9IGZsYXR0ZW5Jc3N1ZVBhdGg7XG5leHBvcnRzLmZvcm1hdElzc3VlTWVzc2FnZSA9IGZvcm1hdElzc3VlTWVzc2FnZTtcbmV4cG9ydHMuem9kRXJyb3JzSW50ZWdyYXRpb24gPSB6b2RFcnJvcnNJbnRlZ3JhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXpvZGVycm9ycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integrations/zoderrors.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/console-integration.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/integration.js\");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\nconst console = __webpack_require__(/*! ../utils-hoist/instrument/console.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/console.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst string = __webpack_require__(/*! ../utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\nconst worldwide = __webpack_require__(/*! ../utils-hoist/worldwide.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js\");\nconst exports$1 = __webpack_require__(/*! ./exports.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/exports.js\");\n\nconst INTEGRATION_NAME = 'ConsoleLogs';\n\nconst DEFAULT_ATTRIBUTES = {\n  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.console.logging',\n};\n\nconst _consoleLoggingIntegration = ((options = {}) => {\n  const levels = options.levels || logger.CONSOLE_LEVELS;\n\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      if (!client.getOptions()._experiments?.enableLogs) {\n        debugBuild.DEBUG_BUILD && logger.logger.warn('`_experiments.enableLogs` is not enabled, ConsoleLogs integration disabled');\n        return;\n      }\n\n      console.addConsoleInstrumentationHandler(({ args, level }) => {\n        if (currentScopes.getClient() !== client || !levels.includes(level)) {\n          return;\n        }\n\n        if (level === 'assert') {\n          if (!args[0]) {\n            const followingArgs = args.slice(1);\n            const message =\n              followingArgs.length > 0 ? `Assertion failed: ${formatConsoleArgs(followingArgs)}` : 'Assertion failed';\n            exports$1._INTERNAL_captureLog({ level: 'error', message, attributes: DEFAULT_ATTRIBUTES });\n          }\n          return;\n        }\n\n        const isLevelLog = level === 'log';\n        exports$1._INTERNAL_captureLog({\n          level: isLevelLog ? 'info' : level,\n          message: formatConsoleArgs(args),\n          severityNumber: isLevelLog ? 10 : undefined,\n          attributes: DEFAULT_ATTRIBUTES,\n        });\n      });\n    },\n  };\n}) ;\n\n/**\n * Captures calls to the `console` API as logs in Sentry. Requires `_experiments.enableLogs` to be enabled.\n *\n * @experimental This feature is experimental and may be changed or removed in future versions.\n *\n * By default the integration instruments `console.debug`, `console.info`, `console.warn`, `console.error`,\n * `console.log`, `console.trace`, and `console.assert`. You can use the `levels` option to customize which\n * levels are captured.\n *\n * @example\n *\n * ```ts\n * import * as Sentry from '@sentry/browser';\n *\n * Sentry.init({\n *   integrations: [Sentry.consoleLoggingIntegration({ levels: ['error', 'warn'] })],\n * });\n * ```\n */\nconst consoleLoggingIntegration = integration.defineIntegration(_consoleLoggingIntegration);\n\nfunction formatConsoleArgs(values) {\n  return 'util' in worldwide.GLOBAL_OBJ && typeof (worldwide.GLOBAL_OBJ ).util.format === 'function'\n    ? (worldwide.GLOBAL_OBJ ).util.format(...values)\n    : string.safeJoin(values, ' ');\n}\n\nexports.consoleLoggingIntegration = consoleLoggingIntegration;\n//# sourceMappingURL=console-integration.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2xvZ3MvY29uc29sZS1pbnRlZ3JhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxzQkFBc0IsbUJBQU8sQ0FBQyw0SEFBcUI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsd0hBQW1CO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLHdIQUFtQjtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyxzSUFBMEI7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsOEpBQXNDO0FBQzlELGVBQWUsbUJBQU8sQ0FBQyxzSUFBMEI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLHNJQUEwQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyw0SUFBNkI7QUFDdkQsa0JBQWtCLG1CQUFPLENBQUMsb0hBQWM7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGlDQUFpQztBQUMvRiw2Q0FBNkMseURBQXlEO0FBQ3RHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDJCQUEyQjtBQUNsRixJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGxvZ3NcXGNvbnNvbGUtaW50ZWdyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IGludGVncmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZWdyYXRpb24uanMnKTtcbmNvbnN0IHNlbWFudGljQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4uL3NlbWFudGljQXR0cmlidXRlcy5qcycpO1xuY29uc3QgY29uc29sZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2luc3RydW1lbnQvY29uc29sZS5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCBzdHJpbmcgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9zdHJpbmcuanMnKTtcbmNvbnN0IHdvcmxkd2lkZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3dvcmxkd2lkZS5qcycpO1xuY29uc3QgZXhwb3J0cyQxID0gcmVxdWlyZSgnLi9leHBvcnRzLmpzJyk7XG5cbmNvbnN0IElOVEVHUkFUSU9OX05BTUUgPSAnQ29uc29sZUxvZ3MnO1xuXG5jb25zdCBERUZBVUxUX0FUVFJJQlVURVMgPSB7XG4gIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnYXV0by5jb25zb2xlLmxvZ2dpbmcnLFxufTtcblxuY29uc3QgX2NvbnNvbGVMb2dnaW5nSW50ZWdyYXRpb24gPSAoKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBsZXZlbHMgPSBvcHRpb25zLmxldmVscyB8fCBsb2dnZXIuQ09OU09MRV9MRVZFTFM7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHNldHVwKGNsaWVudCkge1xuICAgICAgaWYgKCFjbGllbnQuZ2V0T3B0aW9ucygpLl9leHBlcmltZW50cz8uZW5hYmxlTG9ncykge1xuICAgICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybignYF9leHBlcmltZW50cy5lbmFibGVMb2dzYCBpcyBub3QgZW5hYmxlZCwgQ29uc29sZUxvZ3MgaW50ZWdyYXRpb24gZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmFkZENvbnNvbGVJbnN0cnVtZW50YXRpb25IYW5kbGVyKCh7IGFyZ3MsIGxldmVsIH0pID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCkgIT09IGNsaWVudCB8fCAhbGV2ZWxzLmluY2x1ZGVzKGxldmVsKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXZlbCA9PT0gJ2Fzc2VydCcpIHtcbiAgICAgICAgICBpZiAoIWFyZ3NbMF0pIHtcbiAgICAgICAgICAgIGNvbnN0IGZvbGxvd2luZ0FyZ3MgPSBhcmdzLnNsaWNlKDEpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgICAgIGZvbGxvd2luZ0FyZ3MubGVuZ3RoID4gMCA/IGBBc3NlcnRpb24gZmFpbGVkOiAke2Zvcm1hdENvbnNvbGVBcmdzKGZvbGxvd2luZ0FyZ3MpfWAgOiAnQXNzZXJ0aW9uIGZhaWxlZCc7XG4gICAgICAgICAgICBleHBvcnRzJDEuX0lOVEVSTkFMX2NhcHR1cmVMb2coeyBsZXZlbDogJ2Vycm9yJywgbWVzc2FnZSwgYXR0cmlidXRlczogREVGQVVMVF9BVFRSSUJVVEVTIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0xldmVsTG9nID0gbGV2ZWwgPT09ICdsb2cnO1xuICAgICAgICBleHBvcnRzJDEuX0lOVEVSTkFMX2NhcHR1cmVMb2coe1xuICAgICAgICAgIGxldmVsOiBpc0xldmVsTG9nID8gJ2luZm8nIDogbGV2ZWwsXG4gICAgICAgICAgbWVzc2FnZTogZm9ybWF0Q29uc29sZUFyZ3MoYXJncyksXG4gICAgICAgICAgc2V2ZXJpdHlOdW1iZXI6IGlzTGV2ZWxMb2cgPyAxMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBERUZBVUxUX0FUVFJJQlVURVMsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfTtcbn0pIDtcblxuLyoqXG4gKiBDYXB0dXJlcyBjYWxscyB0byB0aGUgYGNvbnNvbGVgIEFQSSBhcyBsb2dzIGluIFNlbnRyeS4gUmVxdWlyZXMgYF9leHBlcmltZW50cy5lbmFibGVMb2dzYCB0byBiZSBlbmFibGVkLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBmZWF0dXJlIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGJlIGNoYW5nZWQgb3IgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMuXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgaW50ZWdyYXRpb24gaW5zdHJ1bWVudHMgYGNvbnNvbGUuZGVidWdgLCBgY29uc29sZS5pbmZvYCwgYGNvbnNvbGUud2FybmAsIGBjb25zb2xlLmVycm9yYCxcbiAqIGBjb25zb2xlLmxvZ2AsIGBjb25zb2xlLnRyYWNlYCwgYW5kIGBjb25zb2xlLmFzc2VydGAuIFlvdSBjYW4gdXNlIHRoZSBgbGV2ZWxzYCBvcHRpb24gdG8gY3VzdG9taXplIHdoaWNoXG4gKiBsZXZlbHMgYXJlIGNhcHR1cmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCAqIGFzIFNlbnRyeSBmcm9tICdAc2VudHJ5L2Jyb3dzZXInO1xuICpcbiAqIFNlbnRyeS5pbml0KHtcbiAqICAgaW50ZWdyYXRpb25zOiBbU2VudHJ5LmNvbnNvbGVMb2dnaW5nSW50ZWdyYXRpb24oeyBsZXZlbHM6IFsnZXJyb3InLCAnd2FybiddIH0pXSxcbiAqIH0pO1xuICogYGBgXG4gKi9cbmNvbnN0IGNvbnNvbGVMb2dnaW5nSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbihfY29uc29sZUxvZ2dpbmdJbnRlZ3JhdGlvbik7XG5cbmZ1bmN0aW9uIGZvcm1hdENvbnNvbGVBcmdzKHZhbHVlcykge1xuICByZXR1cm4gJ3V0aWwnIGluIHdvcmxkd2lkZS5HTE9CQUxfT0JKICYmIHR5cGVvZiAod29ybGR3aWRlLkdMT0JBTF9PQkogKS51dGlsLmZvcm1hdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gKHdvcmxkd2lkZS5HTE9CQUxfT0JKICkudXRpbC5mb3JtYXQoLi4udmFsdWVzKVxuICAgIDogc3RyaW5nLnNhZmVKb2luKHZhbHVlcywgJyAnKTtcbn1cblxuZXhwb3J0cy5jb25zb2xlTG9nZ2luZ0ludGVncmF0aW9uID0gY29uc29sZUxvZ2dpbmdJbnRlZ3JhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnNvbGUtaW50ZWdyYXRpb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/console-integration.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/constants.js":(__unused_webpack_module,exports)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\n/**\n * Maps a log severity level to a log severity number.\n *\n * @see LogSeverityLevel\n */\nconst SEVERITY_TEXT_TO_SEVERITY_NUMBER = {\n  trace: 1,\n  debug: 5,\n  info: 9,\n  warn: 13,\n  error: 17,\n  fatal: 21,\n};\n\nexports.SEVERITY_TEXT_TO_SEVERITY_NUMBER = SEVERITY_TEXT_TO_SEVERITY_NUMBER;\n//# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2xvZ3MvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxsb2dzXFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbi8qKlxuICogTWFwcyBhIGxvZyBzZXZlcml0eSBsZXZlbCB0byBhIGxvZyBzZXZlcml0eSBudW1iZXIuXG4gKlxuICogQHNlZSBMb2dTZXZlcml0eUxldmVsXG4gKi9cbmNvbnN0IFNFVkVSSVRZX1RFWFRfVE9fU0VWRVJJVFlfTlVNQkVSID0ge1xuICB0cmFjZTogMSxcbiAgZGVidWc6IDUsXG4gIGluZm86IDksXG4gIHdhcm46IDEzLFxuICBlcnJvcjogMTcsXG4gIGZhdGFsOiAyMSxcbn07XG5cbmV4cG9ydHMuU0VWRVJJVFlfVEVYVF9UT19TRVZFUklUWV9OVU1CRVIgPSBTRVZFUklUWV9URVhUX1RPX1NFVkVSSVRZX05VTUJFUjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/constants.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/envelope.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst dsn = __webpack_require__(/*! ../utils-hoist/dsn.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/dsn.js\");\nconst envelope = __webpack_require__(/*! ../utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\n\n/**\n * Creates a log container envelope item for a list of logs.\n *\n * @param items - The logs to include in the envelope.\n * @returns The created log container envelope item.\n */\nfunction createLogContainerEnvelopeItem(items) {\n  return [\n    {\n      type: 'log',\n      item_count: items.length,\n      content_type: 'application/vnd.sentry.items.log+json',\n    },\n    {\n      items,\n    },\n  ];\n}\n\n/**\n * Creates an envelope for a list of logs.\n *\n * Logs from multiple traces can be included in the same envelope.\n *\n * @param logs - The logs to include in the envelope.\n * @param metadata - The metadata to include in the envelope.\n * @param tunnel - The tunnel to include in the envelope.\n * @param dsn - The DSN to include in the envelope.\n * @returns The created envelope.\n */\nfunction createLogEnvelope(\n  logs,\n  metadata,\n  tunnel,\n  dsn$1,\n) {\n  const headers = {};\n\n  if (metadata?.sdk) {\n    headers.sdk = {\n      name: metadata.sdk.name,\n      version: metadata.sdk.version,\n    };\n  }\n\n  if (!!tunnel && !!dsn$1) {\n    headers.dsn = dsn.dsnToString(dsn$1);\n  }\n\n  return envelope.createEnvelope(headers, [createLogContainerEnvelopeItem(logs)]);\n}\n\nexports.createLogContainerEnvelopeItem = createLogContainerEnvelopeItem;\nexports.createLogEnvelope = createLogEnvelope;\n//# sourceMappingURL=envelope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2xvZ3MvZW52ZWxvcGUuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsWUFBWSxtQkFBTyxDQUFDLGdJQUF1QjtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQywwSUFBNEI7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEMseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGxvZ3NcXGVudmVsb3BlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBkc24gPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9kc24uanMnKTtcbmNvbnN0IGVudmVsb3BlID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvZW52ZWxvcGUuanMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbG9nIGNvbnRhaW5lciBlbnZlbG9wZSBpdGVtIGZvciBhIGxpc3Qgb2YgbG9ncy5cbiAqXG4gKiBAcGFyYW0gaXRlbXMgLSBUaGUgbG9ncyB0byBpbmNsdWRlIGluIHRoZSBlbnZlbG9wZS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGxvZyBjb250YWluZXIgZW52ZWxvcGUgaXRlbS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9nQ29udGFpbmVyRW52ZWxvcGVJdGVtKGl0ZW1zKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgdHlwZTogJ2xvZycsXG4gICAgICBpdGVtX2NvdW50OiBpdGVtcy5sZW5ndGgsXG4gICAgICBjb250ZW50X3R5cGU6ICdhcHBsaWNhdGlvbi92bmQuc2VudHJ5Lml0ZW1zLmxvZytqc29uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGl0ZW1zLFxuICAgIH0sXG4gIF07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbnZlbG9wZSBmb3IgYSBsaXN0IG9mIGxvZ3MuXG4gKlxuICogTG9ncyBmcm9tIG11bHRpcGxlIHRyYWNlcyBjYW4gYmUgaW5jbHVkZWQgaW4gdGhlIHNhbWUgZW52ZWxvcGUuXG4gKlxuICogQHBhcmFtIGxvZ3MgLSBUaGUgbG9ncyB0byBpbmNsdWRlIGluIHRoZSBlbnZlbG9wZS5cbiAqIEBwYXJhbSBtZXRhZGF0YSAtIFRoZSBtZXRhZGF0YSB0byBpbmNsdWRlIGluIHRoZSBlbnZlbG9wZS5cbiAqIEBwYXJhbSB0dW5uZWwgLSBUaGUgdHVubmVsIHRvIGluY2x1ZGUgaW4gdGhlIGVudmVsb3BlLlxuICogQHBhcmFtIGRzbiAtIFRoZSBEU04gdG8gaW5jbHVkZSBpbiB0aGUgZW52ZWxvcGUuXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBlbnZlbG9wZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9nRW52ZWxvcGUoXG4gIGxvZ3MsXG4gIG1ldGFkYXRhLFxuICB0dW5uZWwsXG4gIGRzbiQxLFxuKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcblxuICBpZiAobWV0YWRhdGE/LnNkaykge1xuICAgIGhlYWRlcnMuc2RrID0ge1xuICAgICAgbmFtZTogbWV0YWRhdGEuc2RrLm5hbWUsXG4gICAgICB2ZXJzaW9uOiBtZXRhZGF0YS5zZGsudmVyc2lvbixcbiAgICB9O1xuICB9XG5cbiAgaWYgKCEhdHVubmVsICYmICEhZHNuJDEpIHtcbiAgICBoZWFkZXJzLmRzbiA9IGRzbi5kc25Ub1N0cmluZyhkc24kMSk7XG4gIH1cblxuICByZXR1cm4gZW52ZWxvcGUuY3JlYXRlRW52ZWxvcGUoaGVhZGVycywgW2NyZWF0ZUxvZ0NvbnRhaW5lckVudmVsb3BlSXRlbShsb2dzKV0pO1xufVxuXG5leHBvcnRzLmNyZWF0ZUxvZ0NvbnRhaW5lckVudmVsb3BlSXRlbSA9IGNyZWF0ZUxvZ0NvbnRhaW5lckVudmVsb3BlSXRlbTtcbmV4cG9ydHMuY3JlYXRlTG9nRW52ZWxvcGUgPSBjcmVhdGVMb2dFbnZlbG9wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudmVsb3BlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/envelope.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/exports.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst client = __webpack_require__(/*! ../client.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/client.js\");\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst applyScopeDataToEvent = __webpack_require__(/*! ../utils/applyScopeDataToEvent.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/applyScopeDataToEvent.js\");\nconst spanOnScope = __webpack_require__(/*! ../utils/spanOnScope.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanOnScope.js\");\nconst is = __webpack_require__(/*! ../utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst time = __webpack_require__(/*! ../utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst worldwide = __webpack_require__(/*! ../utils-hoist/worldwide.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js\");\nconst constants = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/constants.js\");\nconst envelope = __webpack_require__(/*! ./envelope.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/envelope.js\");\n\nconst MAX_LOG_BUFFER_SIZE = 100;\n\n// The reference to the Client <> LogBuffer map is stored to ensure it's always the same\nworldwide.GLOBAL_OBJ._sentryClientToLogBufferMap = new WeakMap();\n\n/**\n * Converts a log attribute to a serialized log attribute.\n *\n * @param key - The key of the log attribute.\n * @param value - The value of the log attribute.\n * @returns The serialized log attribute.\n */\nfunction logAttributeToSerializedLogAttribute(value) {\n  switch (typeof value) {\n    case 'number':\n      if (Number.isInteger(value)) {\n        return {\n          value,\n          type: 'integer',\n        };\n      }\n      return {\n        value,\n        type: 'double',\n      };\n    case 'boolean':\n      return {\n        value,\n        type: 'boolean',\n      };\n    case 'string':\n      return {\n        value,\n        type: 'string',\n      };\n    default: {\n      let stringValue = '';\n      try {\n        stringValue = JSON.stringify(value) ?? '';\n      } catch {\n        // Do nothing\n      }\n      return {\n        value: stringValue,\n        type: 'string',\n      };\n    }\n  }\n}\n\n/**\n * Sets a log attribute if the value exists and the attribute key is not already present.\n *\n * @param logAttributes - The log attributes object to modify.\n * @param key - The attribute key to set.\n * @param value - The value to set (only sets if truthy and key not present).\n * @param setEvenIfPresent - Whether to set the attribute if it is present. Defaults to true.\n */\nfunction setLogAttribute(\n  logAttributes,\n  key,\n  value,\n  setEvenIfPresent = true,\n) {\n  if (value && (!logAttributes[key] || setEvenIfPresent)) {\n    logAttributes[key] = value;\n  }\n}\n\n/**\n * Captures a serialized log event and adds it to the log buffer for the given client.\n *\n * @param client - A client. Uses the current client if not provided.\n * @param serializedLog - The serialized log event to capture.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nfunction _INTERNAL_captureSerializedLog(client, serializedLog) {\n  const logBuffer = _INTERNAL_getLogBuffer(client);\n  if (logBuffer === undefined) {\n    worldwide.GLOBAL_OBJ._sentryClientToLogBufferMap?.set(client, [serializedLog]);\n  } else {\n    worldwide.GLOBAL_OBJ._sentryClientToLogBufferMap?.set(client, [...logBuffer, serializedLog]);\n    if (logBuffer.length >= MAX_LOG_BUFFER_SIZE) {\n      _INTERNAL_flushLogsBuffer(client, logBuffer);\n    }\n  }\n}\n\n/**\n * Captures a log event and sends it to Sentry.\n *\n * @param log - The log event to capture.\n * @param scope - A scope. Uses the current scope if not provided.\n * @param client - A client. Uses the current client if not provided.\n * @param captureSerializedLog - A function to capture the serialized log.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nfunction _INTERNAL_captureLog(\n  beforeLog,\n  client$1 = currentScopes.getClient(),\n  currentScope = currentScopes.getCurrentScope(),\n  captureSerializedLog = _INTERNAL_captureSerializedLog,\n) {\n  if (!client$1) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('No client available to capture log.');\n    return;\n  }\n\n  const { _experiments, release, environment } = client$1.getOptions();\n  const { enableLogs = false, beforeSendLog } = _experiments ?? {};\n  if (!enableLogs) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('logging option not enabled, log will not be captured.');\n    return;\n  }\n\n  const [, traceContext] = client._getTraceInfoFromScope(client$1, currentScope);\n\n  const processedLogAttributes = {\n    ...beforeLog.attributes,\n  };\n\n  const {\n    user: { id, email, username },\n  } = getMergedScopeData(currentScope);\n  setLogAttribute(processedLogAttributes, 'user.id', id, false);\n  setLogAttribute(processedLogAttributes, 'user.email', email, false);\n  setLogAttribute(processedLogAttributes, 'user.name', username, false);\n\n  setLogAttribute(processedLogAttributes, 'sentry.release', release);\n  setLogAttribute(processedLogAttributes, 'sentry.environment', environment);\n\n  const { name, version } = client$1.getSdkMetadata()?.sdk ?? {};\n  setLogAttribute(processedLogAttributes, 'sentry.sdk.name', name);\n  setLogAttribute(processedLogAttributes, 'sentry.sdk.version', version);\n\n  const beforeLogMessage = beforeLog.message;\n  if (is.isParameterizedString(beforeLogMessage)) {\n    const { __sentry_template_string__, __sentry_template_values__ = [] } = beforeLogMessage;\n    processedLogAttributes['sentry.message.template'] = __sentry_template_string__;\n    __sentry_template_values__.forEach((param, index) => {\n      processedLogAttributes[`sentry.message.parameter.${index}`] = param;\n    });\n  }\n\n  const span = spanOnScope._getSpanForScope(currentScope);\n  // Add the parent span ID to the log attributes for trace context\n  setLogAttribute(processedLogAttributes, 'sentry.trace.parent_span_id', span?.spanContext().spanId);\n\n  const processedLog = { ...beforeLog, attributes: processedLogAttributes };\n\n  client$1.emit('beforeCaptureLog', processedLog);\n\n  const log = beforeSendLog ? beforeSendLog(processedLog) : processedLog;\n  if (!log) {\n    client$1.recordDroppedEvent('before_send', 'log_item', 1);\n    debugBuild.DEBUG_BUILD && logger.logger.warn('beforeSendLog returned null, log will not be captured.');\n    return;\n  }\n\n  const { level, message, attributes = {}, severityNumber } = log;\n\n  const serializedLog = {\n    timestamp: time.timestampInSeconds(),\n    level,\n    body: message,\n    trace_id: traceContext?.trace_id,\n    severity_number: severityNumber ?? constants.SEVERITY_TEXT_TO_SEVERITY_NUMBER[level],\n    attributes: Object.keys(attributes).reduce(\n      (acc, key) => {\n        acc[key] = logAttributeToSerializedLogAttribute(attributes[key]);\n        return acc;\n      },\n      {} ,\n    ),\n  };\n\n  captureSerializedLog(client$1, serializedLog);\n\n  client$1.emit('afterCaptureLog', log);\n}\n\n/**\n * Flushes the logs buffer to Sentry.\n *\n * @param client - A client.\n * @param maybeLogBuffer - A log buffer. Uses the log buffer for the given client if not provided.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nfunction _INTERNAL_flushLogsBuffer(client, maybeLogBuffer) {\n  const logBuffer = maybeLogBuffer ?? _INTERNAL_getLogBuffer(client) ?? [];\n  if (logBuffer.length === 0) {\n    return;\n  }\n\n  const clientOptions = client.getOptions();\n  const envelope$1 = envelope.createLogEnvelope(logBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());\n\n  // Clear the log buffer after envelopes have been constructed.\n  worldwide.GLOBAL_OBJ._sentryClientToLogBufferMap?.set(client, []);\n\n  client.emit('flushLogs');\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope$1);\n}\n\n/**\n * Returns the log buffer for a given client.\n *\n * Exported for testing purposes.\n *\n * @param client - The client to get the log buffer for.\n * @returns The log buffer for the given client.\n */\nfunction _INTERNAL_getLogBuffer(client) {\n  return worldwide.GLOBAL_OBJ._sentryClientToLogBufferMap?.get(client);\n}\n\n/**\n * Get the scope data for the current scope after merging with the\n * global scope and isolation scope.\n *\n * @param currentScope - The current scope.\n * @returns The scope data.\n */\nfunction getMergedScopeData(currentScope) {\n  const scopeData = currentScopes.getGlobalScope().getScopeData();\n  applyScopeDataToEvent.mergeScopeData(scopeData, currentScopes.getIsolationScope().getScopeData());\n  applyScopeDataToEvent.mergeScopeData(scopeData, currentScope.getScopeData());\n  return scopeData;\n}\n\nexports._INTERNAL_captureLog = _INTERNAL_captureLog;\nexports._INTERNAL_captureSerializedLog = _INTERNAL_captureSerializedLog;\nexports._INTERNAL_flushLogsBuffer = _INTERNAL_flushLogsBuffer;\nexports._INTERNAL_getLogBuffer = _INTERNAL_getLogBuffer;\nexports.logAttributeToSerializedLogAttribute = logAttributeToSerializedLogAttribute;\n//# sourceMappingURL=exports.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL2xvZ3MvZXhwb3J0cy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxlQUFlLG1CQUFPLENBQUMsOEdBQWM7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsNEhBQXFCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLHdIQUFtQjtBQUM5Qyw4QkFBOEIsbUJBQU8sQ0FBQyx3SkFBbUM7QUFDekUsb0JBQW9CLG1CQUFPLENBQUMsb0lBQXlCO0FBQ3JELFdBQVcsbUJBQU8sQ0FBQyw4SEFBc0I7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHNJQUEwQjtBQUNqRCxhQUFhLG1CQUFPLENBQUMsa0lBQXdCO0FBQzdDLGtCQUFrQixtQkFBTyxDQUFDLDRJQUE2QjtBQUN2RCxrQkFBa0IsbUJBQU8sQ0FBQyx3SEFBZ0I7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsc0hBQWU7O0FBRXhDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUscUNBQXFDO0FBQy9DLFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLDhEQUE4RDtBQUMxRTtBQUNBO0FBQ0EseURBQXlELE1BQU07QUFDL0QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLCtCQUErQixtQkFBbUI7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsc0NBQXNDO0FBQ3RDLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIsNENBQTRDO0FBQzVDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGxvZ3NcXGV4cG9ydHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudC5qcycpO1xuY29uc3QgY3VycmVudFNjb3BlcyA9IHJlcXVpcmUoJy4uL2N1cnJlbnRTY29wZXMuanMnKTtcbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3QgYXBwbHlTY29wZURhdGFUb0V2ZW50ID0gcmVxdWlyZSgnLi4vdXRpbHMvYXBwbHlTY29wZURhdGFUb0V2ZW50LmpzJyk7XG5jb25zdCBzcGFuT25TY29wZSA9IHJlcXVpcmUoJy4uL3V0aWxzL3NwYW5PblNjb3BlLmpzJyk7XG5jb25zdCBpcyA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2lzLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IHRpbWUgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC90aW1lLmpzJyk7XG5jb25zdCB3b3JsZHdpZGUgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC93b3JsZHdpZGUuanMnKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzLmpzJyk7XG5jb25zdCBlbnZlbG9wZSA9IHJlcXVpcmUoJy4vZW52ZWxvcGUuanMnKTtcblxuY29uc3QgTUFYX0xPR19CVUZGRVJfU0laRSA9IDEwMDtcblxuLy8gVGhlIHJlZmVyZW5jZSB0byB0aGUgQ2xpZW50IDw+IExvZ0J1ZmZlciBtYXAgaXMgc3RvcmVkIHRvIGVuc3VyZSBpdCdzIGFsd2F5cyB0aGUgc2FtZVxud29ybGR3aWRlLkdMT0JBTF9PQkouX3NlbnRyeUNsaWVudFRvTG9nQnVmZmVyTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGxvZyBhdHRyaWJ1dGUgdG8gYSBzZXJpYWxpemVkIGxvZyBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIGxvZyBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGxvZyBhdHRyaWJ1dGUuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBsb2cgYXR0cmlidXRlLlxuICovXG5mdW5jdGlvbiBsb2dBdHRyaWJ1dGVUb1NlcmlhbGl6ZWRMb2dBdHRyaWJ1dGUodmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGU6ICdkb3VibGUnLFxuICAgICAgfTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICB9O1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGxldCBzdHJpbmdWYWx1ZSA9ICcnO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RyaW5nVmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgPz8gJyc7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHN0cmluZ1ZhbHVlLFxuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2V0cyBhIGxvZyBhdHRyaWJ1dGUgaWYgdGhlIHZhbHVlIGV4aXN0cyBhbmQgdGhlIGF0dHJpYnV0ZSBrZXkgaXMgbm90IGFscmVhZHkgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0gbG9nQXR0cmlidXRlcyAtIFRoZSBsb2cgYXR0cmlidXRlcyBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIGtleSAtIFRoZSBhdHRyaWJ1dGUga2V5IHRvIHNldC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQgKG9ubHkgc2V0cyBpZiB0cnV0aHkgYW5kIGtleSBub3QgcHJlc2VudCkuXG4gKiBAcGFyYW0gc2V0RXZlbklmUHJlc2VudCAtIFdoZXRoZXIgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgaWYgaXQgaXMgcHJlc2VudC4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gc2V0TG9nQXR0cmlidXRlKFxuICBsb2dBdHRyaWJ1dGVzLFxuICBrZXksXG4gIHZhbHVlLFxuICBzZXRFdmVuSWZQcmVzZW50ID0gdHJ1ZSxcbikge1xuICBpZiAodmFsdWUgJiYgKCFsb2dBdHRyaWJ1dGVzW2tleV0gfHwgc2V0RXZlbklmUHJlc2VudCkpIHtcbiAgICBsb2dBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIENhcHR1cmVzIGEgc2VyaWFsaXplZCBsb2cgZXZlbnQgYW5kIGFkZHMgaXQgdG8gdGhlIGxvZyBidWZmZXIgZm9yIHRoZSBnaXZlbiBjbGllbnQuXG4gKlxuICogQHBhcmFtIGNsaWVudCAtIEEgY2xpZW50LiBVc2VzIHRoZSBjdXJyZW50IGNsaWVudCBpZiBub3QgcHJvdmlkZWQuXG4gKiBAcGFyYW0gc2VyaWFsaXplZExvZyAtIFRoZSBzZXJpYWxpemVkIGxvZyBldmVudCB0byBjYXB0dXJlLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2Qgd2lsbCBleHBlcmllbmNlIGJyZWFraW5nIGNoYW5nZXMuIFRoaXMgaXMgbm90IHlldCBwYXJ0IG9mXG4gKiB0aGUgc3RhYmxlIFNlbnRyeSBTREsgQVBJIGFuZCBjYW4gYmUgY2hhbmdlZCBvciByZW1vdmVkIHdpdGhvdXQgd2FybmluZy5cbiAqL1xuZnVuY3Rpb24gX0lOVEVSTkFMX2NhcHR1cmVTZXJpYWxpemVkTG9nKGNsaWVudCwgc2VyaWFsaXplZExvZykge1xuICBjb25zdCBsb2dCdWZmZXIgPSBfSU5URVJOQUxfZ2V0TG9nQnVmZmVyKGNsaWVudCk7XG4gIGlmIChsb2dCdWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHdvcmxkd2lkZS5HTE9CQUxfT0JKLl9zZW50cnlDbGllbnRUb0xvZ0J1ZmZlck1hcD8uc2V0KGNsaWVudCwgW3NlcmlhbGl6ZWRMb2ddKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JsZHdpZGUuR0xPQkFMX09CSi5fc2VudHJ5Q2xpZW50VG9Mb2dCdWZmZXJNYXA/LnNldChjbGllbnQsIFsuLi5sb2dCdWZmZXIsIHNlcmlhbGl6ZWRMb2ddKTtcbiAgICBpZiAobG9nQnVmZmVyLmxlbmd0aCA+PSBNQVhfTE9HX0JVRkZFUl9TSVpFKSB7XG4gICAgICBfSU5URVJOQUxfZmx1c2hMb2dzQnVmZmVyKGNsaWVudCwgbG9nQnVmZmVyKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDYXB0dXJlcyBhIGxvZyBldmVudCBhbmQgc2VuZHMgaXQgdG8gU2VudHJ5LlxuICpcbiAqIEBwYXJhbSBsb2cgLSBUaGUgbG9nIGV2ZW50IHRvIGNhcHR1cmUuXG4gKiBAcGFyYW0gc2NvcGUgLSBBIHNjb3BlLiBVc2VzIHRoZSBjdXJyZW50IHNjb3BlIGlmIG5vdCBwcm92aWRlZC5cbiAqIEBwYXJhbSBjbGllbnQgLSBBIGNsaWVudC4gVXNlcyB0aGUgY3VycmVudCBjbGllbnQgaWYgbm90IHByb3ZpZGVkLlxuICogQHBhcmFtIGNhcHR1cmVTZXJpYWxpemVkTG9nIC0gQSBmdW5jdGlvbiB0byBjYXB0dXJlIHRoZSBzZXJpYWxpemVkIGxvZy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIHdpbGwgZXhwZXJpZW5jZSBicmVha2luZyBjaGFuZ2VzLiBUaGlzIGlzIG5vdCB5ZXQgcGFydCBvZlxuICogdGhlIHN0YWJsZSBTZW50cnkgU0RLIEFQSSBhbmQgY2FuIGJlIGNoYW5nZWQgb3IgcmVtb3ZlZCB3aXRob3V0IHdhcm5pbmcuXG4gKi9cbmZ1bmN0aW9uIF9JTlRFUk5BTF9jYXB0dXJlTG9nKFxuICBiZWZvcmVMb2csXG4gIGNsaWVudCQxID0gY3VycmVudFNjb3Blcy5nZXRDbGllbnQoKSxcbiAgY3VycmVudFNjb3BlID0gY3VycmVudFNjb3Blcy5nZXRDdXJyZW50U2NvcGUoKSxcbiAgY2FwdHVyZVNlcmlhbGl6ZWRMb2cgPSBfSU5URVJOQUxfY2FwdHVyZVNlcmlhbGl6ZWRMb2csXG4pIHtcbiAgaWYgKCFjbGllbnQkMSkge1xuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdObyBjbGllbnQgYXZhaWxhYmxlIHRvIGNhcHR1cmUgbG9nLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHsgX2V4cGVyaW1lbnRzLCByZWxlYXNlLCBlbnZpcm9ubWVudCB9ID0gY2xpZW50JDEuZ2V0T3B0aW9ucygpO1xuICBjb25zdCB7IGVuYWJsZUxvZ3MgPSBmYWxzZSwgYmVmb3JlU2VuZExvZyB9ID0gX2V4cGVyaW1lbnRzID8/IHt9O1xuICBpZiAoIWVuYWJsZUxvZ3MpIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybignbG9nZ2luZyBvcHRpb24gbm90IGVuYWJsZWQsIGxvZyB3aWxsIG5vdCBiZSBjYXB0dXJlZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBbLCB0cmFjZUNvbnRleHRdID0gY2xpZW50Ll9nZXRUcmFjZUluZm9Gcm9tU2NvcGUoY2xpZW50JDEsIGN1cnJlbnRTY29wZSk7XG5cbiAgY29uc3QgcHJvY2Vzc2VkTG9nQXR0cmlidXRlcyA9IHtcbiAgICAuLi5iZWZvcmVMb2cuYXR0cmlidXRlcyxcbiAgfTtcblxuICBjb25zdCB7XG4gICAgdXNlcjogeyBpZCwgZW1haWwsIHVzZXJuYW1lIH0sXG4gIH0gPSBnZXRNZXJnZWRTY29wZURhdGEoY3VycmVudFNjb3BlKTtcbiAgc2V0TG9nQXR0cmlidXRlKHByb2Nlc3NlZExvZ0F0dHJpYnV0ZXMsICd1c2VyLmlkJywgaWQsIGZhbHNlKTtcbiAgc2V0TG9nQXR0cmlidXRlKHByb2Nlc3NlZExvZ0F0dHJpYnV0ZXMsICd1c2VyLmVtYWlsJywgZW1haWwsIGZhbHNlKTtcbiAgc2V0TG9nQXR0cmlidXRlKHByb2Nlc3NlZExvZ0F0dHJpYnV0ZXMsICd1c2VyLm5hbWUnLCB1c2VybmFtZSwgZmFsc2UpO1xuXG4gIHNldExvZ0F0dHJpYnV0ZShwcm9jZXNzZWRMb2dBdHRyaWJ1dGVzLCAnc2VudHJ5LnJlbGVhc2UnLCByZWxlYXNlKTtcbiAgc2V0TG9nQXR0cmlidXRlKHByb2Nlc3NlZExvZ0F0dHJpYnV0ZXMsICdzZW50cnkuZW52aXJvbm1lbnQnLCBlbnZpcm9ubWVudCk7XG5cbiAgY29uc3QgeyBuYW1lLCB2ZXJzaW9uIH0gPSBjbGllbnQkMS5nZXRTZGtNZXRhZGF0YSgpPy5zZGsgPz8ge307XG4gIHNldExvZ0F0dHJpYnV0ZShwcm9jZXNzZWRMb2dBdHRyaWJ1dGVzLCAnc2VudHJ5LnNkay5uYW1lJywgbmFtZSk7XG4gIHNldExvZ0F0dHJpYnV0ZShwcm9jZXNzZWRMb2dBdHRyaWJ1dGVzLCAnc2VudHJ5LnNkay52ZXJzaW9uJywgdmVyc2lvbik7XG5cbiAgY29uc3QgYmVmb3JlTG9nTWVzc2FnZSA9IGJlZm9yZUxvZy5tZXNzYWdlO1xuICBpZiAoaXMuaXNQYXJhbWV0ZXJpemVkU3RyaW5nKGJlZm9yZUxvZ01lc3NhZ2UpKSB7XG4gICAgY29uc3QgeyBfX3NlbnRyeV90ZW1wbGF0ZV9zdHJpbmdfXywgX19zZW50cnlfdGVtcGxhdGVfdmFsdWVzX18gPSBbXSB9ID0gYmVmb3JlTG9nTWVzc2FnZTtcbiAgICBwcm9jZXNzZWRMb2dBdHRyaWJ1dGVzWydzZW50cnkubWVzc2FnZS50ZW1wbGF0ZSddID0gX19zZW50cnlfdGVtcGxhdGVfc3RyaW5nX187XG4gICAgX19zZW50cnlfdGVtcGxhdGVfdmFsdWVzX18uZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICBwcm9jZXNzZWRMb2dBdHRyaWJ1dGVzW2BzZW50cnkubWVzc2FnZS5wYXJhbWV0ZXIuJHtpbmRleH1gXSA9IHBhcmFtO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3Qgc3BhbiA9IHNwYW5PblNjb3BlLl9nZXRTcGFuRm9yU2NvcGUoY3VycmVudFNjb3BlKTtcbiAgLy8gQWRkIHRoZSBwYXJlbnQgc3BhbiBJRCB0byB0aGUgbG9nIGF0dHJpYnV0ZXMgZm9yIHRyYWNlIGNvbnRleHRcbiAgc2V0TG9nQXR0cmlidXRlKHByb2Nlc3NlZExvZ0F0dHJpYnV0ZXMsICdzZW50cnkudHJhY2UucGFyZW50X3NwYW5faWQnLCBzcGFuPy5zcGFuQ29udGV4dCgpLnNwYW5JZCk7XG5cbiAgY29uc3QgcHJvY2Vzc2VkTG9nID0geyAuLi5iZWZvcmVMb2csIGF0dHJpYnV0ZXM6IHByb2Nlc3NlZExvZ0F0dHJpYnV0ZXMgfTtcblxuICBjbGllbnQkMS5lbWl0KCdiZWZvcmVDYXB0dXJlTG9nJywgcHJvY2Vzc2VkTG9nKTtcblxuICBjb25zdCBsb2cgPSBiZWZvcmVTZW5kTG9nID8gYmVmb3JlU2VuZExvZyhwcm9jZXNzZWRMb2cpIDogcHJvY2Vzc2VkTG9nO1xuICBpZiAoIWxvZykge1xuICAgIGNsaWVudCQxLnJlY29yZERyb3BwZWRFdmVudCgnYmVmb3JlX3NlbmQnLCAnbG9nX2l0ZW0nLCAxKTtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybignYmVmb3JlU2VuZExvZyByZXR1cm5lZCBudWxsLCBsb2cgd2lsbCBub3QgYmUgY2FwdHVyZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgeyBsZXZlbCwgbWVzc2FnZSwgYXR0cmlidXRlcyA9IHt9LCBzZXZlcml0eU51bWJlciB9ID0gbG9nO1xuXG4gIGNvbnN0IHNlcmlhbGl6ZWRMb2cgPSB7XG4gICAgdGltZXN0YW1wOiB0aW1lLnRpbWVzdGFtcEluU2Vjb25kcygpLFxuICAgIGxldmVsLFxuICAgIGJvZHk6IG1lc3NhZ2UsXG4gICAgdHJhY2VfaWQ6IHRyYWNlQ29udGV4dD8udHJhY2VfaWQsXG4gICAgc2V2ZXJpdHlfbnVtYmVyOiBzZXZlcml0eU51bWJlciA/PyBjb25zdGFudHMuU0VWRVJJVFlfVEVYVF9UT19TRVZFUklUWV9OVU1CRVJbbGV2ZWxdLFxuICAgIGF0dHJpYnV0ZXM6IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLnJlZHVjZShcbiAgICAgIChhY2MsIGtleSkgPT4ge1xuICAgICAgICBhY2Nba2V5XSA9IGxvZ0F0dHJpYnV0ZVRvU2VyaWFsaXplZExvZ0F0dHJpYnV0ZShhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHt9ICxcbiAgICApLFxuICB9O1xuXG4gIGNhcHR1cmVTZXJpYWxpemVkTG9nKGNsaWVudCQxLCBzZXJpYWxpemVkTG9nKTtcblxuICBjbGllbnQkMS5lbWl0KCdhZnRlckNhcHR1cmVMb2cnLCBsb2cpO1xufVxuXG4vKipcbiAqIEZsdXNoZXMgdGhlIGxvZ3MgYnVmZmVyIHRvIFNlbnRyeS5cbiAqXG4gKiBAcGFyYW0gY2xpZW50IC0gQSBjbGllbnQuXG4gKiBAcGFyYW0gbWF5YmVMb2dCdWZmZXIgLSBBIGxvZyBidWZmZXIuIFVzZXMgdGhlIGxvZyBidWZmZXIgZm9yIHRoZSBnaXZlbiBjbGllbnQgaWYgbm90IHByb3ZpZGVkLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2Qgd2lsbCBleHBlcmllbmNlIGJyZWFraW5nIGNoYW5nZXMuIFRoaXMgaXMgbm90IHlldCBwYXJ0IG9mXG4gKiB0aGUgc3RhYmxlIFNlbnRyeSBTREsgQVBJIGFuZCBjYW4gYmUgY2hhbmdlZCBvciByZW1vdmVkIHdpdGhvdXQgd2FybmluZy5cbiAqL1xuZnVuY3Rpb24gX0lOVEVSTkFMX2ZsdXNoTG9nc0J1ZmZlcihjbGllbnQsIG1heWJlTG9nQnVmZmVyKSB7XG4gIGNvbnN0IGxvZ0J1ZmZlciA9IG1heWJlTG9nQnVmZmVyID8/IF9JTlRFUk5BTF9nZXRMb2dCdWZmZXIoY2xpZW50KSA/PyBbXTtcbiAgaWYgKGxvZ0J1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBjbGllbnRPcHRpb25zID0gY2xpZW50LmdldE9wdGlvbnMoKTtcbiAgY29uc3QgZW52ZWxvcGUkMSA9IGVudmVsb3BlLmNyZWF0ZUxvZ0VudmVsb3BlKGxvZ0J1ZmZlciwgY2xpZW50T3B0aW9ucy5fbWV0YWRhdGEsIGNsaWVudE9wdGlvbnMudHVubmVsLCBjbGllbnQuZ2V0RHNuKCkpO1xuXG4gIC8vIENsZWFyIHRoZSBsb2cgYnVmZmVyIGFmdGVyIGVudmVsb3BlcyBoYXZlIGJlZW4gY29uc3RydWN0ZWQuXG4gIHdvcmxkd2lkZS5HTE9CQUxfT0JKLl9zZW50cnlDbGllbnRUb0xvZ0J1ZmZlck1hcD8uc2V0KGNsaWVudCwgW10pO1xuXG4gIGNsaWVudC5lbWl0KCdmbHVzaExvZ3MnKTtcblxuICAvLyBzZW5kRW52ZWxvcGUgc2hvdWxkIG5vdCB0aHJvd1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gIGNsaWVudC5zZW5kRW52ZWxvcGUoZW52ZWxvcGUkMSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbG9nIGJ1ZmZlciBmb3IgYSBnaXZlbiBjbGllbnQuXG4gKlxuICogRXhwb3J0ZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKlxuICogQHBhcmFtIGNsaWVudCAtIFRoZSBjbGllbnQgdG8gZ2V0IHRoZSBsb2cgYnVmZmVyIGZvci5cbiAqIEByZXR1cm5zIFRoZSBsb2cgYnVmZmVyIGZvciB0aGUgZ2l2ZW4gY2xpZW50LlxuICovXG5mdW5jdGlvbiBfSU5URVJOQUxfZ2V0TG9nQnVmZmVyKGNsaWVudCkge1xuICByZXR1cm4gd29ybGR3aWRlLkdMT0JBTF9PQkouX3NlbnRyeUNsaWVudFRvTG9nQnVmZmVyTWFwPy5nZXQoY2xpZW50KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNjb3BlIGRhdGEgZm9yIHRoZSBjdXJyZW50IHNjb3BlIGFmdGVyIG1lcmdpbmcgd2l0aCB0aGVcbiAqIGdsb2JhbCBzY29wZSBhbmQgaXNvbGF0aW9uIHNjb3BlLlxuICpcbiAqIEBwYXJhbSBjdXJyZW50U2NvcGUgLSBUaGUgY3VycmVudCBzY29wZS5cbiAqIEByZXR1cm5zIFRoZSBzY29wZSBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNZXJnZWRTY29wZURhdGEoY3VycmVudFNjb3BlKSB7XG4gIGNvbnN0IHNjb3BlRGF0YSA9IGN1cnJlbnRTY29wZXMuZ2V0R2xvYmFsU2NvcGUoKS5nZXRTY29wZURhdGEoKTtcbiAgYXBwbHlTY29wZURhdGFUb0V2ZW50Lm1lcmdlU2NvcGVEYXRhKHNjb3BlRGF0YSwgY3VycmVudFNjb3Blcy5nZXRJc29sYXRpb25TY29wZSgpLmdldFNjb3BlRGF0YSgpKTtcbiAgYXBwbHlTY29wZURhdGFUb0V2ZW50Lm1lcmdlU2NvcGVEYXRhKHNjb3BlRGF0YSwgY3VycmVudFNjb3BlLmdldFNjb3BlRGF0YSgpKTtcbiAgcmV0dXJuIHNjb3BlRGF0YTtcbn1cblxuZXhwb3J0cy5fSU5URVJOQUxfY2FwdHVyZUxvZyA9IF9JTlRFUk5BTF9jYXB0dXJlTG9nO1xuZXhwb3J0cy5fSU5URVJOQUxfY2FwdHVyZVNlcmlhbGl6ZWRMb2cgPSBfSU5URVJOQUxfY2FwdHVyZVNlcmlhbGl6ZWRMb2c7XG5leHBvcnRzLl9JTlRFUk5BTF9mbHVzaExvZ3NCdWZmZXIgPSBfSU5URVJOQUxfZmx1c2hMb2dzQnVmZmVyO1xuZXhwb3J0cy5fSU5URVJOQUxfZ2V0TG9nQnVmZmVyID0gX0lOVEVSTkFMX2dldExvZ0J1ZmZlcjtcbmV4cG9ydHMubG9nQXR0cmlidXRlVG9TZXJpYWxpemVkTG9nQXR0cmlidXRlID0gbG9nQXR0cmlidXRlVG9TZXJpYWxpemVkTG9nQXR0cmlidXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwb3J0cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/exports.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/mcp-server.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst semanticAttributes = __webpack_require__(/*! ./semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\n__webpack_require__(/*! ./tracing/errors.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/errors.js\");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\n__webpack_require__(/*! ./utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst spanUtils = __webpack_require__(/*! ./utils/spanUtils.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanUtils.js\");\nconst trace = __webpack_require__(/*! ./tracing/trace.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/trace.js\");\n\nconst wrappedMcpServerInstances = new WeakSet();\n\n/**\n * Wraps a MCP Server instance from the `@modelcontextprotocol/sdk` package with Sentry instrumentation.\n *\n * Compatible with versions `^1.9.0` of the `@modelcontextprotocol/sdk` package.\n */\n// We are exposing this API for non-node runtimes that cannot rely on auto-instrumentation.\nfunction wrapMcpServerWithSentry(mcpServerInstance) {\n  if (wrappedMcpServerInstances.has(mcpServerInstance)) {\n    return mcpServerInstance;\n  }\n\n  if (!isMcpServerInstance(mcpServerInstance)) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('Did not patch MCP server. Interface is incompatible.');\n    return mcpServerInstance;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  mcpServerInstance.connect = new Proxy(mcpServerInstance.connect, {\n    apply(target, thisArg, argArray) {\n      const [transport, ...restArgs] = argArray ;\n\n      if (!transport.onclose) {\n        transport.onclose = () => {\n          if (transport.sessionId) {\n            handleTransportOnClose(transport.sessionId);\n          }\n        };\n      }\n\n      if (!transport.onmessage) {\n        transport.onmessage = jsonRpcMessage => {\n          if (transport.sessionId && isJsonRPCMessageWithRequestId(jsonRpcMessage)) {\n            handleTransportOnMessage(transport.sessionId, jsonRpcMessage.id);\n          }\n        };\n      }\n\n      const patchedTransport = new Proxy(transport, {\n        set(target, key, value) {\n          if (key === 'onmessage') {\n            target[key] = new Proxy(value, {\n              apply(onMessageTarget, onMessageThisArg, onMessageArgArray) {\n                const [jsonRpcMessage] = onMessageArgArray;\n                if (transport.sessionId && isJsonRPCMessageWithRequestId(jsonRpcMessage)) {\n                  handleTransportOnMessage(transport.sessionId, jsonRpcMessage.id);\n                }\n                return Reflect.apply(onMessageTarget, onMessageThisArg, onMessageArgArray);\n              },\n            });\n          } else if (key === 'onclose') {\n            target[key] = new Proxy(value, {\n              apply(onCloseTarget, onCloseThisArg, onCloseArgArray) {\n                if (transport.sessionId) {\n                  handleTransportOnClose(transport.sessionId);\n                }\n                return Reflect.apply(onCloseTarget, onCloseThisArg, onCloseArgArray);\n              },\n            });\n          } else {\n            target[key ] = value;\n          }\n          return true;\n        },\n      });\n\n      return Reflect.apply(target, thisArg, [patchedTransport, ...restArgs]);\n    },\n  });\n\n  mcpServerInstance.resource = new Proxy(mcpServerInstance.resource, {\n    apply(target, thisArg, argArray) {\n      const resourceName = argArray[0];\n      const resourceHandler = argArray[argArray.length - 1];\n\n      if (typeof resourceName !== 'string' || typeof resourceHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n\n      const wrappedResourceHandler = new Proxy(resourceHandler, {\n        apply(resourceHandlerTarget, resourceHandlerThisArg, resourceHandlerArgArray) {\n          const extraHandlerDataWithRequestId = resourceHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return trace.startSpan(\n              {\n                name: `mcp-server/resource:${resourceName}`,\n                forceTransaction: true,\n                attributes: {\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                  'mcp_server.resource': resourceName,\n                },\n              },\n              () => resourceHandlerTarget.apply(resourceHandlerThisArg, resourceHandlerArgArray),\n            );\n          });\n        },\n      });\n\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedResourceHandler]);\n    },\n  });\n\n  mcpServerInstance.tool = new Proxy(mcpServerInstance.tool, {\n    apply(target, thisArg, argArray) {\n      const toolName = argArray[0];\n      const toolHandler = argArray[argArray.length - 1];\n\n      if (typeof toolName !== 'string' || typeof toolHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n\n      const wrappedToolHandler = new Proxy(toolHandler, {\n        apply(toolHandlerTarget, toolHandlerThisArg, toolHandlerArgArray) {\n          const extraHandlerDataWithRequestId = toolHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return trace.startSpan(\n              {\n                name: `mcp-server/tool:${toolName}`,\n                forceTransaction: true,\n                attributes: {\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                  'mcp_server.tool': toolName,\n                },\n              },\n              () => toolHandlerTarget.apply(toolHandlerThisArg, toolHandlerArgArray),\n            );\n          });\n        },\n      });\n\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedToolHandler]);\n    },\n  });\n\n  mcpServerInstance.prompt = new Proxy(mcpServerInstance.prompt, {\n    apply(target, thisArg, argArray) {\n      const promptName = argArray[0];\n      const promptHandler = argArray[argArray.length - 1];\n\n      if (typeof promptName !== 'string' || typeof promptHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n\n      const wrappedPromptHandler = new Proxy(promptHandler, {\n        apply(promptHandlerTarget, promptHandlerThisArg, promptHandlerArgArray) {\n          const extraHandlerDataWithRequestId = promptHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return trace.startSpan(\n              {\n                name: `mcp-server/prompt:${promptName}`,\n                forceTransaction: true,\n                attributes: {\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                  'mcp_server.prompt': promptName,\n                },\n              },\n              () => promptHandlerTarget.apply(promptHandlerThisArg, promptHandlerArgArray),\n            );\n          });\n        },\n      });\n\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedPromptHandler]);\n    },\n  });\n\n  wrappedMcpServerInstances.add(mcpServerInstance);\n\n  return mcpServerInstance ;\n}\n\nfunction isMcpServerInstance(mcpServerInstance) {\n  return (\n    typeof mcpServerInstance === 'object' &&\n    mcpServerInstance !== null &&\n    'resource' in mcpServerInstance &&\n    typeof mcpServerInstance.resource === 'function' &&\n    'tool' in mcpServerInstance &&\n    typeof mcpServerInstance.tool === 'function' &&\n    'prompt' in mcpServerInstance &&\n    typeof mcpServerInstance.prompt === 'function' &&\n    'connect' in mcpServerInstance &&\n    typeof mcpServerInstance.connect === 'function'\n  );\n}\n\nfunction isJsonRPCMessageWithRequestId(target) {\n  return (\n    typeof target === 'object' &&\n    target !== null &&\n    'id' in target &&\n    (typeof target.id === 'number' || typeof target.id === 'string')\n  );\n}\n\n// Note that not all versions of the MCP library have `requestId` as a field on the extra data.\nfunction isExtraHandlerDataWithRequestId(target) {\n  return (\n    typeof target === 'object' &&\n    target !== null &&\n    'sessionId' in target &&\n    typeof target.sessionId === 'string' &&\n    'requestId' in target &&\n    (typeof target.requestId === 'number' || typeof target.requestId === 'string')\n  );\n}\n\nconst sessionAndRequestToRequestParentSpanMap = new Map();\n\nfunction handleTransportOnClose(sessionId) {\n  sessionAndRequestToRequestParentSpanMap.delete(sessionId);\n}\n\nfunction handleTransportOnMessage(sessionId, requestId) {\n  const activeSpan = spanUtils.getActiveSpan();\n  if (activeSpan) {\n    const requestIdToSpanMap = sessionAndRequestToRequestParentSpanMap.get(sessionId) ?? new Map();\n    requestIdToSpanMap.set(requestId, activeSpan);\n    sessionAndRequestToRequestParentSpanMap.set(sessionId, requestIdToSpanMap);\n  }\n}\n\nfunction associateContextWithRequestSpan(\n  extraHandlerData,\n  cb,\n) {\n  if (extraHandlerData) {\n    const { sessionId, requestId } = extraHandlerData;\n    const requestIdSpanMap = sessionAndRequestToRequestParentSpanMap.get(sessionId);\n\n    if (!requestIdSpanMap) {\n      return cb();\n    }\n\n    const span = requestIdSpanMap.get(requestId);\n    if (!span) {\n      return cb();\n    }\n\n    // remove the span from the map so it can be garbage collected\n    requestIdSpanMap.delete(requestId);\n    return trace.withActiveSpan(span, () => {\n      return cb();\n    });\n  }\n\n  return cb();\n}\n\nexports.wrapMcpServerWithSentry = wrapMcpServerWithSentry;\n//# sourceMappingURL=mcp-server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL21jcC1zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsbUJBQW1CLG1CQUFPLENBQUMsdUhBQWtCO0FBQzdDLDJCQUEyQixtQkFBTyxDQUFDLHFJQUF5QjtBQUM1RCxtQkFBTyxDQUFDLDZIQUFxQjtBQUM3QixlQUFlLG1CQUFPLENBQUMscUlBQXlCO0FBQ2hELG1CQUFPLENBQUMsaUlBQXVCO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLCtIQUFzQjtBQUNoRCxjQUFjLG1CQUFPLENBQUMsMkhBQW9COztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXG1jcC1zZXJ2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBzZW1hbnRpY0F0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL3NlbWFudGljQXR0cmlidXRlcy5qcycpO1xucmVxdWlyZSgnLi90cmFjaW5nL2Vycm9ycy5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbnJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvdGltZS5qcycpO1xuY29uc3Qgc3BhblV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9zcGFuVXRpbHMuanMnKTtcbmNvbnN0IHRyYWNlID0gcmVxdWlyZSgnLi90cmFjaW5nL3RyYWNlLmpzJyk7XG5cbmNvbnN0IHdyYXBwZWRNY3BTZXJ2ZXJJbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpO1xuXG4vKipcbiAqIFdyYXBzIGEgTUNQIFNlcnZlciBpbnN0YW5jZSBmcm9tIHRoZSBgQG1vZGVsY29udGV4dHByb3RvY29sL3Nka2AgcGFja2FnZSB3aXRoIFNlbnRyeSBpbnN0cnVtZW50YXRpb24uXG4gKlxuICogQ29tcGF0aWJsZSB3aXRoIHZlcnNpb25zIGBeMS45LjBgIG9mIHRoZSBgQG1vZGVsY29udGV4dHByb3RvY29sL3Nka2AgcGFja2FnZS5cbiAqL1xuLy8gV2UgYXJlIGV4cG9zaW5nIHRoaXMgQVBJIGZvciBub24tbm9kZSBydW50aW1lcyB0aGF0IGNhbm5vdCByZWx5IG9uIGF1dG8taW5zdHJ1bWVudGF0aW9uLlxuZnVuY3Rpb24gd3JhcE1jcFNlcnZlcldpdGhTZW50cnkobWNwU2VydmVySW5zdGFuY2UpIHtcbiAgaWYgKHdyYXBwZWRNY3BTZXJ2ZXJJbnN0YW5jZXMuaGFzKG1jcFNlcnZlckluc3RhbmNlKSkge1xuICAgIHJldHVybiBtY3BTZXJ2ZXJJbnN0YW5jZTtcbiAgfVxuXG4gIGlmICghaXNNY3BTZXJ2ZXJJbnN0YW5jZShtY3BTZXJ2ZXJJbnN0YW5jZSkpIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybignRGlkIG5vdCBwYXRjaCBNQ1Agc2VydmVyLiBJbnRlcmZhY2UgaXMgaW5jb21wYXRpYmxlLicpO1xuICAgIHJldHVybiBtY3BTZXJ2ZXJJbnN0YW5jZTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgbWNwU2VydmVySW5zdGFuY2UuY29ubmVjdCA9IG5ldyBQcm94eShtY3BTZXJ2ZXJJbnN0YW5jZS5jb25uZWN0LCB7XG4gICAgYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmdBcnJheSkge1xuICAgICAgY29uc3QgW3RyYW5zcG9ydCwgLi4ucmVzdEFyZ3NdID0gYXJnQXJyYXkgO1xuXG4gICAgICBpZiAoIXRyYW5zcG9ydC5vbmNsb3NlKSB7XG4gICAgICAgIHRyYW5zcG9ydC5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0cmFuc3BvcnQuc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICBoYW5kbGVUcmFuc3BvcnRPbkNsb3NlKHRyYW5zcG9ydC5zZXNzaW9uSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0cmFuc3BvcnQub25tZXNzYWdlKSB7XG4gICAgICAgIHRyYW5zcG9ydC5vbm1lc3NhZ2UgPSBqc29uUnBjTWVzc2FnZSA9PiB7XG4gICAgICAgICAgaWYgKHRyYW5zcG9ydC5zZXNzaW9uSWQgJiYgaXNKc29uUlBDTWVzc2FnZVdpdGhSZXF1ZXN0SWQoanNvblJwY01lc3NhZ2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVUcmFuc3BvcnRPbk1lc3NhZ2UodHJhbnNwb3J0LnNlc3Npb25JZCwganNvblJwY01lc3NhZ2UuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGF0Y2hlZFRyYW5zcG9ydCA9IG5ldyBQcm94eSh0cmFuc3BvcnQsIHtcbiAgICAgICAgc2V0KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChrZXkgPT09ICdvbm1lc3NhZ2UnKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG5ldyBQcm94eSh2YWx1ZSwge1xuICAgICAgICAgICAgICBhcHBseShvbk1lc3NhZ2VUYXJnZXQsIG9uTWVzc2FnZVRoaXNBcmcsIG9uTWVzc2FnZUFyZ0FycmF5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2pzb25ScGNNZXNzYWdlXSA9IG9uTWVzc2FnZUFyZ0FycmF5O1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQuc2Vzc2lvbklkICYmIGlzSnNvblJQQ01lc3NhZ2VXaXRoUmVxdWVzdElkKGpzb25ScGNNZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgaGFuZGxlVHJhbnNwb3J0T25NZXNzYWdlKHRyYW5zcG9ydC5zZXNzaW9uSWQsIGpzb25ScGNNZXNzYWdlLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkob25NZXNzYWdlVGFyZ2V0LCBvbk1lc3NhZ2VUaGlzQXJnLCBvbk1lc3NhZ2VBcmdBcnJheSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ29uY2xvc2UnKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG5ldyBQcm94eSh2YWx1ZSwge1xuICAgICAgICAgICAgICBhcHBseShvbkNsb3NlVGFyZ2V0LCBvbkNsb3NlVGhpc0FyZywgb25DbG9zZUFyZ0FycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zcG9ydC5zZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZVRyYW5zcG9ydE9uQ2xvc2UodHJhbnNwb3J0LnNlc3Npb25JZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KG9uQ2xvc2VUYXJnZXQsIG9uQ2xvc2VUaGlzQXJnLCBvbkNsb3NlQXJnQXJyYXkpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXkgXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIFtwYXRjaGVkVHJhbnNwb3J0LCAuLi5yZXN0QXJnc10pO1xuICAgIH0sXG4gIH0pO1xuXG4gIG1jcFNlcnZlckluc3RhbmNlLnJlc291cmNlID0gbmV3IFByb3h5KG1jcFNlcnZlckluc3RhbmNlLnJlc291cmNlLCB7XG4gICAgYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmdBcnJheSkge1xuICAgICAgY29uc3QgcmVzb3VyY2VOYW1lID0gYXJnQXJyYXlbMF07XG4gICAgICBjb25zdCByZXNvdXJjZUhhbmRsZXIgPSBhcmdBcnJheVthcmdBcnJheS5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKHR5cGVvZiByZXNvdXJjZU5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiByZXNvdXJjZUhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmdBcnJheSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdyYXBwZWRSZXNvdXJjZUhhbmRsZXIgPSBuZXcgUHJveHkocmVzb3VyY2VIYW5kbGVyLCB7XG4gICAgICAgIGFwcGx5KHJlc291cmNlSGFuZGxlclRhcmdldCwgcmVzb3VyY2VIYW5kbGVyVGhpc0FyZywgcmVzb3VyY2VIYW5kbGVyQXJnQXJyYXkpIHtcbiAgICAgICAgICBjb25zdCBleHRyYUhhbmRsZXJEYXRhV2l0aFJlcXVlc3RJZCA9IHJlc291cmNlSGFuZGxlckFyZ0FycmF5LmZpbmQoaXNFeHRyYUhhbmRsZXJEYXRhV2l0aFJlcXVlc3RJZCk7XG4gICAgICAgICAgcmV0dXJuIGFzc29jaWF0ZUNvbnRleHRXaXRoUmVxdWVzdFNwYW4oZXh0cmFIYW5kbGVyRGF0YVdpdGhSZXF1ZXN0SWQsICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZS5zdGFydFNwYW4oXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBgbWNwLXNlcnZlci9yZXNvdXJjZToke3Jlc291cmNlTmFtZX1gLFxuICAgICAgICAgICAgICAgIGZvcmNlVHJhbnNhY3Rpb246IHRydWUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXTogJ2F1dG8uZnVuY3Rpb24ubWNwLXNlcnZlcicsXG4gICAgICAgICAgICAgICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXTogJ2F1dG8uZnVuY3Rpb24ubWNwLXNlcnZlcicsXG4gICAgICAgICAgICAgICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXTogJ3JvdXRlJyxcbiAgICAgICAgICAgICAgICAgICdtY3Bfc2VydmVyLnJlc291cmNlJzogcmVzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICgpID0+IHJlc291cmNlSGFuZGxlclRhcmdldC5hcHBseShyZXNvdXJjZUhhbmRsZXJUaGlzQXJnLCByZXNvdXJjZUhhbmRsZXJBcmdBcnJheSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgWy4uLmFyZ0FycmF5LnNsaWNlKDAsIC0xKSwgd3JhcHBlZFJlc291cmNlSGFuZGxlcl0pO1xuICAgIH0sXG4gIH0pO1xuXG4gIG1jcFNlcnZlckluc3RhbmNlLnRvb2wgPSBuZXcgUHJveHkobWNwU2VydmVySW5zdGFuY2UudG9vbCwge1xuICAgIGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJnQXJyYXkpIHtcbiAgICAgIGNvbnN0IHRvb2xOYW1lID0gYXJnQXJyYXlbMF07XG4gICAgICBjb25zdCB0b29sSGFuZGxlciA9IGFyZ0FycmF5W2FyZ0FycmF5Lmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAodHlwZW9mIHRvb2xOYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdG9vbEhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmdBcnJheSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdyYXBwZWRUb29sSGFuZGxlciA9IG5ldyBQcm94eSh0b29sSGFuZGxlciwge1xuICAgICAgICBhcHBseSh0b29sSGFuZGxlclRhcmdldCwgdG9vbEhhbmRsZXJUaGlzQXJnLCB0b29sSGFuZGxlckFyZ0FycmF5KSB7XG4gICAgICAgICAgY29uc3QgZXh0cmFIYW5kbGVyRGF0YVdpdGhSZXF1ZXN0SWQgPSB0b29sSGFuZGxlckFyZ0FycmF5LmZpbmQoaXNFeHRyYUhhbmRsZXJEYXRhV2l0aFJlcXVlc3RJZCk7XG4gICAgICAgICAgcmV0dXJuIGFzc29jaWF0ZUNvbnRleHRXaXRoUmVxdWVzdFNwYW4oZXh0cmFIYW5kbGVyRGF0YVdpdGhSZXF1ZXN0SWQsICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZS5zdGFydFNwYW4oXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBgbWNwLXNlcnZlci90b29sOiR7dG9vbE5hbWV9YCxcbiAgICAgICAgICAgICAgICBmb3JjZVRyYW5zYWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF06ICdhdXRvLmZ1bmN0aW9uLm1jcC1zZXJ2ZXInLFxuICAgICAgICAgICAgICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06ICdhdXRvLmZ1bmN0aW9uLm1jcC1zZXJ2ZXInLFxuICAgICAgICAgICAgICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06ICdyb3V0ZScsXG4gICAgICAgICAgICAgICAgICAnbWNwX3NlcnZlci50b29sJzogdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKCkgPT4gdG9vbEhhbmRsZXJUYXJnZXQuYXBwbHkodG9vbEhhbmRsZXJUaGlzQXJnLCB0b29sSGFuZGxlckFyZ0FycmF5KSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBbLi4uYXJnQXJyYXkuc2xpY2UoMCwgLTEpLCB3cmFwcGVkVG9vbEhhbmRsZXJdKTtcbiAgICB9LFxuICB9KTtcblxuICBtY3BTZXJ2ZXJJbnN0YW5jZS5wcm9tcHQgPSBuZXcgUHJveHkobWNwU2VydmVySW5zdGFuY2UucHJvbXB0LCB7XG4gICAgYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmdBcnJheSkge1xuICAgICAgY29uc3QgcHJvbXB0TmFtZSA9IGFyZ0FycmF5WzBdO1xuICAgICAgY29uc3QgcHJvbXB0SGFuZGxlciA9IGFyZ0FycmF5W2FyZ0FycmF5Lmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAodHlwZW9mIHByb21wdE5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9tcHRIYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJnQXJyYXkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3cmFwcGVkUHJvbXB0SGFuZGxlciA9IG5ldyBQcm94eShwcm9tcHRIYW5kbGVyLCB7XG4gICAgICAgIGFwcGx5KHByb21wdEhhbmRsZXJUYXJnZXQsIHByb21wdEhhbmRsZXJUaGlzQXJnLCBwcm9tcHRIYW5kbGVyQXJnQXJyYXkpIHtcbiAgICAgICAgICBjb25zdCBleHRyYUhhbmRsZXJEYXRhV2l0aFJlcXVlc3RJZCA9IHByb21wdEhhbmRsZXJBcmdBcnJheS5maW5kKGlzRXh0cmFIYW5kbGVyRGF0YVdpdGhSZXF1ZXN0SWQpO1xuICAgICAgICAgIHJldHVybiBhc3NvY2lhdGVDb250ZXh0V2l0aFJlcXVlc3RTcGFuKGV4dHJhSGFuZGxlckRhdGFXaXRoUmVxdWVzdElkLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2Uuc3RhcnRTcGFuKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogYG1jcC1zZXJ2ZXIvcHJvbXB0OiR7cHJvbXB0TmFtZX1gLFxuICAgICAgICAgICAgICAgIGZvcmNlVHJhbnNhY3Rpb246IHRydWUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXTogJ2F1dG8uZnVuY3Rpb24ubWNwLXNlcnZlcicsXG4gICAgICAgICAgICAgICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXTogJ2F1dG8uZnVuY3Rpb24ubWNwLXNlcnZlcicsXG4gICAgICAgICAgICAgICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXTogJ3JvdXRlJyxcbiAgICAgICAgICAgICAgICAgICdtY3Bfc2VydmVyLnByb21wdCc6IHByb21wdE5hbWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKCkgPT4gcHJvbXB0SGFuZGxlclRhcmdldC5hcHBseShwcm9tcHRIYW5kbGVyVGhpc0FyZywgcHJvbXB0SGFuZGxlckFyZ0FycmF5KSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBbLi4uYXJnQXJyYXkuc2xpY2UoMCwgLTEpLCB3cmFwcGVkUHJvbXB0SGFuZGxlcl0pO1xuICAgIH0sXG4gIH0pO1xuXG4gIHdyYXBwZWRNY3BTZXJ2ZXJJbnN0YW5jZXMuYWRkKG1jcFNlcnZlckluc3RhbmNlKTtcblxuICByZXR1cm4gbWNwU2VydmVySW5zdGFuY2UgO1xufVxuXG5mdW5jdGlvbiBpc01jcFNlcnZlckluc3RhbmNlKG1jcFNlcnZlckluc3RhbmNlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIG1jcFNlcnZlckluc3RhbmNlID09PSAnb2JqZWN0JyAmJlxuICAgIG1jcFNlcnZlckluc3RhbmNlICE9PSBudWxsICYmXG4gICAgJ3Jlc291cmNlJyBpbiBtY3BTZXJ2ZXJJbnN0YW5jZSAmJlxuICAgIHR5cGVvZiBtY3BTZXJ2ZXJJbnN0YW5jZS5yZXNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICd0b29sJyBpbiBtY3BTZXJ2ZXJJbnN0YW5jZSAmJlxuICAgIHR5cGVvZiBtY3BTZXJ2ZXJJbnN0YW5jZS50b29sID09PSAnZnVuY3Rpb24nICYmXG4gICAgJ3Byb21wdCcgaW4gbWNwU2VydmVySW5zdGFuY2UgJiZcbiAgICB0eXBlb2YgbWNwU2VydmVySW5zdGFuY2UucHJvbXB0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgJ2Nvbm5lY3QnIGluIG1jcFNlcnZlckluc3RhbmNlICYmXG4gICAgdHlwZW9mIG1jcFNlcnZlckluc3RhbmNlLmNvbm5lY3QgPT09ICdmdW5jdGlvbidcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNKc29uUlBDTWVzc2FnZVdpdGhSZXF1ZXN0SWQodGFyZ2V0KSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiZcbiAgICB0YXJnZXQgIT09IG51bGwgJiZcbiAgICAnaWQnIGluIHRhcmdldCAmJlxuICAgICh0eXBlb2YgdGFyZ2V0LmlkID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdGFyZ2V0LmlkID09PSAnc3RyaW5nJylcbiAgKTtcbn1cblxuLy8gTm90ZSB0aGF0IG5vdCBhbGwgdmVyc2lvbnMgb2YgdGhlIE1DUCBsaWJyYXJ5IGhhdmUgYHJlcXVlc3RJZGAgYXMgYSBmaWVsZCBvbiB0aGUgZXh0cmEgZGF0YS5cbmZ1bmN0aW9uIGlzRXh0cmFIYW5kbGVyRGF0YVdpdGhSZXF1ZXN0SWQodGFyZ2V0KSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiZcbiAgICB0YXJnZXQgIT09IG51bGwgJiZcbiAgICAnc2Vzc2lvbklkJyBpbiB0YXJnZXQgJiZcbiAgICB0eXBlb2YgdGFyZ2V0LnNlc3Npb25JZCA9PT0gJ3N0cmluZycgJiZcbiAgICAncmVxdWVzdElkJyBpbiB0YXJnZXQgJiZcbiAgICAodHlwZW9mIHRhcmdldC5yZXF1ZXN0SWQgPT09ICdudW1iZXInIHx8IHR5cGVvZiB0YXJnZXQucmVxdWVzdElkID09PSAnc3RyaW5nJylcbiAgKTtcbn1cblxuY29uc3Qgc2Vzc2lvbkFuZFJlcXVlc3RUb1JlcXVlc3RQYXJlbnRTcGFuTWFwID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBoYW5kbGVUcmFuc3BvcnRPbkNsb3NlKHNlc3Npb25JZCkge1xuICBzZXNzaW9uQW5kUmVxdWVzdFRvUmVxdWVzdFBhcmVudFNwYW5NYXAuZGVsZXRlKHNlc3Npb25JZCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRyYW5zcG9ydE9uTWVzc2FnZShzZXNzaW9uSWQsIHJlcXVlc3RJZCkge1xuICBjb25zdCBhY3RpdmVTcGFuID0gc3BhblV0aWxzLmdldEFjdGl2ZVNwYW4oKTtcbiAgaWYgKGFjdGl2ZVNwYW4pIHtcbiAgICBjb25zdCByZXF1ZXN0SWRUb1NwYW5NYXAgPSBzZXNzaW9uQW5kUmVxdWVzdFRvUmVxdWVzdFBhcmVudFNwYW5NYXAuZ2V0KHNlc3Npb25JZCkgPz8gbmV3IE1hcCgpO1xuICAgIHJlcXVlc3RJZFRvU3Bhbk1hcC5zZXQocmVxdWVzdElkLCBhY3RpdmVTcGFuKTtcbiAgICBzZXNzaW9uQW5kUmVxdWVzdFRvUmVxdWVzdFBhcmVudFNwYW5NYXAuc2V0KHNlc3Npb25JZCwgcmVxdWVzdElkVG9TcGFuTWFwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NvY2lhdGVDb250ZXh0V2l0aFJlcXVlc3RTcGFuKFxuICBleHRyYUhhbmRsZXJEYXRhLFxuICBjYixcbikge1xuICBpZiAoZXh0cmFIYW5kbGVyRGF0YSkge1xuICAgIGNvbnN0IHsgc2Vzc2lvbklkLCByZXF1ZXN0SWQgfSA9IGV4dHJhSGFuZGxlckRhdGE7XG4gICAgY29uc3QgcmVxdWVzdElkU3Bhbk1hcCA9IHNlc3Npb25BbmRSZXF1ZXN0VG9SZXF1ZXN0UGFyZW50U3Bhbk1hcC5nZXQoc2Vzc2lvbklkKTtcblxuICAgIGlmICghcmVxdWVzdElkU3Bhbk1hcCkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3BhbiA9IHJlcXVlc3RJZFNwYW5NYXAuZ2V0KHJlcXVlc3RJZCk7XG4gICAgaWYgKCFzcGFuKSB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdGhlIHNwYW4gZnJvbSB0aGUgbWFwIHNvIGl0IGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICAgIHJlcXVlc3RJZFNwYW5NYXAuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgcmV0dXJuIHRyYWNlLndpdGhBY3RpdmVTcGFuKHNwYW4sICgpID0+IHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNiKCk7XG59XG5cbmV4cG9ydHMud3JhcE1jcFNlcnZlcldpdGhTZW50cnkgPSB3cmFwTWNwU2VydmVyV2l0aFNlbnRyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1jcC1zZXJ2ZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/mcp-server.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/metadata.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst worldwide = __webpack_require__(/*! ./utils-hoist/worldwide.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js\");\n\n/** Keys are source filename/url, values are metadata objects. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst filenameMetadataMap = new Map();\n/** Set of stack strings that have already been parsed. */\nconst parsedStacks = new Set();\n\nfunction ensureMetadataStacksAreParsed(parser) {\n  if (!worldwide.GLOBAL_OBJ._sentryModuleMetadata) {\n    return;\n  }\n\n  for (const stack of Object.keys(worldwide.GLOBAL_OBJ._sentryModuleMetadata)) {\n    const metadata = worldwide.GLOBAL_OBJ._sentryModuleMetadata[stack];\n\n    if (parsedStacks.has(stack)) {\n      continue;\n    }\n\n    // Ensure this stack doesn't get parsed again\n    parsedStacks.add(stack);\n\n    const frames = parser(stack);\n\n    // Go through the frames starting from the top of the stack and find the first one with a filename\n    for (const frame of frames.reverse()) {\n      if (frame.filename) {\n        // Save the metadata for this filename\n        filenameMetadataMap.set(frame.filename, metadata);\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Retrieve metadata for a specific JavaScript file URL.\n *\n * Metadata is injected by the Sentry bundler plugins using the `_experiments.moduleMetadata` config option.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getMetadataForUrl(parser, filename) {\n  ensureMetadataStacksAreParsed(parser);\n  return filenameMetadataMap.get(filename);\n}\n\n/**\n * Adds metadata to stack frames.\n *\n * Metadata is injected by the Sentry bundler plugins using the `_experiments.moduleMetadata` config option.\n */\nfunction addMetadataToStackFrames(parser, event) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      if (!exception.stacktrace) {\n        return;\n      }\n\n      for (const frame of exception.stacktrace.frames || []) {\n        if (!frame.filename || frame.module_metadata) {\n          continue;\n        }\n\n        const metadata = getMetadataForUrl(parser, frame.filename);\n\n        if (metadata) {\n          frame.module_metadata = metadata;\n        }\n      }\n    });\n  } catch (_) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\n/**\n * Strips metadata from stack frames.\n */\nfunction stripMetadataFromStackFrames(event) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      if (!exception.stacktrace) {\n        return;\n      }\n\n      for (const frame of exception.stacktrace.frames || []) {\n        delete frame.module_metadata;\n      }\n    });\n  } catch (_) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\nexports.addMetadataToStackFrames = addMetadataToStackFrames;\nexports.getMetadataForUrl = getMetadataForUrl;\nexports.stripMetadataFromStackFrames = stripMetadataFromStackFrames;\n//# sourceMappingURL=metadata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL21ldGFkYXRhLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLGtCQUFrQixtQkFBTyxDQUFDLDJJQUE0Qjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQyx5QkFBeUI7QUFDekIsb0NBQW9DO0FBQ3BDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXG1ldGFkYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCB3b3JsZHdpZGUgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3dvcmxkd2lkZS5qcycpO1xuXG4vKiogS2V5cyBhcmUgc291cmNlIGZpbGVuYW1lL3VybCwgdmFsdWVzIGFyZSBtZXRhZGF0YSBvYmplY3RzLiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGZpbGVuYW1lTWV0YWRhdGFNYXAgPSBuZXcgTWFwKCk7XG4vKiogU2V0IG9mIHN0YWNrIHN0cmluZ3MgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBwYXJzZWQuICovXG5jb25zdCBwYXJzZWRTdGFja3MgPSBuZXcgU2V0KCk7XG5cbmZ1bmN0aW9uIGVuc3VyZU1ldGFkYXRhU3RhY2tzQXJlUGFyc2VkKHBhcnNlcikge1xuICBpZiAoIXdvcmxkd2lkZS5HTE9CQUxfT0JKLl9zZW50cnlNb2R1bGVNZXRhZGF0YSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAoY29uc3Qgc3RhY2sgb2YgT2JqZWN0LmtleXMod29ybGR3aWRlLkdMT0JBTF9PQkouX3NlbnRyeU1vZHVsZU1ldGFkYXRhKSkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gd29ybGR3aWRlLkdMT0JBTF9PQkouX3NlbnRyeU1vZHVsZU1ldGFkYXRhW3N0YWNrXTtcblxuICAgIGlmIChwYXJzZWRTdGFja3MuaGFzKHN0YWNrKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoaXMgc3RhY2sgZG9lc24ndCBnZXQgcGFyc2VkIGFnYWluXG4gICAgcGFyc2VkU3RhY2tzLmFkZChzdGFjayk7XG5cbiAgICBjb25zdCBmcmFtZXMgPSBwYXJzZXIoc3RhY2spO1xuXG4gICAgLy8gR28gdGhyb3VnaCB0aGUgZnJhbWVzIHN0YXJ0aW5nIGZyb20gdGhlIHRvcCBvZiB0aGUgc3RhY2sgYW5kIGZpbmQgdGhlIGZpcnN0IG9uZSB3aXRoIGEgZmlsZW5hbWVcbiAgICBmb3IgKGNvbnN0IGZyYW1lIG9mIGZyYW1lcy5yZXZlcnNlKCkpIHtcbiAgICAgIGlmIChmcmFtZS5maWxlbmFtZSkge1xuICAgICAgICAvLyBTYXZlIHRoZSBtZXRhZGF0YSBmb3IgdGhpcyBmaWxlbmFtZVxuICAgICAgICBmaWxlbmFtZU1ldGFkYXRhTWFwLnNldChmcmFtZS5maWxlbmFtZSwgbWV0YWRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyBKYXZhU2NyaXB0IGZpbGUgVVJMLlxuICpcbiAqIE1ldGFkYXRhIGlzIGluamVjdGVkIGJ5IHRoZSBTZW50cnkgYnVuZGxlciBwbHVnaW5zIHVzaW5nIHRoZSBgX2V4cGVyaW1lbnRzLm1vZHVsZU1ldGFkYXRhYCBjb25maWcgb3B0aW9uLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gZ2V0TWV0YWRhdGFGb3JVcmwocGFyc2VyLCBmaWxlbmFtZSkge1xuICBlbnN1cmVNZXRhZGF0YVN0YWNrc0FyZVBhcnNlZChwYXJzZXIpO1xuICByZXR1cm4gZmlsZW5hbWVNZXRhZGF0YU1hcC5nZXQoZmlsZW5hbWUpO1xufVxuXG4vKipcbiAqIEFkZHMgbWV0YWRhdGEgdG8gc3RhY2sgZnJhbWVzLlxuICpcbiAqIE1ldGFkYXRhIGlzIGluamVjdGVkIGJ5IHRoZSBTZW50cnkgYnVuZGxlciBwbHVnaW5zIHVzaW5nIHRoZSBgX2V4cGVyaW1lbnRzLm1vZHVsZU1ldGFkYXRhYCBjb25maWcgb3B0aW9uLlxuICovXG5mdW5jdGlvbiBhZGRNZXRhZGF0YVRvU3RhY2tGcmFtZXMocGFyc2VyLCBldmVudCkge1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgZXZlbnQuZXhjZXB0aW9uLnZhbHVlcy5mb3JFYWNoKGV4Y2VwdGlvbiA9PiB7XG4gICAgICBpZiAoIWV4Y2VwdGlvbi5zdGFja3RyYWNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBmcmFtZSBvZiBleGNlcHRpb24uc3RhY2t0cmFjZS5mcmFtZXMgfHwgW10pIHtcbiAgICAgICAgaWYgKCFmcmFtZS5maWxlbmFtZSB8fCBmcmFtZS5tb2R1bGVfbWV0YWRhdGEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0TWV0YWRhdGFGb3JVcmwocGFyc2VyLCBmcmFtZS5maWxlbmFtZSk7XG5cbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgZnJhbWUubW9kdWxlX21ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIFRvIHNhdmUgYnVuZGxlIHNpemUgd2UncmUganVzdCB0cnkgY2F0Y2hpbmcgaGVyZSBpbnN0ZWFkIG9mIGNoZWNraW5nIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFsbCB0aGUgZGlmZmVyZW50IG9iamVjdHMuXG4gIH1cbn1cblxuLyoqXG4gKiBTdHJpcHMgbWV0YWRhdGEgZnJvbSBzdGFjayBmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIHN0cmlwTWV0YWRhdGFGcm9tU3RhY2tGcmFtZXMoZXZlbnQpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXMuZm9yRWFjaChleGNlcHRpb24gPT4ge1xuICAgICAgaWYgKCFleGNlcHRpb24uc3RhY2t0cmFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZnJhbWUgb2YgZXhjZXB0aW9uLnN0YWNrdHJhY2UuZnJhbWVzIHx8IFtdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFtZS5tb2R1bGVfbWV0YWRhdGE7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBUbyBzYXZlIGJ1bmRsZSBzaXplIHdlJ3JlIGp1c3QgdHJ5IGNhdGNoaW5nIGhlcmUgaW5zdGVhZCBvZiBjaGVja2luZyBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbGwgdGhlIGRpZmZlcmVudCBvYmplY3RzLlxuICB9XG59XG5cbmV4cG9ydHMuYWRkTWV0YWRhdGFUb1N0YWNrRnJhbWVzID0gYWRkTWV0YWRhdGFUb1N0YWNrRnJhbWVzO1xuZXhwb3J0cy5nZXRNZXRhZGF0YUZvclVybCA9IGdldE1ldGFkYXRhRm9yVXJsO1xuZXhwb3J0cy5zdHJpcE1ldGFkYXRhRnJvbVN0YWNrRnJhbWVzID0gc3RyaXBNZXRhZGF0YUZyb21TdGFja0ZyYW1lcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFkYXRhLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/metadata.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/profiling.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\n\nfunction isProfilingIntegrationWithProfiler(\n  integration,\n) {\n  return (\n    !!integration &&\n    typeof integration['_profiler'] !== 'undefined' &&\n    typeof integration['_profiler']['start'] === 'function' &&\n    typeof integration['_profiler']['stop'] === 'function'\n  );\n}\n/**\n * Starts the Sentry continuous profiler.\n * This mode is exclusive with the transaction profiler and will only work if the profilesSampleRate is set to a falsy value.\n * In continuous profiling mode, the profiler will keep reporting profile chunks to Sentry until it is stopped, which allows for continuous profiling of the application.\n */\nfunction startProfiler() {\n  const client = currentScopes.getClient();\n  if (!client) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('No Sentry client available, profiling is not started');\n    return;\n  }\n\n  const integration = client.getIntegrationByName('ProfilingIntegration');\n\n  if (!integration) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('ProfilingIntegration is not available');\n    return;\n  }\n\n  if (!isProfilingIntegrationWithProfiler(integration)) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('Profiler is not available on profiling integration.');\n    return;\n  }\n\n  integration._profiler.start();\n}\n\n/**\n * Stops the Sentry continuous profiler.\n * Calls to stop will stop the profiler and flush the currently collected profile data to Sentry.\n */\nfunction stopProfiler() {\n  const client = currentScopes.getClient();\n  if (!client) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('No Sentry client available, profiling is not started');\n    return;\n  }\n\n  const integration = client.getIntegrationByName('ProfilingIntegration');\n  if (!integration) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('ProfilingIntegration is not available');\n    return;\n  }\n\n  if (!isProfilingIntegrationWithProfiler(integration)) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('Profiler is not available on profiling integration.');\n    return;\n  }\n\n  integration._profiler.stop();\n}\n\nconst profiler = {\n  startProfiler,\n  stopProfiler,\n};\n\nexports.profiler = profiler;\n//# sourceMappingURL=profiling.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3Byb2ZpbGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxzQkFBc0IsbUJBQU8sQ0FBQywySEFBb0I7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsdUhBQWtCO0FBQzdDLGVBQWUsbUJBQU8sQ0FBQyxxSUFBeUI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xccHJvZmlsaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcblxuZnVuY3Rpb24gaXNQcm9maWxpbmdJbnRlZ3JhdGlvbldpdGhQcm9maWxlcihcbiAgaW50ZWdyYXRpb24sXG4pIHtcbiAgcmV0dXJuIChcbiAgICAhIWludGVncmF0aW9uICYmXG4gICAgdHlwZW9mIGludGVncmF0aW9uWydfcHJvZmlsZXInXSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgaW50ZWdyYXRpb25bJ19wcm9maWxlciddWydzdGFydCddID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIGludGVncmF0aW9uWydfcHJvZmlsZXInXVsnc3RvcCddID09PSAnZnVuY3Rpb24nXG4gICk7XG59XG4vKipcbiAqIFN0YXJ0cyB0aGUgU2VudHJ5IGNvbnRpbnVvdXMgcHJvZmlsZXIuXG4gKiBUaGlzIG1vZGUgaXMgZXhjbHVzaXZlIHdpdGggdGhlIHRyYW5zYWN0aW9uIHByb2ZpbGVyIGFuZCB3aWxsIG9ubHkgd29yayBpZiB0aGUgcHJvZmlsZXNTYW1wbGVSYXRlIGlzIHNldCB0byBhIGZhbHN5IHZhbHVlLlxuICogSW4gY29udGludW91cyBwcm9maWxpbmcgbW9kZSwgdGhlIHByb2ZpbGVyIHdpbGwga2VlcCByZXBvcnRpbmcgcHJvZmlsZSBjaHVua3MgdG8gU2VudHJ5IHVudGlsIGl0IGlzIHN0b3BwZWQsIHdoaWNoIGFsbG93cyBmb3IgY29udGludW91cyBwcm9maWxpbmcgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICovXG5mdW5jdGlvbiBzdGFydFByb2ZpbGVyKCkge1xuICBjb25zdCBjbGllbnQgPSBjdXJyZW50U2NvcGVzLmdldENsaWVudCgpO1xuICBpZiAoIWNsaWVudCkge1xuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdObyBTZW50cnkgY2xpZW50IGF2YWlsYWJsZSwgcHJvZmlsaW5nIGlzIG5vdCBzdGFydGVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgaW50ZWdyYXRpb24gPSBjbGllbnQuZ2V0SW50ZWdyYXRpb25CeU5hbWUoJ1Byb2ZpbGluZ0ludGVncmF0aW9uJyk7XG5cbiAgaWYgKCFpbnRlZ3JhdGlvbikge1xuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdQcm9maWxpbmdJbnRlZ3JhdGlvbiBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFpc1Byb2ZpbGluZ0ludGVncmF0aW9uV2l0aFByb2ZpbGVyKGludGVncmF0aW9uKSkge1xuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdQcm9maWxlciBpcyBub3QgYXZhaWxhYmxlIG9uIHByb2ZpbGluZyBpbnRlZ3JhdGlvbi4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpbnRlZ3JhdGlvbi5fcHJvZmlsZXIuc3RhcnQoKTtcbn1cblxuLyoqXG4gKiBTdG9wcyB0aGUgU2VudHJ5IGNvbnRpbnVvdXMgcHJvZmlsZXIuXG4gKiBDYWxscyB0byBzdG9wIHdpbGwgc3RvcCB0aGUgcHJvZmlsZXIgYW5kIGZsdXNoIHRoZSBjdXJyZW50bHkgY29sbGVjdGVkIHByb2ZpbGUgZGF0YSB0byBTZW50cnkuXG4gKi9cbmZ1bmN0aW9uIHN0b3BQcm9maWxlcigpIHtcbiAgY29uc3QgY2xpZW50ID0gY3VycmVudFNjb3Blcy5nZXRDbGllbnQoKTtcbiAgaWYgKCFjbGllbnQpIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybignTm8gU2VudHJ5IGNsaWVudCBhdmFpbGFibGUsIHByb2ZpbGluZyBpcyBub3Qgc3RhcnRlZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGludGVncmF0aW9uID0gY2xpZW50LmdldEludGVncmF0aW9uQnlOYW1lKCdQcm9maWxpbmdJbnRlZ3JhdGlvbicpO1xuICBpZiAoIWludGVncmF0aW9uKSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLndhcm4oJ1Byb2ZpbGluZ0ludGVncmF0aW9uIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWlzUHJvZmlsaW5nSW50ZWdyYXRpb25XaXRoUHJvZmlsZXIoaW50ZWdyYXRpb24pKSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLndhcm4oJ1Byb2ZpbGVyIGlzIG5vdCBhdmFpbGFibGUgb24gcHJvZmlsaW5nIGludGVncmF0aW9uLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGludGVncmF0aW9uLl9wcm9maWxlci5zdG9wKCk7XG59XG5cbmNvbnN0IHByb2ZpbGVyID0ge1xuICBzdGFydFByb2ZpbGVyLFxuICBzdG9wUHJvZmlsZXIsXG59O1xuXG5leHBvcnRzLnByb2ZpbGVyID0gcHJvZmlsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9maWxpbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/profiling.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/scope.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst session = __webpack_require__(/*! ./session.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/session.js\");\nconst merge = __webpack_require__(/*! ./utils/merge.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/merge.js\");\nconst spanOnScope = __webpack_require__(/*! ./utils/spanOnScope.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanOnScope.js\");\nconst is = __webpack_require__(/*! ./utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst misc = __webpack_require__(/*! ./utils-hoist/misc.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js\");\nconst propagationContext = __webpack_require__(/*! ./utils-hoist/propagationContext.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/propagationContext.js\");\nconst string = __webpack_require__(/*! ./utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\nconst time = __webpack_require__(/*! ./utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\n\n/**\n * Default value for maximum number of breadcrumbs added to an event.\n */\nconst DEFAULT_MAX_BREADCRUMBS = 100;\n\n/**\n * A context to be used for capturing an event.\n * This can either be a Scope, or a partial ScopeContext,\n * or a callback that receives the current scope and returns a new scope to use.\n */\n\n/**\n * Holds additional event information.\n */\nclass Scope {\n  /** Flag if notifying is happening. */\n\n  /** Callback for client to receive scope changes. */\n\n  /** Callback list that will be called during event processing. */\n\n  /** Array of breadcrumbs. */\n\n  /** User */\n\n  /** Tags */\n\n  /** Extra */\n\n  /** Contexts */\n\n  /** Attachments */\n\n  /** Propagation Context for distributed tracing */\n\n  /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */\n\n  /** Fingerprint */\n\n  /** Severity */\n\n  /**\n   * Transaction Name\n   *\n   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.\n   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.\n   */\n\n  /** Session */\n\n  /** The client on this scope */\n\n  /** Contains the last event id of a captured event.  */\n\n  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.\n\n   constructor() {\n    this._notifyingListeners = false;\n    this._scopeListeners = [];\n    this._eventProcessors = [];\n    this._breadcrumbs = [];\n    this._attachments = [];\n    this._user = {};\n    this._tags = {};\n    this._extra = {};\n    this._contexts = {};\n    this._sdkProcessingMetadata = {};\n    this._propagationContext = {\n      traceId: propagationContext.generateTraceId(),\n      sampleRand: Math.random(),\n    };\n  }\n\n  /**\n   * Clone all data from this scope into a new scope.\n   */\n   clone() {\n    const newScope = new Scope();\n    newScope._breadcrumbs = [...this._breadcrumbs];\n    newScope._tags = { ...this._tags };\n    newScope._extra = { ...this._extra };\n    newScope._contexts = { ...this._contexts };\n    if (this._contexts.flags) {\n      // We need to copy the `values` array so insertions on a cloned scope\n      // won't affect the original array.\n      newScope._contexts.flags = {\n        values: [...this._contexts.flags.values],\n      };\n    }\n\n    newScope._user = this._user;\n    newScope._level = this._level;\n    newScope._session = this._session;\n    newScope._transactionName = this._transactionName;\n    newScope._fingerprint = this._fingerprint;\n    newScope._eventProcessors = [...this._eventProcessors];\n    newScope._attachments = [...this._attachments];\n    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };\n    newScope._propagationContext = { ...this._propagationContext };\n    newScope._client = this._client;\n    newScope._lastEventId = this._lastEventId;\n\n    spanOnScope._setSpanForScope(newScope, spanOnScope._getSpanForScope(this));\n\n    return newScope;\n  }\n\n  /**\n   * Update the client assigned to this scope.\n   * Note that not every scope will have a client assigned - isolation scopes & the global scope will generally not have a client,\n   * as well as manually created scopes.\n   */\n   setClient(client) {\n    this._client = client;\n  }\n\n  /**\n   * Set the ID of the last captured error event.\n   * This is generally only captured on the isolation scope.\n   */\n   setLastEventId(lastEventId) {\n    this._lastEventId = lastEventId;\n  }\n\n  /**\n   * Get the client assigned to this scope.\n   */\n   getClient() {\n    return this._client ;\n  }\n\n  /**\n   * Get the ID of the last captured error event.\n   * This is generally only available on the isolation scope.\n   */\n   lastEventId() {\n    return this._lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addScopeListener(callback) {\n    this._scopeListeners.push(callback);\n  }\n\n  /**\n   * Add an event processor that will be called before an event is sent.\n   */\n   addEventProcessor(callback) {\n    this._eventProcessors.push(callback);\n    return this;\n  }\n\n  /**\n   * Set the user for this scope.\n   * Set to `null` to unset the user.\n   */\n   setUser(user) {\n    // If null is passed we want to unset everything, but still define keys,\n    // so that later down in the pipeline any existing values are cleared.\n    this._user = user || {\n      email: undefined,\n      id: undefined,\n      ip_address: undefined,\n      username: undefined,\n    };\n\n    if (this._session) {\n      session.updateSession(this._session, { user });\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Get the user from this scope.\n   */\n   getUser() {\n    return this._user;\n  }\n\n  /**\n   * Set an object that will be merged into existing tags on the scope,\n   * and will be sent as tags data with the event.\n   */\n   setTags(tags) {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set a single tag that will be sent as tags data with the event.\n   */\n   setTag(key, value) {\n    this._tags = { ...this._tags, [key]: value };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set an object that will be merged into existing extra on the scope,\n   * and will be sent as extra data with the event.\n   */\n   setExtras(extras) {\n    this._extra = {\n      ...this._extra,\n      ...extras,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set a single key:value extra entry that will be sent as extra data with the event.\n   */\n   setExtra(key, extra) {\n    this._extra = { ...this._extra, [key]: extra };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the fingerprint on the scope to send with the events.\n   * @param {string[]} fingerprint Fingerprint to group events in Sentry.\n   */\n   setFingerprint(fingerprint) {\n    this._fingerprint = fingerprint;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the level on the scope for future events.\n   */\n   setLevel(level) {\n    this._level = level;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the transaction name on the scope so that the name of e.g. taken server route or\n   * the page location is attached to future events.\n   *\n   * IMPORTANT: Calling this function does NOT change the name of the currently active\n   * root span. If you want to change the name of the active root span, use\n   * `Sentry.updateSpanName(rootSpan, 'new name')` instead.\n   *\n   * By default, the SDK updates the scope's transaction name automatically on sensible\n   * occasions, such as a page navigation or when handling a new request on the server.\n   */\n   setTransactionName(name) {\n    this._transactionName = name;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets context data with the given name.\n   * Data passed as context will be normalized. You can also pass `null` to unset the context.\n   * Note that context data will not be merged - calling `setContext` will overwrite an existing context with the same key.\n   */\n   setContext(key, context) {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts[key] = context;\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set the session for the scope.\n   */\n   setSession(session) {\n    if (!session) {\n      delete this._session;\n    } else {\n      this._session = session;\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Get the session from the scope.\n   */\n   getSession() {\n    return this._session;\n  }\n\n  /**\n   * Updates the scope with provided data. Can work in three variations:\n   * - plain object containing updatable attributes\n   * - Scope instance that'll extract the attributes from\n   * - callback function that'll receive the current scope as an argument and allow for modifications\n   */\n   update(captureContext) {\n    if (!captureContext) {\n      return this;\n    }\n\n    const scopeToMerge = typeof captureContext === 'function' ? captureContext(this) : captureContext;\n\n    const scopeInstance =\n      scopeToMerge instanceof Scope\n        ? scopeToMerge.getScopeData()\n        : is.isPlainObject(scopeToMerge)\n          ? (captureContext )\n          : undefined;\n\n    const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};\n\n    this._tags = { ...this._tags, ...tags };\n    this._extra = { ...this._extra, ...extra };\n    this._contexts = { ...this._contexts, ...contexts };\n\n    if (user && Object.keys(user).length) {\n      this._user = user;\n    }\n\n    if (level) {\n      this._level = level;\n    }\n\n    if (fingerprint.length) {\n      this._fingerprint = fingerprint;\n    }\n\n    if (propagationContext) {\n      this._propagationContext = propagationContext;\n    }\n\n    return this;\n  }\n\n  /**\n   * Clears the current scope and resets its properties.\n   * Note: The client will not be cleared.\n   */\n   clear() {\n    // client is not cleared here on purpose!\n    this._breadcrumbs = [];\n    this._tags = {};\n    this._extra = {};\n    this._user = {};\n    this._contexts = {};\n    this._level = undefined;\n    this._transactionName = undefined;\n    this._fingerprint = undefined;\n    this._session = undefined;\n    spanOnScope._setSpanForScope(this, undefined);\n    this._attachments = [];\n    this.setPropagationContext({ traceId: propagationContext.generateTraceId(), sampleRand: Math.random() });\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Adds a breadcrumb to the scope.\n   * By default, the last 100 breadcrumbs are kept.\n   */\n   addBreadcrumb(breadcrumb, maxBreadcrumbs) {\n    const maxCrumbs = typeof maxBreadcrumbs === 'number' ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;\n\n    // No data has been changed, so don't notify scope listeners\n    if (maxCrumbs <= 0) {\n      return this;\n    }\n\n    const mergedBreadcrumb = {\n      timestamp: time.dateTimestampInSeconds(),\n      ...breadcrumb,\n      // Breadcrumb messages can theoretically be infinitely large and they're held in memory so we truncate them not to leak (too much) memory\n      message: breadcrumb.message ? string.truncate(breadcrumb.message, 2048) : breadcrumb.message,\n    };\n\n    this._breadcrumbs.push(mergedBreadcrumb);\n    if (this._breadcrumbs.length > maxCrumbs) {\n      this._breadcrumbs = this._breadcrumbs.slice(-maxCrumbs);\n      this._client?.recordDroppedEvent('buffer_overflow', 'log_item');\n    }\n\n    this._notifyScopeListeners();\n\n    return this;\n  }\n\n  /**\n   * Get the last breadcrumb of the scope.\n   */\n   getLastBreadcrumb() {\n    return this._breadcrumbs[this._breadcrumbs.length - 1];\n  }\n\n  /**\n   * Clear all breadcrumbs from the scope.\n   */\n   clearBreadcrumbs() {\n    this._breadcrumbs = [];\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Add an attachment to the scope.\n   */\n   addAttachment(attachment) {\n    this._attachments.push(attachment);\n    return this;\n  }\n\n  /**\n   * Clear all attachments from the scope.\n   */\n   clearAttachments() {\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * Get the data of this scope, which should be applied to an event during processing.\n   */\n   getScopeData() {\n    return {\n      breadcrumbs: this._breadcrumbs,\n      attachments: this._attachments,\n      contexts: this._contexts,\n      tags: this._tags,\n      extra: this._extra,\n      user: this._user,\n      level: this._level,\n      fingerprint: this._fingerprint || [],\n      eventProcessors: this._eventProcessors,\n      propagationContext: this._propagationContext,\n      sdkProcessingMetadata: this._sdkProcessingMetadata,\n      transactionName: this._transactionName,\n      span: spanOnScope._getSpanForScope(this),\n    };\n  }\n\n  /**\n   * Add data which will be accessible during event processing but won't get sent to Sentry.\n   */\n   setSDKProcessingMetadata(newData) {\n    this._sdkProcessingMetadata = merge.merge(this._sdkProcessingMetadata, newData, 2);\n    return this;\n  }\n\n  /**\n   * Add propagation context to the scope, used for distributed tracing\n   */\n   setPropagationContext(context) {\n    this._propagationContext = context;\n    return this;\n  }\n\n  /**\n   * Get propagation context from the scope, used for distributed tracing\n   */\n   getPropagationContext() {\n    return this._propagationContext;\n  }\n\n  /**\n   * Capture an exception for this scope.\n   *\n   * @returns {string} The id of the captured Sentry event.\n   */\n   captureException(exception, hint) {\n    const eventId = hint?.event_id || misc.uuid4();\n\n    if (!this._client) {\n      logger.logger.warn('No client configured on scope - will not capture exception!');\n      return eventId;\n    }\n\n    const syntheticException = new Error('Sentry syntheticException');\n\n    this._client.captureException(\n      exception,\n      {\n        originalException: exception,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * Capture a message for this scope.\n   *\n   * @returns {string} The id of the captured message.\n   */\n   captureMessage(message, level, hint) {\n    const eventId = hint?.event_id || misc.uuid4();\n\n    if (!this._client) {\n      logger.logger.warn('No client configured on scope - will not capture message!');\n      return eventId;\n    }\n\n    const syntheticException = new Error(message);\n\n    this._client.captureMessage(\n      message,\n      level,\n      {\n        originalException: message,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * Capture a Sentry event for this scope.\n   *\n   * @returns {string} The id of the captured event.\n   */\n   captureEvent(event, hint) {\n    const eventId = hint?.event_id || misc.uuid4();\n\n    if (!this._client) {\n      logger.logger.warn('No client configured on scope - will not capture event!');\n      return eventId;\n    }\n\n    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);\n\n    return eventId;\n  }\n\n  /**\n   * This will be called on every set call.\n   */\n   _notifyScopeListeners() {\n    // We need this check for this._notifyingListeners to be able to work on scope during updates\n    // If this check is not here we'll produce endless recursion when something is done with the scope\n    // during the callback.\n    if (!this._notifyingListeners) {\n      this._notifyingListeners = true;\n      this._scopeListeners.forEach(callback => {\n        callback(this);\n      });\n      this._notifyingListeners = false;\n    }\n  }\n}\n\nexports.Scope = Scope;\n//# sourceMappingURL=scope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3Njb3BlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLGdCQUFnQixtQkFBTyxDQUFDLCtHQUFjO0FBQ3RDLGNBQWMsbUJBQU8sQ0FBQyx1SEFBa0I7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsbUlBQXdCO0FBQ3BELFdBQVcsbUJBQU8sQ0FBQyw2SEFBcUI7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLHFJQUF5QjtBQUNoRCxhQUFhLG1CQUFPLENBQUMsaUlBQXVCO0FBQzVDLDJCQUEyQixtQkFBTyxDQUFDLDZKQUFxQztBQUN4RSxlQUFlLG1CQUFPLENBQUMscUlBQXlCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQyxpSUFBdUI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksMkVBQTJFOztBQUV2RixtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwRUFBMEU7O0FBRTNHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLDRCQUE0Qjs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxzY29wZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3Qgc2Vzc2lvbiA9IHJlcXVpcmUoJy4vc2Vzc2lvbi5qcycpO1xuY29uc3QgbWVyZ2UgPSByZXF1aXJlKCcuL3V0aWxzL21lcmdlLmpzJyk7XG5jb25zdCBzcGFuT25TY29wZSA9IHJlcXVpcmUoJy4vdXRpbHMvc3Bhbk9uU2NvcGUuanMnKTtcbmNvbnN0IGlzID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9pcy5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IG1pc2MgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L21pc2MuanMnKTtcbmNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvcHJvcGFnYXRpb25Db250ZXh0LmpzJyk7XG5jb25zdCBzdHJpbmcgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3N0cmluZy5qcycpO1xuY29uc3QgdGltZSA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvdGltZS5qcycpO1xuXG4vKipcbiAqIERlZmF1bHQgdmFsdWUgZm9yIG1heGltdW0gbnVtYmVyIG9mIGJyZWFkY3J1bWJzIGFkZGVkIHRvIGFuIGV2ZW50LlxuICovXG5jb25zdCBERUZBVUxUX01BWF9CUkVBRENSVU1CUyA9IDEwMDtcblxuLyoqXG4gKiBBIGNvbnRleHQgdG8gYmUgdXNlZCBmb3IgY2FwdHVyaW5nIGFuIGV2ZW50LlxuICogVGhpcyBjYW4gZWl0aGVyIGJlIGEgU2NvcGUsIG9yIGEgcGFydGlhbCBTY29wZUNvbnRleHQsXG4gKiBvciBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgc2NvcGUgYW5kIHJldHVybnMgYSBuZXcgc2NvcGUgdG8gdXNlLlxuICovXG5cbi8qKlxuICogSG9sZHMgYWRkaXRpb25hbCBldmVudCBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgU2NvcGUge1xuICAvKiogRmxhZyBpZiBub3RpZnlpbmcgaXMgaGFwcGVuaW5nLiAqL1xuXG4gIC8qKiBDYWxsYmFjayBmb3IgY2xpZW50IHRvIHJlY2VpdmUgc2NvcGUgY2hhbmdlcy4gKi9cblxuICAvKiogQ2FsbGJhY2sgbGlzdCB0aGF0IHdpbGwgYmUgY2FsbGVkIGR1cmluZyBldmVudCBwcm9jZXNzaW5nLiAqL1xuXG4gIC8qKiBBcnJheSBvZiBicmVhZGNydW1icy4gKi9cblxuICAvKiogVXNlciAqL1xuXG4gIC8qKiBUYWdzICovXG5cbiAgLyoqIEV4dHJhICovXG5cbiAgLyoqIENvbnRleHRzICovXG5cbiAgLyoqIEF0dGFjaG1lbnRzICovXG5cbiAgLyoqIFByb3BhZ2F0aW9uIENvbnRleHQgZm9yIGRpc3RyaWJ1dGVkIHRyYWNpbmcgKi9cblxuICAvKipcbiAgICogQSBwbGFjZSB0byBzdGFzaCBkYXRhIHdoaWNoIGlzIG5lZWRlZCBhdCBzb21lIHBvaW50IGluIHRoZSBTREsncyBldmVudCBwcm9jZXNzaW5nIHBpcGVsaW5lIGJ1dCB3aGljaCBzaG91bGRuJ3QgZ2V0XG4gICAqIHNlbnQgdG8gU2VudHJ5XG4gICAqL1xuXG4gIC8qKiBGaW5nZXJwcmludCAqL1xuXG4gIC8qKiBTZXZlcml0eSAqL1xuXG4gIC8qKlxuICAgKiBUcmFuc2FjdGlvbiBOYW1lXG4gICAqXG4gICAqIElNUE9SVEFOVDogVGhlIHRyYW5zYWN0aW9uIG5hbWUgb24gdGhlIHNjb3BlIGhhcyBub3RoaW5nIHRvIGRvIHdpdGggcm9vdCBzcGFucy90cmFuc2FjdGlvbiBvYmplY3RzLlxuICAgKiBJdCdzIHB1cnBvc2UgaXMgdG8gYXNzaWduIGEgdHJhbnNhY3Rpb24gdG8gdGhlIHNjb3BlIHRoYXQncyBhZGRlZCB0byBub24tdHJhbnNhY3Rpb24gZXZlbnRzLlxuICAgKi9cblxuICAvKiogU2Vzc2lvbiAqL1xuXG4gIC8qKiBUaGUgY2xpZW50IG9uIHRoaXMgc2NvcGUgKi9cblxuICAvKiogQ29udGFpbnMgdGhlIGxhc3QgZXZlbnQgaWQgb2YgYSBjYXB0dXJlZCBldmVudC4gICovXG5cbiAgLy8gTk9URTogQW55IGZpZWxkIHdoaWNoIGdldHMgYWRkZWQgaGVyZSBzaG91bGQgZ2V0IGFkZGVkIG5vdCBvbmx5IHRvIHRoZSBjb25zdHJ1Y3RvciBidXQgYWxzbyB0byB0aGUgYGNsb25lYCBtZXRob2QuXG5cbiAgIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX25vdGlmeWluZ0xpc3RlbmVycyA9IGZhbHNlO1xuICAgIHRoaXMuX3Njb3BlTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fZXZlbnRQcm9jZXNzb3JzID0gW107XG4gICAgdGhpcy5fYnJlYWRjcnVtYnMgPSBbXTtcbiAgICB0aGlzLl9hdHRhY2htZW50cyA9IFtdO1xuICAgIHRoaXMuX3VzZXIgPSB7fTtcbiAgICB0aGlzLl90YWdzID0ge307XG4gICAgdGhpcy5fZXh0cmEgPSB7fTtcbiAgICB0aGlzLl9jb250ZXh0cyA9IHt9O1xuICAgIHRoaXMuX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IHt9O1xuICAgIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCA9IHtcbiAgICAgIHRyYWNlSWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5nZW5lcmF0ZVRyYWNlSWQoKSxcbiAgICAgIHNhbXBsZVJhbmQ6IE1hdGgucmFuZG9tKCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZSBhbGwgZGF0YSBmcm9tIHRoaXMgc2NvcGUgaW50byBhIG5ldyBzY29wZS5cbiAgICovXG4gICBjbG9uZSgpIHtcbiAgICBjb25zdCBuZXdTY29wZSA9IG5ldyBTY29wZSgpO1xuICAgIG5ld1Njb3BlLl9icmVhZGNydW1icyA9IFsuLi50aGlzLl9icmVhZGNydW1ic107XG4gICAgbmV3U2NvcGUuX3RhZ3MgPSB7IC4uLnRoaXMuX3RhZ3MgfTtcbiAgICBuZXdTY29wZS5fZXh0cmEgPSB7IC4uLnRoaXMuX2V4dHJhIH07XG4gICAgbmV3U2NvcGUuX2NvbnRleHRzID0geyAuLi50aGlzLl9jb250ZXh0cyB9O1xuICAgIGlmICh0aGlzLl9jb250ZXh0cy5mbGFncykge1xuICAgICAgLy8gV2UgbmVlZCB0byBjb3B5IHRoZSBgdmFsdWVzYCBhcnJheSBzbyBpbnNlcnRpb25zIG9uIGEgY2xvbmVkIHNjb3BlXG4gICAgICAvLyB3b24ndCBhZmZlY3QgdGhlIG9yaWdpbmFsIGFycmF5LlxuICAgICAgbmV3U2NvcGUuX2NvbnRleHRzLmZsYWdzID0ge1xuICAgICAgICB2YWx1ZXM6IFsuLi50aGlzLl9jb250ZXh0cy5mbGFncy52YWx1ZXNdLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBuZXdTY29wZS5fdXNlciA9IHRoaXMuX3VzZXI7XG4gICAgbmV3U2NvcGUuX2xldmVsID0gdGhpcy5fbGV2ZWw7XG4gICAgbmV3U2NvcGUuX3Nlc3Npb24gPSB0aGlzLl9zZXNzaW9uO1xuICAgIG5ld1Njb3BlLl90cmFuc2FjdGlvbk5hbWUgPSB0aGlzLl90cmFuc2FjdGlvbk5hbWU7XG4gICAgbmV3U2NvcGUuX2ZpbmdlcnByaW50ID0gdGhpcy5fZmluZ2VycHJpbnQ7XG4gICAgbmV3U2NvcGUuX2V2ZW50UHJvY2Vzc29ycyA9IFsuLi50aGlzLl9ldmVudFByb2Nlc3NvcnNdO1xuICAgIG5ld1Njb3BlLl9hdHRhY2htZW50cyA9IFsuLi50aGlzLl9hdHRhY2htZW50c107XG4gICAgbmV3U2NvcGUuX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IHsgLi4udGhpcy5fc2RrUHJvY2Vzc2luZ01ldGFkYXRhIH07XG4gICAgbmV3U2NvcGUuX3Byb3BhZ2F0aW9uQ29udGV4dCA9IHsgLi4udGhpcy5fcHJvcGFnYXRpb25Db250ZXh0IH07XG4gICAgbmV3U2NvcGUuX2NsaWVudCA9IHRoaXMuX2NsaWVudDtcbiAgICBuZXdTY29wZS5fbGFzdEV2ZW50SWQgPSB0aGlzLl9sYXN0RXZlbnRJZDtcblxuICAgIHNwYW5PblNjb3BlLl9zZXRTcGFuRm9yU2NvcGUobmV3U2NvcGUsIHNwYW5PblNjb3BlLl9nZXRTcGFuRm9yU2NvcGUodGhpcykpO1xuXG4gICAgcmV0dXJuIG5ld1Njb3BlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY2xpZW50IGFzc2lnbmVkIHRvIHRoaXMgc2NvcGUuXG4gICAqIE5vdGUgdGhhdCBub3QgZXZlcnkgc2NvcGUgd2lsbCBoYXZlIGEgY2xpZW50IGFzc2lnbmVkIC0gaXNvbGF0aW9uIHNjb3BlcyAmIHRoZSBnbG9iYWwgc2NvcGUgd2lsbCBnZW5lcmFsbHkgbm90IGhhdmUgYSBjbGllbnQsXG4gICAqIGFzIHdlbGwgYXMgbWFudWFsbHkgY3JlYXRlZCBzY29wZXMuXG4gICAqL1xuICAgc2V0Q2xpZW50KGNsaWVudCkge1xuICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIElEIG9mIHRoZSBsYXN0IGNhcHR1cmVkIGVycm9yIGV2ZW50LlxuICAgKiBUaGlzIGlzIGdlbmVyYWxseSBvbmx5IGNhcHR1cmVkIG9uIHRoZSBpc29sYXRpb24gc2NvcGUuXG4gICAqL1xuICAgc2V0TGFzdEV2ZW50SWQobGFzdEV2ZW50SWQpIHtcbiAgICB0aGlzLl9sYXN0RXZlbnRJZCA9IGxhc3RFdmVudElkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY2xpZW50IGFzc2lnbmVkIHRvIHRoaXMgc2NvcGUuXG4gICAqL1xuICAgZ2V0Q2xpZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQgO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgSUQgb2YgdGhlIGxhc3QgY2FwdHVyZWQgZXJyb3IgZXZlbnQuXG4gICAqIFRoaXMgaXMgZ2VuZXJhbGx5IG9ubHkgYXZhaWxhYmxlIG9uIHRoZSBpc29sYXRpb24gc2NvcGUuXG4gICAqL1xuICAgbGFzdEV2ZW50SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhc3RFdmVudElkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgYWRkU2NvcGVMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIHRoaXMuX3Njb3BlTGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBwcm9jZXNzb3IgdGhhdCB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgYW4gZXZlbnQgaXMgc2VudC5cbiAgICovXG4gICBhZGRFdmVudFByb2Nlc3NvcihjYWxsYmFjaykge1xuICAgIHRoaXMuX2V2ZW50UHJvY2Vzc29ycy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHVzZXIgZm9yIHRoaXMgc2NvcGUuXG4gICAqIFNldCB0byBgbnVsbGAgdG8gdW5zZXQgdGhlIHVzZXIuXG4gICAqL1xuICAgc2V0VXNlcih1c2VyKSB7XG4gICAgLy8gSWYgbnVsbCBpcyBwYXNzZWQgd2Ugd2FudCB0byB1bnNldCBldmVyeXRoaW5nLCBidXQgc3RpbGwgZGVmaW5lIGtleXMsXG4gICAgLy8gc28gdGhhdCBsYXRlciBkb3duIGluIHRoZSBwaXBlbGluZSBhbnkgZXhpc3RpbmcgdmFsdWVzIGFyZSBjbGVhcmVkLlxuICAgIHRoaXMuX3VzZXIgPSB1c2VyIHx8IHtcbiAgICAgIGVtYWlsOiB1bmRlZmluZWQsXG4gICAgICBpZDogdW5kZWZpbmVkLFxuICAgICAgaXBfYWRkcmVzczogdW5kZWZpbmVkLFxuICAgICAgdXNlcm5hbWU6IHVuZGVmaW5lZCxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX3Nlc3Npb24pIHtcbiAgICAgIHNlc3Npb24udXBkYXRlU2Vzc2lvbih0aGlzLl9zZXNzaW9uLCB7IHVzZXIgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIgZnJvbSB0aGlzIHNjb3BlLlxuICAgKi9cbiAgIGdldFVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGFuIG9iamVjdCB0aGF0IHdpbGwgYmUgbWVyZ2VkIGludG8gZXhpc3RpbmcgdGFncyBvbiB0aGUgc2NvcGUsXG4gICAqIGFuZCB3aWxsIGJlIHNlbnQgYXMgdGFncyBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICAgKi9cbiAgIHNldFRhZ3ModGFncykge1xuICAgIHRoaXMuX3RhZ3MgPSB7XG4gICAgICAuLi50aGlzLl90YWdzLFxuICAgICAgLi4udGFncyxcbiAgICB9O1xuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgc2luZ2xlIHRhZyB0aGF0IHdpbGwgYmUgc2VudCBhcyB0YWdzIGRhdGEgd2l0aCB0aGUgZXZlbnQuXG4gICAqL1xuICAgc2V0VGFnKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl90YWdzID0geyAuLi50aGlzLl90YWdzLCBba2V5XTogdmFsdWUgfTtcbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhbiBvYmplY3QgdGhhdCB3aWxsIGJlIG1lcmdlZCBpbnRvIGV4aXN0aW5nIGV4dHJhIG9uIHRoZSBzY29wZSxcbiAgICogYW5kIHdpbGwgYmUgc2VudCBhcyBleHRyYSBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICAgKi9cbiAgIHNldEV4dHJhcyhleHRyYXMpIHtcbiAgICB0aGlzLl9leHRyYSA9IHtcbiAgICAgIC4uLnRoaXMuX2V4dHJhLFxuICAgICAgLi4uZXh0cmFzLFxuICAgIH07XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBzaW5nbGUga2V5OnZhbHVlIGV4dHJhIGVudHJ5IHRoYXQgd2lsbCBiZSBzZW50IGFzIGV4dHJhIGRhdGEgd2l0aCB0aGUgZXZlbnQuXG4gICAqL1xuICAgc2V0RXh0cmEoa2V5LCBleHRyYSkge1xuICAgIHRoaXMuX2V4dHJhID0geyAuLi50aGlzLl9leHRyYSwgW2tleV06IGV4dHJhIH07XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaW5nZXJwcmludCBvbiB0aGUgc2NvcGUgdG8gc2VuZCB3aXRoIHRoZSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGZpbmdlcnByaW50IEZpbmdlcnByaW50IHRvIGdyb3VwIGV2ZW50cyBpbiBTZW50cnkuXG4gICAqL1xuICAgc2V0RmluZ2VycHJpbnQoZmluZ2VycHJpbnQpIHtcbiAgICB0aGlzLl9maW5nZXJwcmludCA9IGZpbmdlcnByaW50O1xuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGV2ZWwgb24gdGhlIHNjb3BlIGZvciBmdXR1cmUgZXZlbnRzLlxuICAgKi9cbiAgIHNldExldmVsKGxldmVsKSB7XG4gICAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRyYW5zYWN0aW9uIG5hbWUgb24gdGhlIHNjb3BlIHNvIHRoYXQgdGhlIG5hbWUgb2YgZS5nLiB0YWtlbiBzZXJ2ZXIgcm91dGUgb3JcbiAgICogdGhlIHBhZ2UgbG9jYXRpb24gaXMgYXR0YWNoZWQgdG8gZnV0dXJlIGV2ZW50cy5cbiAgICpcbiAgICogSU1QT1JUQU5UOiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gZG9lcyBOT1QgY2hhbmdlIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlXG4gICAqIHJvb3Qgc3Bhbi4gSWYgeW91IHdhbnQgdG8gY2hhbmdlIHRoZSBuYW1lIG9mIHRoZSBhY3RpdmUgcm9vdCBzcGFuLCB1c2VcbiAgICogYFNlbnRyeS51cGRhdGVTcGFuTmFtZShyb290U3BhbiwgJ25ldyBuYW1lJylgIGluc3RlYWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBTREsgdXBkYXRlcyB0aGUgc2NvcGUncyB0cmFuc2FjdGlvbiBuYW1lIGF1dG9tYXRpY2FsbHkgb24gc2Vuc2libGVcbiAgICogb2NjYXNpb25zLCBzdWNoIGFzIGEgcGFnZSBuYXZpZ2F0aW9uIG9yIHdoZW4gaGFuZGxpbmcgYSBuZXcgcmVxdWVzdCBvbiB0aGUgc2VydmVyLlxuICAgKi9cbiAgIHNldFRyYW5zYWN0aW9uTmFtZShuYW1lKSB7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb25OYW1lID0gbmFtZTtcbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgY29udGV4dCBkYXRhIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqIERhdGEgcGFzc2VkIGFzIGNvbnRleHQgd2lsbCBiZSBub3JtYWxpemVkLiBZb3UgY2FuIGFsc28gcGFzcyBgbnVsbGAgdG8gdW5zZXQgdGhlIGNvbnRleHQuXG4gICAqIE5vdGUgdGhhdCBjb250ZXh0IGRhdGEgd2lsbCBub3QgYmUgbWVyZ2VkIC0gY2FsbGluZyBgc2V0Q29udGV4dGAgd2lsbCBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgY29udGV4dCB3aXRoIHRoZSBzYW1lIGtleS5cbiAgICovXG4gICBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICBkZWxldGUgdGhpcy5fY29udGV4dHNba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY29udGV4dHNba2V5XSA9IGNvbnRleHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNlc3Npb24gZm9yIHRoZSBzY29wZS5cbiAgICovXG4gICBzZXRTZXNzaW9uKHNlc3Npb24pIHtcbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zZXNzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICB9XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlc3Npb24gZnJvbSB0aGUgc2NvcGUuXG4gICAqL1xuICAgZ2V0U2Vzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzY29wZSB3aXRoIHByb3ZpZGVkIGRhdGEuIENhbiB3b3JrIGluIHRocmVlIHZhcmlhdGlvbnM6XG4gICAqIC0gcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdXBkYXRhYmxlIGF0dHJpYnV0ZXNcbiAgICogLSBTY29wZSBpbnN0YW5jZSB0aGF0J2xsIGV4dHJhY3QgdGhlIGF0dHJpYnV0ZXMgZnJvbVxuICAgKiAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQnbGwgcmVjZWl2ZSB0aGUgY3VycmVudCBzY29wZSBhcyBhbiBhcmd1bWVudCBhbmQgYWxsb3cgZm9yIG1vZGlmaWNhdGlvbnNcbiAgICovXG4gICB1cGRhdGUoY2FwdHVyZUNvbnRleHQpIHtcbiAgICBpZiAoIWNhcHR1cmVDb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBzY29wZVRvTWVyZ2UgPSB0eXBlb2YgY2FwdHVyZUNvbnRleHQgPT09ICdmdW5jdGlvbicgPyBjYXB0dXJlQ29udGV4dCh0aGlzKSA6IGNhcHR1cmVDb250ZXh0O1xuXG4gICAgY29uc3Qgc2NvcGVJbnN0YW5jZSA9XG4gICAgICBzY29wZVRvTWVyZ2UgaW5zdGFuY2VvZiBTY29wZVxuICAgICAgICA/IHNjb3BlVG9NZXJnZS5nZXRTY29wZURhdGEoKVxuICAgICAgICA6IGlzLmlzUGxhaW5PYmplY3Qoc2NvcGVUb01lcmdlKVxuICAgICAgICAgID8gKGNhcHR1cmVDb250ZXh0IClcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHsgdGFncywgZXh0cmEsIHVzZXIsIGNvbnRleHRzLCBsZXZlbCwgZmluZ2VycHJpbnQgPSBbXSwgcHJvcGFnYXRpb25Db250ZXh0IH0gPSBzY29wZUluc3RhbmNlIHx8IHt9O1xuXG4gICAgdGhpcy5fdGFncyA9IHsgLi4udGhpcy5fdGFncywgLi4udGFncyB9O1xuICAgIHRoaXMuX2V4dHJhID0geyAuLi50aGlzLl9leHRyYSwgLi4uZXh0cmEgfTtcbiAgICB0aGlzLl9jb250ZXh0cyA9IHsgLi4udGhpcy5fY29udGV4dHMsIC4uLmNvbnRleHRzIH07XG5cbiAgICBpZiAodXNlciAmJiBPYmplY3Qua2V5cyh1c2VyKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3VzZXIgPSB1c2VyO1xuICAgIH1cblxuICAgIGlmIChsZXZlbCkge1xuICAgICAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgICB9XG5cbiAgICBpZiAoZmluZ2VycHJpbnQubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9maW5nZXJwcmludCA9IGZpbmdlcnByaW50O1xuICAgIH1cblxuICAgIGlmIChwcm9wYWdhdGlvbkNvbnRleHQpIHtcbiAgICAgIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCA9IHByb3BhZ2F0aW9uQ29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGN1cnJlbnQgc2NvcGUgYW5kIHJlc2V0cyBpdHMgcHJvcGVydGllcy5cbiAgICogTm90ZTogVGhlIGNsaWVudCB3aWxsIG5vdCBiZSBjbGVhcmVkLlxuICAgKi9cbiAgIGNsZWFyKCkge1xuICAgIC8vIGNsaWVudCBpcyBub3QgY2xlYXJlZCBoZXJlIG9uIHB1cnBvc2UhXG4gICAgdGhpcy5fYnJlYWRjcnVtYnMgPSBbXTtcbiAgICB0aGlzLl90YWdzID0ge307XG4gICAgdGhpcy5fZXh0cmEgPSB7fTtcbiAgICB0aGlzLl91c2VyID0ge307XG4gICAgdGhpcy5fY29udGV4dHMgPSB7fTtcbiAgICB0aGlzLl9sZXZlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90cmFuc2FjdGlvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZmluZ2VycHJpbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2Vzc2lvbiA9IHVuZGVmaW5lZDtcbiAgICBzcGFuT25TY29wZS5fc2V0U3BhbkZvclNjb3BlKHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgdGhpcy5fYXR0YWNobWVudHMgPSBbXTtcbiAgICB0aGlzLnNldFByb3BhZ2F0aW9uQ29udGV4dCh7IHRyYWNlSWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5nZW5lcmF0ZVRyYWNlSWQoKSwgc2FtcGxlUmFuZDogTWF0aC5yYW5kb20oKSB9KTtcblxuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGJyZWFkY3J1bWIgdG8gdGhlIHNjb3BlLlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgbGFzdCAxMDAgYnJlYWRjcnVtYnMgYXJlIGtlcHQuXG4gICAqL1xuICAgYWRkQnJlYWRjcnVtYihicmVhZGNydW1iLCBtYXhCcmVhZGNydW1icykge1xuICAgIGNvbnN0IG1heENydW1icyA9IHR5cGVvZiBtYXhCcmVhZGNydW1icyA9PT0gJ251bWJlcicgPyBtYXhCcmVhZGNydW1icyA6IERFRkFVTFRfTUFYX0JSRUFEQ1JVTUJTO1xuXG4gICAgLy8gTm8gZGF0YSBoYXMgYmVlbiBjaGFuZ2VkLCBzbyBkb24ndCBub3RpZnkgc2NvcGUgbGlzdGVuZXJzXG4gICAgaWYgKG1heENydW1icyA8PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBtZXJnZWRCcmVhZGNydW1iID0ge1xuICAgICAgdGltZXN0YW1wOiB0aW1lLmRhdGVUaW1lc3RhbXBJblNlY29uZHMoKSxcbiAgICAgIC4uLmJyZWFkY3J1bWIsXG4gICAgICAvLyBCcmVhZGNydW1iIG1lc3NhZ2VzIGNhbiB0aGVvcmV0aWNhbGx5IGJlIGluZmluaXRlbHkgbGFyZ2UgYW5kIHRoZXkncmUgaGVsZCBpbiBtZW1vcnkgc28gd2UgdHJ1bmNhdGUgdGhlbSBub3QgdG8gbGVhayAodG9vIG11Y2gpIG1lbW9yeVxuICAgICAgbWVzc2FnZTogYnJlYWRjcnVtYi5tZXNzYWdlID8gc3RyaW5nLnRydW5jYXRlKGJyZWFkY3J1bWIubWVzc2FnZSwgMjA0OCkgOiBicmVhZGNydW1iLm1lc3NhZ2UsXG4gICAgfTtcblxuICAgIHRoaXMuX2JyZWFkY3J1bWJzLnB1c2gobWVyZ2VkQnJlYWRjcnVtYik7XG4gICAgaWYgKHRoaXMuX2JyZWFkY3J1bWJzLmxlbmd0aCA+IG1heENydW1icykge1xuICAgICAgdGhpcy5fYnJlYWRjcnVtYnMgPSB0aGlzLl9icmVhZGNydW1icy5zbGljZSgtbWF4Q3J1bWJzKTtcbiAgICAgIHRoaXMuX2NsaWVudD8ucmVjb3JkRHJvcHBlZEV2ZW50KCdidWZmZXJfb3ZlcmZsb3cnLCAnbG9nX2l0ZW0nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXN0IGJyZWFkY3J1bWIgb2YgdGhlIHNjb3BlLlxuICAgKi9cbiAgIGdldExhc3RCcmVhZGNydW1iKCkge1xuICAgIHJldHVybiB0aGlzLl9icmVhZGNydW1ic1t0aGlzLl9icmVhZGNydW1icy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgYnJlYWRjcnVtYnMgZnJvbSB0aGUgc2NvcGUuXG4gICAqL1xuICAgY2xlYXJCcmVhZGNydW1icygpIHtcbiAgICB0aGlzLl9icmVhZGNydW1icyA9IFtdO1xuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGF0dGFjaG1lbnQgdG8gdGhlIHNjb3BlLlxuICAgKi9cbiAgIGFkZEF0dGFjaG1lbnQoYXR0YWNobWVudCkge1xuICAgIHRoaXMuX2F0dGFjaG1lbnRzLnB1c2goYXR0YWNobWVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGF0dGFjaG1lbnRzIGZyb20gdGhlIHNjb3BlLlxuICAgKi9cbiAgIGNsZWFyQXR0YWNobWVudHMoKSB7XG4gICAgdGhpcy5fYXR0YWNobWVudHMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRhdGEgb2YgdGhpcyBzY29wZSwgd2hpY2ggc2hvdWxkIGJlIGFwcGxpZWQgdG8gYW4gZXZlbnQgZHVyaW5nIHByb2Nlc3NpbmcuXG4gICAqL1xuICAgZ2V0U2NvcGVEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBicmVhZGNydW1iczogdGhpcy5fYnJlYWRjcnVtYnMsXG4gICAgICBhdHRhY2htZW50czogdGhpcy5fYXR0YWNobWVudHMsXG4gICAgICBjb250ZXh0czogdGhpcy5fY29udGV4dHMsXG4gICAgICB0YWdzOiB0aGlzLl90YWdzLFxuICAgICAgZXh0cmE6IHRoaXMuX2V4dHJhLFxuICAgICAgdXNlcjogdGhpcy5fdXNlcixcbiAgICAgIGxldmVsOiB0aGlzLl9sZXZlbCxcbiAgICAgIGZpbmdlcnByaW50OiB0aGlzLl9maW5nZXJwcmludCB8fCBbXSxcbiAgICAgIGV2ZW50UHJvY2Vzc29yczogdGhpcy5fZXZlbnRQcm9jZXNzb3JzLFxuICAgICAgcHJvcGFnYXRpb25Db250ZXh0OiB0aGlzLl9wcm9wYWdhdGlvbkNvbnRleHQsXG4gICAgICBzZGtQcm9jZXNzaW5nTWV0YWRhdGE6IHRoaXMuX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSxcbiAgICAgIHRyYW5zYWN0aW9uTmFtZTogdGhpcy5fdHJhbnNhY3Rpb25OYW1lLFxuICAgICAgc3Bhbjogc3Bhbk9uU2NvcGUuX2dldFNwYW5Gb3JTY29wZSh0aGlzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBkYXRhIHdoaWNoIHdpbGwgYmUgYWNjZXNzaWJsZSBkdXJpbmcgZXZlbnQgcHJvY2Vzc2luZyBidXQgd29uJ3QgZ2V0IHNlbnQgdG8gU2VudHJ5LlxuICAgKi9cbiAgIHNldFNES1Byb2Nlc3NpbmdNZXRhZGF0YShuZXdEYXRhKSB7XG4gICAgdGhpcy5fc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0gbWVyZ2UubWVyZ2UodGhpcy5fc2RrUHJvY2Vzc2luZ01ldGFkYXRhLCBuZXdEYXRhLCAyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgcHJvcGFnYXRpb24gY29udGV4dCB0byB0aGUgc2NvcGUsIHVzZWQgZm9yIGRpc3RyaWJ1dGVkIHRyYWNpbmdcbiAgICovXG4gICBzZXRQcm9wYWdhdGlvbkNvbnRleHQoY29udGV4dCkge1xuICAgIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHByb3BhZ2F0aW9uIGNvbnRleHQgZnJvbSB0aGUgc2NvcGUsIHVzZWQgZm9yIGRpc3RyaWJ1dGVkIHRyYWNpbmdcbiAgICovXG4gICBnZXRQcm9wYWdhdGlvbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXB0dXJlIGFuIGV4Y2VwdGlvbiBmb3IgdGhpcyBzY29wZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGlkIG9mIHRoZSBjYXB0dXJlZCBTZW50cnkgZXZlbnQuXG4gICAqL1xuICAgY2FwdHVyZUV4Y2VwdGlvbihleGNlcHRpb24sIGhpbnQpIHtcbiAgICBjb25zdCBldmVudElkID0gaGludD8uZXZlbnRfaWQgfHwgbWlzYy51dWlkNCgpO1xuXG4gICAgaWYgKCF0aGlzLl9jbGllbnQpIHtcbiAgICAgIGxvZ2dlci5sb2dnZXIud2FybignTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIGV4Y2VwdGlvbiEnKTtcbiAgICAgIHJldHVybiBldmVudElkO1xuICAgIH1cblxuICAgIGNvbnN0IHN5bnRoZXRpY0V4Y2VwdGlvbiA9IG5ldyBFcnJvcignU2VudHJ5IHN5bnRoZXRpY0V4Y2VwdGlvbicpO1xuXG4gICAgdGhpcy5fY2xpZW50LmNhcHR1cmVFeGNlcHRpb24oXG4gICAgICBleGNlcHRpb24sXG4gICAgICB7XG4gICAgICAgIG9yaWdpbmFsRXhjZXB0aW9uOiBleGNlcHRpb24sXG4gICAgICAgIHN5bnRoZXRpY0V4Y2VwdGlvbixcbiAgICAgICAgLi4uaGludCxcbiAgICAgICAgZXZlbnRfaWQ6IGV2ZW50SWQsXG4gICAgICB9LFxuICAgICAgdGhpcyxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV2ZW50SWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FwdHVyZSBhIG1lc3NhZ2UgZm9yIHRoaXMgc2NvcGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBpZCBvZiB0aGUgY2FwdHVyZWQgbWVzc2FnZS5cbiAgICovXG4gICBjYXB0dXJlTWVzc2FnZShtZXNzYWdlLCBsZXZlbCwgaGludCkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBoaW50Py5ldmVudF9pZCB8fCBtaXNjLnV1aWQ0KCk7XG5cbiAgICBpZiAoIXRoaXMuX2NsaWVudCkge1xuICAgICAgbG9nZ2VyLmxvZ2dlci53YXJuKCdObyBjbGllbnQgY29uZmlndXJlZCBvbiBzY29wZSAtIHdpbGwgbm90IGNhcHR1cmUgbWVzc2FnZSEnKTtcbiAgICAgIHJldHVybiBldmVudElkO1xuICAgIH1cblxuICAgIGNvbnN0IHN5bnRoZXRpY0V4Y2VwdGlvbiA9IG5ldyBFcnJvcihtZXNzYWdlKTtcblxuICAgIHRoaXMuX2NsaWVudC5jYXB0dXJlTWVzc2FnZShcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBsZXZlbCxcbiAgICAgIHtcbiAgICAgICAgb3JpZ2luYWxFeGNlcHRpb246IG1lc3NhZ2UsXG4gICAgICAgIHN5bnRoZXRpY0V4Y2VwdGlvbixcbiAgICAgICAgLi4uaGludCxcbiAgICAgICAgZXZlbnRfaWQ6IGV2ZW50SWQsXG4gICAgICB9LFxuICAgICAgdGhpcyxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV2ZW50SWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FwdHVyZSBhIFNlbnRyeSBldmVudCBmb3IgdGhpcyBzY29wZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGlkIG9mIHRoZSBjYXB0dXJlZCBldmVudC5cbiAgICovXG4gICBjYXB0dXJlRXZlbnQoZXZlbnQsIGhpbnQpIHtcbiAgICBjb25zdCBldmVudElkID0gaGludD8uZXZlbnRfaWQgfHwgbWlzYy51dWlkNCgpO1xuXG4gICAgaWYgKCF0aGlzLl9jbGllbnQpIHtcbiAgICAgIGxvZ2dlci5sb2dnZXIud2FybignTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIGV2ZW50IScpO1xuICAgICAgcmV0dXJuIGV2ZW50SWQ7XG4gICAgfVxuXG4gICAgdGhpcy5fY2xpZW50LmNhcHR1cmVFdmVudChldmVudCwgeyAuLi5oaW50LCBldmVudF9pZDogZXZlbnRJZCB9LCB0aGlzKTtcblxuICAgIHJldHVybiBldmVudElkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgc2V0IGNhbGwuXG4gICAqL1xuICAgX25vdGlmeVNjb3BlTGlzdGVuZXJzKCkge1xuICAgIC8vIFdlIG5lZWQgdGhpcyBjaGVjayBmb3IgdGhpcy5fbm90aWZ5aW5nTGlzdGVuZXJzIHRvIGJlIGFibGUgdG8gd29yayBvbiBzY29wZSBkdXJpbmcgdXBkYXRlc1xuICAgIC8vIElmIHRoaXMgY2hlY2sgaXMgbm90IGhlcmUgd2UnbGwgcHJvZHVjZSBlbmRsZXNzIHJlY3Vyc2lvbiB3aGVuIHNvbWV0aGluZyBpcyBkb25lIHdpdGggdGhlIHNjb3BlXG4gICAgLy8gZHVyaW5nIHRoZSBjYWxsYmFjay5cbiAgICBpZiAoIXRoaXMuX25vdGlmeWluZ0xpc3RlbmVycykge1xuICAgICAgdGhpcy5fbm90aWZ5aW5nTGlzdGVuZXJzID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3Njb3BlTGlzdGVuZXJzLmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fbm90aWZ5aW5nTGlzdGVuZXJzID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuU2NvcGUgPSBTY29wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/scope.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/sdk.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js");\nconst debugBuild = __webpack_require__(/*! ./debug-build.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js");\n\n/** A class object that can instantiate Client objects. */\n\n/**\n * Internal function to create a new SDK client instance. The client is\n * installed and then bound to the current scope.\n *\n * @param clientClass The client class to instantiate.\n * @param options Options to pass to the client.\n */\nfunction initAndBind(\n  clientClass,\n  options,\n) {\n  if (options.debug === true) {\n    if (debugBuild.DEBUG_BUILD) {\n      logger.logger.enable();\n    } else {\n      // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped\n      logger.consoleSandbox(() => {\n        // eslint-disable-next-line no-console\n        console.warn(\'[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.\');\n      });\n    }\n  }\n  const scope = currentScopes.getCurrentScope();\n  scope.update(options.initialScope);\n\n  const client = new clientClass(options);\n  setCurrentClient(client);\n  client.init();\n  return client;\n}\n\n/**\n * Make the given client the current client.\n */\nfunction setCurrentClient(client) {\n  currentScopes.getCurrentScope().setClient(client);\n}\n\nexports.initAndBind = initAndBind;\nexports.setCurrentClient = setCurrentClient;\n//# sourceMappingURL=sdk.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3Nkay5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxzQkFBc0IsbUJBQU8sQ0FBQywySEFBb0I7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsdUhBQWtCO0FBQzdDLGVBQWUsbUJBQU8sQ0FBQyxxSUFBeUI7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxzZGsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuL2N1cnJlbnRTY29wZXMuanMnKTtcbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuXG4vKiogQSBjbGFzcyBvYmplY3QgdGhhdCBjYW4gaW5zdGFudGlhdGUgQ2xpZW50IG9iamVjdHMuICovXG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IFNESyBjbGllbnQgaW5zdGFuY2UuIFRoZSBjbGllbnQgaXNcbiAqIGluc3RhbGxlZCBhbmQgdGhlbiBib3VuZCB0byB0aGUgY3VycmVudCBzY29wZS5cbiAqXG4gKiBAcGFyYW0gY2xpZW50Q2xhc3MgVGhlIGNsaWVudCBjbGFzcyB0byBpbnN0YW50aWF0ZS5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgY2xpZW50LlxuICovXG5mdW5jdGlvbiBpbml0QW5kQmluZChcbiAgY2xpZW50Q2xhc3MsXG4gIG9wdGlvbnMsXG4pIHtcbiAgaWYgKG9wdGlvbnMuZGVidWcgPT09IHRydWUpIHtcbiAgICBpZiAoZGVidWdCdWlsZC5ERUJVR19CVUlMRCkge1xuICAgICAgbG9nZ2VyLmxvZ2dlci5lbmFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXNlIGBjb25zb2xlLndhcm5gIHJhdGhlciB0aGFuIGBsb2dnZXIud2FybmAgc2luY2UgYnkgbm9uLWRlYnVnIGJ1bmRsZXMgaGF2ZSBhbGwgYGxvZ2dlci54YCBzdGF0ZW1lbnRzIHN0cmlwcGVkXG4gICAgICBsb2dnZXIuY29uc29sZVNhbmRib3goKCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oJ1tTZW50cnldIENhbm5vdCBpbml0aWFsaXplIFNESyB3aXRoIGBkZWJ1Z2Agb3B0aW9uIHVzaW5nIGEgbm9uLWRlYnVnIGJ1bmRsZS4nKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBzY29wZSA9IGN1cnJlbnRTY29wZXMuZ2V0Q3VycmVudFNjb3BlKCk7XG4gIHNjb3BlLnVwZGF0ZShvcHRpb25zLmluaXRpYWxTY29wZSk7XG5cbiAgY29uc3QgY2xpZW50ID0gbmV3IGNsaWVudENsYXNzKG9wdGlvbnMpO1xuICBzZXRDdXJyZW50Q2xpZW50KGNsaWVudCk7XG4gIGNsaWVudC5pbml0KCk7XG4gIHJldHVybiBjbGllbnQ7XG59XG5cbi8qKlxuICogTWFrZSB0aGUgZ2l2ZW4gY2xpZW50IHRoZSBjdXJyZW50IGNsaWVudC5cbiAqL1xuZnVuY3Rpb24gc2V0Q3VycmVudENsaWVudChjbGllbnQpIHtcbiAgY3VycmVudFNjb3Blcy5nZXRDdXJyZW50U2NvcGUoKS5zZXRDbGllbnQoY2xpZW50KTtcbn1cblxuZXhwb3J0cy5pbml0QW5kQmluZCA9IGluaXRBbmRCaW5kO1xuZXhwb3J0cy5zZXRDdXJyZW50Q2xpZW50ID0gc2V0Q3VycmVudENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNkay5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/sdk.js\n')},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/semanticAttributes.js":(__unused_webpack_module,exports)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\n/**\n * Use this attribute to represent the source of a span.\n * Should be one of: custom, url, route, view, component, task, unknown\n *\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = 'sentry.source';\n\n/**\n * Attributes that holds the sample rate that was locally applied to a span.\n * If this attribute is not defined, it means that the span inherited a sampling decision.\n *\n * NOTE: Is only defined on root spans.\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = 'sentry.sample_rate';\n\n/**\n * Attribute holding the sample rate of the previous trace.\n * This is used to sample consistently across subsequent traces in the browser SDK.\n *\n * Note: Only defined on root spans, if opted into consistent sampling\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE = 'sentry.previous_trace_sample_rate';\n\n/**\n * Use this attribute to represent the operation of a span.\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_OP = 'sentry.op';\n\n/**\n * Use this attribute to represent the origin of a span.\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = 'sentry.origin';\n\n/** The reason why an idle span finished. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON = 'sentry.idle_span_finish_reason';\n\n/** The unit of a measurement, which may be stored as a TimedEvent. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = 'sentry.measurement_unit';\n\n/** The value of a measurement, which may be stored as a TimedEvent. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = 'sentry.measurement_value';\n\n/**\n * A custom span name set by users guaranteed to be taken over any automatically\n * inferred name. This attribute is removed before the span is sent.\n *\n * @internal only meant for internal SDK usage\n * @hidden\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = 'sentry.custom_span_name';\n\n/**\n * The id of the profile that this span occurred in.\n */\nconst SEMANTIC_ATTRIBUTE_PROFILE_ID = 'sentry.profile_id';\n\nconst SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = 'sentry.exclusive_time';\n\nconst SEMANTIC_ATTRIBUTE_CACHE_HIT = 'cache.hit';\n\nconst SEMANTIC_ATTRIBUTE_CACHE_KEY = 'cache.key';\n\nconst SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = 'cache.item_size';\n\n/** TODO: Remove these once we update to latest semantic conventions */\nconst SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD = 'http.request.method';\nconst SEMANTIC_ATTRIBUTE_URL_FULL = 'url.full';\n\n/**\n * A span link attribute to mark the link as a special span link.\n *\n * Known values:\n * - `previous_trace`: The span links to the frontend root span of the previous trace.\n * - `next_trace`: The span links to the frontend root span of the next trace. (Not set by the SDK)\n *\n * Other values may be set as appropriate.\n * @see https://develop.sentry.dev/sdk/telemetry/traces/span-links/#link-types\n */\nconst SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE = 'sentry.link.type';\n\nexports.SEMANTIC_ATTRIBUTE_CACHE_HIT = SEMANTIC_ATTRIBUTE_CACHE_HIT;\nexports.SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE;\nexports.SEMANTIC_ATTRIBUTE_CACHE_KEY = SEMANTIC_ATTRIBUTE_CACHE_KEY;\nexports.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME;\nexports.SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD = SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD;\nexports.SEMANTIC_ATTRIBUTE_PROFILE_ID = SEMANTIC_ATTRIBUTE_PROFILE_ID;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON = SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_OP = SEMANTIC_ATTRIBUTE_SENTRY_OP;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE = SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = SEMANTIC_ATTRIBUTE_SENTRY_SOURCE;\nexports.SEMANTIC_ATTRIBUTE_URL_FULL = SEMANTIC_ATTRIBUTE_URL_FULL;\nexports.SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE = SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE;\n//# sourceMappingURL=semanticAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3NlbWFudGljQXR0cmlidXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEMsMENBQTBDO0FBQzFDLG9DQUFvQztBQUNwQyx5Q0FBeUM7QUFDekMsOENBQThDO0FBQzlDLHFDQUFxQztBQUNyQyxrREFBa0Q7QUFDbEQseURBQXlEO0FBQ3pELGtEQUFrRDtBQUNsRCxtREFBbUQ7QUFDbkQsb0NBQW9DO0FBQ3BDLHdDQUF3QztBQUN4Qyw0REFBNEQ7QUFDNUQsNkNBQTZDO0FBQzdDLHdDQUF3QztBQUN4QyxtQ0FBbUM7QUFDbkMseUNBQXlDO0FBQ3pDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXHNlbWFudGljQXR0cmlidXRlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuLyoqXG4gKiBVc2UgdGhpcyBhdHRyaWJ1dGUgdG8gcmVwcmVzZW50IHRoZSBzb3VyY2Ugb2YgYSBzcGFuLlxuICogU2hvdWxkIGJlIG9uZSBvZjogY3VzdG9tLCB1cmwsIHJvdXRlLCB2aWV3LCBjb21wb25lbnQsIHRhc2ssIHVua25vd25cbiAqXG4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFID0gJ3NlbnRyeS5zb3VyY2UnO1xuXG4vKipcbiAqIEF0dHJpYnV0ZXMgdGhhdCBob2xkcyB0aGUgc2FtcGxlIHJhdGUgdGhhdCB3YXMgbG9jYWxseSBhcHBsaWVkIHRvIGEgc3Bhbi5cbiAqIElmIHRoaXMgYXR0cmlidXRlIGlzIG5vdCBkZWZpbmVkLCBpdCBtZWFucyB0aGF0IHRoZSBzcGFuIGluaGVyaXRlZCBhIHNhbXBsaW5nIGRlY2lzaW9uLlxuICpcbiAqIE5PVEU6IElzIG9ubHkgZGVmaW5lZCBvbiByb290IHNwYW5zLlxuICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFID0gJ3NlbnRyeS5zYW1wbGVfcmF0ZSc7XG5cbi8qKlxuICogQXR0cmlidXRlIGhvbGRpbmcgdGhlIHNhbXBsZSByYXRlIG9mIHRoZSBwcmV2aW91cyB0cmFjZS5cbiAqIFRoaXMgaXMgdXNlZCB0byBzYW1wbGUgY29uc2lzdGVudGx5IGFjcm9zcyBzdWJzZXF1ZW50IHRyYWNlcyBpbiB0aGUgYnJvd3NlciBTREsuXG4gKlxuICogTm90ZTogT25seSBkZWZpbmVkIG9uIHJvb3Qgc3BhbnMsIGlmIG9wdGVkIGludG8gY29uc2lzdGVudCBzYW1wbGluZ1xuICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1BSRVZJT1VTX1RSQUNFX1NBTVBMRV9SQVRFID0gJ3NlbnRyeS5wcmV2aW91c190cmFjZV9zYW1wbGVfcmF0ZSc7XG5cbi8qKlxuICogVXNlIHRoaXMgYXR0cmlidXRlIHRvIHJlcHJlc2VudCB0aGUgb3BlcmF0aW9uIG9mIGEgc3Bhbi5cbiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUCA9ICdzZW50cnkub3AnO1xuXG4vKipcbiAqIFVzZSB0aGlzIGF0dHJpYnV0ZSB0byByZXByZXNlbnQgdGhlIG9yaWdpbiBvZiBhIHNwYW4uXG4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOID0gJ3NlbnRyeS5vcmlnaW4nO1xuXG4vKiogVGhlIHJlYXNvbiB3aHkgYW4gaWRsZSBzcGFuIGZpbmlzaGVkLiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9JRExFX1NQQU5fRklOSVNIX1JFQVNPTiA9ICdzZW50cnkuaWRsZV9zcGFuX2ZpbmlzaF9yZWFzb24nO1xuXG4vKiogVGhlIHVuaXQgb2YgYSBtZWFzdXJlbWVudCwgd2hpY2ggbWF5IGJlIHN0b3JlZCBhcyBhIFRpbWVkRXZlbnQuICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX01FQVNVUkVNRU5UX1VOSVQgPSAnc2VudHJ5Lm1lYXN1cmVtZW50X3VuaXQnO1xuXG4vKiogVGhlIHZhbHVlIG9mIGEgbWVhc3VyZW1lbnQsIHdoaWNoIG1heSBiZSBzdG9yZWQgYXMgYSBUaW1lZEV2ZW50LiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9NRUFTVVJFTUVOVF9WQUxVRSA9ICdzZW50cnkubWVhc3VyZW1lbnRfdmFsdWUnO1xuXG4vKipcbiAqIEEgY3VzdG9tIHNwYW4gbmFtZSBzZXQgYnkgdXNlcnMgZ3VhcmFudGVlZCB0byBiZSB0YWtlbiBvdmVyIGFueSBhdXRvbWF0aWNhbGx5XG4gKiBpbmZlcnJlZCBuYW1lLiBUaGlzIGF0dHJpYnV0ZSBpcyByZW1vdmVkIGJlZm9yZSB0aGUgc3BhbiBpcyBzZW50LlxuICpcbiAqIEBpbnRlcm5hbCBvbmx5IG1lYW50IGZvciBpbnRlcm5hbCBTREsgdXNhZ2VcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FID0gJ3NlbnRyeS5jdXN0b21fc3Bhbl9uYW1lJztcblxuLyoqXG4gKiBUaGUgaWQgb2YgdGhlIHByb2ZpbGUgdGhhdCB0aGlzIHNwYW4gb2NjdXJyZWQgaW4uXG4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9QUk9GSUxFX0lEID0gJ3NlbnRyeS5wcm9maWxlX2lkJztcblxuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX0VYQ0xVU0lWRV9USU1FID0gJ3NlbnRyeS5leGNsdXNpdmVfdGltZSc7XG5cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9ISVQgPSAnY2FjaGUuaGl0JztcblxuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX0NBQ0hFX0tFWSA9ICdjYWNoZS5rZXknO1xuXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfSVRFTV9TSVpFID0gJ2NhY2hlLml0ZW1fc2l6ZSc7XG5cbi8qKiBUT0RPOiBSZW1vdmUgdGhlc2Ugb25jZSB3ZSB1cGRhdGUgdG8gbGF0ZXN0IHNlbWFudGljIGNvbnZlbnRpb25zICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfSFRUUF9SRVFVRVNUX01FVEhPRCA9ICdodHRwLnJlcXVlc3QubWV0aG9kJztcbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9VUkxfRlVMTCA9ICd1cmwuZnVsbCc7XG5cbi8qKlxuICogQSBzcGFuIGxpbmsgYXR0cmlidXRlIHRvIG1hcmsgdGhlIGxpbmsgYXMgYSBzcGVjaWFsIHNwYW4gbGluay5cbiAqXG4gKiBLbm93biB2YWx1ZXM6XG4gKiAtIGBwcmV2aW91c190cmFjZWA6IFRoZSBzcGFuIGxpbmtzIHRvIHRoZSBmcm9udGVuZCByb290IHNwYW4gb2YgdGhlIHByZXZpb3VzIHRyYWNlLlxuICogLSBgbmV4dF90cmFjZWA6IFRoZSBzcGFuIGxpbmtzIHRvIHRoZSBmcm9udGVuZCByb290IHNwYW4gb2YgdGhlIG5leHQgdHJhY2UuIChOb3Qgc2V0IGJ5IHRoZSBTREspXG4gKlxuICogT3RoZXIgdmFsdWVzIG1heSBiZSBzZXQgYXMgYXBwcm9wcmlhdGUuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcC5zZW50cnkuZGV2L3Nkay90ZWxlbWV0cnkvdHJhY2VzL3NwYW4tbGlua3MvI2xpbmstdHlwZXNcbiAqL1xuY29uc3QgU0VNQU5USUNfTElOS19BVFRSSUJVVEVfTElOS19UWVBFID0gJ3NlbnRyeS5saW5rLnR5cGUnO1xuXG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9ISVQgPSBTRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfSElUO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfSVRFTV9TSVpFID0gU0VNQU5USUNfQVRUUklCVVRFX0NBQ0hFX0lURU1fU0laRTtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX0NBQ0hFX0tFWSA9IFNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9LRVk7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9FWENMVVNJVkVfVElNRSA9IFNFTUFOVElDX0FUVFJJQlVURV9FWENMVVNJVkVfVElNRTtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX0hUVFBfUkVRVUVTVF9NRVRIT0QgPSBTRU1BTlRJQ19BVFRSSUJVVEVfSFRUUF9SRVFVRVNUX01FVEhPRDtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1BST0ZJTEVfSUQgPSBTRU1BTlRJQ19BVFRSSUJVVEVfUFJPRklMRV9JRDtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FID0gU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0lETEVfU1BBTl9GSU5JU0hfUkVBU09OID0gU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9JRExFX1NQQU5fRklOSVNIX1JFQVNPTjtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9NRUFTVVJFTUVOVF9VTklUID0gU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9NRUFTVVJFTUVOVF9VTklUO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX01FQVNVUkVNRU5UX1ZBTFVFID0gU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9NRUFTVVJFTUVOVF9WQUxVRTtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUCA9IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1A7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOID0gU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU47XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUFJFVklPVVNfVFJBQ0VfU0FNUExFX1JBVEUgPSBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1BSRVZJT1VTX1RSQUNFX1NBTVBMRV9SQVRFO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFID0gU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURTtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0UgPSBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRTtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1VSTF9GVUxMID0gU0VNQU5USUNfQVRUUklCVVRFX1VSTF9GVUxMO1xuZXhwb3J0cy5TRU1BTlRJQ19MSU5LX0FUVFJJQlVURV9MSU5LX1RZUEUgPSBTRU1BTlRJQ19MSU5LX0FUVFJJQlVURV9MSU5LX1RZUEU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW1hbnRpY0F0dHJpYnV0ZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/semanticAttributes.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/server-runtime-client.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst checkin = __webpack_require__(/*! ./checkin.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/checkin.js\");\nconst client = __webpack_require__(/*! ./client.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/client.js\");\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst exports$1 = __webpack_require__(/*! ./logs/exports.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/logs/exports.js\");\nconst errors = __webpack_require__(/*! ./tracing/errors.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/errors.js\");\nconst is = __webpack_require__(/*! ./utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst misc = __webpack_require__(/*! ./utils-hoist/misc.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js\");\n__webpack_require__(/*! ./utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst eventbuilder = __webpack_require__(/*! ./utils-hoist/eventbuilder.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/eventbuilder.js\");\nconst syncpromise = __webpack_require__(/*! ./utils-hoist/syncpromise.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/syncpromise.js\");\n\n// TODO: Make this configurable\nconst DEFAULT_LOG_FLUSH_INTERVAL = 5000;\n\n/**\n * The Sentry Server Runtime Client SDK.\n */\nclass ServerRuntimeClient\n\n extends client.Client {\n\n  /**\n   * Creates a new Edge SDK instance.\n   * @param options Configuration options for this SDK.\n   */\n   constructor(options) {\n    // Server clients always support tracing\n    errors.registerSpanErrorInstrumentation();\n\n    super(options);\n\n    this._logWeight = 0;\n\n    if (this._options._experiments?.enableLogs) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const client = this;\n\n      client.on('flushLogs', () => {\n        client._logWeight = 0;\n        clearTimeout(client._logFlushIdleTimeout);\n      });\n\n      client.on('afterCaptureLog', log => {\n        client._logWeight += estimateLogSizeInBytes(log);\n\n        // We flush the logs buffer if it exceeds 0.8 MB\n        // The log weight is a rough estimate, so we flush way before\n        // the payload gets too big.\n        if (client._logWeight >= 800000) {\n          exports$1._INTERNAL_flushLogsBuffer(client);\n        } else {\n          // start an idle timeout to flush the logs buffer if no logs are captured for a while\n          client._logFlushIdleTimeout = setTimeout(() => {\n            exports$1._INTERNAL_flushLogsBuffer(client);\n          }, DEFAULT_LOG_FLUSH_INTERVAL);\n        }\n      });\n\n      client.on('flush', () => {\n        exports$1._INTERNAL_flushLogsBuffer(client);\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromException(exception, hint) {\n    const event = eventbuilder.eventFromUnknownInput(this, this._options.stackParser, exception, hint);\n    event.level = 'error';\n\n    return syncpromise.resolvedSyncPromise(event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromMessage(\n    message,\n    level = 'info',\n    hint,\n  ) {\n    return syncpromise.resolvedSyncPromise(\n      eventbuilder.eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureException(exception, hint, scope) {\n    setCurrentRequestSessionErroredOrCrashed(hint);\n    return super.captureException(exception, hint, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureEvent(event, hint, scope) {\n    // If the event is of type Exception, then a request session should be captured\n    const isException = !event.type && event.exception?.values && event.exception.values.length > 0;\n    if (isException) {\n      setCurrentRequestSessionErroredOrCrashed(hint);\n    }\n\n    return super.captureEvent(event, hint, scope);\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   */\n   captureCheckIn(checkIn, monitorConfig, scope) {\n    const id = 'checkInId' in checkIn && checkIn.checkInId ? checkIn.checkInId : misc.uuid4();\n    if (!this._isEnabled()) {\n      debugBuild.DEBUG_BUILD && logger.logger.warn('SDK not enabled, will not capture check-in.');\n      return id;\n    }\n\n    const options = this.getOptions();\n    const { release, environment, tunnel } = options;\n\n    const serializedCheckIn = {\n      check_in_id: id,\n      monitor_slug: checkIn.monitorSlug,\n      status: checkIn.status,\n      release,\n      environment,\n    };\n\n    if ('duration' in checkIn) {\n      serializedCheckIn.duration = checkIn.duration;\n    }\n\n    if (monitorConfig) {\n      serializedCheckIn.monitor_config = {\n        schedule: monitorConfig.schedule,\n        checkin_margin: monitorConfig.checkinMargin,\n        max_runtime: monitorConfig.maxRuntime,\n        timezone: monitorConfig.timezone,\n        failure_issue_threshold: monitorConfig.failureIssueThreshold,\n        recovery_threshold: monitorConfig.recoveryThreshold,\n      };\n    }\n\n    const [dynamicSamplingContext, traceContext] = client._getTraceInfoFromScope(this, scope);\n    if (traceContext) {\n      serializedCheckIn.contexts = {\n        trace: traceContext,\n      };\n    }\n\n    const envelope = checkin.createCheckInEnvelope(\n      serializedCheckIn,\n      dynamicSamplingContext,\n      this.getSdkMetadata(),\n      tunnel,\n      this.getDsn(),\n    );\n\n    debugBuild.DEBUG_BUILD && logger.logger.info('Sending checkin:', checkIn.monitorSlug, checkIn.status);\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(envelope);\n\n    return id;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   _prepareEvent(\n    event,\n    hint,\n    currentScope,\n    isolationScope,\n  ) {\n    if (this._options.platform) {\n      event.platform = event.platform || this._options.platform;\n    }\n\n    if (this._options.runtime) {\n      event.contexts = {\n        ...event.contexts,\n        runtime: event.contexts?.runtime || this._options.runtime,\n      };\n    }\n\n    if (this._options.serverName) {\n      event.server_name = event.server_name || this._options.serverName;\n    }\n\n    return super._prepareEvent(event, hint, currentScope, isolationScope);\n  }\n}\n\nfunction setCurrentRequestSessionErroredOrCrashed(eventHint) {\n  const requestSession = currentScopes.getIsolationScope().getScopeData().sdkProcessingMetadata.requestSession;\n  if (requestSession) {\n    // We mutate instead of doing `setSdkProcessingMetadata` because the http integration stores away a particular\n    // isolationScope. If that isolation scope is forked, setting the processing metadata here will not mutate the\n    // original isolation scope that the http integration stored away.\n    const isHandledException = eventHint?.mechanism?.handled ?? true;\n    // A request session can go from \"errored\" -> \"crashed\" but not \"crashed\" -> \"errored\".\n    // Crashed (unhandled exception) is worse than errored (handled exception).\n    if (isHandledException && requestSession.status !== 'crashed') {\n      requestSession.status = 'errored';\n    } else if (!isHandledException) {\n      requestSession.status = 'crashed';\n    }\n  }\n}\n\n/**\n * Estimate the size of a log in bytes.\n *\n * @param log - The log to estimate the size of.\n * @returns The estimated size of the log in bytes.\n */\nfunction estimateLogSizeInBytes(log) {\n  let weight = 0;\n\n  // Estimate byte size of 2 bytes per character. This is a rough estimate JS strings are stored as UTF-16.\n  if (log.message) {\n    weight += log.message.length * 2;\n  }\n\n  if (log.attributes) {\n    Object.values(log.attributes).forEach(value => {\n      if (Array.isArray(value)) {\n        weight += value.length * estimatePrimitiveSizeInBytes(value[0]);\n      } else if (is.isPrimitive(value)) {\n        weight += estimatePrimitiveSizeInBytes(value);\n      } else {\n        // For objects values, we estimate the size of the object as 100 bytes\n        weight += 100;\n      }\n    });\n  }\n\n  return weight;\n}\n\nfunction estimatePrimitiveSizeInBytes(value) {\n  if (typeof value === 'string') {\n    return value.length * 2;\n  } else if (typeof value === 'number') {\n    return 8;\n  } else if (typeof value === 'boolean') {\n    return 4;\n  }\n\n  return 0;\n}\n\nexports.ServerRuntimeClient = ServerRuntimeClient;\n//# sourceMappingURL=server-runtime-client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3NlcnZlci1ydW50aW1lLWNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxnQkFBZ0IsbUJBQU8sQ0FBQywrR0FBYztBQUN0QyxlQUFlLG1CQUFPLENBQUMsNkdBQWE7QUFDcEMsc0JBQXNCLG1CQUFPLENBQUMsMkhBQW9CO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLHVIQUFrQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyx5SEFBbUI7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLDZIQUFxQjtBQUM1QyxXQUFXLG1CQUFPLENBQUMsNkhBQXFCO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyxxSUFBeUI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLGlJQUF1QjtBQUM1QyxtQkFBTyxDQUFDLGlJQUF1QjtBQUMvQixxQkFBcUIsbUJBQU8sQ0FBQyxpSkFBK0I7QUFDNUQsb0JBQW9CLG1CQUFPLENBQUMsK0lBQThCOztBQUUxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLCtCQUErQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXHNlcnZlci1ydW50aW1lLWNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgY2hlY2tpbiA9IHJlcXVpcmUoJy4vY2hlY2tpbi5qcycpO1xuY29uc3QgY2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQuanMnKTtcbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuL2N1cnJlbnRTY29wZXMuanMnKTtcbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBleHBvcnRzJDEgPSByZXF1aXJlKCcuL2xvZ3MvZXhwb3J0cy5qcycpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi90cmFjaW5nL2Vycm9ycy5qcycpO1xuY29uc3QgaXMgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2lzLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuY29uc3QgbWlzYyA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvbWlzYy5qcycpO1xucmVxdWlyZSgnLi91dGlscy1ob2lzdC90aW1lLmpzJyk7XG5jb25zdCBldmVudGJ1aWxkZXIgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2V2ZW50YnVpbGRlci5qcycpO1xuY29uc3Qgc3luY3Byb21pc2UgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3N5bmNwcm9taXNlLmpzJyk7XG5cbi8vIFRPRE86IE1ha2UgdGhpcyBjb25maWd1cmFibGVcbmNvbnN0IERFRkFVTFRfTE9HX0ZMVVNIX0lOVEVSVkFMID0gNTAwMDtcblxuLyoqXG4gKiBUaGUgU2VudHJ5IFNlcnZlciBSdW50aW1lIENsaWVudCBTREsuXG4gKi9cbmNsYXNzIFNlcnZlclJ1bnRpbWVDbGllbnRcblxuIGV4dGVuZHMgY2xpZW50LkNsaWVudCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRWRnZSBTREsgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhpcyBTREsuXG4gICAqL1xuICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8vIFNlcnZlciBjbGllbnRzIGFsd2F5cyBzdXBwb3J0IHRyYWNpbmdcbiAgICBlcnJvcnMucmVnaXN0ZXJTcGFuRXJyb3JJbnN0cnVtZW50YXRpb24oKTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fbG9nV2VpZ2h0ID0gMDtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLl9leHBlcmltZW50cz8uZW5hYmxlTG9ncykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICBjb25zdCBjbGllbnQgPSB0aGlzO1xuXG4gICAgICBjbGllbnQub24oJ2ZsdXNoTG9ncycsICgpID0+IHtcbiAgICAgICAgY2xpZW50Ll9sb2dXZWlnaHQgPSAwO1xuICAgICAgICBjbGVhclRpbWVvdXQoY2xpZW50Ll9sb2dGbHVzaElkbGVUaW1lb3V0KTtcbiAgICAgIH0pO1xuXG4gICAgICBjbGllbnQub24oJ2FmdGVyQ2FwdHVyZUxvZycsIGxvZyA9PiB7XG4gICAgICAgIGNsaWVudC5fbG9nV2VpZ2h0ICs9IGVzdGltYXRlTG9nU2l6ZUluQnl0ZXMobG9nKTtcblxuICAgICAgICAvLyBXZSBmbHVzaCB0aGUgbG9ncyBidWZmZXIgaWYgaXQgZXhjZWVkcyAwLjggTUJcbiAgICAgICAgLy8gVGhlIGxvZyB3ZWlnaHQgaXMgYSByb3VnaCBlc3RpbWF0ZSwgc28gd2UgZmx1c2ggd2F5IGJlZm9yZVxuICAgICAgICAvLyB0aGUgcGF5bG9hZCBnZXRzIHRvbyBiaWcuXG4gICAgICAgIGlmIChjbGllbnQuX2xvZ1dlaWdodCA+PSA4MDAwMDApIHtcbiAgICAgICAgICBleHBvcnRzJDEuX0lOVEVSTkFMX2ZsdXNoTG9nc0J1ZmZlcihjbGllbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN0YXJ0IGFuIGlkbGUgdGltZW91dCB0byBmbHVzaCB0aGUgbG9ncyBidWZmZXIgaWYgbm8gbG9ncyBhcmUgY2FwdHVyZWQgZm9yIGEgd2hpbGVcbiAgICAgICAgICBjbGllbnQuX2xvZ0ZsdXNoSWRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGV4cG9ydHMkMS5fSU5URVJOQUxfZmx1c2hMb2dzQnVmZmVyKGNsaWVudCk7XG4gICAgICAgICAgfSwgREVGQVVMVF9MT0dfRkxVU0hfSU5URVJWQUwpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY2xpZW50Lm9uKCdmbHVzaCcsICgpID0+IHtcbiAgICAgICAgZXhwb3J0cyQxLl9JTlRFUk5BTF9mbHVzaExvZ3NCdWZmZXIoY2xpZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGV2ZW50RnJvbUV4Y2VwdGlvbihleGNlcHRpb24sIGhpbnQpIHtcbiAgICBjb25zdCBldmVudCA9IGV2ZW50YnVpbGRlci5ldmVudEZyb21Vbmtub3duSW5wdXQodGhpcywgdGhpcy5fb3B0aW9ucy5zdGFja1BhcnNlciwgZXhjZXB0aW9uLCBoaW50KTtcbiAgICBldmVudC5sZXZlbCA9ICdlcnJvcic7XG5cbiAgICByZXR1cm4gc3luY3Byb21pc2UucmVzb2x2ZWRTeW5jUHJvbWlzZShldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBldmVudEZyb21NZXNzYWdlKFxuICAgIG1lc3NhZ2UsXG4gICAgbGV2ZWwgPSAnaW5mbycsXG4gICAgaGludCxcbiAgKSB7XG4gICAgcmV0dXJuIHN5bmNwcm9taXNlLnJlc29sdmVkU3luY1Byb21pc2UoXG4gICAgICBldmVudGJ1aWxkZXIuZXZlbnRGcm9tTWVzc2FnZSh0aGlzLl9vcHRpb25zLnN0YWNrUGFyc2VyLCBtZXNzYWdlLCBsZXZlbCwgaGludCwgdGhpcy5fb3B0aW9ucy5hdHRhY2hTdGFja3RyYWNlKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgY2FwdHVyZUV4Y2VwdGlvbihleGNlcHRpb24sIGhpbnQsIHNjb3BlKSB7XG4gICAgc2V0Q3VycmVudFJlcXVlc3RTZXNzaW9uRXJyb3JlZE9yQ3Jhc2hlZChoaW50KTtcbiAgICByZXR1cm4gc3VwZXIuY2FwdHVyZUV4Y2VwdGlvbihleGNlcHRpb24sIGhpbnQsIHNjb3BlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGNhcHR1cmVFdmVudChldmVudCwgaGludCwgc2NvcGUpIHtcbiAgICAvLyBJZiB0aGUgZXZlbnQgaXMgb2YgdHlwZSBFeGNlcHRpb24sIHRoZW4gYSByZXF1ZXN0IHNlc3Npb24gc2hvdWxkIGJlIGNhcHR1cmVkXG4gICAgY29uc3QgaXNFeGNlcHRpb24gPSAhZXZlbnQudHlwZSAmJiBldmVudC5leGNlcHRpb24/LnZhbHVlcyAmJiBldmVudC5leGNlcHRpb24udmFsdWVzLmxlbmd0aCA+IDA7XG4gICAgaWYgKGlzRXhjZXB0aW9uKSB7XG4gICAgICBzZXRDdXJyZW50UmVxdWVzdFNlc3Npb25FcnJvcmVkT3JDcmFzaGVkKGhpbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5jYXB0dXJlRXZlbnQoZXZlbnQsIGhpbnQsIHNjb3BlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjcm9uIG1vbml0b3IgY2hlY2sgaW4gYW5kIHNlbmQgaXQgdG8gU2VudHJ5LlxuICAgKlxuICAgKiBAcGFyYW0gY2hlY2tJbiBBbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgYSBjaGVjayBpbi5cbiAgICogQHBhcmFtIHVwc2VydE1vbml0b3JDb25maWcgQW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbW9uaXRvciBjb25maWcuIFVzZSB0aGlzIGlmIHlvdSB3YW50XG4gICAqIHRvIGNyZWF0ZSBhIG1vbml0b3IgYXV0b21hdGljYWxseSB3aGVuIHNlbmRpbmcgYSBjaGVjayBpbi5cbiAgICovXG4gICBjYXB0dXJlQ2hlY2tJbihjaGVja0luLCBtb25pdG9yQ29uZmlnLCBzY29wZSkge1xuICAgIGNvbnN0IGlkID0gJ2NoZWNrSW5JZCcgaW4gY2hlY2tJbiAmJiBjaGVja0luLmNoZWNrSW5JZCA/IGNoZWNrSW4uY2hlY2tJbklkIDogbWlzYy51dWlkNCgpO1xuICAgIGlmICghdGhpcy5faXNFbmFibGVkKCkpIHtcbiAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdTREsgbm90IGVuYWJsZWQsIHdpbGwgbm90IGNhcHR1cmUgY2hlY2staW4uJyk7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIGNvbnN0IHsgcmVsZWFzZSwgZW52aXJvbm1lbnQsIHR1bm5lbCB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGVja0luID0ge1xuICAgICAgY2hlY2tfaW5faWQ6IGlkLFxuICAgICAgbW9uaXRvcl9zbHVnOiBjaGVja0luLm1vbml0b3JTbHVnLFxuICAgICAgc3RhdHVzOiBjaGVja0luLnN0YXR1cyxcbiAgICAgIHJlbGVhc2UsXG4gICAgICBlbnZpcm9ubWVudCxcbiAgICB9O1xuXG4gICAgaWYgKCdkdXJhdGlvbicgaW4gY2hlY2tJbikge1xuICAgICAgc2VyaWFsaXplZENoZWNrSW4uZHVyYXRpb24gPSBjaGVja0luLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIGlmIChtb25pdG9yQ29uZmlnKSB7XG4gICAgICBzZXJpYWxpemVkQ2hlY2tJbi5tb25pdG9yX2NvbmZpZyA9IHtcbiAgICAgICAgc2NoZWR1bGU6IG1vbml0b3JDb25maWcuc2NoZWR1bGUsXG4gICAgICAgIGNoZWNraW5fbWFyZ2luOiBtb25pdG9yQ29uZmlnLmNoZWNraW5NYXJnaW4sXG4gICAgICAgIG1heF9ydW50aW1lOiBtb25pdG9yQ29uZmlnLm1heFJ1bnRpbWUsXG4gICAgICAgIHRpbWV6b25lOiBtb25pdG9yQ29uZmlnLnRpbWV6b25lLFxuICAgICAgICBmYWlsdXJlX2lzc3VlX3RocmVzaG9sZDogbW9uaXRvckNvbmZpZy5mYWlsdXJlSXNzdWVUaHJlc2hvbGQsXG4gICAgICAgIHJlY292ZXJ5X3RocmVzaG9sZDogbW9uaXRvckNvbmZpZy5yZWNvdmVyeVRocmVzaG9sZCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgW2R5bmFtaWNTYW1wbGluZ0NvbnRleHQsIHRyYWNlQ29udGV4dF0gPSBjbGllbnQuX2dldFRyYWNlSW5mb0Zyb21TY29wZSh0aGlzLCBzY29wZSk7XG4gICAgaWYgKHRyYWNlQ29udGV4dCkge1xuICAgICAgc2VyaWFsaXplZENoZWNrSW4uY29udGV4dHMgPSB7XG4gICAgICAgIHRyYWNlOiB0cmFjZUNvbnRleHQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGVudmVsb3BlID0gY2hlY2tpbi5jcmVhdGVDaGVja0luRW52ZWxvcGUoXG4gICAgICBzZXJpYWxpemVkQ2hlY2tJbixcbiAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsXG4gICAgICB0aGlzLmdldFNka01ldGFkYXRhKCksXG4gICAgICB0dW5uZWwsXG4gICAgICB0aGlzLmdldERzbigpLFxuICAgICk7XG5cbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIuaW5mbygnU2VuZGluZyBjaGVja2luOicsIGNoZWNrSW4ubW9uaXRvclNsdWcsIGNoZWNrSW4uc3RhdHVzKTtcblxuICAgIC8vIHNlbmRFbnZlbG9wZSBzaG91bGQgbm90IHRocm93XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgIHRoaXMuc2VuZEVudmVsb3BlKGVudmVsb3BlKTtcblxuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIF9wcmVwYXJlRXZlbnQoXG4gICAgZXZlbnQsXG4gICAgaGludCxcbiAgICBjdXJyZW50U2NvcGUsXG4gICAgaXNvbGF0aW9uU2NvcGUsXG4gICkge1xuICAgIGlmICh0aGlzLl9vcHRpb25zLnBsYXRmb3JtKSB7XG4gICAgICBldmVudC5wbGF0Zm9ybSA9IGV2ZW50LnBsYXRmb3JtIHx8IHRoaXMuX29wdGlvbnMucGxhdGZvcm07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMucnVudGltZSkge1xuICAgICAgZXZlbnQuY29udGV4dHMgPSB7XG4gICAgICAgIC4uLmV2ZW50LmNvbnRleHRzLFxuICAgICAgICBydW50aW1lOiBldmVudC5jb250ZXh0cz8ucnVudGltZSB8fCB0aGlzLl9vcHRpb25zLnJ1bnRpbWUsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5hbWUpIHtcbiAgICAgIGV2ZW50LnNlcnZlcl9uYW1lID0gZXZlbnQuc2VydmVyX25hbWUgfHwgdGhpcy5fb3B0aW9ucy5zZXJ2ZXJOYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5fcHJlcGFyZUV2ZW50KGV2ZW50LCBoaW50LCBjdXJyZW50U2NvcGUsIGlzb2xhdGlvblNjb3BlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50UmVxdWVzdFNlc3Npb25FcnJvcmVkT3JDcmFzaGVkKGV2ZW50SGludCkge1xuICBjb25zdCByZXF1ZXN0U2Vzc2lvbiA9IGN1cnJlbnRTY29wZXMuZ2V0SXNvbGF0aW9uU2NvcGUoKS5nZXRTY29wZURhdGEoKS5zZGtQcm9jZXNzaW5nTWV0YWRhdGEucmVxdWVzdFNlc3Npb247XG4gIGlmIChyZXF1ZXN0U2Vzc2lvbikge1xuICAgIC8vIFdlIG11dGF0ZSBpbnN0ZWFkIG9mIGRvaW5nIGBzZXRTZGtQcm9jZXNzaW5nTWV0YWRhdGFgIGJlY2F1c2UgdGhlIGh0dHAgaW50ZWdyYXRpb24gc3RvcmVzIGF3YXkgYSBwYXJ0aWN1bGFyXG4gICAgLy8gaXNvbGF0aW9uU2NvcGUuIElmIHRoYXQgaXNvbGF0aW9uIHNjb3BlIGlzIGZvcmtlZCwgc2V0dGluZyB0aGUgcHJvY2Vzc2luZyBtZXRhZGF0YSBoZXJlIHdpbGwgbm90IG11dGF0ZSB0aGVcbiAgICAvLyBvcmlnaW5hbCBpc29sYXRpb24gc2NvcGUgdGhhdCB0aGUgaHR0cCBpbnRlZ3JhdGlvbiBzdG9yZWQgYXdheS5cbiAgICBjb25zdCBpc0hhbmRsZWRFeGNlcHRpb24gPSBldmVudEhpbnQ/Lm1lY2hhbmlzbT8uaGFuZGxlZCA/PyB0cnVlO1xuICAgIC8vIEEgcmVxdWVzdCBzZXNzaW9uIGNhbiBnbyBmcm9tIFwiZXJyb3JlZFwiIC0+IFwiY3Jhc2hlZFwiIGJ1dCBub3QgXCJjcmFzaGVkXCIgLT4gXCJlcnJvcmVkXCIuXG4gICAgLy8gQ3Jhc2hlZCAodW5oYW5kbGVkIGV4Y2VwdGlvbikgaXMgd29yc2UgdGhhbiBlcnJvcmVkIChoYW5kbGVkIGV4Y2VwdGlvbikuXG4gICAgaWYgKGlzSGFuZGxlZEV4Y2VwdGlvbiAmJiByZXF1ZXN0U2Vzc2lvbi5zdGF0dXMgIT09ICdjcmFzaGVkJykge1xuICAgICAgcmVxdWVzdFNlc3Npb24uc3RhdHVzID0gJ2Vycm9yZWQnO1xuICAgIH0gZWxzZSBpZiAoIWlzSGFuZGxlZEV4Y2VwdGlvbikge1xuICAgICAgcmVxdWVzdFNlc3Npb24uc3RhdHVzID0gJ2NyYXNoZWQnO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVzdGltYXRlIHRoZSBzaXplIG9mIGEgbG9nIGluIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBsb2cgLSBUaGUgbG9nIHRvIGVzdGltYXRlIHRoZSBzaXplIG9mLlxuICogQHJldHVybnMgVGhlIGVzdGltYXRlZCBzaXplIG9mIHRoZSBsb2cgaW4gYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGVzdGltYXRlTG9nU2l6ZUluQnl0ZXMobG9nKSB7XG4gIGxldCB3ZWlnaHQgPSAwO1xuXG4gIC8vIEVzdGltYXRlIGJ5dGUgc2l6ZSBvZiAyIGJ5dGVzIHBlciBjaGFyYWN0ZXIuIFRoaXMgaXMgYSByb3VnaCBlc3RpbWF0ZSBKUyBzdHJpbmdzIGFyZSBzdG9yZWQgYXMgVVRGLTE2LlxuICBpZiAobG9nLm1lc3NhZ2UpIHtcbiAgICB3ZWlnaHQgKz0gbG9nLm1lc3NhZ2UubGVuZ3RoICogMjtcbiAgfVxuXG4gIGlmIChsb2cuYXR0cmlidXRlcykge1xuICAgIE9iamVjdC52YWx1ZXMobG9nLmF0dHJpYnV0ZXMpLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHdlaWdodCArPSB2YWx1ZS5sZW5ndGggKiBlc3RpbWF0ZVByaW1pdGl2ZVNpemVJbkJ5dGVzKHZhbHVlWzBdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXMuaXNQcmltaXRpdmUodmFsdWUpKSB7XG4gICAgICAgIHdlaWdodCArPSBlc3RpbWF0ZVByaW1pdGl2ZVNpemVJbkJ5dGVzKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvYmplY3RzIHZhbHVlcywgd2UgZXN0aW1hdGUgdGhlIHNpemUgb2YgdGhlIG9iamVjdCBhcyAxMDAgYnl0ZXNcbiAgICAgICAgd2VpZ2h0ICs9IDEwMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB3ZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGVzdGltYXRlUHJpbWl0aXZlU2l6ZUluQnl0ZXModmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoICogMjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIDg7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gNDtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5leHBvcnRzLlNlcnZlclJ1bnRpbWVDbGllbnQgPSBTZXJ2ZXJSdW50aW1lQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLXJ1bnRpbWUtY2xpZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/server-runtime-client.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/session.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst misc = __webpack_require__(/*! ./utils-hoist/misc.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js\");\nconst time = __webpack_require__(/*! ./utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\n\n/**\n * Creates a new `Session` object by setting certain default parameters. If optional @param context\n * is passed, the passed properties are applied to the session object.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns a new `Session` object\n */\nfunction makeSession(context) {\n  // Both timestamp and started are in seconds since the UNIX epoch.\n  const startingTime = time.timestampInSeconds();\n\n  const session = {\n    sid: misc.uuid4(),\n    init: true,\n    timestamp: startingTime,\n    started: startingTime,\n    duration: 0,\n    status: 'ok',\n    errors: 0,\n    ignoreDuration: false,\n    toJSON: () => sessionToJSON(session),\n  };\n\n  if (context) {\n    updateSession(session, context);\n  }\n\n  return session;\n}\n\n/**\n * Updates a session object with the properties passed in the context.\n *\n * Note that this function mutates the passed object and returns void.\n * (Had to do this instead of returning a new and updated session because closing and sending a session\n * makes an update to the session after it was passed to the sending logic.\n * @see Client.captureSession )\n *\n * @param session the `Session` to update\n * @param context the `SessionContext` holding the properties that should be updated in @param session\n */\n// eslint-disable-next-line complexity\nfunction updateSession(session, context = {}) {\n  if (context.user) {\n    if (!session.ipAddress && context.user.ip_address) {\n      session.ipAddress = context.user.ip_address;\n    }\n\n    if (!session.did && !context.did) {\n      session.did = context.user.id || context.user.email || context.user.username;\n    }\n  }\n\n  session.timestamp = context.timestamp || time.timestampInSeconds();\n\n  if (context.abnormal_mechanism) {\n    session.abnormal_mechanism = context.abnormal_mechanism;\n  }\n\n  if (context.ignoreDuration) {\n    session.ignoreDuration = context.ignoreDuration;\n  }\n  if (context.sid) {\n    // Good enough uuid validation.  Kamil\n    session.sid = context.sid.length === 32 ? context.sid : misc.uuid4();\n  }\n  if (context.init !== undefined) {\n    session.init = context.init;\n  }\n  if (!session.did && context.did) {\n    session.did = `${context.did}`;\n  }\n  if (typeof context.started === 'number') {\n    session.started = context.started;\n  }\n  if (session.ignoreDuration) {\n    session.duration = undefined;\n  } else if (typeof context.duration === 'number') {\n    session.duration = context.duration;\n  } else {\n    const duration = session.timestamp - session.started;\n    session.duration = duration >= 0 ? duration : 0;\n  }\n  if (context.release) {\n    session.release = context.release;\n  }\n  if (context.environment) {\n    session.environment = context.environment;\n  }\n  if (!session.ipAddress && context.ipAddress) {\n    session.ipAddress = context.ipAddress;\n  }\n  if (!session.userAgent && context.userAgent) {\n    session.userAgent = context.userAgent;\n  }\n  if (typeof context.errors === 'number') {\n    session.errors = context.errors;\n  }\n  if (context.status) {\n    session.status = context.status;\n  }\n}\n\n/**\n * Closes a session by setting its status and updating the session object with it.\n * Internally calls `updateSession` to update the passed session object.\n *\n * Note that this function mutates the passed session (@see updateSession for explanation).\n *\n * @param session the `Session` object to be closed\n * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,\n *               this function will keep the previously set status, unless it was `'ok'` in which case\n *               it is changed to `'exited'`.\n */\nfunction closeSession(session, status) {\n  let context = {};\n  if (status) {\n    context = { status };\n  } else if (session.status === 'ok') {\n    context = { status: 'exited' };\n  }\n\n  updateSession(session, context);\n}\n\n/**\n * Serializes a passed session object to a JSON object with a slightly different structure.\n * This is necessary because the Sentry backend requires a slightly different schema of a session\n * than the one the JS SDKs use internally.\n *\n * @param session the session to be converted\n *\n * @returns a JSON object of the passed session\n */\nfunction sessionToJSON(session) {\n  return {\n    sid: `${session.sid}`,\n    init: session.init,\n    // Make sure that sec is converted to ms for date constructor\n    started: new Date(session.started * 1000).toISOString(),\n    timestamp: new Date(session.timestamp * 1000).toISOString(),\n    status: session.status,\n    errors: session.errors,\n    did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,\n    duration: session.duration,\n    abnormal_mechanism: session.abnormal_mechanism,\n    attrs: {\n      release: session.release,\n      environment: session.environment,\n      ip_address: session.ipAddress,\n      user_agent: session.userAgent,\n    },\n  };\n}\n\nexports.closeSession = closeSession;\nexports.makeSession = makeSession;\nexports.updateSession = updateSession;\n//# sourceMappingURL=session.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3Nlc3Npb24uanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsYUFBYSxtQkFBTyxDQUFDLGlJQUF1QjtBQUM1QyxhQUFhLG1CQUFPLENBQUMsaUlBQXVCOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsSUFBSTtBQUNKLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFlBQVk7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxzZXNzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBtaXNjID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9taXNjLmpzJyk7XG5jb25zdCB0aW1lID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC90aW1lLmpzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgU2Vzc2lvbmAgb2JqZWN0IGJ5IHNldHRpbmcgY2VydGFpbiBkZWZhdWx0IHBhcmFtZXRlcnMuIElmIG9wdGlvbmFsIEBwYXJhbSBjb250ZXh0XG4gKiBpcyBwYXNzZWQsIHRoZSBwYXNzZWQgcHJvcGVydGllcyBhcmUgYXBwbGllZCB0byB0aGUgc2Vzc2lvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIGNvbnRleHQgKG9wdGlvbmFsKSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgcmV0dXJuZWQgc2Vzc2lvbiBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyBhIG5ldyBgU2Vzc2lvbmAgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1ha2VTZXNzaW9uKGNvbnRleHQpIHtcbiAgLy8gQm90aCB0aW1lc3RhbXAgYW5kIHN0YXJ0ZWQgYXJlIGluIHNlY29uZHMgc2luY2UgdGhlIFVOSVggZXBvY2guXG4gIGNvbnN0IHN0YXJ0aW5nVGltZSA9IHRpbWUudGltZXN0YW1wSW5TZWNvbmRzKCk7XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IHtcbiAgICBzaWQ6IG1pc2MudXVpZDQoKSxcbiAgICBpbml0OiB0cnVlLFxuICAgIHRpbWVzdGFtcDogc3RhcnRpbmdUaW1lLFxuICAgIHN0YXJ0ZWQ6IHN0YXJ0aW5nVGltZSxcbiAgICBkdXJhdGlvbjogMCxcbiAgICBzdGF0dXM6ICdvaycsXG4gICAgZXJyb3JzOiAwLFxuICAgIGlnbm9yZUR1cmF0aW9uOiBmYWxzZSxcbiAgICB0b0pTT046ICgpID0+IHNlc3Npb25Ub0pTT04oc2Vzc2lvbiksXG4gIH07XG5cbiAgaWYgKGNvbnRleHQpIHtcbiAgICB1cGRhdGVTZXNzaW9uKHNlc3Npb24sIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHNlc3Npb247XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIHNlc3Npb24gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgcGFzc2VkIGluIHRoZSBjb250ZXh0LlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHBhc3NlZCBvYmplY3QgYW5kIHJldHVybnMgdm9pZC5cbiAqIChIYWQgdG8gZG8gdGhpcyBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG5ldyBhbmQgdXBkYXRlZCBzZXNzaW9uIGJlY2F1c2UgY2xvc2luZyBhbmQgc2VuZGluZyBhIHNlc3Npb25cbiAqIG1ha2VzIGFuIHVwZGF0ZSB0byB0aGUgc2Vzc2lvbiBhZnRlciBpdCB3YXMgcGFzc2VkIHRvIHRoZSBzZW5kaW5nIGxvZ2ljLlxuICogQHNlZSBDbGllbnQuY2FwdHVyZVNlc3Npb24gKVxuICpcbiAqIEBwYXJhbSBzZXNzaW9uIHRoZSBgU2Vzc2lvbmAgdG8gdXBkYXRlXG4gKiBAcGFyYW0gY29udGV4dCB0aGUgYFNlc3Npb25Db250ZXh0YCBob2xkaW5nIHRoZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWQgaW4gQHBhcmFtIHNlc3Npb25cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVwZGF0ZVNlc3Npb24oc2Vzc2lvbiwgY29udGV4dCA9IHt9KSB7XG4gIGlmIChjb250ZXh0LnVzZXIpIHtcbiAgICBpZiAoIXNlc3Npb24uaXBBZGRyZXNzICYmIGNvbnRleHQudXNlci5pcF9hZGRyZXNzKSB7XG4gICAgICBzZXNzaW9uLmlwQWRkcmVzcyA9IGNvbnRleHQudXNlci5pcF9hZGRyZXNzO1xuICAgIH1cblxuICAgIGlmICghc2Vzc2lvbi5kaWQgJiYgIWNvbnRleHQuZGlkKSB7XG4gICAgICBzZXNzaW9uLmRpZCA9IGNvbnRleHQudXNlci5pZCB8fCBjb250ZXh0LnVzZXIuZW1haWwgfHwgY29udGV4dC51c2VyLnVzZXJuYW1lO1xuICAgIH1cbiAgfVxuXG4gIHNlc3Npb24udGltZXN0YW1wID0gY29udGV4dC50aW1lc3RhbXAgfHwgdGltZS50aW1lc3RhbXBJblNlY29uZHMoKTtcblxuICBpZiAoY29udGV4dC5hYm5vcm1hbF9tZWNoYW5pc20pIHtcbiAgICBzZXNzaW9uLmFibm9ybWFsX21lY2hhbmlzbSA9IGNvbnRleHQuYWJub3JtYWxfbWVjaGFuaXNtO1xuICB9XG5cbiAgaWYgKGNvbnRleHQuaWdub3JlRHVyYXRpb24pIHtcbiAgICBzZXNzaW9uLmlnbm9yZUR1cmF0aW9uID0gY29udGV4dC5pZ25vcmVEdXJhdGlvbjtcbiAgfVxuICBpZiAoY29udGV4dC5zaWQpIHtcbiAgICAvLyBHb29kIGVub3VnaCB1dWlkIHZhbGlkYXRpb24uIOKAlCBLYW1pbFxuICAgIHNlc3Npb24uc2lkID0gY29udGV4dC5zaWQubGVuZ3RoID09PSAzMiA/IGNvbnRleHQuc2lkIDogbWlzYy51dWlkNCgpO1xuICB9XG4gIGlmIChjb250ZXh0LmluaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHNlc3Npb24uaW5pdCA9IGNvbnRleHQuaW5pdDtcbiAgfVxuICBpZiAoIXNlc3Npb24uZGlkICYmIGNvbnRleHQuZGlkKSB7XG4gICAgc2Vzc2lvbi5kaWQgPSBgJHtjb250ZXh0LmRpZH1gO1xuICB9XG4gIGlmICh0eXBlb2YgY29udGV4dC5zdGFydGVkID09PSAnbnVtYmVyJykge1xuICAgIHNlc3Npb24uc3RhcnRlZCA9IGNvbnRleHQuc3RhcnRlZDtcbiAgfVxuICBpZiAoc2Vzc2lvbi5pZ25vcmVEdXJhdGlvbikge1xuICAgIHNlc3Npb24uZHVyYXRpb24gPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHQuZHVyYXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgc2Vzc2lvbi5kdXJhdGlvbiA9IGNvbnRleHQuZHVyYXRpb247XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSBzZXNzaW9uLnRpbWVzdGFtcCAtIHNlc3Npb24uc3RhcnRlZDtcbiAgICBzZXNzaW9uLmR1cmF0aW9uID0gZHVyYXRpb24gPj0gMCA/IGR1cmF0aW9uIDogMDtcbiAgfVxuICBpZiAoY29udGV4dC5yZWxlYXNlKSB7XG4gICAgc2Vzc2lvbi5yZWxlYXNlID0gY29udGV4dC5yZWxlYXNlO1xuICB9XG4gIGlmIChjb250ZXh0LmVudmlyb25tZW50KSB7XG4gICAgc2Vzc2lvbi5lbnZpcm9ubWVudCA9IGNvbnRleHQuZW52aXJvbm1lbnQ7XG4gIH1cbiAgaWYgKCFzZXNzaW9uLmlwQWRkcmVzcyAmJiBjb250ZXh0LmlwQWRkcmVzcykge1xuICAgIHNlc3Npb24uaXBBZGRyZXNzID0gY29udGV4dC5pcEFkZHJlc3M7XG4gIH1cbiAgaWYgKCFzZXNzaW9uLnVzZXJBZ2VudCAmJiBjb250ZXh0LnVzZXJBZ2VudCkge1xuICAgIHNlc3Npb24udXNlckFnZW50ID0gY29udGV4dC51c2VyQWdlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZXh0LmVycm9ycyA9PT0gJ251bWJlcicpIHtcbiAgICBzZXNzaW9uLmVycm9ycyA9IGNvbnRleHQuZXJyb3JzO1xuICB9XG4gIGlmIChjb250ZXh0LnN0YXR1cykge1xuICAgIHNlc3Npb24uc3RhdHVzID0gY29udGV4dC5zdGF0dXM7XG4gIH1cbn1cblxuLyoqXG4gKiBDbG9zZXMgYSBzZXNzaW9uIGJ5IHNldHRpbmcgaXRzIHN0YXR1cyBhbmQgdXBkYXRpbmcgdGhlIHNlc3Npb24gb2JqZWN0IHdpdGggaXQuXG4gKiBJbnRlcm5hbGx5IGNhbGxzIGB1cGRhdGVTZXNzaW9uYCB0byB1cGRhdGUgdGhlIHBhc3NlZCBzZXNzaW9uIG9iamVjdC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSBwYXNzZWQgc2Vzc2lvbiAoQHNlZSB1cGRhdGVTZXNzaW9uIGZvciBleHBsYW5hdGlvbikuXG4gKlxuICogQHBhcmFtIHNlc3Npb24gdGhlIGBTZXNzaW9uYCBvYmplY3QgdG8gYmUgY2xvc2VkXG4gKiBAcGFyYW0gc3RhdHVzIHRoZSBgU2Vzc2lvblN0YXR1c2Agd2l0aCB3aGljaCB0aGUgc2Vzc2lvbiB3YXMgY2xvc2VkLiBJZiB5b3UgZG9uJ3QgcGFzcyBhIHN0YXR1cyxcbiAqICAgICAgICAgICAgICAgdGhpcyBmdW5jdGlvbiB3aWxsIGtlZXAgdGhlIHByZXZpb3VzbHkgc2V0IHN0YXR1cywgdW5sZXNzIGl0IHdhcyBgJ29rJ2AgaW4gd2hpY2ggY2FzZVxuICogICAgICAgICAgICAgICBpdCBpcyBjaGFuZ2VkIHRvIGAnZXhpdGVkJ2AuXG4gKi9cbmZ1bmN0aW9uIGNsb3NlU2Vzc2lvbihzZXNzaW9uLCBzdGF0dXMpIHtcbiAgbGV0IGNvbnRleHQgPSB7fTtcbiAgaWYgKHN0YXR1cykge1xuICAgIGNvbnRleHQgPSB7IHN0YXR1cyB9O1xuICB9IGVsc2UgaWYgKHNlc3Npb24uc3RhdHVzID09PSAnb2snKSB7XG4gICAgY29udGV4dCA9IHsgc3RhdHVzOiAnZXhpdGVkJyB9O1xuICB9XG5cbiAgdXBkYXRlU2Vzc2lvbihzZXNzaW9uLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemVzIGEgcGFzc2VkIHNlc3Npb24gb2JqZWN0IHRvIGEgSlNPTiBvYmplY3Qgd2l0aCBhIHNsaWdodGx5IGRpZmZlcmVudCBzdHJ1Y3R1cmUuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBTZW50cnkgYmFja2VuZCByZXF1aXJlcyBhIHNsaWdodGx5IGRpZmZlcmVudCBzY2hlbWEgb2YgYSBzZXNzaW9uXG4gKiB0aGFuIHRoZSBvbmUgdGhlIEpTIFNES3MgdXNlIGludGVybmFsbHkuXG4gKlxuICogQHBhcmFtIHNlc3Npb24gdGhlIHNlc3Npb24gdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgYSBKU09OIG9iamVjdCBvZiB0aGUgcGFzc2VkIHNlc3Npb25cbiAqL1xuZnVuY3Rpb24gc2Vzc2lvblRvSlNPTihzZXNzaW9uKSB7XG4gIHJldHVybiB7XG4gICAgc2lkOiBgJHtzZXNzaW9uLnNpZH1gLFxuICAgIGluaXQ6IHNlc3Npb24uaW5pdCxcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBzZWMgaXMgY29udmVydGVkIHRvIG1zIGZvciBkYXRlIGNvbnN0cnVjdG9yXG4gICAgc3RhcnRlZDogbmV3IERhdGUoc2Vzc2lvbi5zdGFydGVkICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHNlc3Npb24udGltZXN0YW1wICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICBzdGF0dXM6IHNlc3Npb24uc3RhdHVzLFxuICAgIGVycm9yczogc2Vzc2lvbi5lcnJvcnMsXG4gICAgZGlkOiB0eXBlb2Ygc2Vzc2lvbi5kaWQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBzZXNzaW9uLmRpZCA9PT0gJ3N0cmluZycgPyBgJHtzZXNzaW9uLmRpZH1gIDogdW5kZWZpbmVkLFxuICAgIGR1cmF0aW9uOiBzZXNzaW9uLmR1cmF0aW9uLFxuICAgIGFibm9ybWFsX21lY2hhbmlzbTogc2Vzc2lvbi5hYm5vcm1hbF9tZWNoYW5pc20sXG4gICAgYXR0cnM6IHtcbiAgICAgIHJlbGVhc2U6IHNlc3Npb24ucmVsZWFzZSxcbiAgICAgIGVudmlyb25tZW50OiBzZXNzaW9uLmVudmlyb25tZW50LFxuICAgICAgaXBfYWRkcmVzczogc2Vzc2lvbi5pcEFkZHJlc3MsXG4gICAgICB1c2VyX2FnZW50OiBzZXNzaW9uLnVzZXJBZ2VudCxcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnRzLmNsb3NlU2Vzc2lvbiA9IGNsb3NlU2Vzc2lvbjtcbmV4cG9ydHMubWFrZVNlc3Npb24gPSBtYWtlU2Vzc2lvbjtcbmV4cG9ydHMudXBkYXRlU2Vzc2lvbiA9IHVwZGF0ZVNlc3Npb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXNzaW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/session.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst constants = __webpack_require__(/*! ../constants.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/constants.js");\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/semanticAttributes.js");\nconst hasSpansEnabled = __webpack_require__(/*! ../utils/hasSpansEnabled.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/hasSpansEnabled.js");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanUtils.js");\nconst baggage = __webpack_require__(/*! ../utils-hoist/baggage.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/baggage.js");\nconst dsn = __webpack_require__(/*! ../utils-hoist/dsn.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/dsn.js");\nconst object = __webpack_require__(/*! ../utils-hoist/object.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/object.js");\nconst utils = __webpack_require__(/*! ./utils.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/utils.js");\n\n/**\n * If you change this value, also update the terser plugin config to\n * avoid minification of the object property!\n */\nconst FROZEN_DSC_FIELD = \'_frozenDsc\';\n\n/**\n * Freeze the given DSC on the given span.\n */\nfunction freezeDscOnSpan(span, dsc) {\n  const spanWithMaybeDsc = span ;\n  object.addNonEnumerableProperty(spanWithMaybeDsc, FROZEN_DSC_FIELD, dsc);\n}\n\n/**\n * Creates a dynamic sampling context from a client.\n *\n * Dispatches the `createDsc` lifecycle hook as a side effect.\n */\nfunction getDynamicSamplingContextFromClient(trace_id, client) {\n  const options = client.getOptions();\n\n  const { publicKey: public_key, host } = client.getDsn() || {};\n\n  let org_id;\n  if (options.orgId) {\n    org_id = String(options.orgId);\n  } else if (host) {\n    org_id = dsn.extractOrgIdFromDsnHost(host);\n  }\n\n  // Instead of conditionally adding non-undefined values, we add them and then remove them if needed\n  // otherwise, the order of baggage entries changes, which "breaks" a bunch of tests etc.\n  const dsc = {\n    environment: options.environment || constants.DEFAULT_ENVIRONMENT,\n    release: options.release,\n    public_key,\n    trace_id,\n    org_id,\n  };\n\n  client.emit(\'createDsc\', dsc);\n\n  return dsc;\n}\n\n/**\n * Get the dynamic sampling context for the currently active scopes.\n */\nfunction getDynamicSamplingContextFromScope(client, scope) {\n  const propagationContext = scope.getPropagationContext();\n  return propagationContext.dsc || getDynamicSamplingContextFromClient(propagationContext.traceId, client);\n}\n\n/**\n * Creates a dynamic sampling context from a span (and client and scope)\n *\n * @param span the span from which a few values like the root span name and sample rate are extracted.\n *\n * @returns a dynamic sampling context\n */\nfunction getDynamicSamplingContextFromSpan(span) {\n  const client = currentScopes.getClient();\n  if (!client) {\n    return {};\n  }\n\n  const rootSpan = spanUtils.getRootSpan(span);\n  const rootSpanJson = spanUtils.spanToJSON(rootSpan);\n  const rootSpanAttributes = rootSpanJson.data;\n  const traceState = rootSpan.spanContext().traceState;\n\n  // The span sample rate that was locally applied to the root span should also always be applied to the DSC, even if the DSC is frozen.\n  // This is so that the downstream traces/services can use parentSampleRate in their `tracesSampler` to make consistent sampling decisions across the entire trace.\n  const rootSpanSampleRate =\n    traceState?.get(\'sentry.sample_rate\') ??\n    rootSpanAttributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ??\n    rootSpanAttributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE];\n\n  function applyLocalSampleRateToDsc(dsc) {\n    if (typeof rootSpanSampleRate === \'number\' || typeof rootSpanSampleRate === \'string\') {\n      dsc.sample_rate = `${rootSpanSampleRate}`;\n    }\n    return dsc;\n  }\n\n  // For core implementation, we freeze the DSC onto the span as a non-enumerable property\n  const frozenDsc = (rootSpan )[FROZEN_DSC_FIELD];\n  if (frozenDsc) {\n    return applyLocalSampleRateToDsc(frozenDsc);\n  }\n\n  // For OpenTelemetry, we freeze the DSC on the trace state\n  const traceStateDsc = traceState?.get(\'sentry.dsc\');\n\n  // If the span has a DSC, we want it to take precedence\n  const dscOnTraceState = traceStateDsc && baggage.baggageHeaderToDynamicSamplingContext(traceStateDsc);\n\n  if (dscOnTraceState) {\n    return applyLocalSampleRateToDsc(dscOnTraceState);\n  }\n\n  // Else, we generate it from the span\n  const dsc = getDynamicSamplingContextFromClient(span.spanContext().traceId, client);\n\n  // We don\'t want to have a transaction name in the DSC if the source is "url" because URLs might contain PII\n  const source = rootSpanAttributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n  // after JSON conversion, txn.name becomes jsonSpan.description\n  const name = rootSpanJson.description;\n  if (source !== \'url\' && name) {\n    dsc.transaction = name;\n  }\n\n  // How can we even land here with hasSpansEnabled() returning false?\n  // Otel creates a Non-recording span in Tracing Without Performance mode when handling incoming requests\n  // So we end up with an active span that is not sampled (neither positively nor negatively)\n  if (hasSpansEnabled.hasSpansEnabled()) {\n    dsc.sampled = String(spanUtils.spanIsSampled(rootSpan));\n    dsc.sample_rand =\n      // In OTEL we store the sample rand on the trace state because we cannot access scopes for NonRecordingSpans\n      // The Sentry OTEL SpanSampler takes care of writing the sample rand on the root span\n      traceState?.get(\'sentry.sample_rand\') ??\n      // On all other platforms we can actually get the scopes from a root span (we use this as a fallback)\n      utils.getCapturedScopesOnSpan(rootSpan).scope?.getPropagationContext().sampleRand.toString();\n  }\n\n  applyLocalSampleRateToDsc(dsc);\n\n  client.emit(\'createDsc\', dsc, rootSpan);\n\n  return dsc;\n}\n\n/**\n * Convert a Span to a baggage header.\n */\nfunction spanToBaggageHeader(span) {\n  const dsc = getDynamicSamplingContextFromSpan(span);\n  return baggage.dynamicSamplingContextToSentryBaggageHeader(dsc);\n}\n\nexports.freezeDscOnSpan = freezeDscOnSpan;\nexports.getDynamicSamplingContextFromClient = getDynamicSamplingContextFromClient;\nexports.getDynamicSamplingContextFromScope = getDynamicSamplingContextFromScope;\nexports.getDynamicSamplingContextFromSpan = getDynamicSamplingContextFromSpan;\nexports.spanToBaggageHeader = spanToBaggageHeader;\n//# sourceMappingURL=dynamicSamplingContext.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYWNpbmcvZHluYW1pY1NhbXBsaW5nQ29udGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxrQkFBa0IsbUJBQU8sQ0FBQyxvSEFBaUI7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsNEhBQXFCO0FBQ25ELDJCQUEyQixtQkFBTyxDQUFDLHNJQUEwQjtBQUM3RCx3QkFBd0IsbUJBQU8sQ0FBQyw0SUFBNkI7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsZ0lBQXVCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLHdJQUEyQjtBQUNuRCxZQUFZLG1CQUFPLENBQUMsZ0lBQXVCO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxzSUFBMEI7QUFDakQsY0FBYyxtQkFBTyxDQUFDLG1IQUFZOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsOEJBQThCOztBQUV4QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLDJDQUEyQztBQUMzQywwQ0FBMEM7QUFDMUMseUNBQXlDO0FBQ3pDLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFx0cmFjaW5nXFxkeW5hbWljU2FtcGxpbmdDb250ZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMuanMnKTtcbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBzZW1hbnRpY0F0dHJpYnV0ZXMgPSByZXF1aXJlKCcuLi9zZW1hbnRpY0F0dHJpYnV0ZXMuanMnKTtcbmNvbnN0IGhhc1NwYW5zRW5hYmxlZCA9IHJlcXVpcmUoJy4uL3V0aWxzL2hhc1NwYW5zRW5hYmxlZC5qcycpO1xuY29uc3Qgc3BhblV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvc3BhblV0aWxzLmpzJyk7XG5jb25zdCBiYWdnYWdlID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvYmFnZ2FnZS5qcycpO1xuY29uc3QgZHNuID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvZHNuLmpzJyk7XG5jb25zdCBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9vYmplY3QuanMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xuXG4vKipcbiAqIElmIHlvdSBjaGFuZ2UgdGhpcyB2YWx1ZSwgYWxzbyB1cGRhdGUgdGhlIHRlcnNlciBwbHVnaW4gY29uZmlnIHRvXG4gKiBhdm9pZCBtaW5pZmljYXRpb24gb2YgdGhlIG9iamVjdCBwcm9wZXJ0eSFcbiAqL1xuY29uc3QgRlJPWkVOX0RTQ19GSUVMRCA9ICdfZnJvemVuRHNjJztcblxuLyoqXG4gKiBGcmVlemUgdGhlIGdpdmVuIERTQyBvbiB0aGUgZ2l2ZW4gc3Bhbi5cbiAqL1xuZnVuY3Rpb24gZnJlZXplRHNjT25TcGFuKHNwYW4sIGRzYykge1xuICBjb25zdCBzcGFuV2l0aE1heWJlRHNjID0gc3BhbiA7XG4gIG9iamVjdC5hZGROb25FbnVtZXJhYmxlUHJvcGVydHkoc3BhbldpdGhNYXliZURzYywgRlJPWkVOX0RTQ19GSUVMRCwgZHNjKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZHluYW1pYyBzYW1wbGluZyBjb250ZXh0IGZyb20gYSBjbGllbnQuXG4gKlxuICogRGlzcGF0Y2hlcyB0aGUgYGNyZWF0ZURzY2AgbGlmZWN5Y2xlIGhvb2sgYXMgYSBzaWRlIGVmZmVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21DbGllbnQodHJhY2VfaWQsIGNsaWVudCkge1xuICBjb25zdCBvcHRpb25zID0gY2xpZW50LmdldE9wdGlvbnMoKTtcblxuICBjb25zdCB7IHB1YmxpY0tleTogcHVibGljX2tleSwgaG9zdCB9ID0gY2xpZW50LmdldERzbigpIHx8IHt9O1xuXG4gIGxldCBvcmdfaWQ7XG4gIGlmIChvcHRpb25zLm9yZ0lkKSB7XG4gICAgb3JnX2lkID0gU3RyaW5nKG9wdGlvbnMub3JnSWQpO1xuICB9IGVsc2UgaWYgKGhvc3QpIHtcbiAgICBvcmdfaWQgPSBkc24uZXh0cmFjdE9yZ0lkRnJvbURzbkhvc3QoaG9zdCk7XG4gIH1cblxuICAvLyBJbnN0ZWFkIG9mIGNvbmRpdGlvbmFsbHkgYWRkaW5nIG5vbi11bmRlZmluZWQgdmFsdWVzLCB3ZSBhZGQgdGhlbSBhbmQgdGhlbiByZW1vdmUgdGhlbSBpZiBuZWVkZWRcbiAgLy8gb3RoZXJ3aXNlLCB0aGUgb3JkZXIgb2YgYmFnZ2FnZSBlbnRyaWVzIGNoYW5nZXMsIHdoaWNoIFwiYnJlYWtzXCIgYSBidW5jaCBvZiB0ZXN0cyBldGMuXG4gIGNvbnN0IGRzYyA9IHtcbiAgICBlbnZpcm9ubWVudDogb3B0aW9ucy5lbnZpcm9ubWVudCB8fCBjb25zdGFudHMuREVGQVVMVF9FTlZJUk9OTUVOVCxcbiAgICByZWxlYXNlOiBvcHRpb25zLnJlbGVhc2UsXG4gICAgcHVibGljX2tleSxcbiAgICB0cmFjZV9pZCxcbiAgICBvcmdfaWQsXG4gIH07XG5cbiAgY2xpZW50LmVtaXQoJ2NyZWF0ZURzYycsIGRzYyk7XG5cbiAgcmV0dXJuIGRzYztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGR5bmFtaWMgc2FtcGxpbmcgY29udGV4dCBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2NvcGVzLlxuICovXG5mdW5jdGlvbiBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNjb3BlKGNsaWVudCwgc2NvcGUpIHtcbiAgY29uc3QgcHJvcGFnYXRpb25Db250ZXh0ID0gc2NvcGUuZ2V0UHJvcGFnYXRpb25Db250ZXh0KCk7XG4gIHJldHVybiBwcm9wYWdhdGlvbkNvbnRleHQuZHNjIHx8IGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tQ2xpZW50KHByb3BhZ2F0aW9uQ29udGV4dC50cmFjZUlkLCBjbGllbnQpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBkeW5hbWljIHNhbXBsaW5nIGNvbnRleHQgZnJvbSBhIHNwYW4gKGFuZCBjbGllbnQgYW5kIHNjb3BlKVxuICpcbiAqIEBwYXJhbSBzcGFuIHRoZSBzcGFuIGZyb20gd2hpY2ggYSBmZXcgdmFsdWVzIGxpa2UgdGhlIHJvb3Qgc3BhbiBuYW1lIGFuZCBzYW1wbGUgcmF0ZSBhcmUgZXh0cmFjdGVkLlxuICpcbiAqIEByZXR1cm5zIGEgZHluYW1pYyBzYW1wbGluZyBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuKSB7XG4gIGNvbnN0IGNsaWVudCA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG4gIGlmICghY2xpZW50KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3Qgcm9vdFNwYW4gPSBzcGFuVXRpbHMuZ2V0Um9vdFNwYW4oc3Bhbik7XG4gIGNvbnN0IHJvb3RTcGFuSnNvbiA9IHNwYW5VdGlscy5zcGFuVG9KU09OKHJvb3RTcGFuKTtcbiAgY29uc3Qgcm9vdFNwYW5BdHRyaWJ1dGVzID0gcm9vdFNwYW5Kc29uLmRhdGE7XG4gIGNvbnN0IHRyYWNlU3RhdGUgPSByb290U3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlU3RhdGU7XG5cbiAgLy8gVGhlIHNwYW4gc2FtcGxlIHJhdGUgdGhhdCB3YXMgbG9jYWxseSBhcHBsaWVkIHRvIHRoZSByb290IHNwYW4gc2hvdWxkIGFsc28gYWx3YXlzIGJlIGFwcGxpZWQgdG8gdGhlIERTQywgZXZlbiBpZiB0aGUgRFNDIGlzIGZyb3plbi5cbiAgLy8gVGhpcyBpcyBzbyB0aGF0IHRoZSBkb3duc3RyZWFtIHRyYWNlcy9zZXJ2aWNlcyBjYW4gdXNlIHBhcmVudFNhbXBsZVJhdGUgaW4gdGhlaXIgYHRyYWNlc1NhbXBsZXJgIHRvIG1ha2UgY29uc2lzdGVudCBzYW1wbGluZyBkZWNpc2lvbnMgYWNyb3NzIHRoZSBlbnRpcmUgdHJhY2UuXG4gIGNvbnN0IHJvb3RTcGFuU2FtcGxlUmF0ZSA9XG4gICAgdHJhY2VTdGF0ZT8uZ2V0KCdzZW50cnkuc2FtcGxlX3JhdGUnKSA/P1xuICAgIHJvb3RTcGFuQXR0cmlidXRlc1tzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURV0gPz9cbiAgICByb290U3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUFJFVklPVVNfVFJBQ0VfU0FNUExFX1JBVEVdO1xuXG4gIGZ1bmN0aW9uIGFwcGx5TG9jYWxTYW1wbGVSYXRlVG9Ec2MoZHNjKSB7XG4gICAgaWYgKHR5cGVvZiByb290U3BhblNhbXBsZVJhdGUgPT09ICdudW1iZXInIHx8IHR5cGVvZiByb290U3BhblNhbXBsZVJhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkc2Muc2FtcGxlX3JhdGUgPSBgJHtyb290U3BhblNhbXBsZVJhdGV9YDtcbiAgICB9XG4gICAgcmV0dXJuIGRzYztcbiAgfVxuXG4gIC8vIEZvciBjb3JlIGltcGxlbWVudGF0aW9uLCB3ZSBmcmVlemUgdGhlIERTQyBvbnRvIHRoZSBzcGFuIGFzIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcbiAgY29uc3QgZnJvemVuRHNjID0gKHJvb3RTcGFuIClbRlJPWkVOX0RTQ19GSUVMRF07XG4gIGlmIChmcm96ZW5Ec2MpIHtcbiAgICByZXR1cm4gYXBwbHlMb2NhbFNhbXBsZVJhdGVUb0RzYyhmcm96ZW5Ec2MpO1xuICB9XG5cbiAgLy8gRm9yIE9wZW5UZWxlbWV0cnksIHdlIGZyZWV6ZSB0aGUgRFNDIG9uIHRoZSB0cmFjZSBzdGF0ZVxuICBjb25zdCB0cmFjZVN0YXRlRHNjID0gdHJhY2VTdGF0ZT8uZ2V0KCdzZW50cnkuZHNjJyk7XG5cbiAgLy8gSWYgdGhlIHNwYW4gaGFzIGEgRFNDLCB3ZSB3YW50IGl0IHRvIHRha2UgcHJlY2VkZW5jZVxuICBjb25zdCBkc2NPblRyYWNlU3RhdGUgPSB0cmFjZVN0YXRlRHNjICYmIGJhZ2dhZ2UuYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dCh0cmFjZVN0YXRlRHNjKTtcblxuICBpZiAoZHNjT25UcmFjZVN0YXRlKSB7XG4gICAgcmV0dXJuIGFwcGx5TG9jYWxTYW1wbGVSYXRlVG9Ec2MoZHNjT25UcmFjZVN0YXRlKTtcbiAgfVxuXG4gIC8vIEVsc2UsIHdlIGdlbmVyYXRlIGl0IGZyb20gdGhlIHNwYW5cbiAgY29uc3QgZHNjID0gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21DbGllbnQoc3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWQsIGNsaWVudCk7XG5cbiAgLy8gV2UgZG9uJ3Qgd2FudCB0byBoYXZlIGEgdHJhbnNhY3Rpb24gbmFtZSBpbiB0aGUgRFNDIGlmIHRoZSBzb3VyY2UgaXMgXCJ1cmxcIiBiZWNhdXNlIFVSTHMgbWlnaHQgY29udGFpbiBQSUlcbiAgY29uc3Qgc291cmNlID0gcm9vdFNwYW5BdHRyaWJ1dGVzW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV07XG5cbiAgLy8gYWZ0ZXIgSlNPTiBjb252ZXJzaW9uLCB0eG4ubmFtZSBiZWNvbWVzIGpzb25TcGFuLmRlc2NyaXB0aW9uXG4gIGNvbnN0IG5hbWUgPSByb290U3Bhbkpzb24uZGVzY3JpcHRpb247XG4gIGlmIChzb3VyY2UgIT09ICd1cmwnICYmIG5hbWUpIHtcbiAgICBkc2MudHJhbnNhY3Rpb24gPSBuYW1lO1xuICB9XG5cbiAgLy8gSG93IGNhbiB3ZSBldmVuIGxhbmQgaGVyZSB3aXRoIGhhc1NwYW5zRW5hYmxlZCgpIHJldHVybmluZyBmYWxzZT9cbiAgLy8gT3RlbCBjcmVhdGVzIGEgTm9uLXJlY29yZGluZyBzcGFuIGluIFRyYWNpbmcgV2l0aG91dCBQZXJmb3JtYW5jZSBtb2RlIHdoZW4gaGFuZGxpbmcgaW5jb21pbmcgcmVxdWVzdHNcbiAgLy8gU28gd2UgZW5kIHVwIHdpdGggYW4gYWN0aXZlIHNwYW4gdGhhdCBpcyBub3Qgc2FtcGxlZCAobmVpdGhlciBwb3NpdGl2ZWx5IG5vciBuZWdhdGl2ZWx5KVxuICBpZiAoaGFzU3BhbnNFbmFibGVkLmhhc1NwYW5zRW5hYmxlZCgpKSB7XG4gICAgZHNjLnNhbXBsZWQgPSBTdHJpbmcoc3BhblV0aWxzLnNwYW5Jc1NhbXBsZWQocm9vdFNwYW4pKTtcbiAgICBkc2Muc2FtcGxlX3JhbmQgPVxuICAgICAgLy8gSW4gT1RFTCB3ZSBzdG9yZSB0aGUgc2FtcGxlIHJhbmQgb24gdGhlIHRyYWNlIHN0YXRlIGJlY2F1c2Ugd2UgY2Fubm90IGFjY2VzcyBzY29wZXMgZm9yIE5vblJlY29yZGluZ1NwYW5zXG4gICAgICAvLyBUaGUgU2VudHJ5IE9URUwgU3BhblNhbXBsZXIgdGFrZXMgY2FyZSBvZiB3cml0aW5nIHRoZSBzYW1wbGUgcmFuZCBvbiB0aGUgcm9vdCBzcGFuXG4gICAgICB0cmFjZVN0YXRlPy5nZXQoJ3NlbnRyeS5zYW1wbGVfcmFuZCcpID8/XG4gICAgICAvLyBPbiBhbGwgb3RoZXIgcGxhdGZvcm1zIHdlIGNhbiBhY3R1YWxseSBnZXQgdGhlIHNjb3BlcyBmcm9tIGEgcm9vdCBzcGFuICh3ZSB1c2UgdGhpcyBhcyBhIGZhbGxiYWNrKVxuICAgICAgdXRpbHMuZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4ocm9vdFNwYW4pLnNjb3BlPy5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKS5zYW1wbGVSYW5kLnRvU3RyaW5nKCk7XG4gIH1cblxuICBhcHBseUxvY2FsU2FtcGxlUmF0ZVRvRHNjKGRzYyk7XG5cbiAgY2xpZW50LmVtaXQoJ2NyZWF0ZURzYycsIGRzYywgcm9vdFNwYW4pO1xuXG4gIHJldHVybiBkc2M7XG59XG5cbi8qKlxuICogQ29udmVydCBhIFNwYW4gdG8gYSBiYWdnYWdlIGhlYWRlci5cbiAqL1xuZnVuY3Rpb24gc3BhblRvQmFnZ2FnZUhlYWRlcihzcGFuKSB7XG4gIGNvbnN0IGRzYyA9IGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuKTtcbiAgcmV0dXJuIGJhZ2dhZ2UuZHluYW1pY1NhbXBsaW5nQ29udGV4dFRvU2VudHJ5QmFnZ2FnZUhlYWRlcihkc2MpO1xufVxuXG5leHBvcnRzLmZyZWV6ZURzY09uU3BhbiA9IGZyZWV6ZURzY09uU3BhbjtcbmV4cG9ydHMuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21DbGllbnQgPSBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbUNsaWVudDtcbmV4cG9ydHMuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TY29wZSA9IGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU2NvcGU7XG5leHBvcnRzLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbiA9IGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbjtcbmV4cG9ydHMuc3BhblRvQmFnZ2FnZUhlYWRlciA9IHNwYW5Ub0JhZ2dhZ2VIZWFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1keW5hbWljU2FtcGxpbmdDb250ZXh0LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js\n')},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/errors.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanUtils.js");\nconst globalError = __webpack_require__(/*! ../utils-hoist/instrument/globalError.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/globalError.js");\nconst globalUnhandledRejection = __webpack_require__(/*! ../utils-hoist/instrument/globalUnhandledRejection.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/globalUnhandledRejection.js");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js");\nconst spanstatus = __webpack_require__(/*! ./spanstatus.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js");\n\nlet errorsInstrumented = false;\n\n/**\n * Ensure that global errors automatically set the active span status.\n */\nfunction registerSpanErrorInstrumentation() {\n  if (errorsInstrumented) {\n    return;\n  }\n\n  errorsInstrumented = true;\n  globalError.addGlobalErrorInstrumentationHandler(errorCallback);\n  globalUnhandledRejection.addGlobalUnhandledRejectionInstrumentationHandler(errorCallback);\n}\n\n/**\n * If an error or unhandled promise occurs, we mark the active root span as failed\n */\nfunction errorCallback() {\n  const activeSpan = spanUtils.getActiveSpan();\n  const rootSpan = activeSpan && spanUtils.getRootSpan(activeSpan);\n  if (rootSpan) {\n    const message = \'internal_error\';\n    debugBuild.DEBUG_BUILD && logger.logger.log(`[Tracing] Root span: ${message} -> Global error occurred`);\n    rootSpan.setStatus({ code: spanstatus.SPAN_STATUS_ERROR, message });\n  }\n}\n\n// The function name will be lost when bundling but we need to be able to identify this listener later to maintain the\n// node.js default exit behaviour\nerrorCallback.tag = \'sentry_tracingErrorCallback\';\n\nexports.registerSpanErrorInstrumentation = registerSpanErrorInstrumentation;\n//# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYWNpbmcvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLG1CQUFtQixtQkFBTyxDQUFDLHdIQUFtQjtBQUM5QyxrQkFBa0IsbUJBQU8sQ0FBQyxnSUFBdUI7QUFDakQsb0JBQW9CLG1CQUFPLENBQUMsc0tBQTBDO0FBQ3RFLGlDQUFpQyxtQkFBTyxDQUFDLGdNQUF1RDtBQUNoRyxlQUFlLG1CQUFPLENBQUMsc0lBQTBCO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLDZIQUFpQjs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxTQUFTO0FBQ2pGLHlCQUF5Qiw2Q0FBNkM7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXHRyYWNpbmdcXGVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgZGVidWdCdWlsZCA9IHJlcXVpcmUoJy4uL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBzcGFuVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9zcGFuVXRpbHMuanMnKTtcbmNvbnN0IGdsb2JhbEVycm9yID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvaW5zdHJ1bWVudC9nbG9iYWxFcnJvci5qcycpO1xuY29uc3QgZ2xvYmFsVW5oYW5kbGVkUmVqZWN0aW9uID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvaW5zdHJ1bWVudC9nbG9iYWxVbmhhbmRsZWRSZWplY3Rpb24uanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuY29uc3Qgc3BhbnN0YXR1cyA9IHJlcXVpcmUoJy4vc3BhbnN0YXR1cy5qcycpO1xuXG5sZXQgZXJyb3JzSW5zdHJ1bWVudGVkID0gZmFsc2U7XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZ2xvYmFsIGVycm9ycyBhdXRvbWF0aWNhbGx5IHNldCB0aGUgYWN0aXZlIHNwYW4gc3RhdHVzLlxuICovXG5mdW5jdGlvbiByZWdpc3RlclNwYW5FcnJvckluc3RydW1lbnRhdGlvbigpIHtcbiAgaWYgKGVycm9yc0luc3RydW1lbnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVycm9yc0luc3RydW1lbnRlZCA9IHRydWU7XG4gIGdsb2JhbEVycm9yLmFkZEdsb2JhbEVycm9ySW5zdHJ1bWVudGF0aW9uSGFuZGxlcihlcnJvckNhbGxiYWNrKTtcbiAgZ2xvYmFsVW5oYW5kbGVkUmVqZWN0aW9uLmFkZEdsb2JhbFVuaGFuZGxlZFJlamVjdGlvbkluc3RydW1lbnRhdGlvbkhhbmRsZXIoZXJyb3JDYWxsYmFjayk7XG59XG5cbi8qKlxuICogSWYgYW4gZXJyb3Igb3IgdW5oYW5kbGVkIHByb21pc2Ugb2NjdXJzLCB3ZSBtYXJrIHRoZSBhY3RpdmUgcm9vdCBzcGFuIGFzIGZhaWxlZFxuICovXG5mdW5jdGlvbiBlcnJvckNhbGxiYWNrKCkge1xuICBjb25zdCBhY3RpdmVTcGFuID0gc3BhblV0aWxzLmdldEFjdGl2ZVNwYW4oKTtcbiAgY29uc3Qgcm9vdFNwYW4gPSBhY3RpdmVTcGFuICYmIHNwYW5VdGlscy5nZXRSb290U3BhbihhY3RpdmVTcGFuKTtcbiAgaWYgKHJvb3RTcGFuKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9ICdpbnRlcm5hbF9lcnJvcic7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLmxvZyhgW1RyYWNpbmddIFJvb3Qgc3BhbjogJHttZXNzYWdlfSAtPiBHbG9iYWwgZXJyb3Igb2NjdXJyZWRgKTtcbiAgICByb290U3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBzcGFuc3RhdHVzLlNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlIH0pO1xuICB9XG59XG5cbi8vIFRoZSBmdW5jdGlvbiBuYW1lIHdpbGwgYmUgbG9zdCB3aGVuIGJ1bmRsaW5nIGJ1dCB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gaWRlbnRpZnkgdGhpcyBsaXN0ZW5lciBsYXRlciB0byBtYWludGFpbiB0aGVcbi8vIG5vZGUuanMgZGVmYXVsdCBleGl0IGJlaGF2aW91clxuZXJyb3JDYWxsYmFjay50YWcgPSAnc2VudHJ5X3RyYWNpbmdFcnJvckNhbGxiYWNrJztcblxuZXhwb3J0cy5yZWdpc3RlclNwYW5FcnJvckluc3RydW1lbnRhdGlvbiA9IHJlZ2lzdGVyU3BhbkVycm9ySW5zdHJ1bWVudGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/errors.js\n')},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/idleSpan.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\nconst hasSpansEnabled = __webpack_require__(/*! ../utils/hasSpansEnabled.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/hasSpansEnabled.js\");\nconst spanOnScope = __webpack_require__(/*! ../utils/spanOnScope.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanOnScope.js\");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanUtils.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst time = __webpack_require__(/*! ../utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst dynamicSamplingContext = __webpack_require__(/*! ./dynamicSamplingContext.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js\");\nconst sentryNonRecordingSpan = __webpack_require__(/*! ./sentryNonRecordingSpan.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sentryNonRecordingSpan.js\");\nconst spanstatus = __webpack_require__(/*! ./spanstatus.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js\");\nconst trace = __webpack_require__(/*! ./trace.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/trace.js\");\n\nconst TRACING_DEFAULTS = {\n  idleTimeout: 1000,\n  finalTimeout: 30000,\n  childSpanTimeout: 15000,\n};\n\nconst FINISH_REASON_HEARTBEAT_FAILED = 'heartbeatFailed';\nconst FINISH_REASON_IDLE_TIMEOUT = 'idleTimeout';\nconst FINISH_REASON_FINAL_TIMEOUT = 'finalTimeout';\nconst FINISH_REASON_EXTERNAL_FINISH = 'externalFinish';\n\n/**\n * An idle span is a span that automatically finishes. It does this by tracking child spans as activities.\n * An idle span is always the active span.\n */\nfunction startIdleSpan(startSpanOptions, options = {}) {\n  // Activities store a list of active spans\n  const activities = new Map();\n\n  // We should not use heartbeat if we finished a span\n  let _finished = false;\n\n  // Timer that tracks idleTimeout\n  let _idleTimeoutID;\n\n  // The reason why the span was finished\n  let _finishReason = FINISH_REASON_EXTERNAL_FINISH;\n\n  let _autoFinishAllowed = !options.disableAutoFinish;\n\n  const _cleanupHooks = [];\n\n  const {\n    idleTimeout = TRACING_DEFAULTS.idleTimeout,\n    finalTimeout = TRACING_DEFAULTS.finalTimeout,\n    childSpanTimeout = TRACING_DEFAULTS.childSpanTimeout,\n    beforeSpanEnd,\n  } = options;\n\n  const client = currentScopes.getClient();\n\n  if (!client || !hasSpansEnabled.hasSpansEnabled()) {\n    const span = new sentryNonRecordingSpan.SentryNonRecordingSpan();\n\n    const dsc = {\n      sample_rate: '0',\n      sampled: 'false',\n      ...dynamicSamplingContext.getDynamicSamplingContextFromSpan(span),\n    } ;\n    dynamicSamplingContext.freezeDscOnSpan(span, dsc);\n\n    return span;\n  }\n\n  const scope = currentScopes.getCurrentScope();\n  const previousActiveSpan = spanUtils.getActiveSpan();\n  const span = _startIdleSpan(startSpanOptions);\n\n  // We patch span.end to ensure we can run some things before the span is ended\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  span.end = new Proxy(span.end, {\n    apply(target, thisArg, args) {\n      if (beforeSpanEnd) {\n        beforeSpanEnd(span);\n      }\n\n      // If the span is non-recording, nothing more to do here...\n      // This is the case if tracing is enabled but this specific span was not sampled\n      if (thisArg instanceof sentryNonRecordingSpan.SentryNonRecordingSpan) {\n        return;\n      }\n\n      // Just ensuring that this keeps working, even if we ever have more arguments here\n      const [definedEndTimestamp, ...rest] = args;\n      const timestamp = definedEndTimestamp || time.timestampInSeconds();\n      const spanEndTimestamp = spanUtils.spanTimeInputToSeconds(timestamp);\n\n      // Ensure we end with the last span timestamp, if possible\n      const spans = spanUtils.getSpanDescendants(span).filter(child => child !== span);\n\n      // If we have no spans, we just end, nothing else to do here\n      if (!spans.length) {\n        onIdleSpanEnded(spanEndTimestamp);\n        return Reflect.apply(target, thisArg, [spanEndTimestamp, ...rest]);\n      }\n\n      const childEndTimestamps = spans\n        .map(span => spanUtils.spanToJSON(span).timestamp)\n        .filter(timestamp => !!timestamp) ;\n      const latestSpanEndTimestamp = childEndTimestamps.length ? Math.max(...childEndTimestamps) : undefined;\n\n      // In reality this should always exist here, but type-wise it may be undefined...\n      const spanStartTimestamp = spanUtils.spanToJSON(span).start_timestamp;\n\n      // The final endTimestamp should:\n      // * Never be before the span start timestamp\n      // * Be the latestSpanEndTimestamp, if there is one, and it is smaller than the passed span end timestamp\n      // * Otherwise be the passed end timestamp\n      // Final timestamp can never be after finalTimeout\n      const endTimestamp = Math.min(\n        spanStartTimestamp ? spanStartTimestamp + finalTimeout / 1000 : Infinity,\n        Math.max(spanStartTimestamp || -Infinity, Math.min(spanEndTimestamp, latestSpanEndTimestamp || Infinity)),\n      );\n\n      onIdleSpanEnded(endTimestamp);\n      return Reflect.apply(target, thisArg, [endTimestamp, ...rest]);\n    },\n  });\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   */\n  function _cancelIdleTimeout() {\n    if (_idleTimeoutID) {\n      clearTimeout(_idleTimeoutID);\n      _idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  function _restartIdleTimeout(endTimestamp) {\n    _cancelIdleTimeout();\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && activities.size === 0 && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_IDLE_TIMEOUT;\n        span.end(endTimestamp);\n      }\n    }, idleTimeout);\n  }\n\n  /**\n   * Restarts child span timeout, if there is none running it will start one.\n   */\n  function _restartChildSpanTimeout(endTimestamp) {\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_HEARTBEAT_FAILED;\n        span.end(endTimestamp);\n      }\n    }, childSpanTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  function _pushActivity(spanId) {\n    _cancelIdleTimeout();\n    activities.set(spanId, true);\n\n    const endTimestamp = time.timestampInSeconds();\n    // We need to add the timeout here to have the real endtimestamp of the idle span\n    // Remember timestampInSeconds is in seconds, timeout is in ms\n    _restartChildSpanTimeout(endTimestamp + childSpanTimeout / 1000);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  function _popActivity(spanId) {\n    if (activities.has(spanId)) {\n      activities.delete(spanId);\n    }\n\n    if (activities.size === 0) {\n      const endTimestamp = time.timestampInSeconds();\n      // We need to add the timeout here to have the real endtimestamp of the idle span\n      // Remember timestampInSeconds is in seconds, timeout is in ms\n      _restartIdleTimeout(endTimestamp + idleTimeout / 1000);\n    }\n  }\n\n  function onIdleSpanEnded(endTimestamp) {\n    _finished = true;\n    activities.clear();\n\n    _cleanupHooks.forEach(cleanup => cleanup());\n\n    spanOnScope._setSpanForScope(scope, previousActiveSpan);\n\n    const spanJSON = spanUtils.spanToJSON(span);\n\n    const { start_timestamp: startTimestamp } = spanJSON;\n    // This should never happen, but to make TS happy...\n    if (!startTimestamp) {\n      return;\n    }\n\n    const attributes = spanJSON.data;\n    if (!attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON]) {\n      span.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, _finishReason);\n    }\n\n    logger.logger.log(`[Tracing] Idle span \"${spanJSON.op}\" finished`);\n\n    const childSpans = spanUtils.getSpanDescendants(span).filter(child => child !== span);\n\n    let discardedSpans = 0;\n    childSpans.forEach(childSpan => {\n      // We cancel all pending spans with status \"cancelled\" to indicate the idle span was finished early\n      if (childSpan.isRecording()) {\n        childSpan.setStatus({ code: spanstatus.SPAN_STATUS_ERROR, message: 'cancelled' });\n        childSpan.end(endTimestamp);\n        debugBuild.DEBUG_BUILD &&\n          logger.logger.log('[Tracing] Cancelling span since span ended early', JSON.stringify(childSpan, undefined, 2));\n      }\n\n      const childSpanJSON = spanUtils.spanToJSON(childSpan);\n      const { timestamp: childEndTimestamp = 0, start_timestamp: childStartTimestamp = 0 } = childSpanJSON;\n\n      const spanStartedBeforeIdleSpanEnd = childStartTimestamp <= endTimestamp;\n\n      // Add a delta with idle timeout so that we prevent false positives\n      const timeoutWithMarginOfError = (finalTimeout + idleTimeout) / 1000;\n      const spanEndedBeforeFinalTimeout = childEndTimestamp - childStartTimestamp <= timeoutWithMarginOfError;\n\n      if (debugBuild.DEBUG_BUILD) {\n        const stringifiedSpan = JSON.stringify(childSpan, undefined, 2);\n        if (!spanStartedBeforeIdleSpanEnd) {\n          logger.logger.log('[Tracing] Discarding span since it happened after idle span was finished', stringifiedSpan);\n        } else if (!spanEndedBeforeFinalTimeout) {\n          logger.logger.log('[Tracing] Discarding span since it finished after idle span final timeout', stringifiedSpan);\n        }\n      }\n\n      if (!spanEndedBeforeFinalTimeout || !spanStartedBeforeIdleSpanEnd) {\n        spanUtils.removeChildSpanFromSpan(span, childSpan);\n        discardedSpans++;\n      }\n    });\n\n    if (discardedSpans > 0) {\n      span.setAttribute('sentry.idle_span_discarded_spans', discardedSpans);\n    }\n  }\n\n  _cleanupHooks.push(\n    client.on('spanStart', startedSpan => {\n      // If we already finished the idle span,\n      // or if this is the idle span itself being started,\n      // or if the started span has already been closed,\n      // we don't care about it for activity\n      if (_finished || startedSpan === span || !!spanUtils.spanToJSON(startedSpan).timestamp) {\n        return;\n      }\n\n      const allSpans = spanUtils.getSpanDescendants(span);\n\n      // If the span that was just started is a child of the idle span, we should track it\n      if (allSpans.includes(startedSpan)) {\n        _pushActivity(startedSpan.spanContext().spanId);\n      }\n    }),\n  );\n\n  _cleanupHooks.push(\n    client.on('spanEnd', endedSpan => {\n      if (_finished) {\n        return;\n      }\n\n      _popActivity(endedSpan.spanContext().spanId);\n    }),\n  );\n\n  _cleanupHooks.push(\n    client.on('idleSpanEnableAutoFinish', spanToAllowAutoFinish => {\n      if (spanToAllowAutoFinish === span) {\n        _autoFinishAllowed = true;\n        _restartIdleTimeout();\n\n        if (activities.size) {\n          _restartChildSpanTimeout();\n        }\n      }\n    }),\n  );\n\n  // We only start the initial idle timeout if we are not delaying the auto finish\n  if (!options.disableAutoFinish) {\n    _restartIdleTimeout();\n  }\n\n  setTimeout(() => {\n    if (!_finished) {\n      span.setStatus({ code: spanstatus.SPAN_STATUS_ERROR, message: 'deadline_exceeded' });\n      _finishReason = FINISH_REASON_FINAL_TIMEOUT;\n      span.end();\n    }\n  }, finalTimeout);\n\n  return span;\n}\n\nfunction _startIdleSpan(options) {\n  const span = trace.startInactiveSpan(options);\n\n  spanOnScope._setSpanForScope(currentScopes.getCurrentScope(), span);\n\n  debugBuild.DEBUG_BUILD && logger.logger.log('[Tracing] Started span is an idle span');\n\n  return span;\n}\n\nexports.TRACING_DEFAULTS = TRACING_DEFAULTS;\nexports.startIdleSpan = startIdleSpan;\n//# sourceMappingURL=idleSpan.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYWNpbmcvaWRsZVNwYW4uanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsc0JBQXNCLG1CQUFPLENBQUMsNEhBQXFCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLHdIQUFtQjtBQUM5QywyQkFBMkIsbUJBQU8sQ0FBQyxzSUFBMEI7QUFDN0Qsd0JBQXdCLG1CQUFPLENBQUMsNElBQTZCO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLG9JQUF5QjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyxnSUFBdUI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLHNJQUEwQjtBQUNqRCxhQUFhLG1CQUFPLENBQUMsa0lBQXdCO0FBQzdDLCtCQUErQixtQkFBTyxDQUFDLHFKQUE2QjtBQUNwRSwrQkFBK0IsbUJBQU8sQ0FBQyxxSkFBNkI7QUFDcEUsbUJBQW1CLG1CQUFPLENBQUMsNkhBQWlCO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQyxtSEFBWTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLFlBQVk7O0FBRTFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBEQUEwRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsNkVBQTZFOztBQUUzRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsa0VBQWtFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFx0cmFjaW5nXFxpZGxlU3Bhbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgY3VycmVudFNjb3BlcyA9IHJlcXVpcmUoJy4uL2N1cnJlbnRTY29wZXMuanMnKTtcbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3Qgc2VtYW50aWNBdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi4vc2VtYW50aWNBdHRyaWJ1dGVzLmpzJyk7XG5jb25zdCBoYXNTcGFuc0VuYWJsZWQgPSByZXF1aXJlKCcuLi91dGlscy9oYXNTcGFuc0VuYWJsZWQuanMnKTtcbmNvbnN0IHNwYW5PblNjb3BlID0gcmVxdWlyZSgnLi4vdXRpbHMvc3Bhbk9uU2NvcGUuanMnKTtcbmNvbnN0IHNwYW5VdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3NwYW5VdGlscy5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCB0aW1lID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvdGltZS5qcycpO1xuY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IHJlcXVpcmUoJy4vZHluYW1pY1NhbXBsaW5nQ29udGV4dC5qcycpO1xuY29uc3Qgc2VudHJ5Tm9uUmVjb3JkaW5nU3BhbiA9IHJlcXVpcmUoJy4vc2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbi5qcycpO1xuY29uc3Qgc3BhbnN0YXR1cyA9IHJlcXVpcmUoJy4vc3BhbnN0YXR1cy5qcycpO1xuY29uc3QgdHJhY2UgPSByZXF1aXJlKCcuL3RyYWNlLmpzJyk7XG5cbmNvbnN0IFRSQUNJTkdfREVGQVVMVFMgPSB7XG4gIGlkbGVUaW1lb3V0OiAxMDAwLFxuICBmaW5hbFRpbWVvdXQ6IDMwMDAwLFxuICBjaGlsZFNwYW5UaW1lb3V0OiAxNTAwMCxcbn07XG5cbmNvbnN0IEZJTklTSF9SRUFTT05fSEVBUlRCRUFUX0ZBSUxFRCA9ICdoZWFydGJlYXRGYWlsZWQnO1xuY29uc3QgRklOSVNIX1JFQVNPTl9JRExFX1RJTUVPVVQgPSAnaWRsZVRpbWVvdXQnO1xuY29uc3QgRklOSVNIX1JFQVNPTl9GSU5BTF9USU1FT1VUID0gJ2ZpbmFsVGltZW91dCc7XG5jb25zdCBGSU5JU0hfUkVBU09OX0VYVEVSTkFMX0ZJTklTSCA9ICdleHRlcm5hbEZpbmlzaCc7XG5cbi8qKlxuICogQW4gaWRsZSBzcGFuIGlzIGEgc3BhbiB0aGF0IGF1dG9tYXRpY2FsbHkgZmluaXNoZXMuIEl0IGRvZXMgdGhpcyBieSB0cmFja2luZyBjaGlsZCBzcGFucyBhcyBhY3Rpdml0aWVzLlxuICogQW4gaWRsZSBzcGFuIGlzIGFsd2F5cyB0aGUgYWN0aXZlIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0SWRsZVNwYW4oc3RhcnRTcGFuT3B0aW9ucywgb3B0aW9ucyA9IHt9KSB7XG4gIC8vIEFjdGl2aXRpZXMgc3RvcmUgYSBsaXN0IG9mIGFjdGl2ZSBzcGFuc1xuICBjb25zdCBhY3Rpdml0aWVzID0gbmV3IE1hcCgpO1xuXG4gIC8vIFdlIHNob3VsZCBub3QgdXNlIGhlYXJ0YmVhdCBpZiB3ZSBmaW5pc2hlZCBhIHNwYW5cbiAgbGV0IF9maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRpbWVyIHRoYXQgdHJhY2tzIGlkbGVUaW1lb3V0XG4gIGxldCBfaWRsZVRpbWVvdXRJRDtcblxuICAvLyBUaGUgcmVhc29uIHdoeSB0aGUgc3BhbiB3YXMgZmluaXNoZWRcbiAgbGV0IF9maW5pc2hSZWFzb24gPSBGSU5JU0hfUkVBU09OX0VYVEVSTkFMX0ZJTklTSDtcblxuICBsZXQgX2F1dG9GaW5pc2hBbGxvd2VkID0gIW9wdGlvbnMuZGlzYWJsZUF1dG9GaW5pc2g7XG5cbiAgY29uc3QgX2NsZWFudXBIb29rcyA9IFtdO1xuXG4gIGNvbnN0IHtcbiAgICBpZGxlVGltZW91dCA9IFRSQUNJTkdfREVGQVVMVFMuaWRsZVRpbWVvdXQsXG4gICAgZmluYWxUaW1lb3V0ID0gVFJBQ0lOR19ERUZBVUxUUy5maW5hbFRpbWVvdXQsXG4gICAgY2hpbGRTcGFuVGltZW91dCA9IFRSQUNJTkdfREVGQVVMVFMuY2hpbGRTcGFuVGltZW91dCxcbiAgICBiZWZvcmVTcGFuRW5kLFxuICB9ID0gb3B0aW9ucztcblxuICBjb25zdCBjbGllbnQgPSBjdXJyZW50U2NvcGVzLmdldENsaWVudCgpO1xuXG4gIGlmICghY2xpZW50IHx8ICFoYXNTcGFuc0VuYWJsZWQuaGFzU3BhbnNFbmFibGVkKCkpIHtcbiAgICBjb25zdCBzcGFuID0gbmV3IHNlbnRyeU5vblJlY29yZGluZ1NwYW4uU2VudHJ5Tm9uUmVjb3JkaW5nU3BhbigpO1xuXG4gICAgY29uc3QgZHNjID0ge1xuICAgICAgc2FtcGxlX3JhdGU6ICcwJyxcbiAgICAgIHNhbXBsZWQ6ICdmYWxzZScsXG4gICAgICAuLi5keW5hbWljU2FtcGxpbmdDb250ZXh0LmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuKSxcbiAgICB9IDtcbiAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0LmZyZWV6ZURzY09uU3BhbihzcGFuLCBkc2MpO1xuXG4gICAgcmV0dXJuIHNwYW47XG4gIH1cblxuICBjb25zdCBzY29wZSA9IGN1cnJlbnRTY29wZXMuZ2V0Q3VycmVudFNjb3BlKCk7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlU3BhbiA9IHNwYW5VdGlscy5nZXRBY3RpdmVTcGFuKCk7XG4gIGNvbnN0IHNwYW4gPSBfc3RhcnRJZGxlU3BhbihzdGFydFNwYW5PcHRpb25zKTtcblxuICAvLyBXZSBwYXRjaCBzcGFuLmVuZCB0byBlbnN1cmUgd2UgY2FuIHJ1biBzb21lIHRoaW5ncyBiZWZvcmUgdGhlIHNwYW4gaXMgZW5kZWRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICBzcGFuLmVuZCA9IG5ldyBQcm94eShzcGFuLmVuZCwge1xuICAgIGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJncykge1xuICAgICAgaWYgKGJlZm9yZVNwYW5FbmQpIHtcbiAgICAgICAgYmVmb3JlU3BhbkVuZChzcGFuKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHNwYW4gaXMgbm9uLXJlY29yZGluZywgbm90aGluZyBtb3JlIHRvIGRvIGhlcmUuLi5cbiAgICAgIC8vIFRoaXMgaXMgdGhlIGNhc2UgaWYgdHJhY2luZyBpcyBlbmFibGVkIGJ1dCB0aGlzIHNwZWNpZmljIHNwYW4gd2FzIG5vdCBzYW1wbGVkXG4gICAgICBpZiAodGhpc0FyZyBpbnN0YW5jZW9mIHNlbnRyeU5vblJlY29yZGluZ1NwYW4uU2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEp1c3QgZW5zdXJpbmcgdGhhdCB0aGlzIGtlZXBzIHdvcmtpbmcsIGV2ZW4gaWYgd2UgZXZlciBoYXZlIG1vcmUgYXJndW1lbnRzIGhlcmVcbiAgICAgIGNvbnN0IFtkZWZpbmVkRW5kVGltZXN0YW1wLCAuLi5yZXN0XSA9IGFyZ3M7XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBkZWZpbmVkRW5kVGltZXN0YW1wIHx8IHRpbWUudGltZXN0YW1wSW5TZWNvbmRzKCk7XG4gICAgICBjb25zdCBzcGFuRW5kVGltZXN0YW1wID0gc3BhblV0aWxzLnNwYW5UaW1lSW5wdXRUb1NlY29uZHModGltZXN0YW1wKTtcblxuICAgICAgLy8gRW5zdXJlIHdlIGVuZCB3aXRoIHRoZSBsYXN0IHNwYW4gdGltZXN0YW1wLCBpZiBwb3NzaWJsZVxuICAgICAgY29uc3Qgc3BhbnMgPSBzcGFuVXRpbHMuZ2V0U3BhbkRlc2NlbmRhbnRzKHNwYW4pLmZpbHRlcihjaGlsZCA9PiBjaGlsZCAhPT0gc3Bhbik7XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgbm8gc3BhbnMsIHdlIGp1c3QgZW5kLCBub3RoaW5nIGVsc2UgdG8gZG8gaGVyZVxuICAgICAgaWYgKCFzcGFucy5sZW5ndGgpIHtcbiAgICAgICAgb25JZGxlU3BhbkVuZGVkKHNwYW5FbmRUaW1lc3RhbXApO1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIFtzcGFuRW5kVGltZXN0YW1wLCAuLi5yZXN0XSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkRW5kVGltZXN0YW1wcyA9IHNwYW5zXG4gICAgICAgIC5tYXAoc3BhbiA9PiBzcGFuVXRpbHMuc3BhblRvSlNPTihzcGFuKS50aW1lc3RhbXApXG4gICAgICAgIC5maWx0ZXIodGltZXN0YW1wID0+ICEhdGltZXN0YW1wKSA7XG4gICAgICBjb25zdCBsYXRlc3RTcGFuRW5kVGltZXN0YW1wID0gY2hpbGRFbmRUaW1lc3RhbXBzLmxlbmd0aCA/IE1hdGgubWF4KC4uLmNoaWxkRW5kVGltZXN0YW1wcykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIEluIHJlYWxpdHkgdGhpcyBzaG91bGQgYWx3YXlzIGV4aXN0IGhlcmUsIGJ1dCB0eXBlLXdpc2UgaXQgbWF5IGJlIHVuZGVmaW5lZC4uLlxuICAgICAgY29uc3Qgc3BhblN0YXJ0VGltZXN0YW1wID0gc3BhblV0aWxzLnNwYW5Ub0pTT04oc3Bhbikuc3RhcnRfdGltZXN0YW1wO1xuXG4gICAgICAvLyBUaGUgZmluYWwgZW5kVGltZXN0YW1wIHNob3VsZDpcbiAgICAgIC8vICogTmV2ZXIgYmUgYmVmb3JlIHRoZSBzcGFuIHN0YXJ0IHRpbWVzdGFtcFxuICAgICAgLy8gKiBCZSB0aGUgbGF0ZXN0U3BhbkVuZFRpbWVzdGFtcCwgaWYgdGhlcmUgaXMgb25lLCBhbmQgaXQgaXMgc21hbGxlciB0aGFuIHRoZSBwYXNzZWQgc3BhbiBlbmQgdGltZXN0YW1wXG4gICAgICAvLyAqIE90aGVyd2lzZSBiZSB0aGUgcGFzc2VkIGVuZCB0aW1lc3RhbXBcbiAgICAgIC8vIEZpbmFsIHRpbWVzdGFtcCBjYW4gbmV2ZXIgYmUgYWZ0ZXIgZmluYWxUaW1lb3V0XG4gICAgICBjb25zdCBlbmRUaW1lc3RhbXAgPSBNYXRoLm1pbihcbiAgICAgICAgc3BhblN0YXJ0VGltZXN0YW1wID8gc3BhblN0YXJ0VGltZXN0YW1wICsgZmluYWxUaW1lb3V0IC8gMTAwMCA6IEluZmluaXR5LFxuICAgICAgICBNYXRoLm1heChzcGFuU3RhcnRUaW1lc3RhbXAgfHwgLUluZmluaXR5LCBNYXRoLm1pbihzcGFuRW5kVGltZXN0YW1wLCBsYXRlc3RTcGFuRW5kVGltZXN0YW1wIHx8IEluZmluaXR5KSksXG4gICAgICApO1xuXG4gICAgICBvbklkbGVTcGFuRW5kZWQoZW5kVGltZXN0YW1wKTtcbiAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgW2VuZFRpbWVzdGFtcCwgLi4ucmVzdF0pO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDYW5jZWxzIHRoZSBleGlzdGluZyBpZGxlIHRpbWVvdXQsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9jYW5jZWxJZGxlVGltZW91dCgpIHtcbiAgICBpZiAoX2lkbGVUaW1lb3V0SUQpIHtcbiAgICAgIGNsZWFyVGltZW91dChfaWRsZVRpbWVvdXRJRCk7XG4gICAgICBfaWRsZVRpbWVvdXRJRCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzdGFydHMgaWRsZSB0aW1lb3V0LCBpZiB0aGVyZSBpcyBubyBydW5uaW5nIGlkbGUgdGltZW91dCBpdCB3aWxsIHN0YXJ0IG9uZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9yZXN0YXJ0SWRsZVRpbWVvdXQoZW5kVGltZXN0YW1wKSB7XG4gICAgX2NhbmNlbElkbGVUaW1lb3V0KCk7XG4gICAgX2lkbGVUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghX2ZpbmlzaGVkICYmIGFjdGl2aXRpZXMuc2l6ZSA9PT0gMCAmJiBfYXV0b0ZpbmlzaEFsbG93ZWQpIHtcbiAgICAgICAgX2ZpbmlzaFJlYXNvbiA9IEZJTklTSF9SRUFTT05fSURMRV9USU1FT1VUO1xuICAgICAgICBzcGFuLmVuZChlbmRUaW1lc3RhbXApO1xuICAgICAgfVxuICAgIH0sIGlkbGVUaW1lb3V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0YXJ0cyBjaGlsZCBzcGFuIHRpbWVvdXQsIGlmIHRoZXJlIGlzIG5vbmUgcnVubmluZyBpdCB3aWxsIHN0YXJ0IG9uZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9yZXN0YXJ0Q2hpbGRTcGFuVGltZW91dChlbmRUaW1lc3RhbXApIHtcbiAgICBfaWRsZVRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFfZmluaXNoZWQgJiYgX2F1dG9GaW5pc2hBbGxvd2VkKSB7XG4gICAgICAgIF9maW5pc2hSZWFzb24gPSBGSU5JU0hfUkVBU09OX0hFQVJUQkVBVF9GQUlMRUQ7XG4gICAgICAgIHNwYW4uZW5kKGVuZFRpbWVzdGFtcCk7XG4gICAgICB9XG4gICAgfSwgY2hpbGRTcGFuVGltZW91dCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdHJhY2tpbmcgYSBzcGVjaWZpYyBhY3Rpdml0eS5cbiAgICogQHBhcmFtIHNwYW5JZCBUaGUgc3BhbiBpZCB0aGF0IHJlcHJlc2VudHMgdGhlIGFjdGl2aXR5XG4gICAqL1xuICBmdW5jdGlvbiBfcHVzaEFjdGl2aXR5KHNwYW5JZCkge1xuICAgIF9jYW5jZWxJZGxlVGltZW91dCgpO1xuICAgIGFjdGl2aXRpZXMuc2V0KHNwYW5JZCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBlbmRUaW1lc3RhbXAgPSB0aW1lLnRpbWVzdGFtcEluU2Vjb25kcygpO1xuICAgIC8vIFdlIG5lZWQgdG8gYWRkIHRoZSB0aW1lb3V0IGhlcmUgdG8gaGF2ZSB0aGUgcmVhbCBlbmR0aW1lc3RhbXAgb2YgdGhlIGlkbGUgc3BhblxuICAgIC8vIFJlbWVtYmVyIHRpbWVzdGFtcEluU2Vjb25kcyBpcyBpbiBzZWNvbmRzLCB0aW1lb3V0IGlzIGluIG1zXG4gICAgX3Jlc3RhcnRDaGlsZFNwYW5UaW1lb3V0KGVuZFRpbWVzdGFtcCArIGNoaWxkU3BhblRpbWVvdXQgLyAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gYWN0aXZpdHkgZnJvbSB1c2FnZVxuICAgKiBAcGFyYW0gc3BhbklkIFRoZSBzcGFuIGlkIHRoYXQgcmVwcmVzZW50cyB0aGUgYWN0aXZpdHlcbiAgICovXG4gIGZ1bmN0aW9uIF9wb3BBY3Rpdml0eShzcGFuSWQpIHtcbiAgICBpZiAoYWN0aXZpdGllcy5oYXMoc3BhbklkKSkge1xuICAgICAgYWN0aXZpdGllcy5kZWxldGUoc3BhbklkKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZpdGllcy5zaXplID09PSAwKSB7XG4gICAgICBjb25zdCBlbmRUaW1lc3RhbXAgPSB0aW1lLnRpbWVzdGFtcEluU2Vjb25kcygpO1xuICAgICAgLy8gV2UgbmVlZCB0byBhZGQgdGhlIHRpbWVvdXQgaGVyZSB0byBoYXZlIHRoZSByZWFsIGVuZHRpbWVzdGFtcCBvZiB0aGUgaWRsZSBzcGFuXG4gICAgICAvLyBSZW1lbWJlciB0aW1lc3RhbXBJblNlY29uZHMgaXMgaW4gc2Vjb25kcywgdGltZW91dCBpcyBpbiBtc1xuICAgICAgX3Jlc3RhcnRJZGxlVGltZW91dChlbmRUaW1lc3RhbXAgKyBpZGxlVGltZW91dCAvIDEwMDApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSWRsZVNwYW5FbmRlZChlbmRUaW1lc3RhbXApIHtcbiAgICBfZmluaXNoZWQgPSB0cnVlO1xuICAgIGFjdGl2aXRpZXMuY2xlYXIoKTtcblxuICAgIF9jbGVhbnVwSG9va3MuZm9yRWFjaChjbGVhbnVwID0+IGNsZWFudXAoKSk7XG5cbiAgICBzcGFuT25TY29wZS5fc2V0U3BhbkZvclNjb3BlKHNjb3BlLCBwcmV2aW91c0FjdGl2ZVNwYW4pO1xuXG4gICAgY29uc3Qgc3BhbkpTT04gPSBzcGFuVXRpbHMuc3BhblRvSlNPTihzcGFuKTtcblxuICAgIGNvbnN0IHsgc3RhcnRfdGltZXN0YW1wOiBzdGFydFRpbWVzdGFtcCB9ID0gc3BhbkpTT047XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgdG8gbWFrZSBUUyBoYXBweS4uLlxuICAgIGlmICghc3RhcnRUaW1lc3RhbXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gc3BhbkpTT04uZGF0YTtcbiAgICBpZiAoIWF0dHJpYnV0ZXNbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfSURMRV9TUEFOX0ZJTklTSF9SRUFTT05dKSB7XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZShzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9JRExFX1NQQU5fRklOSVNIX1JFQVNPTiwgX2ZpbmlzaFJlYXNvbik7XG4gICAgfVxuXG4gICAgbG9nZ2VyLmxvZ2dlci5sb2coYFtUcmFjaW5nXSBJZGxlIHNwYW4gXCIke3NwYW5KU09OLm9wfVwiIGZpbmlzaGVkYCk7XG5cbiAgICBjb25zdCBjaGlsZFNwYW5zID0gc3BhblV0aWxzLmdldFNwYW5EZXNjZW5kYW50cyhzcGFuKS5maWx0ZXIoY2hpbGQgPT4gY2hpbGQgIT09IHNwYW4pO1xuXG4gICAgbGV0IGRpc2NhcmRlZFNwYW5zID0gMDtcbiAgICBjaGlsZFNwYW5zLmZvckVhY2goY2hpbGRTcGFuID0+IHtcbiAgICAgIC8vIFdlIGNhbmNlbCBhbGwgcGVuZGluZyBzcGFucyB3aXRoIHN0YXR1cyBcImNhbmNlbGxlZFwiIHRvIGluZGljYXRlIHRoZSBpZGxlIHNwYW4gd2FzIGZpbmlzaGVkIGVhcmx5XG4gICAgICBpZiAoY2hpbGRTcGFuLmlzUmVjb3JkaW5nKCkpIHtcbiAgICAgICAgY2hpbGRTcGFuLnNldFN0YXR1cyh7IGNvZGU6IHNwYW5zdGF0dXMuU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICdjYW5jZWxsZWQnIH0pO1xuICAgICAgICBjaGlsZFNwYW4uZW5kKGVuZFRpbWVzdGFtcCk7XG4gICAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiZcbiAgICAgICAgICBsb2dnZXIubG9nZ2VyLmxvZygnW1RyYWNpbmddIENhbmNlbGxpbmcgc3BhbiBzaW5jZSBzcGFuIGVuZGVkIGVhcmx5JywgSlNPTi5zdHJpbmdpZnkoY2hpbGRTcGFuLCB1bmRlZmluZWQsIDIpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hpbGRTcGFuSlNPTiA9IHNwYW5VdGlscy5zcGFuVG9KU09OKGNoaWxkU3Bhbik7XG4gICAgICBjb25zdCB7IHRpbWVzdGFtcDogY2hpbGRFbmRUaW1lc3RhbXAgPSAwLCBzdGFydF90aW1lc3RhbXA6IGNoaWxkU3RhcnRUaW1lc3RhbXAgPSAwIH0gPSBjaGlsZFNwYW5KU09OO1xuXG4gICAgICBjb25zdCBzcGFuU3RhcnRlZEJlZm9yZUlkbGVTcGFuRW5kID0gY2hpbGRTdGFydFRpbWVzdGFtcCA8PSBlbmRUaW1lc3RhbXA7XG5cbiAgICAgIC8vIEFkZCBhIGRlbHRhIHdpdGggaWRsZSB0aW1lb3V0IHNvIHRoYXQgd2UgcHJldmVudCBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgIGNvbnN0IHRpbWVvdXRXaXRoTWFyZ2luT2ZFcnJvciA9IChmaW5hbFRpbWVvdXQgKyBpZGxlVGltZW91dCkgLyAxMDAwO1xuICAgICAgY29uc3Qgc3BhbkVuZGVkQmVmb3JlRmluYWxUaW1lb3V0ID0gY2hpbGRFbmRUaW1lc3RhbXAgLSBjaGlsZFN0YXJ0VGltZXN0YW1wIDw9IHRpbWVvdXRXaXRoTWFyZ2luT2ZFcnJvcjtcblxuICAgICAgaWYgKGRlYnVnQnVpbGQuREVCVUdfQlVJTEQpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRTcGFuID0gSlNPTi5zdHJpbmdpZnkoY2hpbGRTcGFuLCB1bmRlZmluZWQsIDIpO1xuICAgICAgICBpZiAoIXNwYW5TdGFydGVkQmVmb3JlSWRsZVNwYW5FbmQpIHtcbiAgICAgICAgICBsb2dnZXIubG9nZ2VyLmxvZygnW1RyYWNpbmddIERpc2NhcmRpbmcgc3BhbiBzaW5jZSBpdCBoYXBwZW5lZCBhZnRlciBpZGxlIHNwYW4gd2FzIGZpbmlzaGVkJywgc3RyaW5naWZpZWRTcGFuKTtcbiAgICAgICAgfSBlbHNlIGlmICghc3BhbkVuZGVkQmVmb3JlRmluYWxUaW1lb3V0KSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZ2dlci5sb2coJ1tUcmFjaW5nXSBEaXNjYXJkaW5nIHNwYW4gc2luY2UgaXQgZmluaXNoZWQgYWZ0ZXIgaWRsZSBzcGFuIGZpbmFsIHRpbWVvdXQnLCBzdHJpbmdpZmllZFNwYW4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc3BhbkVuZGVkQmVmb3JlRmluYWxUaW1lb3V0IHx8ICFzcGFuU3RhcnRlZEJlZm9yZUlkbGVTcGFuRW5kKSB7XG4gICAgICAgIHNwYW5VdGlscy5yZW1vdmVDaGlsZFNwYW5Gcm9tU3BhbihzcGFuLCBjaGlsZFNwYW4pO1xuICAgICAgICBkaXNjYXJkZWRTcGFucysrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGRpc2NhcmRlZFNwYW5zID4gMCkge1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoJ3NlbnRyeS5pZGxlX3NwYW5fZGlzY2FyZGVkX3NwYW5zJywgZGlzY2FyZGVkU3BhbnMpO1xuICAgIH1cbiAgfVxuXG4gIF9jbGVhbnVwSG9va3MucHVzaChcbiAgICBjbGllbnQub24oJ3NwYW5TdGFydCcsIHN0YXJ0ZWRTcGFuID0+IHtcbiAgICAgIC8vIElmIHdlIGFscmVhZHkgZmluaXNoZWQgdGhlIGlkbGUgc3BhbixcbiAgICAgIC8vIG9yIGlmIHRoaXMgaXMgdGhlIGlkbGUgc3BhbiBpdHNlbGYgYmVpbmcgc3RhcnRlZCxcbiAgICAgIC8vIG9yIGlmIHRoZSBzdGFydGVkIHNwYW4gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQsXG4gICAgICAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGl0IGZvciBhY3Rpdml0eVxuICAgICAgaWYgKF9maW5pc2hlZCB8fCBzdGFydGVkU3BhbiA9PT0gc3BhbiB8fCAhIXNwYW5VdGlscy5zcGFuVG9KU09OKHN0YXJ0ZWRTcGFuKS50aW1lc3RhbXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhbGxTcGFucyA9IHNwYW5VdGlscy5nZXRTcGFuRGVzY2VuZGFudHMoc3Bhbik7XG5cbiAgICAgIC8vIElmIHRoZSBzcGFuIHRoYXQgd2FzIGp1c3Qgc3RhcnRlZCBpcyBhIGNoaWxkIG9mIHRoZSBpZGxlIHNwYW4sIHdlIHNob3VsZCB0cmFjayBpdFxuICAgICAgaWYgKGFsbFNwYW5zLmluY2x1ZGVzKHN0YXJ0ZWRTcGFuKSkge1xuICAgICAgICBfcHVzaEFjdGl2aXR5KHN0YXJ0ZWRTcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgKTtcblxuICBfY2xlYW51cEhvb2tzLnB1c2goXG4gICAgY2xpZW50Lm9uKCdzcGFuRW5kJywgZW5kZWRTcGFuID0+IHtcbiAgICAgIGlmIChfZmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfcG9wQWN0aXZpdHkoZW5kZWRTcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkKTtcbiAgICB9KSxcbiAgKTtcblxuICBfY2xlYW51cEhvb2tzLnB1c2goXG4gICAgY2xpZW50Lm9uKCdpZGxlU3BhbkVuYWJsZUF1dG9GaW5pc2gnLCBzcGFuVG9BbGxvd0F1dG9GaW5pc2ggPT4ge1xuICAgICAgaWYgKHNwYW5Ub0FsbG93QXV0b0ZpbmlzaCA9PT0gc3Bhbikge1xuICAgICAgICBfYXV0b0ZpbmlzaEFsbG93ZWQgPSB0cnVlO1xuICAgICAgICBfcmVzdGFydElkbGVUaW1lb3V0KCk7XG5cbiAgICAgICAgaWYgKGFjdGl2aXRpZXMuc2l6ZSkge1xuICAgICAgICAgIF9yZXN0YXJ0Q2hpbGRTcGFuVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICk7XG5cbiAgLy8gV2Ugb25seSBzdGFydCB0aGUgaW5pdGlhbCBpZGxlIHRpbWVvdXQgaWYgd2UgYXJlIG5vdCBkZWxheWluZyB0aGUgYXV0byBmaW5pc2hcbiAgaWYgKCFvcHRpb25zLmRpc2FibGVBdXRvRmluaXNoKSB7XG4gICAgX3Jlc3RhcnRJZGxlVGltZW91dCgpO1xuICB9XG5cbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKCFfZmluaXNoZWQpIHtcbiAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogc3BhbnN0YXR1cy5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ2RlYWRsaW5lX2V4Y2VlZGVkJyB9KTtcbiAgICAgIF9maW5pc2hSZWFzb24gPSBGSU5JU0hfUkVBU09OX0ZJTkFMX1RJTUVPVVQ7XG4gICAgICBzcGFuLmVuZCgpO1xuICAgIH1cbiAgfSwgZmluYWxUaW1lb3V0KTtcblxuICByZXR1cm4gc3Bhbjtcbn1cblxuZnVuY3Rpb24gX3N0YXJ0SWRsZVNwYW4ob3B0aW9ucykge1xuICBjb25zdCBzcGFuID0gdHJhY2Uuc3RhcnRJbmFjdGl2ZVNwYW4ob3B0aW9ucyk7XG5cbiAgc3Bhbk9uU2NvcGUuX3NldFNwYW5Gb3JTY29wZShjdXJyZW50U2NvcGVzLmdldEN1cnJlbnRTY29wZSgpLCBzcGFuKTtcblxuICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIubG9nKCdbVHJhY2luZ10gU3RhcnRlZCBzcGFuIGlzIGFuIGlkbGUgc3BhbicpO1xuXG4gIHJldHVybiBzcGFuO1xufVxuXG5leHBvcnRzLlRSQUNJTkdfREVGQVVMVFMgPSBUUkFDSU5HX0RFRkFVTFRTO1xuZXhwb3J0cy5zdGFydElkbGVTcGFuID0gc3RhcnRJZGxlU3Bhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkbGVTcGFuLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/idleSpan.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/logSpans.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanUtils.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\n\n/**\n * Print a log message for a started span.\n */\nfunction logSpanStart(span) {\n  if (!debugBuild.DEBUG_BUILD) return;\n\n  const { description = '< unknown name >', op = '< unknown op >', parent_span_id: parentSpanId } = spanUtils.spanToJSON(span);\n  const { spanId } = span.spanContext();\n\n  const sampled = spanUtils.spanIsSampled(span);\n  const rootSpan = spanUtils.getRootSpan(span);\n  const isRootSpan = rootSpan === span;\n\n  const header = `[Tracing] Starting ${sampled ? 'sampled' : 'unsampled'} ${isRootSpan ? 'root ' : ''}span`;\n\n  const infoParts = [`op: ${op}`, `name: ${description}`, `ID: ${spanId}`];\n\n  if (parentSpanId) {\n    infoParts.push(`parent ID: ${parentSpanId}`);\n  }\n\n  if (!isRootSpan) {\n    const { op, description } = spanUtils.spanToJSON(rootSpan);\n    infoParts.push(`root ID: ${rootSpan.spanContext().spanId}`);\n    if (op) {\n      infoParts.push(`root op: ${op}`);\n    }\n    if (description) {\n      infoParts.push(`root description: ${description}`);\n    }\n  }\n\n  logger.logger.log(`${header}\n  ${infoParts.join('\\n  ')}`);\n}\n\n/**\n * Print a log message for an ended span.\n */\nfunction logSpanEnd(span) {\n  if (!debugBuild.DEBUG_BUILD) return;\n\n  const { description = '< unknown name >', op = '< unknown op >' } = spanUtils.spanToJSON(span);\n  const { spanId } = span.spanContext();\n  const rootSpan = spanUtils.getRootSpan(span);\n  const isRootSpan = rootSpan === span;\n\n  const msg = `[Tracing] Finishing \"${op}\" ${isRootSpan ? 'root ' : ''}span \"${description}\" with ID ${spanId}`;\n  logger.logger.log(msg);\n}\n\nexports.logSpanEnd = logSpanEnd;\nexports.logSpanStart = logSpanStart;\n//# sourceMappingURL=logSpans.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYWNpbmcvbG9nU3BhbnMuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsbUJBQW1CLG1CQUFPLENBQUMsd0hBQW1CO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLGdJQUF1QjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsc0lBQTBCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsd0ZBQXdGO0FBQ2xHLFVBQVUsU0FBUzs7QUFFbkI7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxtQ0FBbUMsRUFBRSwwQkFBMEI7O0FBRXRHLDRCQUE0QixHQUFHLFlBQVksWUFBWSxVQUFVLE9BQU87O0FBRXhFO0FBQ0EsaUNBQWlDLGFBQWE7QUFDOUM7O0FBRUE7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QiwrQkFBK0IsOEJBQThCO0FBQzdEO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLElBQUksdUJBQXVCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSwwREFBMEQ7QUFDcEUsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7O0FBRUEsc0NBQXNDLEdBQUcsSUFBSSwwQkFBMEIsUUFBUSxZQUFZLFlBQVksT0FBTztBQUM5RztBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcdHJhY2luZ1xcbG9nU3BhbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3Qgc3BhblV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvc3BhblV0aWxzLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcblxuLyoqXG4gKiBQcmludCBhIGxvZyBtZXNzYWdlIGZvciBhIHN0YXJ0ZWQgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gbG9nU3BhblN0YXJ0KHNwYW4pIHtcbiAgaWYgKCFkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEKSByZXR1cm47XG5cbiAgY29uc3QgeyBkZXNjcmlwdGlvbiA9ICc8IHVua25vd24gbmFtZSA+Jywgb3AgPSAnPCB1bmtub3duIG9wID4nLCBwYXJlbnRfc3Bhbl9pZDogcGFyZW50U3BhbklkIH0gPSBzcGFuVXRpbHMuc3BhblRvSlNPTihzcGFuKTtcbiAgY29uc3QgeyBzcGFuSWQgfSA9IHNwYW4uc3BhbkNvbnRleHQoKTtcblxuICBjb25zdCBzYW1wbGVkID0gc3BhblV0aWxzLnNwYW5Jc1NhbXBsZWQoc3Bhbik7XG4gIGNvbnN0IHJvb3RTcGFuID0gc3BhblV0aWxzLmdldFJvb3RTcGFuKHNwYW4pO1xuICBjb25zdCBpc1Jvb3RTcGFuID0gcm9vdFNwYW4gPT09IHNwYW47XG5cbiAgY29uc3QgaGVhZGVyID0gYFtUcmFjaW5nXSBTdGFydGluZyAke3NhbXBsZWQgPyAnc2FtcGxlZCcgOiAndW5zYW1wbGVkJ30gJHtpc1Jvb3RTcGFuID8gJ3Jvb3QgJyA6ICcnfXNwYW5gO1xuXG4gIGNvbnN0IGluZm9QYXJ0cyA9IFtgb3A6ICR7b3B9YCwgYG5hbWU6ICR7ZGVzY3JpcHRpb259YCwgYElEOiAke3NwYW5JZH1gXTtcblxuICBpZiAocGFyZW50U3BhbklkKSB7XG4gICAgaW5mb1BhcnRzLnB1c2goYHBhcmVudCBJRDogJHtwYXJlbnRTcGFuSWR9YCk7XG4gIH1cblxuICBpZiAoIWlzUm9vdFNwYW4pIHtcbiAgICBjb25zdCB7IG9wLCBkZXNjcmlwdGlvbiB9ID0gc3BhblV0aWxzLnNwYW5Ub0pTT04ocm9vdFNwYW4pO1xuICAgIGluZm9QYXJ0cy5wdXNoKGByb290IElEOiAke3Jvb3RTcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkfWApO1xuICAgIGlmIChvcCkge1xuICAgICAgaW5mb1BhcnRzLnB1c2goYHJvb3Qgb3A6ICR7b3B9YCk7XG4gICAgfVxuICAgIGlmIChkZXNjcmlwdGlvbikge1xuICAgICAgaW5mb1BhcnRzLnB1c2goYHJvb3QgZGVzY3JpcHRpb246ICR7ZGVzY3JpcHRpb259YCk7XG4gICAgfVxuICB9XG5cbiAgbG9nZ2VyLmxvZ2dlci5sb2coYCR7aGVhZGVyfVxuICAke2luZm9QYXJ0cy5qb2luKCdcXG4gICcpfWApO1xufVxuXG4vKipcbiAqIFByaW50IGEgbG9nIG1lc3NhZ2UgZm9yIGFuIGVuZGVkIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGxvZ1NwYW5FbmQoc3Bhbikge1xuICBpZiAoIWRlYnVnQnVpbGQuREVCVUdfQlVJTEQpIHJldHVybjtcblxuICBjb25zdCB7IGRlc2NyaXB0aW9uID0gJzwgdW5rbm93biBuYW1lID4nLCBvcCA9ICc8IHVua25vd24gb3AgPicgfSA9IHNwYW5VdGlscy5zcGFuVG9KU09OKHNwYW4pO1xuICBjb25zdCB7IHNwYW5JZCB9ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuICBjb25zdCByb290U3BhbiA9IHNwYW5VdGlscy5nZXRSb290U3BhbihzcGFuKTtcbiAgY29uc3QgaXNSb290U3BhbiA9IHJvb3RTcGFuID09PSBzcGFuO1xuXG4gIGNvbnN0IG1zZyA9IGBbVHJhY2luZ10gRmluaXNoaW5nIFwiJHtvcH1cIiAke2lzUm9vdFNwYW4gPyAncm9vdCAnIDogJyd9c3BhbiBcIiR7ZGVzY3JpcHRpb259XCIgd2l0aCBJRCAke3NwYW5JZH1gO1xuICBsb2dnZXIubG9nZ2VyLmxvZyhtc2cpO1xufVxuXG5leHBvcnRzLmxvZ1NwYW5FbmQgPSBsb2dTcGFuRW5kO1xuZXhwb3J0cy5sb2dTcGFuU3RhcnQgPSBsb2dTcGFuU3RhcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dTcGFucy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/logSpans.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/measurement.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/semanticAttributes.js");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanUtils.js");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js");\n\n/**\n * Adds a measurement to the active transaction on the current global scope. You can optionally pass in a different span\n * as the 4th parameter.\n */\nfunction setMeasurement(name, value, unit, activeSpan = spanUtils.getActiveSpan()) {\n  const rootSpan = activeSpan && spanUtils.getRootSpan(activeSpan);\n\n  if (rootSpan) {\n    debugBuild.DEBUG_BUILD && logger.logger.log(`[Measurement] Setting measurement on root span: ${name} = ${value} ${unit}`);\n    rootSpan.addEvent(name, {\n      [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: value,\n      [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: unit ,\n    });\n  }\n}\n\n/**\n * Convert timed events to measurements.\n */\nfunction timedEventsToMeasurements(events) {\n  if (!events || events.length === 0) {\n    return undefined;\n  }\n\n  const measurements = {};\n  events.forEach(event => {\n    const attributes = event.attributes || {};\n    const unit = attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT] ;\n    const value = attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE] ;\n\n    if (typeof unit === \'string\' && typeof value === \'number\') {\n      measurements[event.name] = { value, unit };\n    }\n  });\n\n  return measurements;\n}\n\nexports.setMeasurement = setMeasurement;\nexports.timedEventsToMeasurements = timedEventsToMeasurements;\n//# sourceMappingURL=measurement.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYWNpbmcvbWVhc3VyZW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsbUJBQW1CLG1CQUFPLENBQUMsd0hBQW1CO0FBQzlDLDJCQUEyQixtQkFBTyxDQUFDLHNJQUEwQjtBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxnSUFBdUI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLHNJQUEwQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUdBQW1HLE1BQU0sSUFBSSxPQUFPLEVBQUUsS0FBSztBQUMzSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QixpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcdHJhY2luZ1xcbWVhc3VyZW1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3Qgc2VtYW50aWNBdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi4vc2VtYW50aWNBdHRyaWJ1dGVzLmpzJyk7XG5jb25zdCBzcGFuVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9zcGFuVXRpbHMuanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuXG4vKipcbiAqIEFkZHMgYSBtZWFzdXJlbWVudCB0byB0aGUgYWN0aXZlIHRyYW5zYWN0aW9uIG9uIHRoZSBjdXJyZW50IGdsb2JhbCBzY29wZS4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgaW4gYSBkaWZmZXJlbnQgc3BhblxuICogYXMgdGhlIDR0aCBwYXJhbWV0ZXIuXG4gKi9cbmZ1bmN0aW9uIHNldE1lYXN1cmVtZW50KG5hbWUsIHZhbHVlLCB1bml0LCBhY3RpdmVTcGFuID0gc3BhblV0aWxzLmdldEFjdGl2ZVNwYW4oKSkge1xuICBjb25zdCByb290U3BhbiA9IGFjdGl2ZVNwYW4gJiYgc3BhblV0aWxzLmdldFJvb3RTcGFuKGFjdGl2ZVNwYW4pO1xuXG4gIGlmIChyb290U3Bhbikge1xuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci5sb2coYFtNZWFzdXJlbWVudF0gU2V0dGluZyBtZWFzdXJlbWVudCBvbiByb290IHNwYW46ICR7bmFtZX0gPSAke3ZhbHVlfSAke3VuaXR9YCk7XG4gICAgcm9vdFNwYW4uYWRkRXZlbnQobmFtZSwge1xuICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX01FQVNVUkVNRU5UX1ZBTFVFXTogdmFsdWUsXG4gICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfTUVBU1VSRU1FTlRfVU5JVF06IHVuaXQgLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCB0aW1lZCBldmVudHMgdG8gbWVhc3VyZW1lbnRzLlxuICovXG5mdW5jdGlvbiB0aW1lZEV2ZW50c1RvTWVhc3VyZW1lbnRzKGV2ZW50cykge1xuICBpZiAoIWV2ZW50cyB8fCBldmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IG1lYXN1cmVtZW50cyA9IHt9O1xuICBldmVudHMuZm9yRWFjaChldmVudCA9PiB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGV2ZW50LmF0dHJpYnV0ZXMgfHwge307XG4gICAgY29uc3QgdW5pdCA9IGF0dHJpYnV0ZXNbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfTUVBU1VSRU1FTlRfVU5JVF0gO1xuICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9NRUFTVVJFTUVOVF9WQUxVRV0gO1xuXG4gICAgaWYgKHR5cGVvZiB1bml0ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBtZWFzdXJlbWVudHNbZXZlbnQubmFtZV0gPSB7IHZhbHVlLCB1bml0IH07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbWVhc3VyZW1lbnRzO1xufVxuXG5leHBvcnRzLnNldE1lYXN1cmVtZW50ID0gc2V0TWVhc3VyZW1lbnQ7XG5leHBvcnRzLnRpbWVkRXZlbnRzVG9NZWFzdXJlbWVudHMgPSB0aW1lZEV2ZW50c1RvTWVhc3VyZW1lbnRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVhc3VyZW1lbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/measurement.js\n')},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sampling.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst hasSpansEnabled = __webpack_require__(/*! ../utils/hasSpansEnabled.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/hasSpansEnabled.js\");\nconst parseSampleRate = __webpack_require__(/*! ../utils/parseSampleRate.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/parseSampleRate.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\n\n/**\n * Makes a sampling decision for the given options.\n *\n * Called every time a root span is created. Only root spans which emerge with a `sampled` value of `true` will be\n * sent to Sentry.\n */\nfunction sampleSpan(\n  options,\n  samplingContext,\n  sampleRand,\n) {\n  // nothing to do if span recording is not enabled\n  if (!hasSpansEnabled.hasSpansEnabled(options)) {\n    return [false];\n  }\n\n  let localSampleRateWasApplied = undefined;\n\n  // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should\n  // work; prefer the hook if so\n  let sampleRate;\n  if (typeof options.tracesSampler === 'function') {\n    sampleRate = options.tracesSampler({\n      ...samplingContext,\n      inheritOrSampleWith: fallbackSampleRate => {\n        // If we have an incoming parent sample rate, we'll just use that one.\n        // The sampling decision will be inherited because of the sample_rand that was generated when the trace reached the incoming boundaries of the SDK.\n        if (typeof samplingContext.parentSampleRate === 'number') {\n          return samplingContext.parentSampleRate;\n        }\n\n        // Fallback if parent sample rate is not on the incoming trace (e.g. if there is no baggage)\n        // This is to provide backwards compatibility if there are incoming traces from older SDKs that don't send a parent sample rate or a sample rand. In these cases we just want to force either a sampling decision on the downstream traces via the sample rate.\n        if (typeof samplingContext.parentSampled === 'boolean') {\n          return Number(samplingContext.parentSampled);\n        }\n\n        return fallbackSampleRate;\n      },\n    });\n    localSampleRateWasApplied = true;\n  } else if (samplingContext.parentSampled !== undefined) {\n    sampleRate = samplingContext.parentSampled;\n  } else if (typeof options.tracesSampleRate !== 'undefined') {\n    sampleRate = options.tracesSampleRate;\n    localSampleRateWasApplied = true;\n  }\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get.\n  // (The only valid values are booleans or numbers between 0 and 1.)\n  const parsedSampleRate = parseSampleRate.parseSampleRate(sampleRate);\n\n  if (parsedSampleRate === undefined) {\n    debugBuild.DEBUG_BUILD &&\n      logger.logger.warn(\n        `[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          sampleRate,\n        )} of type ${JSON.stringify(typeof sampleRate)}.`,\n      );\n    return [false];\n  }\n\n  // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped\n  if (!parsedSampleRate) {\n    debugBuild.DEBUG_BUILD &&\n      logger.logger.log(\n        `[Tracing] Discarding transaction because ${\n          typeof options.tracesSampler === 'function'\n            ? 'tracesSampler returned 0 or false'\n            : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'\n        }`,\n      );\n    return [false, parsedSampleRate, localSampleRateWasApplied];\n  }\n\n  // We always compare the sample rand for the current execution context against the chosen sample rate.\n  // Read more: https://develop.sentry.dev/sdk/telemetry/traces/#propagated-random-value\n  const shouldSample = sampleRand < parsedSampleRate;\n\n  // if we're not going to keep it, we're done\n  if (!shouldSample) {\n    debugBuild.DEBUG_BUILD &&\n      logger.logger.log(\n        `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(\n          sampleRate,\n        )})`,\n      );\n  }\n\n  return [shouldSample, parsedSampleRate, localSampleRateWasApplied];\n}\n\nexports.sampleSpan = sampleSpan;\n//# sourceMappingURL=sampling.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYWNpbmcvc2FtcGxpbmcuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsbUJBQW1CLG1CQUFPLENBQUMsd0hBQW1CO0FBQzlDLHdCQUF3QixtQkFBTyxDQUFDLDRJQUE2QjtBQUM3RCx3QkFBd0IsbUJBQU8sQ0FBQyw0SUFBNkI7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLHNJQUEwQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUlBQXlJO0FBQ3pJO0FBQ0EsV0FBVyxVQUFVLGtDQUFrQztBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcdHJhY2luZ1xcc2FtcGxpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3QgaGFzU3BhbnNFbmFibGVkID0gcmVxdWlyZSgnLi4vdXRpbHMvaGFzU3BhbnNFbmFibGVkLmpzJyk7XG5jb25zdCBwYXJzZVNhbXBsZVJhdGUgPSByZXF1aXJlKCcuLi91dGlscy9wYXJzZVNhbXBsZVJhdGUuanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuXG4vKipcbiAqIE1ha2VzIGEgc2FtcGxpbmcgZGVjaXNpb24gZm9yIHRoZSBnaXZlbiBvcHRpb25zLlxuICpcbiAqIENhbGxlZCBldmVyeSB0aW1lIGEgcm9vdCBzcGFuIGlzIGNyZWF0ZWQuIE9ubHkgcm9vdCBzcGFucyB3aGljaCBlbWVyZ2Ugd2l0aCBhIGBzYW1wbGVkYCB2YWx1ZSBvZiBgdHJ1ZWAgd2lsbCBiZVxuICogc2VudCB0byBTZW50cnkuXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVNwYW4oXG4gIG9wdGlvbnMsXG4gIHNhbXBsaW5nQ29udGV4dCxcbiAgc2FtcGxlUmFuZCxcbikge1xuICAvLyBub3RoaW5nIHRvIGRvIGlmIHNwYW4gcmVjb3JkaW5nIGlzIG5vdCBlbmFibGVkXG4gIGlmICghaGFzU3BhbnNFbmFibGVkLmhhc1NwYW5zRW5hYmxlZChvcHRpb25zKSkge1xuICAgIHJldHVybiBbZmFsc2VdO1xuICB9XG5cbiAgbGV0IGxvY2FsU2FtcGxlUmF0ZVdhc0FwcGxpZWQgPSB1bmRlZmluZWQ7XG5cbiAgLy8gd2Ugd291bGQgaGF2ZSBiYWlsZWQgYWxyZWFkeSBpZiBuZWl0aGVyIGB0cmFjZXNTYW1wbGVyYCBub3IgYHRyYWNlc1NhbXBsZVJhdGVgIHdlcmUgZGVmaW5lZCwgc28gb25lIG9mIHRoZXNlIHNob3VsZFxuICAvLyB3b3JrOyBwcmVmZXIgdGhlIGhvb2sgaWYgc29cbiAgbGV0IHNhbXBsZVJhdGU7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFjZXNTYW1wbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2FtcGxlUmF0ZSA9IG9wdGlvbnMudHJhY2VzU2FtcGxlcih7XG4gICAgICAuLi5zYW1wbGluZ0NvbnRleHQsXG4gICAgICBpbmhlcml0T3JTYW1wbGVXaXRoOiBmYWxsYmFja1NhbXBsZVJhdGUgPT4ge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGluY29taW5nIHBhcmVudCBzYW1wbGUgcmF0ZSwgd2UnbGwganVzdCB1c2UgdGhhdCBvbmUuXG4gICAgICAgIC8vIFRoZSBzYW1wbGluZyBkZWNpc2lvbiB3aWxsIGJlIGluaGVyaXRlZCBiZWNhdXNlIG9mIHRoZSBzYW1wbGVfcmFuZCB0aGF0IHdhcyBnZW5lcmF0ZWQgd2hlbiB0aGUgdHJhY2UgcmVhY2hlZCB0aGUgaW5jb21pbmcgYm91bmRhcmllcyBvZiB0aGUgU0RLLlxuICAgICAgICBpZiAodHlwZW9mIHNhbXBsaW5nQ29udGV4dC5wYXJlbnRTYW1wbGVSYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBzYW1wbGluZ0NvbnRleHQucGFyZW50U2FtcGxlUmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZhbGxiYWNrIGlmIHBhcmVudCBzYW1wbGUgcmF0ZSBpcyBub3Qgb24gdGhlIGluY29taW5nIHRyYWNlIChlLmcuIGlmIHRoZXJlIGlzIG5vIGJhZ2dhZ2UpXG4gICAgICAgIC8vIFRoaXMgaXMgdG8gcHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBpZiB0aGVyZSBhcmUgaW5jb21pbmcgdHJhY2VzIGZyb20gb2xkZXIgU0RLcyB0aGF0IGRvbid0IHNlbmQgYSBwYXJlbnQgc2FtcGxlIHJhdGUgb3IgYSBzYW1wbGUgcmFuZC4gSW4gdGhlc2UgY2FzZXMgd2UganVzdCB3YW50IHRvIGZvcmNlIGVpdGhlciBhIHNhbXBsaW5nIGRlY2lzaW9uIG9uIHRoZSBkb3duc3RyZWFtIHRyYWNlcyB2aWEgdGhlIHNhbXBsZSByYXRlLlxuICAgICAgICBpZiAodHlwZW9mIHNhbXBsaW5nQ29udGV4dC5wYXJlbnRTYW1wbGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm4gTnVtYmVyKHNhbXBsaW5nQ29udGV4dC5wYXJlbnRTYW1wbGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxsYmFja1NhbXBsZVJhdGU7XG4gICAgICB9LFxuICAgIH0pO1xuICAgIGxvY2FsU2FtcGxlUmF0ZVdhc0FwcGxpZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHNhbXBsaW5nQ29udGV4dC5wYXJlbnRTYW1wbGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBzYW1wbGVSYXRlID0gc2FtcGxpbmdDb250ZXh0LnBhcmVudFNhbXBsZWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMudHJhY2VzU2FtcGxlUmF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzYW1wbGVSYXRlID0gb3B0aW9ucy50cmFjZXNTYW1wbGVSYXRlO1xuICAgIGxvY2FsU2FtcGxlUmF0ZVdhc0FwcGxpZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gU2luY2UgdGhpcyBpcyBjb21pbmcgZnJvbSB0aGUgdXNlciAob3IgZnJvbSBhIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSB1c2VyKSwgd2hvIGtub3dzIHdoYXQgd2UgbWlnaHQgZ2V0LlxuICAvLyAoVGhlIG9ubHkgdmFsaWQgdmFsdWVzIGFyZSBib29sZWFucyBvciBudW1iZXJzIGJldHdlZW4gMCBhbmQgMS4pXG4gIGNvbnN0IHBhcnNlZFNhbXBsZVJhdGUgPSBwYXJzZVNhbXBsZVJhdGUucGFyc2VTYW1wbGVSYXRlKHNhbXBsZVJhdGUpO1xuXG4gIGlmIChwYXJzZWRTYW1wbGVSYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmXG4gICAgICBsb2dnZXIubG9nZ2VyLndhcm4oXG4gICAgICAgIGBbVHJhY2luZ10gRGlzY2FyZGluZyByb290IHNwYW4gYmVjYXVzZSBvZiBpbnZhbGlkIHNhbXBsZSByYXRlLiBTYW1wbGUgcmF0ZSBtdXN0IGJlIGEgYm9vbGVhbiBvciBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuIEdvdCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHNhbXBsZVJhdGUsXG4gICAgICAgICl9IG9mIHR5cGUgJHtKU09OLnN0cmluZ2lmeSh0eXBlb2Ygc2FtcGxlUmF0ZSl9LmAsXG4gICAgICApO1xuICAgIHJldHVybiBbZmFsc2VdO1xuICB9XG5cbiAgLy8gaWYgdGhlIGZ1bmN0aW9uIHJldHVybmVkIDAgKG9yIGZhbHNlKSwgb3IgaWYgYHRyYWNlc1NhbXBsZVJhdGVgIGlzIDAsIGl0J3MgYSBzaWduIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgZHJvcHBlZFxuICBpZiAoIXBhcnNlZFNhbXBsZVJhdGUpIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmXG4gICAgICBsb2dnZXIubG9nZ2VyLmxvZyhcbiAgICAgICAgYFtUcmFjaW5nXSBEaXNjYXJkaW5nIHRyYW5zYWN0aW9uIGJlY2F1c2UgJHtcbiAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy50cmFjZXNTYW1wbGVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/ICd0cmFjZXNTYW1wbGVyIHJldHVybmVkIDAgb3IgZmFsc2UnXG4gICAgICAgICAgICA6ICdhIG5lZ2F0aXZlIHNhbXBsaW5nIGRlY2lzaW9uIHdhcyBpbmhlcml0ZWQgb3IgdHJhY2VzU2FtcGxlUmF0ZSBpcyBzZXQgdG8gMCdcbiAgICAgICAgfWAsXG4gICAgICApO1xuICAgIHJldHVybiBbZmFsc2UsIHBhcnNlZFNhbXBsZVJhdGUsIGxvY2FsU2FtcGxlUmF0ZVdhc0FwcGxpZWRdO1xuICB9XG5cbiAgLy8gV2UgYWx3YXlzIGNvbXBhcmUgdGhlIHNhbXBsZSByYW5kIGZvciB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dCBhZ2FpbnN0IHRoZSBjaG9zZW4gc2FtcGxlIHJhdGUuXG4gIC8vIFJlYWQgbW9yZTogaHR0cHM6Ly9kZXZlbG9wLnNlbnRyeS5kZXYvc2RrL3RlbGVtZXRyeS90cmFjZXMvI3Byb3BhZ2F0ZWQtcmFuZG9tLXZhbHVlXG4gIGNvbnN0IHNob3VsZFNhbXBsZSA9IHNhbXBsZVJhbmQgPCBwYXJzZWRTYW1wbGVSYXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBnb2luZyB0byBrZWVwIGl0LCB3ZSdyZSBkb25lXG4gIGlmICghc2hvdWxkU2FtcGxlKSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJlxuICAgICAgbG9nZ2VyLmxvZ2dlci5sb2coXG4gICAgICAgIGBbVHJhY2luZ10gRGlzY2FyZGluZyB0cmFuc2FjdGlvbiBiZWNhdXNlIGl0J3Mgbm90IGluY2x1ZGVkIGluIHRoZSByYW5kb20gc2FtcGxlIChzYW1wbGluZyByYXRlID0gJHtOdW1iZXIoXG4gICAgICAgICAgc2FtcGxlUmF0ZSxcbiAgICAgICAgKX0pYCxcbiAgICAgICk7XG4gIH1cblxuICByZXR1cm4gW3Nob3VsZFNhbXBsZSwgcGFyc2VkU2FtcGxlUmF0ZSwgbG9jYWxTYW1wbGVSYXRlV2FzQXBwbGllZF07XG59XG5cbmV4cG9ydHMuc2FtcGxlU3BhbiA9IHNhbXBsZVNwYW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW1wbGluZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sampling.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sentryNonRecordingSpan.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanUtils.js");\nconst propagationContext = __webpack_require__(/*! ../utils-hoist/propagationContext.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/propagationContext.js");\n\n/**\n * A Sentry Span that is non-recording, meaning it will not be sent to Sentry.\n */\nclass SentryNonRecordingSpan  {\n\n   constructor(spanContext = {}) {\n    this._traceId = spanContext.traceId || propagationContext.generateTraceId();\n    this._spanId = spanContext.spanId || propagationContext.generateSpanId();\n  }\n\n  /** @inheritdoc */\n   spanContext() {\n    return {\n      spanId: this._spanId,\n      traceId: this._traceId,\n      traceFlags: spanUtils.TRACE_FLAG_NONE,\n    };\n  }\n\n  /** @inheritdoc */\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n   end(_timestamp) {}\n\n  /** @inheritdoc */\n   setAttribute(_key, _value) {\n    return this;\n  }\n\n  /** @inheritdoc */\n   setAttributes(_values) {\n    return this;\n  }\n\n  /** @inheritdoc */\n   setStatus(_status) {\n    return this;\n  }\n\n  /** @inheritdoc */\n   updateName(_name) {\n    return this;\n  }\n\n  /** @inheritdoc */\n   isRecording() {\n    return false;\n  }\n\n  /** @inheritdoc */\n   addEvent(\n    _name,\n    _attributesOrStartTime,\n    _startTime,\n  ) {\n    return this;\n  }\n\n  /** @inheritDoc */\n   addLink(_link) {\n    return this;\n  }\n\n  /** @inheritDoc */\n   addLinks(_links) {\n    return this;\n  }\n\n  /**\n   * This should generally not be used,\n   * but we need it for being compliant with the OTEL Span interface.\n   *\n   * @hidden\n   * @internal\n   */\n   recordException(_exception, _time) {\n    // noop\n  }\n}\n\nexports.SentryNonRecordingSpan = SentryNonRecordingSpan;\n//# sourceMappingURL=sentryNonRecordingSpan.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYWNpbmcvc2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxrQkFBa0IsbUJBQU8sQ0FBQyxnSUFBdUI7QUFDakQsMkJBQTJCLG1CQUFPLENBQUMsOEpBQXNDOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcdHJhY2luZ1xcc2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3Qgc3BhblV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvc3BhblV0aWxzLmpzJyk7XG5jb25zdCBwcm9wYWdhdGlvbkNvbnRleHQgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9wcm9wYWdhdGlvbkNvbnRleHQuanMnKTtcblxuLyoqXG4gKiBBIFNlbnRyeSBTcGFuIHRoYXQgaXMgbm9uLXJlY29yZGluZywgbWVhbmluZyBpdCB3aWxsIG5vdCBiZSBzZW50IHRvIFNlbnRyeS5cbiAqL1xuY2xhc3MgU2VudHJ5Tm9uUmVjb3JkaW5nU3BhbiAge1xuXG4gICBjb25zdHJ1Y3RvcihzcGFuQ29udGV4dCA9IHt9KSB7XG4gICAgdGhpcy5fdHJhY2VJZCA9IHNwYW5Db250ZXh0LnRyYWNlSWQgfHwgcHJvcGFnYXRpb25Db250ZXh0LmdlbmVyYXRlVHJhY2VJZCgpO1xuICAgIHRoaXMuX3NwYW5JZCA9IHNwYW5Db250ZXh0LnNwYW5JZCB8fCBwcm9wYWdhdGlvbkNvbnRleHQuZ2VuZXJhdGVTcGFuSWQoKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgc3BhbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNwYW5JZDogdGhpcy5fc3BhbklkLFxuICAgICAgdHJhY2VJZDogdGhpcy5fdHJhY2VJZCxcbiAgICAgIHRyYWNlRmxhZ3M6IHNwYW5VdGlscy5UUkFDRV9GTEFHX05PTkUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICBlbmQoX3RpbWVzdGFtcCkge31cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIHNldEF0dHJpYnV0ZShfa2V5LCBfdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgc2V0QXR0cmlidXRlcyhfdmFsdWVzKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIHNldFN0YXR1cyhfc3RhdHVzKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIHVwZGF0ZU5hbWUoX25hbWUpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgaXNSZWNvcmRpbmcoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBhZGRFdmVudChcbiAgICBfbmFtZSxcbiAgICBfYXR0cmlidXRlc09yU3RhcnRUaW1lLFxuICAgIF9zdGFydFRpbWUsXG4gICkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gICBhZGRMaW5rKF9saW5rKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgIGFkZExpbmtzKF9saW5rcykge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgdXNlZCxcbiAgICogYnV0IHdlIG5lZWQgaXQgZm9yIGJlaW5nIGNvbXBsaWFudCB3aXRoIHRoZSBPVEVMIFNwYW4gaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAaGlkZGVuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgIHJlY29yZEV4Y2VwdGlvbihfZXhjZXB0aW9uLCBfdGltZSkge1xuICAgIC8vIG5vb3BcbiAgfVxufVxuXG5leHBvcnRzLlNlbnRyeU5vblJlY29yZGluZ1NwYW4gPSBTZW50cnlOb25SZWNvcmRpbmdTcGFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sentryNonRecordingSpan.js\n')},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sentrySpan.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst envelope = __webpack_require__(/*! ../envelope.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/envelope.js\");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanUtils.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst propagationContext = __webpack_require__(/*! ../utils-hoist/propagationContext.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/propagationContext.js\");\nconst time = __webpack_require__(/*! ../utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst dynamicSamplingContext = __webpack_require__(/*! ./dynamicSamplingContext.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js\");\nconst logSpans = __webpack_require__(/*! ./logSpans.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/logSpans.js\");\nconst measurement = __webpack_require__(/*! ./measurement.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/measurement.js\");\nconst utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/utils.js\");\n\nconst MAX_SPAN_COUNT = 1000;\n\n/**\n * Span contains all data about a span\n */\nclass SentrySpan  {\n\n  /** Epoch timestamp in seconds when the span started. */\n\n  /** Epoch timestamp in seconds when the span ended. */\n\n  /** Internal keeper of the status */\n\n  /** The timed events added to this span. */\n\n  /** if true, treat span as a standalone span (not part of a transaction) */\n\n  /**\n   * You should never call the constructor manually, always use `Sentry.startSpan()`\n   * or other span methods.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n   constructor(spanContext = {}) {\n    this._traceId = spanContext.traceId || propagationContext.generateTraceId();\n    this._spanId = spanContext.spanId || propagationContext.generateSpanId();\n    this._startTime = spanContext.startTimestamp || time.timestampInSeconds();\n    this._links = spanContext.links;\n\n    this._attributes = {};\n    this.setAttributes({\n      [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'manual',\n      [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: spanContext.op,\n      ...spanContext.attributes,\n    });\n\n    this._name = spanContext.name;\n\n    if (spanContext.parentSpanId) {\n      this._parentSpanId = spanContext.parentSpanId;\n    }\n    // We want to include booleans as well here\n    if ('sampled' in spanContext) {\n      this._sampled = spanContext.sampled;\n    }\n    if (spanContext.endTimestamp) {\n      this._endTime = spanContext.endTimestamp;\n    }\n\n    this._events = [];\n\n    this._isStandaloneSpan = spanContext.isStandalone;\n\n    // If the span is already ended, ensure we finalize the span immediately\n    if (this._endTime) {\n      this._onSpanEnded();\n    }\n  }\n\n  /** @inheritDoc */\n   addLink(link) {\n    if (this._links) {\n      this._links.push(link);\n    } else {\n      this._links = [link];\n    }\n    return this;\n  }\n\n  /** @inheritDoc */\n   addLinks(links) {\n    if (this._links) {\n      this._links.push(...links);\n    } else {\n      this._links = links;\n    }\n    return this;\n  }\n\n  /**\n   * This should generally not be used,\n   * but it is needed for being compliant with the OTEL Span interface.\n   *\n   * @hidden\n   * @internal\n   */\n   recordException(_exception, _time) {\n    // noop\n  }\n\n  /** @inheritdoc */\n   spanContext() {\n    const { _spanId: spanId, _traceId: traceId, _sampled: sampled } = this;\n    return {\n      spanId,\n      traceId,\n      traceFlags: sampled ? spanUtils.TRACE_FLAG_SAMPLED : spanUtils.TRACE_FLAG_NONE,\n    };\n  }\n\n  /** @inheritdoc */\n   setAttribute(key, value) {\n    if (value === undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._attributes[key];\n    } else {\n      this._attributes[key] = value;\n    }\n\n    return this;\n  }\n\n  /** @inheritdoc */\n   setAttributes(attributes) {\n    Object.keys(attributes).forEach(key => this.setAttribute(key, attributes[key]));\n    return this;\n  }\n\n  /**\n   * This should generally not be used,\n   * but we need it for browser tracing where we want to adjust the start time afterwards.\n   * USE THIS WITH CAUTION!\n   *\n   * @hidden\n   * @internal\n   */\n   updateStartTime(timeInput) {\n    this._startTime = spanUtils.spanTimeInputToSeconds(timeInput);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setStatus(value) {\n    this._status = value;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   updateName(name) {\n    this._name = name;\n    this.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'custom');\n    return this;\n  }\n\n  /** @inheritdoc */\n   end(endTimestamp) {\n    // If already ended, skip\n    if (this._endTime) {\n      return;\n    }\n\n    this._endTime = spanUtils.spanTimeInputToSeconds(endTimestamp);\n    logSpans.logSpanEnd(this);\n\n    this._onSpanEnded();\n  }\n\n  /**\n   * Get JSON representation of this span.\n   *\n   * @hidden\n   * @internal This method is purely for internal purposes and should not be used outside\n   * of SDK code. If you need to get a JSON representation of a span,\n   * use `spanToJSON(span)` instead.\n   */\n   getSpanJSON() {\n    return {\n      data: this._attributes,\n      description: this._name,\n      op: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP],\n      parent_span_id: this._parentSpanId,\n      span_id: this._spanId,\n      start_timestamp: this._startTime,\n      status: spanUtils.getStatusMessage(this._status),\n      timestamp: this._endTime,\n      trace_id: this._traceId,\n      origin: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ,\n      profile_id: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_PROFILE_ID] ,\n      exclusive_time: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME] ,\n      measurements: measurement.timedEventsToMeasurements(this._events),\n      is_segment: (this._isStandaloneSpan && spanUtils.getRootSpan(this) === this) || undefined,\n      segment_id: this._isStandaloneSpan ? spanUtils.getRootSpan(this).spanContext().spanId : undefined,\n      links: spanUtils.convertSpanLinksForEnvelope(this._links),\n    };\n  }\n\n  /** @inheritdoc */\n   isRecording() {\n    return !this._endTime && !!this._sampled;\n  }\n\n  /**\n   * @inheritdoc\n   */\n   addEvent(\n    name,\n    attributesOrStartTime,\n    startTime,\n  ) {\n    debugBuild.DEBUG_BUILD && logger.logger.log('[Tracing] Adding an event to span:', name);\n\n    const time$1 = isSpanTimeInput(attributesOrStartTime) ? attributesOrStartTime : startTime || time.timestampInSeconds();\n    const attributes = isSpanTimeInput(attributesOrStartTime) ? {} : attributesOrStartTime || {};\n\n    const event = {\n      name,\n      time: spanUtils.spanTimeInputToSeconds(time$1),\n      attributes,\n    };\n\n    this._events.push(event);\n\n    return this;\n  }\n\n  /**\n   * This method should generally not be used,\n   * but for now we need a way to publicly check if the `_isStandaloneSpan` flag is set.\n   * USE THIS WITH CAUTION!\n   * @internal\n   * @hidden\n   * @experimental\n   */\n   isStandaloneSpan() {\n    return !!this._isStandaloneSpan;\n  }\n\n  /** Emit `spanEnd` when the span is ended. */\n   _onSpanEnded() {\n    const client = currentScopes.getClient();\n    if (client) {\n      client.emit('spanEnd', this);\n    }\n\n    // A segment span is basically the root span of a local span tree.\n    // So for now, this is either what we previously refer to as the root span,\n    // or a standalone span.\n    const isSegmentSpan = this._isStandaloneSpan || this === spanUtils.getRootSpan(this);\n\n    if (!isSegmentSpan) {\n      return;\n    }\n\n    // if this is a standalone span, we send it immediately\n    if (this._isStandaloneSpan) {\n      if (this._sampled) {\n        sendSpanEnvelope(envelope.createSpanEnvelope([this], client));\n      } else {\n        debugBuild.DEBUG_BUILD &&\n          logger.logger.log('[Tracing] Discarding standalone span because its trace was not chosen to be sampled.');\n        if (client) {\n          client.recordDroppedEvent('sample_rate', 'span');\n        }\n      }\n      return;\n    }\n\n    const transactionEvent = this._convertSpanToTransaction();\n    if (transactionEvent) {\n      const scope = utils.getCapturedScopesOnSpan(this).scope || currentScopes.getCurrentScope();\n      scope.captureEvent(transactionEvent);\n    }\n  }\n\n  /**\n   * Finish the transaction & prepare the event to send to Sentry.\n   */\n   _convertSpanToTransaction() {\n    // We can only convert finished spans\n    if (!isFullFinishedSpan(spanUtils.spanToJSON(this))) {\n      return undefined;\n    }\n\n    if (!this._name) {\n      debugBuild.DEBUG_BUILD && logger.logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this._name = '<unlabeled transaction>';\n    }\n\n    const { scope: capturedSpanScope, isolationScope: capturedSpanIsolationScope } = utils.getCapturedScopesOnSpan(this);\n\n    const normalizedRequest = capturedSpanScope?.getScopeData().sdkProcessingMetadata?.normalizedRequest;\n\n    if (this._sampled !== true) {\n      return undefined;\n    }\n\n    // The transaction span itself as well as any potential standalone spans should be filtered out\n    const finishedSpans = spanUtils.getSpanDescendants(this).filter(span => span !== this && !isStandaloneSpan(span));\n\n    const spans = finishedSpans.map(span => spanUtils.spanToJSON(span)).filter(isFullFinishedSpan);\n\n    const source = this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ;\n\n    // remove internal root span attributes we don't need to send.\n    /* eslint-disable @typescript-eslint/no-dynamic-delete */\n    delete this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n    spans.forEach(span => {\n      delete span.data[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n    });\n    // eslint-enabled-next-line @typescript-eslint/no-dynamic-delete\n\n    const transaction = {\n      contexts: {\n        trace: spanUtils.spanToTransactionTraceContext(this),\n      },\n      spans:\n        // spans.sort() mutates the array, but `spans` is already a copy so we can safely do this here\n        // we do not use spans anymore after this point\n        spans.length > MAX_SPAN_COUNT\n          ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n          : spans,\n      start_timestamp: this._startTime,\n      timestamp: this._endTime,\n      transaction: this._name,\n      type: 'transaction',\n      sdkProcessingMetadata: {\n        capturedSpanScope,\n        capturedSpanIsolationScope,\n        dynamicSamplingContext: dynamicSamplingContext.getDynamicSamplingContextFromSpan(this),\n      },\n      request: normalizedRequest,\n      ...(source && {\n        transaction_info: {\n          source,\n        },\n      }),\n    };\n\n    const measurements = measurement.timedEventsToMeasurements(this._events);\n    const hasMeasurements = measurements && Object.keys(measurements).length;\n\n    if (hasMeasurements) {\n      debugBuild.DEBUG_BUILD &&\n        logger.logger.log(\n          '[Measurements] Adding measurements to transaction event',\n          JSON.stringify(measurements, undefined, 2),\n        );\n      transaction.measurements = measurements;\n    }\n\n    return transaction;\n  }\n}\n\nfunction isSpanTimeInput(value) {\n  return (value && typeof value === 'number') || value instanceof Date || Array.isArray(value);\n}\n\n// We want to filter out any incomplete SpanJSON objects\nfunction isFullFinishedSpan(input) {\n  return !!input.start_timestamp && !!input.timestamp && !!input.span_id && !!input.trace_id;\n}\n\n/** `SentrySpan`s can be sent as a standalone span rather than belonging to a transaction */\nfunction isStandaloneSpan(span) {\n  return span instanceof SentrySpan && span.isStandaloneSpan();\n}\n\n/**\n * Sends a `SpanEnvelope`.\n *\n * Note: If the envelope's spans are dropped, e.g. via `beforeSendSpan`,\n * the envelope will not be sent either.\n */\nfunction sendSpanEnvelope(envelope) {\n  const client = currentScopes.getClient();\n  if (!client) {\n    return;\n  }\n\n  const spanItems = envelope[1];\n  if (!spanItems || spanItems.length === 0) {\n    client.recordDroppedEvent('before_send', 'span');\n    return;\n  }\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope);\n}\n\nexports.SentrySpan = SentrySpan;\n//# sourceMappingURL=sentrySpan.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYWNpbmcvc2VudHJ5U3Bhbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxzQkFBc0IsbUJBQU8sQ0FBQyw0SEFBcUI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsd0hBQW1CO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLGtIQUFnQjtBQUN6QywyQkFBMkIsbUJBQU8sQ0FBQyxzSUFBMEI7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsZ0lBQXVCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxzSUFBMEI7QUFDakQsMkJBQTJCLG1CQUFPLENBQUMsOEpBQXNDO0FBQ3pFLGFBQWEsbUJBQU8sQ0FBQyxrSUFBd0I7QUFDN0MsK0JBQStCLG1CQUFPLENBQUMscUpBQTZCO0FBQ3BFLGlCQUFpQixtQkFBTyxDQUFDLHlIQUFlO0FBQ3hDLG9CQUFvQixtQkFBTyxDQUFDLCtIQUFrQjtBQUM5QyxjQUFjLG1CQUFPLENBQUMsbUhBQVk7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksd0RBQXdEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksdUVBQXVFOztBQUVuRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXHRyYWNpbmdcXHNlbnRyeVNwYW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IGVudmVsb3BlID0gcmVxdWlyZSgnLi4vZW52ZWxvcGUuanMnKTtcbmNvbnN0IHNlbWFudGljQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4uL3NlbWFudGljQXR0cmlidXRlcy5qcycpO1xuY29uc3Qgc3BhblV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvc3BhblV0aWxzLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3Byb3BhZ2F0aW9uQ29udGV4dC5qcycpO1xuY29uc3QgdGltZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3RpbWUuanMnKTtcbmNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSByZXF1aXJlKCcuL2R5bmFtaWNTYW1wbGluZ0NvbnRleHQuanMnKTtcbmNvbnN0IGxvZ1NwYW5zID0gcmVxdWlyZSgnLi9sb2dTcGFucy5qcycpO1xuY29uc3QgbWVhc3VyZW1lbnQgPSByZXF1aXJlKCcuL21lYXN1cmVtZW50LmpzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcblxuY29uc3QgTUFYX1NQQU5fQ09VTlQgPSAxMDAwO1xuXG4vKipcbiAqIFNwYW4gY29udGFpbnMgYWxsIGRhdGEgYWJvdXQgYSBzcGFuXG4gKi9cbmNsYXNzIFNlbnRyeVNwYW4gIHtcblxuICAvKiogRXBvY2ggdGltZXN0YW1wIGluIHNlY29uZHMgd2hlbiB0aGUgc3BhbiBzdGFydGVkLiAqL1xuXG4gIC8qKiBFcG9jaCB0aW1lc3RhbXAgaW4gc2Vjb25kcyB3aGVuIHRoZSBzcGFuIGVuZGVkLiAqL1xuXG4gIC8qKiBJbnRlcm5hbCBrZWVwZXIgb2YgdGhlIHN0YXR1cyAqL1xuXG4gIC8qKiBUaGUgdGltZWQgZXZlbnRzIGFkZGVkIHRvIHRoaXMgc3Bhbi4gKi9cblxuICAvKiogaWYgdHJ1ZSwgdHJlYXQgc3BhbiBhcyBhIHN0YW5kYWxvbmUgc3BhbiAobm90IHBhcnQgb2YgYSB0cmFuc2FjdGlvbikgKi9cblxuICAvKipcbiAgICogWW91IHNob3VsZCBuZXZlciBjYWxsIHRoZSBjb25zdHJ1Y3RvciBtYW51YWxseSwgYWx3YXlzIHVzZSBgU2VudHJ5LnN0YXJ0U3BhbigpYFxuICAgKiBvciBvdGhlciBzcGFuIG1ldGhvZHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAaGlkZWNvbnN0cnVjdG9yXG4gICAqIEBoaWRkZW5cbiAgICovXG4gICBjb25zdHJ1Y3RvcihzcGFuQ29udGV4dCA9IHt9KSB7XG4gICAgdGhpcy5fdHJhY2VJZCA9IHNwYW5Db250ZXh0LnRyYWNlSWQgfHwgcHJvcGFnYXRpb25Db250ZXh0LmdlbmVyYXRlVHJhY2VJZCgpO1xuICAgIHRoaXMuX3NwYW5JZCA9IHNwYW5Db250ZXh0LnNwYW5JZCB8fCBwcm9wYWdhdGlvbkNvbnRleHQuZ2VuZXJhdGVTcGFuSWQoKTtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBzcGFuQ29udGV4dC5zdGFydFRpbWVzdGFtcCB8fCB0aW1lLnRpbWVzdGFtcEluU2Vjb25kcygpO1xuICAgIHRoaXMuX2xpbmtzID0gc3BhbkNvbnRleHQubGlua3M7XG5cbiAgICB0aGlzLl9hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnbWFudWFsJyxcbiAgICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF06IHNwYW5Db250ZXh0Lm9wLFxuICAgICAgLi4uc3BhbkNvbnRleHQuYXR0cmlidXRlcyxcbiAgICB9KTtcblxuICAgIHRoaXMuX25hbWUgPSBzcGFuQ29udGV4dC5uYW1lO1xuXG4gICAgaWYgKHNwYW5Db250ZXh0LnBhcmVudFNwYW5JZCkge1xuICAgICAgdGhpcy5fcGFyZW50U3BhbklkID0gc3BhbkNvbnRleHQucGFyZW50U3BhbklkO1xuICAgIH1cbiAgICAvLyBXZSB3YW50IHRvIGluY2x1ZGUgYm9vbGVhbnMgYXMgd2VsbCBoZXJlXG4gICAgaWYgKCdzYW1wbGVkJyBpbiBzcGFuQ29udGV4dCkge1xuICAgICAgdGhpcy5fc2FtcGxlZCA9IHNwYW5Db250ZXh0LnNhbXBsZWQ7XG4gICAgfVxuICAgIGlmIChzcGFuQ29udGV4dC5lbmRUaW1lc3RhbXApIHtcbiAgICAgIHRoaXMuX2VuZFRpbWUgPSBzcGFuQ29udGV4dC5lbmRUaW1lc3RhbXA7XG4gICAgfVxuXG4gICAgdGhpcy5fZXZlbnRzID0gW107XG5cbiAgICB0aGlzLl9pc1N0YW5kYWxvbmVTcGFuID0gc3BhbkNvbnRleHQuaXNTdGFuZGFsb25lO1xuXG4gICAgLy8gSWYgdGhlIHNwYW4gaXMgYWxyZWFkeSBlbmRlZCwgZW5zdXJlIHdlIGZpbmFsaXplIHRoZSBzcGFuIGltbWVkaWF0ZWx5XG4gICAgaWYgKHRoaXMuX2VuZFRpbWUpIHtcbiAgICAgIHRoaXMuX29uU3BhbkVuZGVkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gICBhZGRMaW5rKGxpbmspIHtcbiAgICBpZiAodGhpcy5fbGlua3MpIHtcbiAgICAgIHRoaXMuX2xpbmtzLnB1c2gobGluayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpbmtzID0gW2xpbmtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgYWRkTGlua3MobGlua3MpIHtcbiAgICBpZiAodGhpcy5fbGlua3MpIHtcbiAgICAgIHRoaXMuX2xpbmtzLnB1c2goLi4ubGlua3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9saW5rcyA9IGxpbmtzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQsXG4gICAqIGJ1dCBpdCBpcyBuZWVkZWQgZm9yIGJlaW5nIGNvbXBsaWFudCB3aXRoIHRoZSBPVEVMIFNwYW4gaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAaGlkZGVuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgIHJlY29yZEV4Y2VwdGlvbihfZXhjZXB0aW9uLCBfdGltZSkge1xuICAgIC8vIG5vb3BcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgc3BhbkNvbnRleHQoKSB7XG4gICAgY29uc3QgeyBfc3BhbklkOiBzcGFuSWQsIF90cmFjZUlkOiB0cmFjZUlkLCBfc2FtcGxlZDogc2FtcGxlZCB9ID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgc3BhbklkLFxuICAgICAgdHJhY2VJZCxcbiAgICAgIHRyYWNlRmxhZ3M6IHNhbXBsZWQgPyBzcGFuVXRpbHMuVFJBQ0VfRkxBR19TQU1QTEVEIDogc3BhblV0aWxzLlRSQUNFX0ZMQUdfTk9ORSxcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBzZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICBkZWxldGUgdGhpcy5fYXR0cmlidXRlc1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChrZXkgPT4gdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQsXG4gICAqIGJ1dCB3ZSBuZWVkIGl0IGZvciBicm93c2VyIHRyYWNpbmcgd2hlcmUgd2Ugd2FudCB0byBhZGp1c3QgdGhlIHN0YXJ0IHRpbWUgYWZ0ZXJ3YXJkcy5cbiAgICogVVNFIFRISVMgV0lUSCBDQVVUSU9OIVxuICAgKlxuICAgKiBAaGlkZGVuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgIHVwZGF0ZVN0YXJ0VGltZSh0aW1lSW5wdXQpIHtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBzcGFuVXRpbHMuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyh0aW1lSW5wdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgc2V0U3RhdHVzKHZhbHVlKSB7XG4gICAgdGhpcy5fc3RhdHVzID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICB1cGRhdGVOYW1lKG5hbWUpIHtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0UsICdjdXN0b20nKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgZW5kKGVuZFRpbWVzdGFtcCkge1xuICAgIC8vIElmIGFscmVhZHkgZW5kZWQsIHNraXBcbiAgICBpZiAodGhpcy5fZW5kVGltZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2VuZFRpbWUgPSBzcGFuVXRpbHMuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhlbmRUaW1lc3RhbXApO1xuICAgIGxvZ1NwYW5zLmxvZ1NwYW5FbmQodGhpcyk7XG5cbiAgICB0aGlzLl9vblNwYW5FbmRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc3Bhbi5cbiAgICpcbiAgICogQGhpZGRlblxuICAgKiBAaW50ZXJuYWwgVGhpcyBtZXRob2QgaXMgcHVyZWx5IGZvciBpbnRlcm5hbCBwdXJwb3NlcyBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIG91dHNpZGVcbiAgICogb2YgU0RLIGNvZGUuIElmIHlvdSBuZWVkIHRvIGdldCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBzcGFuLFxuICAgKiB1c2UgYHNwYW5Ub0pTT04oc3BhbilgIGluc3RlYWQuXG4gICAqL1xuICAgZ2V0U3BhbkpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHRoaXMuX2F0dHJpYnV0ZXMsXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5fbmFtZSxcbiAgICAgIG9wOiB0aGlzLl9hdHRyaWJ1dGVzW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXSxcbiAgICAgIHBhcmVudF9zcGFuX2lkOiB0aGlzLl9wYXJlbnRTcGFuSWQsXG4gICAgICBzcGFuX2lkOiB0aGlzLl9zcGFuSWQsXG4gICAgICBzdGFydF90aW1lc3RhbXA6IHRoaXMuX3N0YXJ0VGltZSxcbiAgICAgIHN0YXR1czogc3BhblV0aWxzLmdldFN0YXR1c01lc3NhZ2UodGhpcy5fc3RhdHVzKSxcbiAgICAgIHRpbWVzdGFtcDogdGhpcy5fZW5kVGltZSxcbiAgICAgIHRyYWNlX2lkOiB0aGlzLl90cmFjZUlkLFxuICAgICAgb3JpZ2luOiB0aGlzLl9hdHRyaWJ1dGVzW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl0gLFxuICAgICAgcHJvZmlsZV9pZDogdGhpcy5fYXR0cmlidXRlc1tzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1BST0ZJTEVfSURdICxcbiAgICAgIGV4Y2x1c2l2ZV90aW1lOiB0aGlzLl9hdHRyaWJ1dGVzW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfRVhDTFVTSVZFX1RJTUVdICxcbiAgICAgIG1lYXN1cmVtZW50czogbWVhc3VyZW1lbnQudGltZWRFdmVudHNUb01lYXN1cmVtZW50cyh0aGlzLl9ldmVudHMpLFxuICAgICAgaXNfc2VnbWVudDogKHRoaXMuX2lzU3RhbmRhbG9uZVNwYW4gJiYgc3BhblV0aWxzLmdldFJvb3RTcGFuKHRoaXMpID09PSB0aGlzKSB8fCB1bmRlZmluZWQsXG4gICAgICBzZWdtZW50X2lkOiB0aGlzLl9pc1N0YW5kYWxvbmVTcGFuID8gc3BhblV0aWxzLmdldFJvb3RTcGFuKHRoaXMpLnNwYW5Db250ZXh0KCkuc3BhbklkIDogdW5kZWZpbmVkLFxuICAgICAgbGlua3M6IHNwYW5VdGlscy5jb252ZXJ0U3BhbkxpbmtzRm9yRW52ZWxvcGUodGhpcy5fbGlua3MpLFxuICAgIH07XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGlzUmVjb3JkaW5nKCkge1xuICAgIHJldHVybiAhdGhpcy5fZW5kVGltZSAmJiAhIXRoaXMuX3NhbXBsZWQ7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gICBhZGRFdmVudChcbiAgICBuYW1lLFxuICAgIGF0dHJpYnV0ZXNPclN0YXJ0VGltZSxcbiAgICBzdGFydFRpbWUsXG4gICkge1xuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci5sb2coJ1tUcmFjaW5nXSBBZGRpbmcgYW4gZXZlbnQgdG8gc3BhbjonLCBuYW1lKTtcblxuICAgIGNvbnN0IHRpbWUkMSA9IGlzU3BhblRpbWVJbnB1dChhdHRyaWJ1dGVzT3JTdGFydFRpbWUpID8gYXR0cmlidXRlc09yU3RhcnRUaW1lIDogc3RhcnRUaW1lIHx8IHRpbWUudGltZXN0YW1wSW5TZWNvbmRzKCk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGlzU3BhblRpbWVJbnB1dChhdHRyaWJ1dGVzT3JTdGFydFRpbWUpID8ge30gOiBhdHRyaWJ1dGVzT3JTdGFydFRpbWUgfHwge307XG5cbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIG5hbWUsXG4gICAgICB0aW1lOiBzcGFuVXRpbHMuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyh0aW1lJDEpLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICB9O1xuXG4gICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgdXNlZCxcbiAgICogYnV0IGZvciBub3cgd2UgbmVlZCBhIHdheSB0byBwdWJsaWNseSBjaGVjayBpZiB0aGUgYF9pc1N0YW5kYWxvbmVTcGFuYCBmbGFnIGlzIHNldC5cbiAgICogVVNFIFRISVMgV0lUSCBDQVVUSU9OIVxuICAgKiBAaW50ZXJuYWxcbiAgICogQGhpZGRlblxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICAgaXNTdGFuZGFsb25lU3BhbigpIHtcbiAgICByZXR1cm4gISF0aGlzLl9pc1N0YW5kYWxvbmVTcGFuO1xuICB9XG5cbiAgLyoqIEVtaXQgYHNwYW5FbmRgIHdoZW4gdGhlIHNwYW4gaXMgZW5kZWQuICovXG4gICBfb25TcGFuRW5kZWQoKSB7XG4gICAgY29uc3QgY2xpZW50ID0gY3VycmVudFNjb3Blcy5nZXRDbGllbnQoKTtcbiAgICBpZiAoY2xpZW50KSB7XG4gICAgICBjbGllbnQuZW1pdCgnc3BhbkVuZCcsIHRoaXMpO1xuICAgIH1cblxuICAgIC8vIEEgc2VnbWVudCBzcGFuIGlzIGJhc2ljYWxseSB0aGUgcm9vdCBzcGFuIG9mIGEgbG9jYWwgc3BhbiB0cmVlLlxuICAgIC8vIFNvIGZvciBub3csIHRoaXMgaXMgZWl0aGVyIHdoYXQgd2UgcHJldmlvdXNseSByZWZlciB0byBhcyB0aGUgcm9vdCBzcGFuLFxuICAgIC8vIG9yIGEgc3RhbmRhbG9uZSBzcGFuLlxuICAgIGNvbnN0IGlzU2VnbWVudFNwYW4gPSB0aGlzLl9pc1N0YW5kYWxvbmVTcGFuIHx8IHRoaXMgPT09IHNwYW5VdGlscy5nZXRSb290U3Bhbih0aGlzKTtcblxuICAgIGlmICghaXNTZWdtZW50U3Bhbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgaXMgYSBzdGFuZGFsb25lIHNwYW4sIHdlIHNlbmQgaXQgaW1tZWRpYXRlbHlcbiAgICBpZiAodGhpcy5faXNTdGFuZGFsb25lU3Bhbikge1xuICAgICAgaWYgKHRoaXMuX3NhbXBsZWQpIHtcbiAgICAgICAgc2VuZFNwYW5FbnZlbG9wZShlbnZlbG9wZS5jcmVhdGVTcGFuRW52ZWxvcGUoW3RoaXNdLCBjbGllbnQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiZcbiAgICAgICAgICBsb2dnZXIubG9nZ2VyLmxvZygnW1RyYWNpbmddIERpc2NhcmRpbmcgc3RhbmRhbG9uZSBzcGFuIGJlY2F1c2UgaXRzIHRyYWNlIHdhcyBub3QgY2hvc2VuIHRvIGJlIHNhbXBsZWQuJyk7XG4gICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICBjbGllbnQucmVjb3JkRHJvcHBlZEV2ZW50KCdzYW1wbGVfcmF0ZScsICdzcGFuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbkV2ZW50ID0gdGhpcy5fY29udmVydFNwYW5Ub1RyYW5zYWN0aW9uKCk7XG4gICAgaWYgKHRyYW5zYWN0aW9uRXZlbnQpIHtcbiAgICAgIGNvbnN0IHNjb3BlID0gdXRpbHMuZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4odGhpcykuc2NvcGUgfHwgY3VycmVudFNjb3Blcy5nZXRDdXJyZW50U2NvcGUoKTtcbiAgICAgIHNjb3BlLmNhcHR1cmVFdmVudCh0cmFuc2FjdGlvbkV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluaXNoIHRoZSB0cmFuc2FjdGlvbiAmIHByZXBhcmUgdGhlIGV2ZW50IHRvIHNlbmQgdG8gU2VudHJ5LlxuICAgKi9cbiAgIF9jb252ZXJ0U3BhblRvVHJhbnNhY3Rpb24oKSB7XG4gICAgLy8gV2UgY2FuIG9ubHkgY29udmVydCBmaW5pc2hlZCBzcGFuc1xuICAgIGlmICghaXNGdWxsRmluaXNoZWRTcGFuKHNwYW5VdGlscy5zcGFuVG9KU09OKHRoaXMpKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX25hbWUpIHtcbiAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdUcmFuc2FjdGlvbiBoYXMgbm8gbmFtZSwgZmFsbGluZyBiYWNrIHRvIGA8dW5sYWJlbGVkIHRyYW5zYWN0aW9uPmAuJyk7XG4gICAgICB0aGlzLl9uYW1lID0gJzx1bmxhYmVsZWQgdHJhbnNhY3Rpb24+JztcbiAgICB9XG5cbiAgICBjb25zdCB7IHNjb3BlOiBjYXB0dXJlZFNwYW5TY29wZSwgaXNvbGF0aW9uU2NvcGU6IGNhcHR1cmVkU3Bhbklzb2xhdGlvblNjb3BlIH0gPSB1dGlscy5nZXRDYXB0dXJlZFNjb3Blc09uU3Bhbih0aGlzKTtcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWRSZXF1ZXN0ID0gY2FwdHVyZWRTcGFuU2NvcGU/LmdldFNjb3BlRGF0YSgpLnNka1Byb2Nlc3NpbmdNZXRhZGF0YT8ubm9ybWFsaXplZFJlcXVlc3Q7XG5cbiAgICBpZiAodGhpcy5fc2FtcGxlZCAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBUaGUgdHJhbnNhY3Rpb24gc3BhbiBpdHNlbGYgYXMgd2VsbCBhcyBhbnkgcG90ZW50aWFsIHN0YW5kYWxvbmUgc3BhbnMgc2hvdWxkIGJlIGZpbHRlcmVkIG91dFxuICAgIGNvbnN0IGZpbmlzaGVkU3BhbnMgPSBzcGFuVXRpbHMuZ2V0U3BhbkRlc2NlbmRhbnRzKHRoaXMpLmZpbHRlcihzcGFuID0+IHNwYW4gIT09IHRoaXMgJiYgIWlzU3RhbmRhbG9uZVNwYW4oc3BhbikpO1xuXG4gICAgY29uc3Qgc3BhbnMgPSBmaW5pc2hlZFNwYW5zLm1hcChzcGFuID0+IHNwYW5VdGlscy5zcGFuVG9KU09OKHNwYW4pKS5maWx0ZXIoaXNGdWxsRmluaXNoZWRTcGFuKTtcblxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuX2F0dHJpYnV0ZXNbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSA7XG5cbiAgICAvLyByZW1vdmUgaW50ZXJuYWwgcm9vdCBzcGFuIGF0dHJpYnV0ZXMgd2UgZG9uJ3QgbmVlZCB0byBzZW5kLlxuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZSAqL1xuICAgIGRlbGV0ZSB0aGlzLl9hdHRyaWJ1dGVzW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0NVU1RPTV9TUEFOX05BTUVdO1xuICAgIHNwYW5zLmZvckVhY2goc3BhbiA9PiB7XG4gICAgICBkZWxldGUgc3Bhbi5kYXRhW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0NVU1RPTV9TUEFOX05BTUVdO1xuICAgIH0pO1xuICAgIC8vIGVzbGludC1lbmFibGVkLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgY29udGV4dHM6IHtcbiAgICAgICAgdHJhY2U6IHNwYW5VdGlscy5zcGFuVG9UcmFuc2FjdGlvblRyYWNlQ29udGV4dCh0aGlzKSxcbiAgICAgIH0sXG4gICAgICBzcGFuczpcbiAgICAgICAgLy8gc3BhbnMuc29ydCgpIG11dGF0ZXMgdGhlIGFycmF5LCBidXQgYHNwYW5zYCBpcyBhbHJlYWR5IGEgY29weSBzbyB3ZSBjYW4gc2FmZWx5IGRvIHRoaXMgaGVyZVxuICAgICAgICAvLyB3ZSBkbyBub3QgdXNlIHNwYW5zIGFueW1vcmUgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICBzcGFucy5sZW5ndGggPiBNQVhfU1BBTl9DT1VOVFxuICAgICAgICAgID8gc3BhbnMuc29ydCgoYSwgYikgPT4gYS5zdGFydF90aW1lc3RhbXAgLSBiLnN0YXJ0X3RpbWVzdGFtcCkuc2xpY2UoMCwgTUFYX1NQQU5fQ09VTlQpXG4gICAgICAgICAgOiBzcGFucyxcbiAgICAgIHN0YXJ0X3RpbWVzdGFtcDogdGhpcy5fc3RhcnRUaW1lLFxuICAgICAgdGltZXN0YW1wOiB0aGlzLl9lbmRUaW1lLFxuICAgICAgdHJhbnNhY3Rpb246IHRoaXMuX25hbWUsXG4gICAgICB0eXBlOiAndHJhbnNhY3Rpb24nLFxuICAgICAgc2RrUHJvY2Vzc2luZ01ldGFkYXRhOiB7XG4gICAgICAgIGNhcHR1cmVkU3BhblNjb3BlLFxuICAgICAgICBjYXB0dXJlZFNwYW5Jc29sYXRpb25TY29wZSxcbiAgICAgICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dDogZHluYW1pY1NhbXBsaW5nQ29udGV4dC5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4odGhpcyksXG4gICAgICB9LFxuICAgICAgcmVxdWVzdDogbm9ybWFsaXplZFJlcXVlc3QsXG4gICAgICAuLi4oc291cmNlICYmIHtcbiAgICAgICAgdHJhbnNhY3Rpb25faW5mbzoge1xuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIH07XG5cbiAgICBjb25zdCBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudC50aW1lZEV2ZW50c1RvTWVhc3VyZW1lbnRzKHRoaXMuX2V2ZW50cyk7XG4gICAgY29uc3QgaGFzTWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzICYmIE9iamVjdC5rZXlzKG1lYXN1cmVtZW50cykubGVuZ3RoO1xuXG4gICAgaWYgKGhhc01lYXN1cmVtZW50cykge1xuICAgICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJlxuICAgICAgICBsb2dnZXIubG9nZ2VyLmxvZyhcbiAgICAgICAgICAnW01lYXN1cmVtZW50c10gQWRkaW5nIG1lYXN1cmVtZW50cyB0byB0cmFuc2FjdGlvbiBldmVudCcsXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkobWVhc3VyZW1lbnRzLCB1bmRlZmluZWQsIDIpLFxuICAgICAgICApO1xuICAgICAgdHJhbnNhY3Rpb24ubWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NwYW5UaW1lSW5wdXQodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5cbi8vIFdlIHdhbnQgdG8gZmlsdGVyIG91dCBhbnkgaW5jb21wbGV0ZSBTcGFuSlNPTiBvYmplY3RzXG5mdW5jdGlvbiBpc0Z1bGxGaW5pc2hlZFNwYW4oaW5wdXQpIHtcbiAgcmV0dXJuICEhaW5wdXQuc3RhcnRfdGltZXN0YW1wICYmICEhaW5wdXQudGltZXN0YW1wICYmICEhaW5wdXQuc3Bhbl9pZCAmJiAhIWlucHV0LnRyYWNlX2lkO1xufVxuXG4vKiogYFNlbnRyeVNwYW5gcyBjYW4gYmUgc2VudCBhcyBhIHN0YW5kYWxvbmUgc3BhbiByYXRoZXIgdGhhbiBiZWxvbmdpbmcgdG8gYSB0cmFuc2FjdGlvbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFsb25lU3BhbihzcGFuKSB7XG4gIHJldHVybiBzcGFuIGluc3RhbmNlb2YgU2VudHJ5U3BhbiAmJiBzcGFuLmlzU3RhbmRhbG9uZVNwYW4oKTtcbn1cblxuLyoqXG4gKiBTZW5kcyBhIGBTcGFuRW52ZWxvcGVgLlxuICpcbiAqIE5vdGU6IElmIHRoZSBlbnZlbG9wZSdzIHNwYW5zIGFyZSBkcm9wcGVkLCBlLmcuIHZpYSBgYmVmb3JlU2VuZFNwYW5gLFxuICogdGhlIGVudmVsb3BlIHdpbGwgbm90IGJlIHNlbnQgZWl0aGVyLlxuICovXG5mdW5jdGlvbiBzZW5kU3BhbkVudmVsb3BlKGVudmVsb3BlKSB7XG4gIGNvbnN0IGNsaWVudCA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG4gIGlmICghY2xpZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3Bhbkl0ZW1zID0gZW52ZWxvcGVbMV07XG4gIGlmICghc3Bhbkl0ZW1zIHx8IHNwYW5JdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICBjbGllbnQucmVjb3JkRHJvcHBlZEV2ZW50KCdiZWZvcmVfc2VuZCcsICdzcGFuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2VuZEVudmVsb3BlIHNob3VsZCBub3QgdGhyb3dcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICBjbGllbnQuc2VuZEVudmVsb3BlKGVudmVsb3BlKTtcbn1cblxuZXhwb3J0cy5TZW50cnlTcGFuID0gU2VudHJ5U3Bhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbnRyeVNwYW4uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sentrySpan.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js":(__unused_webpack_module,exports)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst SPAN_STATUS_UNSET = 0;\nconst SPAN_STATUS_OK = 1;\nconst SPAN_STATUS_ERROR = 2;\n\n/**\n * Converts a HTTP status code into a sentry status with a message.\n *\n * @param httpStatus The HTTP response status code.\n * @returns The span status or unknown_error.\n */\n// https://develop.sentry.dev/sdk/event-payloads/span/\nfunction getSpanStatusFromHttpCode(httpStatus) {\n  if (httpStatus < 400 && httpStatus >= 100) {\n    return { code: SPAN_STATUS_OK };\n  }\n\n  if (httpStatus >= 400 && httpStatus < 500) {\n    switch (httpStatus) {\n      case 401:\n        return { code: SPAN_STATUS_ERROR, message: 'unauthenticated' };\n      case 403:\n        return { code: SPAN_STATUS_ERROR, message: 'permission_denied' };\n      case 404:\n        return { code: SPAN_STATUS_ERROR, message: 'not_found' };\n      case 409:\n        return { code: SPAN_STATUS_ERROR, message: 'already_exists' };\n      case 413:\n        return { code: SPAN_STATUS_ERROR, message: 'failed_precondition' };\n      case 429:\n        return { code: SPAN_STATUS_ERROR, message: 'resource_exhausted' };\n      case 499:\n        return { code: SPAN_STATUS_ERROR, message: 'cancelled' };\n      default:\n        return { code: SPAN_STATUS_ERROR, message: 'invalid_argument' };\n    }\n  }\n\n  if (httpStatus >= 500 && httpStatus < 600) {\n    switch (httpStatus) {\n      case 501:\n        return { code: SPAN_STATUS_ERROR, message: 'unimplemented' };\n      case 503:\n        return { code: SPAN_STATUS_ERROR, message: 'unavailable' };\n      case 504:\n        return { code: SPAN_STATUS_ERROR, message: 'deadline_exceeded' };\n      default:\n        return { code: SPAN_STATUS_ERROR, message: 'internal_error' };\n    }\n  }\n\n  return { code: SPAN_STATUS_ERROR, message: 'unknown_error' };\n}\n\n/**\n * Sets the Http status attributes on the current span based on the http code.\n * Additionally, the span's status is updated, depending on the http code.\n */\nfunction setHttpStatus(span, httpStatus) {\n  span.setAttribute('http.response.status_code', httpStatus);\n\n  const spanStatus = getSpanStatusFromHttpCode(httpStatus);\n  if (spanStatus.message !== 'unknown_error') {\n    span.setStatus(spanStatus);\n  }\n}\n\nexports.SPAN_STATUS_ERROR = SPAN_STATUS_ERROR;\nexports.SPAN_STATUS_OK = SPAN_STATUS_OK;\nexports.SPAN_STATUS_UNSET = SPAN_STATUS_UNSET;\nexports.getSpanStatusFromHttpCode = getSpanStatusFromHttpCode;\nexports.setHttpStatus = setHttpStatus;\n//# sourceMappingURL=spanstatus.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYWNpbmcvc3BhbnN0YXR1cy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6QixpQ0FBaUM7QUFDakMscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXHRyYWNpbmdcXHNwYW5zdGF0dXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IFNQQU5fU1RBVFVTX1VOU0VUID0gMDtcbmNvbnN0IFNQQU5fU1RBVFVTX09LID0gMTtcbmNvbnN0IFNQQU5fU1RBVFVTX0VSUk9SID0gMjtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEhUVFAgc3RhdHVzIGNvZGUgaW50byBhIHNlbnRyeSBzdGF0dXMgd2l0aCBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGh0dHBTdGF0dXMgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuXG4gKiBAcmV0dXJucyBUaGUgc3BhbiBzdGF0dXMgb3IgdW5rbm93bl9lcnJvci5cbiAqL1xuLy8gaHR0cHM6Ly9kZXZlbG9wLnNlbnRyeS5kZXYvc2RrL2V2ZW50LXBheWxvYWRzL3NwYW4vXG5mdW5jdGlvbiBnZXRTcGFuU3RhdHVzRnJvbUh0dHBDb2RlKGh0dHBTdGF0dXMpIHtcbiAgaWYgKGh0dHBTdGF0dXMgPCA0MDAgJiYgaHR0cFN0YXR1cyA+PSAxMDApIHtcbiAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19PSyB9O1xuICB9XG5cbiAgaWYgKGh0dHBTdGF0dXMgPj0gNDAwICYmIGh0dHBTdGF0dXMgPCA1MDApIHtcbiAgICBzd2l0Y2ggKGh0dHBTdGF0dXMpIHtcbiAgICAgIGNhc2UgNDAxOlxuICAgICAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ3VuYXV0aGVudGljYXRlZCcgfTtcbiAgICAgIGNhc2UgNDAzOlxuICAgICAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ3Blcm1pc3Npb25fZGVuaWVkJyB9O1xuICAgICAgY2FzZSA0MDQ6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnbm90X2ZvdW5kJyB9O1xuICAgICAgY2FzZSA0MDk6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnYWxyZWFkeV9leGlzdHMnIH07XG4gICAgICBjYXNlIDQxMzpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICdmYWlsZWRfcHJlY29uZGl0aW9uJyB9O1xuICAgICAgY2FzZSA0Mjk6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAncmVzb3VyY2VfZXhoYXVzdGVkJyB9O1xuICAgICAgY2FzZSA0OTk6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnY2FuY2VsbGVkJyB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICdpbnZhbGlkX2FyZ3VtZW50JyB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChodHRwU3RhdHVzID49IDUwMCAmJiBodHRwU3RhdHVzIDwgNjAwKSB7XG4gICAgc3dpdGNoIChodHRwU3RhdHVzKSB7XG4gICAgICBjYXNlIDUwMTpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICd1bmltcGxlbWVudGVkJyB9O1xuICAgICAgY2FzZSA1MDM6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAndW5hdmFpbGFibGUnIH07XG4gICAgICBjYXNlIDUwNDpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICdkZWFkbGluZV9leGNlZWRlZCcgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnaW50ZXJuYWxfZXJyb3InIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICd1bmtub3duX2Vycm9yJyB9O1xufVxuXG4vKipcbiAqIFNldHMgdGhlIEh0dHAgc3RhdHVzIGF0dHJpYnV0ZXMgb24gdGhlIGN1cnJlbnQgc3BhbiBiYXNlZCBvbiB0aGUgaHR0cCBjb2RlLlxuICogQWRkaXRpb25hbGx5LCB0aGUgc3BhbidzIHN0YXR1cyBpcyB1cGRhdGVkLCBkZXBlbmRpbmcgb24gdGhlIGh0dHAgY29kZS5cbiAqL1xuZnVuY3Rpb24gc2V0SHR0cFN0YXR1cyhzcGFuLCBodHRwU3RhdHVzKSB7XG4gIHNwYW4uc2V0QXR0cmlidXRlKCdodHRwLnJlc3BvbnNlLnN0YXR1c19jb2RlJywgaHR0cFN0YXR1cyk7XG5cbiAgY29uc3Qgc3BhblN0YXR1cyA9IGdldFNwYW5TdGF0dXNGcm9tSHR0cENvZGUoaHR0cFN0YXR1cyk7XG4gIGlmIChzcGFuU3RhdHVzLm1lc3NhZ2UgIT09ICd1bmtub3duX2Vycm9yJykge1xuICAgIHNwYW4uc2V0U3RhdHVzKHNwYW5TdGF0dXMpO1xuICB9XG59XG5cbmV4cG9ydHMuU1BBTl9TVEFUVVNfRVJST1IgPSBTUEFOX1NUQVRVU19FUlJPUjtcbmV4cG9ydHMuU1BBTl9TVEFUVVNfT0sgPSBTUEFOX1NUQVRVU19PSztcbmV4cG9ydHMuU1BBTl9TVEFUVVNfVU5TRVQgPSBTUEFOX1NUQVRVU19VTlNFVDtcbmV4cG9ydHMuZ2V0U3BhblN0YXR1c0Zyb21IdHRwQ29kZSA9IGdldFNwYW5TdGF0dXNGcm9tSHR0cENvZGU7XG5leHBvcnRzLnNldEh0dHBTdGF0dXMgPSBzZXRIdHRwU3RhdHVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BhbnN0YXR1cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/trace.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst index = __webpack_require__(/*! ../asyncContext/index.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/asyncContext/index.js");\nconst carrier = __webpack_require__(/*! ../carrier.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/carrier.js");\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js");\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/semanticAttributes.js");\nconst handleCallbackErrors = __webpack_require__(/*! ../utils/handleCallbackErrors.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/handleCallbackErrors.js");\nconst hasSpansEnabled = __webpack_require__(/*! ../utils/hasSpansEnabled.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/hasSpansEnabled.js");\nconst parseSampleRate = __webpack_require__(/*! ../utils/parseSampleRate.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/parseSampleRate.js");\nconst spanOnScope = __webpack_require__(/*! ../utils/spanOnScope.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanOnScope.js");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils/spanUtils.js");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js");\nconst propagationContext = __webpack_require__(/*! ../utils-hoist/propagationContext.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/propagationContext.js");\nconst tracing = __webpack_require__(/*! ../utils-hoist/tracing.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/tracing.js");\nconst dynamicSamplingContext = __webpack_require__(/*! ./dynamicSamplingContext.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js");\nconst logSpans = __webpack_require__(/*! ./logSpans.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/logSpans.js");\nconst sampling = __webpack_require__(/*! ./sampling.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sampling.js");\nconst sentryNonRecordingSpan = __webpack_require__(/*! ./sentryNonRecordingSpan.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sentryNonRecordingSpan.js");\nconst sentrySpan = __webpack_require__(/*! ./sentrySpan.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/sentrySpan.js");\nconst spanstatus = __webpack_require__(/*! ./spanstatus.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js");\nconst utils = __webpack_require__(/*! ./utils.js */ "(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/utils.js");\n\n/* eslint-disable max-lines */\n\n\nconst SUPPRESS_TRACING_KEY = \'__SENTRY_SUPPRESS_TRACING__\';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You\'ll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpan(options, callback) {\n  const acs = getAcs();\n  if (acs.startSpan) {\n    return acs.startSpan(options, callback);\n  }\n\n  const spanArguments = parseSentrySpanArguments(options);\n  const { forceTransaction, parentSpan: customParentSpan, scope: customScope } = options;\n\n  // We still need to fork a potentially passed scope, as we set the active span on it\n  // and we need to ensure that it is cleaned up properly once the span ends.\n  const customForkedScope = customScope?.clone();\n\n  return currentScopes.withScope(customForkedScope, () => {\n    // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n    const wrapper = getActiveSpanWrapper(customParentSpan);\n\n    return wrapper(() => {\n      const scope = currentScopes.getCurrentScope();\n      const parentSpan = getParentSpan(scope);\n\n      const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan\n        ? new sentryNonRecordingSpan.SentryNonRecordingSpan()\n        : createChildOrRootSpan({\n            parentSpan,\n            spanArguments,\n            forceTransaction,\n            scope,\n          });\n\n      spanOnScope._setSpanForScope(scope, activeSpan);\n\n      return handleCallbackErrors.handleCallbackErrors(\n        () => callback(activeSpan),\n        () => {\n          // Only update the span status if it hasn\'t been changed yet, and the span is not yet finished\n          const { status } = spanUtils.spanToJSON(activeSpan);\n          if (activeSpan.isRecording() && (!status || status === \'ok\')) {\n            activeSpan.setStatus({ code: spanstatus.SPAN_STATUS_ERROR, message: \'internal_error\' });\n          }\n        },\n        () => {\n          activeSpan.end();\n        },\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a transaction/span, but does not finish the span\n * after the function is done automatically. Use `span.end()` to end the span.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You\'ll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpanManual(options, callback) {\n  const acs = getAcs();\n  if (acs.startSpanManual) {\n    return acs.startSpanManual(options, callback);\n  }\n\n  const spanArguments = parseSentrySpanArguments(options);\n  const { forceTransaction, parentSpan: customParentSpan, scope: customScope } = options;\n\n  const customForkedScope = customScope?.clone();\n\n  return currentScopes.withScope(customForkedScope, () => {\n    // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n    const wrapper = getActiveSpanWrapper(customParentSpan);\n\n    return wrapper(() => {\n      const scope = currentScopes.getCurrentScope();\n      const parentSpan = getParentSpan(scope);\n\n      const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan\n        ? new sentryNonRecordingSpan.SentryNonRecordingSpan()\n        : createChildOrRootSpan({\n            parentSpan,\n            spanArguments,\n            forceTransaction,\n            scope,\n          });\n\n      spanOnScope._setSpanForScope(scope, activeSpan);\n\n      return handleCallbackErrors.handleCallbackErrors(\n        // We pass the `finish` function to the callback, so the user can finish the span manually\n        // this is mainly here for historic purposes because previously, we instructed users to call\n        // `finish` instead of `span.end()` to also clean up the scope. Nowadays, calling `span.end()`\n        // or `finish` has the same effect and we simply leave it here to avoid breaking user code.\n        () => callback(activeSpan, () => activeSpan.end()),\n        () => {\n          // Only update the span status if it hasn\'t been changed yet, and the span is not yet finished\n          const { status } = spanUtils.spanToJSON(activeSpan);\n          if (activeSpan.isRecording() && (!status || status === \'ok\')) {\n            activeSpan.setStatus({ code: spanstatus.SPAN_STATUS_ERROR, message: \'internal_error\' });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startInactiveSpan(options) {\n  const acs = getAcs();\n  if (acs.startInactiveSpan) {\n    return acs.startInactiveSpan(options);\n  }\n\n  const spanArguments = parseSentrySpanArguments(options);\n  const { forceTransaction, parentSpan: customParentSpan } = options;\n\n  // If `options.scope` is defined, we use this as as a wrapper,\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = options.scope\n    ? (callback) => currentScopes.withScope(options.scope, callback)\n    : customParentSpan !== undefined\n      ? (callback) => withActiveSpan(customParentSpan, callback)\n      : (callback) => callback();\n\n  return wrapper(() => {\n    const scope = currentScopes.getCurrentScope();\n    const parentSpan = getParentSpan(scope);\n\n    const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n\n    if (shouldSkipSpan) {\n      return new sentryNonRecordingSpan.SentryNonRecordingSpan();\n    }\n\n    return createChildOrRootSpan({\n      parentSpan,\n      spanArguments,\n      forceTransaction,\n      scope,\n    });\n  });\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name="sentry-trace">`\n * and `<meta name="baggage">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n */\nconst continueTrace = (\n  options\n\n,\n  callback,\n) => {\n  const carrier$1 = carrier.getMainCarrier();\n  const acs = index.getAsyncContextStrategy(carrier$1);\n  if (acs.continueTrace) {\n    return acs.continueTrace(options, callback);\n  }\n\n  const { sentryTrace, baggage } = options;\n\n  return currentScopes.withScope(scope => {\n    const propagationContext = tracing.propagationContextFromHeaders(sentryTrace, baggage);\n    scope.setPropagationContext(propagationContext);\n    return callback();\n  });\n};\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will not be attached to a parent span.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nfunction withActiveSpan(span, callback) {\n  const acs = getAcs();\n  if (acs.withActiveSpan) {\n    return acs.withActiveSpan(span, callback);\n  }\n\n  return currentScopes.withScope(scope => {\n    spanOnScope._setSpanForScope(scope, span || undefined);\n    return callback(scope);\n  });\n}\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nfunction suppressTracing(callback) {\n  const acs = getAcs();\n\n  if (acs.suppressTracing) {\n    return acs.suppressTracing(callback);\n  }\n\n  return currentScopes.withScope(scope => {\n    // Note: We do not wait for the callback to finish before we reset the metadata\n    // the reason for this is that otherwise, in the browser this can lead to very weird behavior\n    // as there is only a single top scope, if the callback takes longer to finish,\n    // other, unrelated spans may also be suppressed, which we do not want\n    // so instead, we only suppress tracing synchronoysly in the browser\n    scope.setSDKProcessingMetadata({ [SUPPRESS_TRACING_KEY]: true });\n    const res = callback();\n    scope.setSDKProcessingMetadata({ [SUPPRESS_TRACING_KEY]: undefined });\n    return res;\n  });\n}\n\n/**\n * Starts a new trace for the duration of the provided callback. Spans started within the\n * callback will be part of the new trace instead of a potentially previously started trace.\n *\n * Important: Only use this function if you want to override the default trace lifetime and\n * propagation mechanism of the SDK for the duration and scope of the provided callback.\n * The newly created trace will also be the root of a new distributed trace, for example if\n * you make http requests within the callback.\n * This function might be useful if the operation you want to instrument should not be part\n * of a potentially ongoing trace.\n *\n * Default behavior:\n * - Server-side: A new trace is started for each incoming request.\n * - Browser: A new trace is started for each page our route. Navigating to a new route\n *            or page will automatically create a new trace.\n */\nfunction startNewTrace(callback) {\n  return currentScopes.withScope(scope => {\n    scope.setPropagationContext({\n      traceId: propagationContext.generateTraceId(),\n      sampleRand: Math.random(),\n    });\n    debugBuild.DEBUG_BUILD && logger.logger.info(`Starting a new trace with id ${scope.getPropagationContext().traceId}`);\n    return withActiveSpan(null, callback);\n  });\n}\n\nfunction createChildOrRootSpan({\n  parentSpan,\n  spanArguments,\n  forceTransaction,\n  scope,\n}\n\n) {\n  if (!hasSpansEnabled.hasSpansEnabled()) {\n    const span = new sentryNonRecordingSpan.SentryNonRecordingSpan();\n\n    // If this is a root span, we ensure to freeze a DSC\n    // So we can have at least partial data here\n    if (forceTransaction || !parentSpan) {\n      const dsc = {\n        sampled: \'false\',\n        sample_rate: \'0\',\n        transaction: spanArguments.name,\n        ...dynamicSamplingContext.getDynamicSamplingContextFromSpan(span),\n      } ;\n      dynamicSamplingContext.freezeDscOnSpan(span, dsc);\n    }\n\n    return span;\n  }\n\n  const isolationScope = currentScopes.getIsolationScope();\n\n  let span;\n  if (parentSpan && !forceTransaction) {\n    span = _startChildSpan(parentSpan, scope, spanArguments);\n    spanUtils.addChildSpanToSpan(parentSpan, span);\n  } else if (parentSpan) {\n    // If we forced a transaction but have a parent span, make sure to continue from the parent span, not the scope\n    const dsc = dynamicSamplingContext.getDynamicSamplingContextFromSpan(parentSpan);\n    const { traceId, spanId: parentSpanId } = parentSpan.spanContext();\n    const parentSampled = spanUtils.spanIsSampled(parentSpan);\n\n    span = _startRootSpan(\n      {\n        traceId,\n        parentSpanId,\n        ...spanArguments,\n      },\n      scope,\n      parentSampled,\n    );\n\n    dynamicSamplingContext.freezeDscOnSpan(span, dsc);\n  } else {\n    const {\n      traceId,\n      dsc,\n      parentSpanId,\n      sampled: parentSampled,\n    } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext(),\n    };\n\n    span = _startRootSpan(\n      {\n        traceId,\n        parentSpanId,\n        ...spanArguments,\n      },\n      scope,\n      parentSampled,\n    );\n\n    if (dsc) {\n      dynamicSamplingContext.freezeDscOnSpan(span, dsc);\n    }\n  }\n\n  logSpans.logSpanStart(span);\n\n  utils.setCapturedScopesOnSpan(span, scope, isolationScope);\n\n  return span;\n}\n\n/**\n * This converts StartSpanOptions to SentrySpanArguments.\n * For the most part (for now) we accept the same options,\n * but some of them need to be transformed.\n */\nfunction parseSentrySpanArguments(options) {\n  const exp = options.experimental || {};\n  const initialCtx = {\n    isStandalone: exp.standalone,\n    ...options,\n  };\n\n  if (options.startTime) {\n    const ctx = { ...initialCtx };\n    ctx.startTimestamp = spanUtils.spanTimeInputToSeconds(options.startTime);\n    delete ctx.startTime;\n    return ctx;\n  }\n\n  return initialCtx;\n}\n\nfunction getAcs() {\n  const carrier$1 = carrier.getMainCarrier();\n  return index.getAsyncContextStrategy(carrier$1);\n}\n\nfunction _startRootSpan(spanArguments, scope, parentSampled) {\n  const client = currentScopes.getClient();\n  const options = client?.getOptions() || {};\n\n  const { name = \'\' } = spanArguments;\n\n  const mutableSpanSamplingData = { spanAttributes: { ...spanArguments.attributes }, spanName: name, parentSampled };\n\n  // we don\'t care about the decision for the moment; this is just a placeholder\n  client?.emit(\'beforeSampling\', mutableSpanSamplingData, { decision: false });\n\n  // If hook consumers override the parentSampled flag, we will use that value instead of the actual one\n  const finalParentSampled = mutableSpanSamplingData.parentSampled ?? parentSampled;\n  const finalAttributes = mutableSpanSamplingData.spanAttributes;\n\n  const currentPropagationContext = scope.getPropagationContext();\n  const [sampled, sampleRate, localSampleRateWasApplied] = scope.getScopeData().sdkProcessingMetadata[\n    SUPPRESS_TRACING_KEY\n  ]\n    ? [false]\n    : sampling.sampleSpan(\n        options,\n        {\n          name,\n          parentSampled: finalParentSampled,\n          attributes: finalAttributes,\n          parentSampleRate: parseSampleRate.parseSampleRate(currentPropagationContext.dsc?.sample_rate),\n        },\n        currentPropagationContext.sampleRand,\n      );\n\n  const rootSpan = new sentrySpan.SentrySpan({\n    ...spanArguments,\n    attributes: {\n      [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: \'custom\',\n      [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]:\n        sampleRate !== undefined && localSampleRateWasApplied ? sampleRate : undefined,\n      ...finalAttributes,\n    },\n    sampled,\n  });\n\n  if (!sampled && client) {\n    debugBuild.DEBUG_BUILD && logger.logger.log(\'[Tracing] Discarding root span because its trace was not chosen to be sampled.\');\n    client.recordDroppedEvent(\'sample_rate\', \'transaction\');\n  }\n\n  if (client) {\n    client.emit(\'spanStart\', rootSpan);\n  }\n\n  return rootSpan;\n}\n\n/**\n * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.\n * This inherits the sampling decision from the parent span.\n */\nfunction _startChildSpan(parentSpan, scope, spanArguments) {\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? false : spanUtils.spanIsSampled(parentSpan);\n\n  const childSpan = sampled\n    ? new sentrySpan.SentrySpan({\n        ...spanArguments,\n        parentSpanId: spanId,\n        traceId,\n        sampled,\n      })\n    : new sentryNonRecordingSpan.SentryNonRecordingSpan({ traceId });\n\n  spanUtils.addChildSpanToSpan(parentSpan, childSpan);\n\n  const client = currentScopes.getClient();\n  if (client) {\n    client.emit(\'spanStart\', childSpan);\n    // If it has an endTimestamp, it\'s already ended\n    if (spanArguments.endTimestamp) {\n      client.emit(\'spanEnd\', childSpan);\n    }\n  }\n\n  return childSpan;\n}\n\nfunction getParentSpan(scope) {\n  const span = spanOnScope._getSpanForScope(scope) ;\n\n  if (!span) {\n    return undefined;\n  }\n\n  const client = currentScopes.getClient();\n  const options = client ? client.getOptions() : {};\n  if (options.parentSpanIsAlwaysRootSpan) {\n    return spanUtils.getRootSpan(span) ;\n  }\n\n  return span;\n}\n\nfunction getActiveSpanWrapper(parentSpan) {\n  return parentSpan !== undefined\n    ? (callback) => {\n        return withActiveSpan(parentSpan, callback);\n      }\n    : (callback) => callback();\n}\n\nexports.continueTrace = continueTrace;\nexports.startInactiveSpan = startInactiveSpan;\nexports.startNewTrace = startNewTrace;\nexports.startSpan = startSpan;\nexports.startSpanManual = startSpanManual;\nexports.suppressTracing = suppressTracing;\nexports.withActiveSpan = withActiveSpan;\n//# sourceMappingURL=trace.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYWNpbmcvdHJhY2UuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsY0FBYyxtQkFBTyxDQUFDLHNJQUEwQjtBQUNoRCxnQkFBZ0IsbUJBQU8sQ0FBQyxnSEFBZTtBQUN2QyxzQkFBc0IsbUJBQU8sQ0FBQyw0SEFBcUI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsd0hBQW1CO0FBQzlDLDJCQUEyQixtQkFBTyxDQUFDLHNJQUEwQjtBQUM3RCw2QkFBNkIsbUJBQU8sQ0FBQyxzSkFBa0M7QUFDdkUsd0JBQXdCLG1CQUFPLENBQUMsNElBQTZCO0FBQzdELHdCQUF3QixtQkFBTyxDQUFDLDRJQUE2QjtBQUM3RCxvQkFBb0IsbUJBQU8sQ0FBQyxvSUFBeUI7QUFDckQsa0JBQWtCLG1CQUFPLENBQUMsZ0lBQXVCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxzSUFBMEI7QUFDakQsMkJBQTJCLG1CQUFPLENBQUMsOEpBQXNDO0FBQ3pFLGdCQUFnQixtQkFBTyxDQUFDLHdJQUEyQjtBQUNuRCwrQkFBK0IsbUJBQU8sQ0FBQyxxSkFBNkI7QUFDcEUsaUJBQWlCLG1CQUFPLENBQUMseUhBQWU7QUFDeEMsaUJBQWlCLG1CQUFPLENBQUMseUhBQWU7QUFDeEMsK0JBQStCLG1CQUFPLENBQUMscUpBQTZCO0FBQ3BFLG1CQUFtQixtQkFBTyxDQUFDLDZIQUFpQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyw2SEFBaUI7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLG1IQUFZOztBQUVsQzs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx3QkFBd0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxxRUFBcUU7O0FBRS9FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxtQ0FBbUMsK0RBQStEO0FBQ2xHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUscUVBQXFFOztBQUUvRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBLG1DQUFtQywrREFBK0Q7QUFDbEc7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGlEQUFpRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsdUJBQXVCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4QkFBOEI7QUFDbkU7QUFDQSxxQ0FBcUMsbUNBQW1DO0FBQ3hFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpRkFBaUYsc0NBQXNDO0FBQ3ZIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxZQUFZLGdDQUFnQztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxZQUFZOztBQUV0QixvQ0FBb0Msa0JBQWtCLDZCQUE2Qjs7QUFFbkYsc0RBQXNEO0FBQ3RELDREQUE0RCxpQkFBaUI7O0FBRTdFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwwREFBMEQsU0FBUzs7QUFFbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcdHJhY2luZ1xcdHJhY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGluZGV4ID0gcmVxdWlyZSgnLi4vYXN5bmNDb250ZXh0L2luZGV4LmpzJyk7XG5jb25zdCBjYXJyaWVyID0gcmVxdWlyZSgnLi4vY2Fycmllci5qcycpO1xuY29uc3QgY3VycmVudFNjb3BlcyA9IHJlcXVpcmUoJy4uL2N1cnJlbnRTY29wZXMuanMnKTtcbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3Qgc2VtYW50aWNBdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi4vc2VtYW50aWNBdHRyaWJ1dGVzLmpzJyk7XG5jb25zdCBoYW5kbGVDYWxsYmFja0Vycm9ycyA9IHJlcXVpcmUoJy4uL3V0aWxzL2hhbmRsZUNhbGxiYWNrRXJyb3JzLmpzJyk7XG5jb25zdCBoYXNTcGFuc0VuYWJsZWQgPSByZXF1aXJlKCcuLi91dGlscy9oYXNTcGFuc0VuYWJsZWQuanMnKTtcbmNvbnN0IHBhcnNlU2FtcGxlUmF0ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL3BhcnNlU2FtcGxlUmF0ZS5qcycpO1xuY29uc3Qgc3Bhbk9uU2NvcGUgPSByZXF1aXJlKCcuLi91dGlscy9zcGFuT25TY29wZS5qcycpO1xuY29uc3Qgc3BhblV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvc3BhblV0aWxzLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3Byb3BhZ2F0aW9uQ29udGV4dC5qcycpO1xuY29uc3QgdHJhY2luZyA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3RyYWNpbmcuanMnKTtcbmNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSByZXF1aXJlKCcuL2R5bmFtaWNTYW1wbGluZ0NvbnRleHQuanMnKTtcbmNvbnN0IGxvZ1NwYW5zID0gcmVxdWlyZSgnLi9sb2dTcGFucy5qcycpO1xuY29uc3Qgc2FtcGxpbmcgPSByZXF1aXJlKCcuL3NhbXBsaW5nLmpzJyk7XG5jb25zdCBzZW50cnlOb25SZWNvcmRpbmdTcGFuID0gcmVxdWlyZSgnLi9zZW50cnlOb25SZWNvcmRpbmdTcGFuLmpzJyk7XG5jb25zdCBzZW50cnlTcGFuID0gcmVxdWlyZSgnLi9zZW50cnlTcGFuLmpzJyk7XG5jb25zdCBzcGFuc3RhdHVzID0gcmVxdWlyZSgnLi9zcGFuc3RhdHVzLmpzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxpbmVzICovXG5cblxuY29uc3QgU1VQUFJFU1NfVFJBQ0lOR19LRVkgPSAnX19TRU5UUllfU1VQUFJFU1NfVFJBQ0lOR19fJztcblxuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIHdpdGggYSB0cmFuc2FjdGlvbi9zcGFuIGFuZCBmaW5pc2hlcyB0aGUgc3BhbiBhZnRlciB0aGUgZnVuY3Rpb24gaXMgZG9uZS5cbiAqIFRoZSBjcmVhdGVkIHNwYW4gaXMgdGhlIGFjdGl2ZSBzcGFuIGFuZCB3aWxsIGJlIHVzZWQgYXMgcGFyZW50IGJ5IG90aGVyIHNwYW5zIGNyZWF0ZWQgaW5zaWRlIHRoZSBmdW5jdGlvblxuICogYW5kIGNhbiBiZSBhY2Nlc3NlZCB2aWEgYFNlbnRyeS5nZXRBY3RpdmVTcGFuKClgLCBhcyBsb25nIGFzIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aGlsZSB0aGUgc2NvcGUgaXMgYWN0aXZlLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIHNwYW4gdGhhdCBpcyBub3Qgc2V0IGFzIGFjdGl2ZSwgdXNlIHtAbGluayBzdGFydEluYWN0aXZlU3Bhbn0uXG4gKlxuICogWW91J2xsIGFsd2F5cyBnZXQgYSBzcGFuIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssXG4gKiBpdCBtYXkganVzdCBiZSBhIG5vbi1yZWNvcmRpbmcgc3BhbiBpZiB0aGUgc3BhbiBpcyBub3Qgc2FtcGxlZCBvciBpZiB0cmFjaW5nIGlzIGRpc2FibGVkLlxuICovXG5mdW5jdGlvbiBzdGFydFNwYW4ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3QgYWNzID0gZ2V0QWNzKCk7XG4gIGlmIChhY3Muc3RhcnRTcGFuKSB7XG4gICAgcmV0dXJuIGFjcy5zdGFydFNwYW4ob3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG5cbiAgY29uc3Qgc3BhbkFyZ3VtZW50cyA9IHBhcnNlU2VudHJ5U3BhbkFyZ3VtZW50cyhvcHRpb25zKTtcbiAgY29uc3QgeyBmb3JjZVRyYW5zYWN0aW9uLCBwYXJlbnRTcGFuOiBjdXN0b21QYXJlbnRTcGFuLCBzY29wZTogY3VzdG9tU2NvcGUgfSA9IG9wdGlvbnM7XG5cbiAgLy8gV2Ugc3RpbGwgbmVlZCB0byBmb3JrIGEgcG90ZW50aWFsbHkgcGFzc2VkIHNjb3BlLCBhcyB3ZSBzZXQgdGhlIGFjdGl2ZSBzcGFuIG9uIGl0XG4gIC8vIGFuZCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IGl0IGlzIGNsZWFuZWQgdXAgcHJvcGVybHkgb25jZSB0aGUgc3BhbiBlbmRzLlxuICBjb25zdCBjdXN0b21Gb3JrZWRTY29wZSA9IGN1c3RvbVNjb3BlPy5jbG9uZSgpO1xuXG4gIHJldHVybiBjdXJyZW50U2NvcGVzLndpdGhTY29wZShjdXN0b21Gb3JrZWRTY29wZSwgKCkgPT4ge1xuICAgIC8vIElmIGBvcHRpb25zLnBhcmVudFNwYW5gIGlzIGRlZmluZWQsIHdlIHdhbnQgdG8gd3JhcCB0aGUgY2FsbGJhY2sgaW4gYHdpdGhBY3RpdmVTcGFuYFxuICAgIGNvbnN0IHdyYXBwZXIgPSBnZXRBY3RpdmVTcGFuV3JhcHBlcihjdXN0b21QYXJlbnRTcGFuKTtcblxuICAgIHJldHVybiB3cmFwcGVyKCgpID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlID0gY3VycmVudFNjb3Blcy5nZXRDdXJyZW50U2NvcGUoKTtcbiAgICAgIGNvbnN0IHBhcmVudFNwYW4gPSBnZXRQYXJlbnRTcGFuKHNjb3BlKTtcblxuICAgICAgY29uc3Qgc2hvdWxkU2tpcFNwYW4gPSBvcHRpb25zLm9ubHlJZlBhcmVudCAmJiAhcGFyZW50U3BhbjtcbiAgICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSBzaG91bGRTa2lwU3BhblxuICAgICAgICA/IG5ldyBzZW50cnlOb25SZWNvcmRpbmdTcGFuLlNlbnRyeU5vblJlY29yZGluZ1NwYW4oKVxuICAgICAgICA6IGNyZWF0ZUNoaWxkT3JSb290U3Bhbih7XG4gICAgICAgICAgICBwYXJlbnRTcGFuLFxuICAgICAgICAgICAgc3BhbkFyZ3VtZW50cyxcbiAgICAgICAgICAgIGZvcmNlVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICB9KTtcblxuICAgICAgc3Bhbk9uU2NvcGUuX3NldFNwYW5Gb3JTY29wZShzY29wZSwgYWN0aXZlU3Bhbik7XG5cbiAgICAgIHJldHVybiBoYW5kbGVDYWxsYmFja0Vycm9ycy5oYW5kbGVDYWxsYmFja0Vycm9ycyhcbiAgICAgICAgKCkgPT4gY2FsbGJhY2soYWN0aXZlU3BhbiksXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgc3BhbiBzdGF0dXMgaWYgaXQgaGFzbid0IGJlZW4gY2hhbmdlZCB5ZXQsIGFuZCB0aGUgc3BhbiBpcyBub3QgeWV0IGZpbmlzaGVkXG4gICAgICAgICAgY29uc3QgeyBzdGF0dXMgfSA9IHNwYW5VdGlscy5zcGFuVG9KU09OKGFjdGl2ZVNwYW4pO1xuICAgICAgICAgIGlmIChhY3RpdmVTcGFuLmlzUmVjb3JkaW5nKCkgJiYgKCFzdGF0dXMgfHwgc3RhdHVzID09PSAnb2snKSkge1xuICAgICAgICAgICAgYWN0aXZlU3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBzcGFuc3RhdHVzLlNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnaW50ZXJuYWxfZXJyb3InIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGFjdGl2ZVNwYW4uZW5kKCk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGBTZW50cnkuc3RhcnRTcGFuYC4gV3JhcHMgYSBmdW5jdGlvbiB3aXRoIGEgdHJhbnNhY3Rpb24vc3BhbiwgYnV0IGRvZXMgbm90IGZpbmlzaCB0aGUgc3BhblxuICogYWZ0ZXIgdGhlIGZ1bmN0aW9uIGlzIGRvbmUgYXV0b21hdGljYWxseS4gVXNlIGBzcGFuLmVuZCgpYCB0byBlbmQgdGhlIHNwYW4uXG4gKlxuICogVGhlIGNyZWF0ZWQgc3BhbiBpcyB0aGUgYWN0aXZlIHNwYW4gYW5kIHdpbGwgYmUgdXNlZCBhcyBwYXJlbnQgYnkgb3RoZXIgc3BhbnMgY3JlYXRlZCBpbnNpZGUgdGhlIGZ1bmN0aW9uXG4gKiBhbmQgY2FuIGJlIGFjY2Vzc2VkIHZpYSBgU2VudHJ5LmdldEFjdGl2ZVNwYW4oKWAsIGFzIGxvbmcgYXMgdGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdoaWxlIHRoZSBzY29wZSBpcyBhY3RpdmUuXG4gKlxuICogWW91J2xsIGFsd2F5cyBnZXQgYSBzcGFuIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssXG4gKiBpdCBtYXkganVzdCBiZSBhIG5vbi1yZWNvcmRpbmcgc3BhbiBpZiB0aGUgc3BhbiBpcyBub3Qgc2FtcGxlZCBvciBpZiB0cmFjaW5nIGlzIGRpc2FibGVkLlxuICovXG5mdW5jdGlvbiBzdGFydFNwYW5NYW51YWwob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3QgYWNzID0gZ2V0QWNzKCk7XG4gIGlmIChhY3Muc3RhcnRTcGFuTWFudWFsKSB7XG4gICAgcmV0dXJuIGFjcy5zdGFydFNwYW5NYW51YWwob3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG5cbiAgY29uc3Qgc3BhbkFyZ3VtZW50cyA9IHBhcnNlU2VudHJ5U3BhbkFyZ3VtZW50cyhvcHRpb25zKTtcbiAgY29uc3QgeyBmb3JjZVRyYW5zYWN0aW9uLCBwYXJlbnRTcGFuOiBjdXN0b21QYXJlbnRTcGFuLCBzY29wZTogY3VzdG9tU2NvcGUgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgY3VzdG9tRm9ya2VkU2NvcGUgPSBjdXN0b21TY29wZT8uY2xvbmUoKTtcblxuICByZXR1cm4gY3VycmVudFNjb3Blcy53aXRoU2NvcGUoY3VzdG9tRm9ya2VkU2NvcGUsICgpID0+IHtcbiAgICAvLyBJZiBgb3B0aW9ucy5wYXJlbnRTcGFuYCBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIHdyYXAgdGhlIGNhbGxiYWNrIGluIGB3aXRoQWN0aXZlU3BhbmBcbiAgICBjb25zdCB3cmFwcGVyID0gZ2V0QWN0aXZlU3BhbldyYXBwZXIoY3VzdG9tUGFyZW50U3Bhbik7XG5cbiAgICByZXR1cm4gd3JhcHBlcigoKSA9PiB7XG4gICAgICBjb25zdCBzY29wZSA9IGN1cnJlbnRTY29wZXMuZ2V0Q3VycmVudFNjb3BlKCk7XG4gICAgICBjb25zdCBwYXJlbnRTcGFuID0gZ2V0UGFyZW50U3BhbihzY29wZSk7XG5cbiAgICAgIGNvbnN0IHNob3VsZFNraXBTcGFuID0gb3B0aW9ucy5vbmx5SWZQYXJlbnQgJiYgIXBhcmVudFNwYW47XG4gICAgICBjb25zdCBhY3RpdmVTcGFuID0gc2hvdWxkU2tpcFNwYW5cbiAgICAgICAgPyBuZXcgc2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbi5TZW50cnlOb25SZWNvcmRpbmdTcGFuKClcbiAgICAgICAgOiBjcmVhdGVDaGlsZE9yUm9vdFNwYW4oe1xuICAgICAgICAgICAgcGFyZW50U3BhbixcbiAgICAgICAgICAgIHNwYW5Bcmd1bWVudHMsXG4gICAgICAgICAgICBmb3JjZVRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgfSk7XG5cbiAgICAgIHNwYW5PblNjb3BlLl9zZXRTcGFuRm9yU2NvcGUoc2NvcGUsIGFjdGl2ZVNwYW4pO1xuXG4gICAgICByZXR1cm4gaGFuZGxlQ2FsbGJhY2tFcnJvcnMuaGFuZGxlQ2FsbGJhY2tFcnJvcnMoXG4gICAgICAgIC8vIFdlIHBhc3MgdGhlIGBmaW5pc2hgIGZ1bmN0aW9uIHRvIHRoZSBjYWxsYmFjaywgc28gdGhlIHVzZXIgY2FuIGZpbmlzaCB0aGUgc3BhbiBtYW51YWxseVxuICAgICAgICAvLyB0aGlzIGlzIG1haW5seSBoZXJlIGZvciBoaXN0b3JpYyBwdXJwb3NlcyBiZWNhdXNlIHByZXZpb3VzbHksIHdlIGluc3RydWN0ZWQgdXNlcnMgdG8gY2FsbFxuICAgICAgICAvLyBgZmluaXNoYCBpbnN0ZWFkIG9mIGBzcGFuLmVuZCgpYCB0byBhbHNvIGNsZWFuIHVwIHRoZSBzY29wZS4gTm93YWRheXMsIGNhbGxpbmcgYHNwYW4uZW5kKClgXG4gICAgICAgIC8vIG9yIGBmaW5pc2hgIGhhcyB0aGUgc2FtZSBlZmZlY3QgYW5kIHdlIHNpbXBseSBsZWF2ZSBpdCBoZXJlIHRvIGF2b2lkIGJyZWFraW5nIHVzZXIgY29kZS5cbiAgICAgICAgKCkgPT4gY2FsbGJhY2soYWN0aXZlU3BhbiwgKCkgPT4gYWN0aXZlU3Bhbi5lbmQoKSksXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgc3BhbiBzdGF0dXMgaWYgaXQgaGFzbid0IGJlZW4gY2hhbmdlZCB5ZXQsIGFuZCB0aGUgc3BhbiBpcyBub3QgeWV0IGZpbmlzaGVkXG4gICAgICAgICAgY29uc3QgeyBzdGF0dXMgfSA9IHNwYW5VdGlscy5zcGFuVG9KU09OKGFjdGl2ZVNwYW4pO1xuICAgICAgICAgIGlmIChhY3RpdmVTcGFuLmlzUmVjb3JkaW5nKCkgJiYgKCFzdGF0dXMgfHwgc3RhdHVzID09PSAnb2snKSkge1xuICAgICAgICAgICAgYWN0aXZlU3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBzcGFuc3RhdHVzLlNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnaW50ZXJuYWxfZXJyb3InIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzcGFuLiBUaGlzIHNwYW4gaXMgbm90IHNldCBhcyBhY3RpdmUsIHNvIHdpbGwgbm90IGdldCBhdXRvbWF0aWMgaW5zdHJ1bWVudGF0aW9uIHNwYW5zXG4gKiBhcyBjaGlsZHJlbiBvciBiZSBhYmxlIHRvIGJlIGFjY2Vzc2VkIHZpYSBgU2VudHJ5LmdldEFjdGl2ZVNwYW4oKWAuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgc3BhbiB0aGF0IGlzIHNldCBhcyBhY3RpdmUsIHVzZSB7QGxpbmsgc3RhcnRTcGFufS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIHJldHVybiBhIHNwYW4sXG4gKiBpdCBtYXkganVzdCBiZSBhIG5vbi1yZWNvcmRpbmcgc3BhbiBpZiB0aGUgc3BhbiBpcyBub3Qgc2FtcGxlZCBvciBpZiB0cmFjaW5nIGlzIGRpc2FibGVkLlxuICovXG5mdW5jdGlvbiBzdGFydEluYWN0aXZlU3BhbihvcHRpb25zKSB7XG4gIGNvbnN0IGFjcyA9IGdldEFjcygpO1xuICBpZiAoYWNzLnN0YXJ0SW5hY3RpdmVTcGFuKSB7XG4gICAgcmV0dXJuIGFjcy5zdGFydEluYWN0aXZlU3BhbihvcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN0IHNwYW5Bcmd1bWVudHMgPSBwYXJzZVNlbnRyeVNwYW5Bcmd1bWVudHMob3B0aW9ucyk7XG4gIGNvbnN0IHsgZm9yY2VUcmFuc2FjdGlvbiwgcGFyZW50U3BhbjogY3VzdG9tUGFyZW50U3BhbiB9ID0gb3B0aW9ucztcblxuICAvLyBJZiBgb3B0aW9ucy5zY29wZWAgaXMgZGVmaW5lZCwgd2UgdXNlIHRoaXMgYXMgYXMgYSB3cmFwcGVyLFxuICAvLyBJZiBgb3B0aW9ucy5wYXJlbnRTcGFuYCBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIHdyYXAgdGhlIGNhbGxiYWNrIGluIGB3aXRoQWN0aXZlU3BhbmBcbiAgY29uc3Qgd3JhcHBlciA9IG9wdGlvbnMuc2NvcGVcbiAgICA/IChjYWxsYmFjaykgPT4gY3VycmVudFNjb3Blcy53aXRoU2NvcGUob3B0aW9ucy5zY29wZSwgY2FsbGJhY2spXG4gICAgOiBjdXN0b21QYXJlbnRTcGFuICE9PSB1bmRlZmluZWRcbiAgICAgID8gKGNhbGxiYWNrKSA9PiB3aXRoQWN0aXZlU3BhbihjdXN0b21QYXJlbnRTcGFuLCBjYWxsYmFjaylcbiAgICAgIDogKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpO1xuXG4gIHJldHVybiB3cmFwcGVyKCgpID0+IHtcbiAgICBjb25zdCBzY29wZSA9IGN1cnJlbnRTY29wZXMuZ2V0Q3VycmVudFNjb3BlKCk7XG4gICAgY29uc3QgcGFyZW50U3BhbiA9IGdldFBhcmVudFNwYW4oc2NvcGUpO1xuXG4gICAgY29uc3Qgc2hvdWxkU2tpcFNwYW4gPSBvcHRpb25zLm9ubHlJZlBhcmVudCAmJiAhcGFyZW50U3BhbjtcblxuICAgIGlmIChzaG91bGRTa2lwU3Bhbikge1xuICAgICAgcmV0dXJuIG5ldyBzZW50cnlOb25SZWNvcmRpbmdTcGFuLlNlbnRyeU5vblJlY29yZGluZ1NwYW4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hpbGRPclJvb3RTcGFuKHtcbiAgICAgIHBhcmVudFNwYW4sXG4gICAgICBzcGFuQXJndW1lbnRzLFxuICAgICAgZm9yY2VUcmFuc2FjdGlvbixcbiAgICAgIHNjb3BlLFxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb250aW51ZSBhIHRyYWNlIGZyb20gYHNlbnRyeS10cmFjZWAgYW5kIGBiYWdnYWdlYCB2YWx1ZXMuXG4gKiBUaGVzZSB2YWx1ZXMgY2FuIGJlIG9idGFpbmVkIGZyb20gaW5jb21pbmcgcmVxdWVzdCBoZWFkZXJzLCBvciBpbiB0aGUgYnJvd3NlciBmcm9tIGA8bWV0YSBuYW1lPVwic2VudHJ5LXRyYWNlXCI+YFxuICogYW5kIGA8bWV0YSBuYW1lPVwiYmFnZ2FnZVwiPmAgSFRNTCB0YWdzLlxuICpcbiAqIFNwYW5zIHN0YXJ0ZWQgd2l0aCBgc3RhcnRTcGFuYCwgYHN0YXJ0U3Bhbk1hbnVhbGAgYW5kIGBzdGFydEluYWN0aXZlU3BhbmAsIHdpdGhpbiB0aGUgY2FsbGJhY2sgd2lsbCBhdXRvbWF0aWNhbGx5XG4gKiBiZSBhdHRhY2hlZCB0byB0aGUgaW5jb21pbmcgdHJhY2UuXG4gKi9cbmNvbnN0IGNvbnRpbnVlVHJhY2UgPSAoXG4gIG9wdGlvbnNcblxuLFxuICBjYWxsYmFjayxcbikgPT4ge1xuICBjb25zdCBjYXJyaWVyJDEgPSBjYXJyaWVyLmdldE1haW5DYXJyaWVyKCk7XG4gIGNvbnN0IGFjcyA9IGluZGV4LmdldEFzeW5jQ29udGV4dFN0cmF0ZWd5KGNhcnJpZXIkMSk7XG4gIGlmIChhY3MuY29udGludWVUcmFjZSkge1xuICAgIHJldHVybiBhY3MuY29udGludWVUcmFjZShvcHRpb25zLCBjYWxsYmFjayk7XG4gIH1cblxuICBjb25zdCB7IHNlbnRyeVRyYWNlLCBiYWdnYWdlIH0gPSBvcHRpb25zO1xuXG4gIHJldHVybiBjdXJyZW50U2NvcGVzLndpdGhTY29wZShzY29wZSA9PiB7XG4gICAgY29uc3QgcHJvcGFnYXRpb25Db250ZXh0ID0gdHJhY2luZy5wcm9wYWdhdGlvbkNvbnRleHRGcm9tSGVhZGVycyhzZW50cnlUcmFjZSwgYmFnZ2FnZSk7XG4gICAgc2NvcGUuc2V0UHJvcGFnYXRpb25Db250ZXh0KHByb3BhZ2F0aW9uQ29udGV4dCk7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBGb3JrcyB0aGUgY3VycmVudCBzY29wZSBhbmQgc2V0cyB0aGUgcHJvdmlkZWQgc3BhbiBhcyBhY3RpdmUgc3BhbiBpbiB0aGUgY29udGV4dCBvZiB0aGUgcHJvdmlkZWQgY2FsbGJhY2suIENhbiBiZVxuICogcGFzc2VkIGBudWxsYCB0byBzdGFydCBhbiBlbnRpcmVseSBuZXcgc3BhbiB0cmVlLlxuICpcbiAqIEBwYXJhbSBzcGFuIFNwYW5zIHN0YXJ0ZWQgaW4gdGhlIGNvbnRleHQgb2YgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmUgY2hpbGRyZW4gb2YgdGhpcyBzcGFuLiBJZiBgbnVsbGAgaXMgcGFzc2VkLFxuICogc3BhbnMgc3RhcnRlZCB3aXRoaW4gdGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGF0dGFjaGVkIHRvIGEgcGFyZW50IHNwYW4uXG4gKiBAcGFyYW0gY2FsbGJhY2sgRXhlY3V0aW9uIGNvbnRleHQgaW4gd2hpY2ggdGhlIHByb3ZpZGVkIHNwYW4gd2lsbCBiZSBhY3RpdmUuIElzIHBhc3NlZCB0aGUgbmV3bHkgZm9ya2VkIHNjb3BlLlxuICogQHJldHVybnMgdGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB3aXRoQWN0aXZlU3BhbihzcGFuLCBjYWxsYmFjaykge1xuICBjb25zdCBhY3MgPSBnZXRBY3MoKTtcbiAgaWYgKGFjcy53aXRoQWN0aXZlU3Bhbikge1xuICAgIHJldHVybiBhY3Mud2l0aEFjdGl2ZVNwYW4oc3BhbiwgY2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRTY29wZXMud2l0aFNjb3BlKHNjb3BlID0+IHtcbiAgICBzcGFuT25TY29wZS5fc2V0U3BhbkZvclNjb3BlKHNjb3BlLCBzcGFuIHx8IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHNjb3BlKTtcbiAgfSk7XG59XG5cbi8qKiBTdXBwcmVzcyB0cmFjaW5nIGluIHRoZSBnaXZlbiBjYWxsYmFjaywgZW5zdXJpbmcgbm8gc3BhbnMgYXJlIGdlbmVyYXRlZCBpbnNpZGUgb2YgaXQuICovXG5mdW5jdGlvbiBzdXBwcmVzc1RyYWNpbmcoY2FsbGJhY2spIHtcbiAgY29uc3QgYWNzID0gZ2V0QWNzKCk7XG5cbiAgaWYgKGFjcy5zdXBwcmVzc1RyYWNpbmcpIHtcbiAgICByZXR1cm4gYWNzLnN1cHByZXNzVHJhY2luZyhjYWxsYmFjayk7XG4gIH1cblxuICByZXR1cm4gY3VycmVudFNjb3Blcy53aXRoU2NvcGUoc2NvcGUgPT4ge1xuICAgIC8vIE5vdGU6IFdlIGRvIG5vdCB3YWl0IGZvciB0aGUgY2FsbGJhY2sgdG8gZmluaXNoIGJlZm9yZSB3ZSByZXNldCB0aGUgbWV0YWRhdGFcbiAgICAvLyB0aGUgcmVhc29uIGZvciB0aGlzIGlzIHRoYXQgb3RoZXJ3aXNlLCBpbiB0aGUgYnJvd3NlciB0aGlzIGNhbiBsZWFkIHRvIHZlcnkgd2VpcmQgYmVoYXZpb3JcbiAgICAvLyBhcyB0aGVyZSBpcyBvbmx5IGEgc2luZ2xlIHRvcCBzY29wZSwgaWYgdGhlIGNhbGxiYWNrIHRha2VzIGxvbmdlciB0byBmaW5pc2gsXG4gICAgLy8gb3RoZXIsIHVucmVsYXRlZCBzcGFucyBtYXkgYWxzbyBiZSBzdXBwcmVzc2VkLCB3aGljaCB3ZSBkbyBub3Qgd2FudFxuICAgIC8vIHNvIGluc3RlYWQsIHdlIG9ubHkgc3VwcHJlc3MgdHJhY2luZyBzeW5jaHJvbm95c2x5IGluIHRoZSBicm93c2VyXG4gICAgc2NvcGUuc2V0U0RLUHJvY2Vzc2luZ01ldGFkYXRhKHsgW1NVUFBSRVNTX1RSQUNJTkdfS0VZXTogdHJ1ZSB9KTtcbiAgICBjb25zdCByZXMgPSBjYWxsYmFjaygpO1xuICAgIHNjb3BlLnNldFNES1Byb2Nlc3NpbmdNZXRhZGF0YSh7IFtTVVBQUkVTU19UUkFDSU5HX0tFWV06IHVuZGVmaW5lZCB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTdGFydHMgYSBuZXcgdHJhY2UgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgcHJvdmlkZWQgY2FsbGJhY2suIFNwYW5zIHN0YXJ0ZWQgd2l0aGluIHRoZVxuICogY2FsbGJhY2sgd2lsbCBiZSBwYXJ0IG9mIHRoZSBuZXcgdHJhY2UgaW5zdGVhZCBvZiBhIHBvdGVudGlhbGx5IHByZXZpb3VzbHkgc3RhcnRlZCB0cmFjZS5cbiAqXG4gKiBJbXBvcnRhbnQ6IE9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgdHJhY2UgbGlmZXRpbWUgYW5kXG4gKiBwcm9wYWdhdGlvbiBtZWNoYW5pc20gb2YgdGhlIFNESyBmb3IgdGhlIGR1cmF0aW9uIGFuZCBzY29wZSBvZiB0aGUgcHJvdmlkZWQgY2FsbGJhY2suXG4gKiBUaGUgbmV3bHkgY3JlYXRlZCB0cmFjZSB3aWxsIGFsc28gYmUgdGhlIHJvb3Qgb2YgYSBuZXcgZGlzdHJpYnV0ZWQgdHJhY2UsIGZvciBleGFtcGxlIGlmXG4gKiB5b3UgbWFrZSBodHRwIHJlcXVlc3RzIHdpdGhpbiB0aGUgY2FsbGJhY2suXG4gKiBUaGlzIGZ1bmN0aW9uIG1pZ2h0IGJlIHVzZWZ1bCBpZiB0aGUgb3BlcmF0aW9uIHlvdSB3YW50IHRvIGluc3RydW1lbnQgc2hvdWxkIG5vdCBiZSBwYXJ0XG4gKiBvZiBhIHBvdGVudGlhbGx5IG9uZ29pbmcgdHJhY2UuXG4gKlxuICogRGVmYXVsdCBiZWhhdmlvcjpcbiAqIC0gU2VydmVyLXNpZGU6IEEgbmV3IHRyYWNlIGlzIHN0YXJ0ZWQgZm9yIGVhY2ggaW5jb21pbmcgcmVxdWVzdC5cbiAqIC0gQnJvd3NlcjogQSBuZXcgdHJhY2UgaXMgc3RhcnRlZCBmb3IgZWFjaCBwYWdlIG91ciByb3V0ZS4gTmF2aWdhdGluZyB0byBhIG5ldyByb3V0ZVxuICogICAgICAgICAgICBvciBwYWdlIHdpbGwgYXV0b21hdGljYWxseSBjcmVhdGUgYSBuZXcgdHJhY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0TmV3VHJhY2UoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGN1cnJlbnRTY29wZXMud2l0aFNjb3BlKHNjb3BlID0+IHtcbiAgICBzY29wZS5zZXRQcm9wYWdhdGlvbkNvbnRleHQoe1xuICAgICAgdHJhY2VJZDogcHJvcGFnYXRpb25Db250ZXh0LmdlbmVyYXRlVHJhY2VJZCgpLFxuICAgICAgc2FtcGxlUmFuZDogTWF0aC5yYW5kb20oKSxcbiAgICB9KTtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIuaW5mbyhgU3RhcnRpbmcgYSBuZXcgdHJhY2Ugd2l0aCBpZCAke3Njb3BlLmdldFByb3BhZ2F0aW9uQ29udGV4dCgpLnRyYWNlSWR9YCk7XG4gICAgcmV0dXJuIHdpdGhBY3RpdmVTcGFuKG51bGwsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkT3JSb290U3Bhbih7XG4gIHBhcmVudFNwYW4sXG4gIHNwYW5Bcmd1bWVudHMsXG4gIGZvcmNlVHJhbnNhY3Rpb24sXG4gIHNjb3BlLFxufVxuXG4pIHtcbiAgaWYgKCFoYXNTcGFuc0VuYWJsZWQuaGFzU3BhbnNFbmFibGVkKCkpIHtcbiAgICBjb25zdCBzcGFuID0gbmV3IHNlbnRyeU5vblJlY29yZGluZ1NwYW4uU2VudHJ5Tm9uUmVjb3JkaW5nU3BhbigpO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHJvb3Qgc3Bhbiwgd2UgZW5zdXJlIHRvIGZyZWV6ZSBhIERTQ1xuICAgIC8vIFNvIHdlIGNhbiBoYXZlIGF0IGxlYXN0IHBhcnRpYWwgZGF0YSBoZXJlXG4gICAgaWYgKGZvcmNlVHJhbnNhY3Rpb24gfHwgIXBhcmVudFNwYW4pIHtcbiAgICAgIGNvbnN0IGRzYyA9IHtcbiAgICAgICAgc2FtcGxlZDogJ2ZhbHNlJyxcbiAgICAgICAgc2FtcGxlX3JhdGU6ICcwJyxcbiAgICAgICAgdHJhbnNhY3Rpb246IHNwYW5Bcmd1bWVudHMubmFtZSxcbiAgICAgICAgLi4uZHluYW1pY1NhbXBsaW5nQ29udGV4dC5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3BhbiksXG4gICAgICB9IDtcbiAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQuZnJlZXplRHNjT25TcGFuKHNwYW4sIGRzYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwYW47XG4gIH1cblxuICBjb25zdCBpc29sYXRpb25TY29wZSA9IGN1cnJlbnRTY29wZXMuZ2V0SXNvbGF0aW9uU2NvcGUoKTtcblxuICBsZXQgc3BhbjtcbiAgaWYgKHBhcmVudFNwYW4gJiYgIWZvcmNlVHJhbnNhY3Rpb24pIHtcbiAgICBzcGFuID0gX3N0YXJ0Q2hpbGRTcGFuKHBhcmVudFNwYW4sIHNjb3BlLCBzcGFuQXJndW1lbnRzKTtcbiAgICBzcGFuVXRpbHMuYWRkQ2hpbGRTcGFuVG9TcGFuKHBhcmVudFNwYW4sIHNwYW4pO1xuICB9IGVsc2UgaWYgKHBhcmVudFNwYW4pIHtcbiAgICAvLyBJZiB3ZSBmb3JjZWQgYSB0cmFuc2FjdGlvbiBidXQgaGF2ZSBhIHBhcmVudCBzcGFuLCBtYWtlIHN1cmUgdG8gY29udGludWUgZnJvbSB0aGUgcGFyZW50IHNwYW4sIG5vdCB0aGUgc2NvcGVcbiAgICBjb25zdCBkc2MgPSBkeW5hbWljU2FtcGxpbmdDb250ZXh0LmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihwYXJlbnRTcGFuKTtcbiAgICBjb25zdCB7IHRyYWNlSWQsIHNwYW5JZDogcGFyZW50U3BhbklkIH0gPSBwYXJlbnRTcGFuLnNwYW5Db250ZXh0KCk7XG4gICAgY29uc3QgcGFyZW50U2FtcGxlZCA9IHNwYW5VdGlscy5zcGFuSXNTYW1wbGVkKHBhcmVudFNwYW4pO1xuXG4gICAgc3BhbiA9IF9zdGFydFJvb3RTcGFuKFxuICAgICAge1xuICAgICAgICB0cmFjZUlkLFxuICAgICAgICBwYXJlbnRTcGFuSWQsXG4gICAgICAgIC4uLnNwYW5Bcmd1bWVudHMsXG4gICAgICB9LFxuICAgICAgc2NvcGUsXG4gICAgICBwYXJlbnRTYW1wbGVkLFxuICAgICk7XG5cbiAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0LmZyZWV6ZURzY09uU3BhbihzcGFuLCBkc2MpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYWNlSWQsXG4gICAgICBkc2MsXG4gICAgICBwYXJlbnRTcGFuSWQsXG4gICAgICBzYW1wbGVkOiBwYXJlbnRTYW1wbGVkLFxuICAgIH0gPSB7XG4gICAgICAuLi5pc29sYXRpb25TY29wZS5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKSxcbiAgICAgIC4uLnNjb3BlLmdldFByb3BhZ2F0aW9uQ29udGV4dCgpLFxuICAgIH07XG5cbiAgICBzcGFuID0gX3N0YXJ0Um9vdFNwYW4oXG4gICAgICB7XG4gICAgICAgIHRyYWNlSWQsXG4gICAgICAgIHBhcmVudFNwYW5JZCxcbiAgICAgICAgLi4uc3BhbkFyZ3VtZW50cyxcbiAgICAgIH0sXG4gICAgICBzY29wZSxcbiAgICAgIHBhcmVudFNhbXBsZWQsXG4gICAgKTtcblxuICAgIGlmIChkc2MpIHtcbiAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQuZnJlZXplRHNjT25TcGFuKHNwYW4sIGRzYyk7XG4gICAgfVxuICB9XG5cbiAgbG9nU3BhbnMubG9nU3BhblN0YXJ0KHNwYW4pO1xuXG4gIHV0aWxzLnNldENhcHR1cmVkU2NvcGVzT25TcGFuKHNwYW4sIHNjb3BlLCBpc29sYXRpb25TY29wZSk7XG5cbiAgcmV0dXJuIHNwYW47XG59XG5cbi8qKlxuICogVGhpcyBjb252ZXJ0cyBTdGFydFNwYW5PcHRpb25zIHRvIFNlbnRyeVNwYW5Bcmd1bWVudHMuXG4gKiBGb3IgdGhlIG1vc3QgcGFydCAoZm9yIG5vdykgd2UgYWNjZXB0IHRoZSBzYW1lIG9wdGlvbnMsXG4gKiBidXQgc29tZSBvZiB0aGVtIG5lZWQgdG8gYmUgdHJhbnNmb3JtZWQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2VudHJ5U3BhbkFyZ3VtZW50cyhvcHRpb25zKSB7XG4gIGNvbnN0IGV4cCA9IG9wdGlvbnMuZXhwZXJpbWVudGFsIHx8IHt9O1xuICBjb25zdCBpbml0aWFsQ3R4ID0ge1xuICAgIGlzU3RhbmRhbG9uZTogZXhwLnN0YW5kYWxvbmUsXG4gICAgLi4ub3B0aW9ucyxcbiAgfTtcblxuICBpZiAob3B0aW9ucy5zdGFydFRpbWUpIHtcbiAgICBjb25zdCBjdHggPSB7IC4uLmluaXRpYWxDdHggfTtcbiAgICBjdHguc3RhcnRUaW1lc3RhbXAgPSBzcGFuVXRpbHMuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhvcHRpb25zLnN0YXJ0VGltZSk7XG4gICAgZGVsZXRlIGN0eC5zdGFydFRpbWU7XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuXG4gIHJldHVybiBpbml0aWFsQ3R4O1xufVxuXG5mdW5jdGlvbiBnZXRBY3MoKSB7XG4gIGNvbnN0IGNhcnJpZXIkMSA9IGNhcnJpZXIuZ2V0TWFpbkNhcnJpZXIoKTtcbiAgcmV0dXJuIGluZGV4LmdldEFzeW5jQ29udGV4dFN0cmF0ZWd5KGNhcnJpZXIkMSk7XG59XG5cbmZ1bmN0aW9uIF9zdGFydFJvb3RTcGFuKHNwYW5Bcmd1bWVudHMsIHNjb3BlLCBwYXJlbnRTYW1wbGVkKSB7XG4gIGNvbnN0IGNsaWVudCA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG4gIGNvbnN0IG9wdGlvbnMgPSBjbGllbnQ/LmdldE9wdGlvbnMoKSB8fCB7fTtcblxuICBjb25zdCB7IG5hbWUgPSAnJyB9ID0gc3BhbkFyZ3VtZW50cztcblxuICBjb25zdCBtdXRhYmxlU3BhblNhbXBsaW5nRGF0YSA9IHsgc3BhbkF0dHJpYnV0ZXM6IHsgLi4uc3BhbkFyZ3VtZW50cy5hdHRyaWJ1dGVzIH0sIHNwYW5OYW1lOiBuYW1lLCBwYXJlbnRTYW1wbGVkIH07XG5cbiAgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgZGVjaXNpb24gZm9yIHRoZSBtb21lbnQ7IHRoaXMgaXMganVzdCBhIHBsYWNlaG9sZGVyXG4gIGNsaWVudD8uZW1pdCgnYmVmb3JlU2FtcGxpbmcnLCBtdXRhYmxlU3BhblNhbXBsaW5nRGF0YSwgeyBkZWNpc2lvbjogZmFsc2UgfSk7XG5cbiAgLy8gSWYgaG9vayBjb25zdW1lcnMgb3ZlcnJpZGUgdGhlIHBhcmVudFNhbXBsZWQgZmxhZywgd2Ugd2lsbCB1c2UgdGhhdCB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSBhY3R1YWwgb25lXG4gIGNvbnN0IGZpbmFsUGFyZW50U2FtcGxlZCA9IG11dGFibGVTcGFuU2FtcGxpbmdEYXRhLnBhcmVudFNhbXBsZWQgPz8gcGFyZW50U2FtcGxlZDtcbiAgY29uc3QgZmluYWxBdHRyaWJ1dGVzID0gbXV0YWJsZVNwYW5TYW1wbGluZ0RhdGEuc3BhbkF0dHJpYnV0ZXM7XG5cbiAgY29uc3QgY3VycmVudFByb3BhZ2F0aW9uQ29udGV4dCA9IHNjb3BlLmdldFByb3BhZ2F0aW9uQ29udGV4dCgpO1xuICBjb25zdCBbc2FtcGxlZCwgc2FtcGxlUmF0ZSwgbG9jYWxTYW1wbGVSYXRlV2FzQXBwbGllZF0gPSBzY29wZS5nZXRTY29wZURhdGEoKS5zZGtQcm9jZXNzaW5nTWV0YWRhdGFbXG4gICAgU1VQUFJFU1NfVFJBQ0lOR19LRVlcbiAgXVxuICAgID8gW2ZhbHNlXVxuICAgIDogc2FtcGxpbmcuc2FtcGxlU3BhbihcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgcGFyZW50U2FtcGxlZDogZmluYWxQYXJlbnRTYW1wbGVkLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IGZpbmFsQXR0cmlidXRlcyxcbiAgICAgICAgICBwYXJlbnRTYW1wbGVSYXRlOiBwYXJzZVNhbXBsZVJhdGUucGFyc2VTYW1wbGVSYXRlKGN1cnJlbnRQcm9wYWdhdGlvbkNvbnRleHQuZHNjPy5zYW1wbGVfcmF0ZSksXG4gICAgICAgIH0sXG4gICAgICAgIGN1cnJlbnRQcm9wYWdhdGlvbkNvbnRleHQuc2FtcGxlUmFuZCxcbiAgICAgICk7XG5cbiAgY29uc3Qgcm9vdFNwYW4gPSBuZXcgc2VudHJ5U3Bhbi5TZW50cnlTcGFuKHtcbiAgICAuLi5zcGFuQXJndW1lbnRzLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdOiAnY3VzdG9tJyxcbiAgICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURV06XG4gICAgICAgIHNhbXBsZVJhdGUgIT09IHVuZGVmaW5lZCAmJiBsb2NhbFNhbXBsZVJhdGVXYXNBcHBsaWVkID8gc2FtcGxlUmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIC4uLmZpbmFsQXR0cmlidXRlcyxcbiAgICB9LFxuICAgIHNhbXBsZWQsXG4gIH0pO1xuXG4gIGlmICghc2FtcGxlZCAmJiBjbGllbnQpIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIubG9nKCdbVHJhY2luZ10gRGlzY2FyZGluZyByb290IHNwYW4gYmVjYXVzZSBpdHMgdHJhY2Ugd2FzIG5vdCBjaG9zZW4gdG8gYmUgc2FtcGxlZC4nKTtcbiAgICBjbGllbnQucmVjb3JkRHJvcHBlZEV2ZW50KCdzYW1wbGVfcmF0ZScsICd0cmFuc2FjdGlvbicpO1xuICB9XG5cbiAgaWYgKGNsaWVudCkge1xuICAgIGNsaWVudC5lbWl0KCdzcGFuU3RhcnQnLCByb290U3Bhbik7XG4gIH1cblxuICByZXR1cm4gcm9vdFNwYW47XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgU3BhbmAgd2hpbGUgc2V0dGluZyB0aGUgY3VycmVudCBgU3Bhbi5pZGAgYXMgYHBhcmVudFNwYW5JZGAuXG4gKiBUaGlzIGluaGVyaXRzIHRoZSBzYW1wbGluZyBkZWNpc2lvbiBmcm9tIHRoZSBwYXJlbnQgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gX3N0YXJ0Q2hpbGRTcGFuKHBhcmVudFNwYW4sIHNjb3BlLCBzcGFuQXJndW1lbnRzKSB7XG4gIGNvbnN0IHsgc3BhbklkLCB0cmFjZUlkIH0gPSBwYXJlbnRTcGFuLnNwYW5Db250ZXh0KCk7XG4gIGNvbnN0IHNhbXBsZWQgPSBzY29wZS5nZXRTY29wZURhdGEoKS5zZGtQcm9jZXNzaW5nTWV0YWRhdGFbU1VQUFJFU1NfVFJBQ0lOR19LRVldID8gZmFsc2UgOiBzcGFuVXRpbHMuc3BhbklzU2FtcGxlZChwYXJlbnRTcGFuKTtcblxuICBjb25zdCBjaGlsZFNwYW4gPSBzYW1wbGVkXG4gICAgPyBuZXcgc2VudHJ5U3Bhbi5TZW50cnlTcGFuKHtcbiAgICAgICAgLi4uc3BhbkFyZ3VtZW50cyxcbiAgICAgICAgcGFyZW50U3BhbklkOiBzcGFuSWQsXG4gICAgICAgIHRyYWNlSWQsXG4gICAgICAgIHNhbXBsZWQsXG4gICAgICB9KVxuICAgIDogbmV3IHNlbnRyeU5vblJlY29yZGluZ1NwYW4uU2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbih7IHRyYWNlSWQgfSk7XG5cbiAgc3BhblV0aWxzLmFkZENoaWxkU3BhblRvU3BhbihwYXJlbnRTcGFuLCBjaGlsZFNwYW4pO1xuXG4gIGNvbnN0IGNsaWVudCA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG4gIGlmIChjbGllbnQpIHtcbiAgICBjbGllbnQuZW1pdCgnc3BhblN0YXJ0JywgY2hpbGRTcGFuKTtcbiAgICAvLyBJZiBpdCBoYXMgYW4gZW5kVGltZXN0YW1wLCBpdCdzIGFscmVhZHkgZW5kZWRcbiAgICBpZiAoc3BhbkFyZ3VtZW50cy5lbmRUaW1lc3RhbXApIHtcbiAgICAgIGNsaWVudC5lbWl0KCdzcGFuRW5kJywgY2hpbGRTcGFuKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRTcGFuO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTcGFuKHNjb3BlKSB7XG4gIGNvbnN0IHNwYW4gPSBzcGFuT25TY29wZS5fZ2V0U3BhbkZvclNjb3BlKHNjb3BlKSA7XG5cbiAgaWYgKCFzcGFuKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGNsaWVudCA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG4gIGNvbnN0IG9wdGlvbnMgPSBjbGllbnQgPyBjbGllbnQuZ2V0T3B0aW9ucygpIDoge307XG4gIGlmIChvcHRpb25zLnBhcmVudFNwYW5Jc0Fsd2F5c1Jvb3RTcGFuKSB7XG4gICAgcmV0dXJuIHNwYW5VdGlscy5nZXRSb290U3BhbihzcGFuKSA7XG4gIH1cblxuICByZXR1cm4gc3Bhbjtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlU3BhbldyYXBwZXIocGFyZW50U3Bhbikge1xuICByZXR1cm4gcGFyZW50U3BhbiAhPT0gdW5kZWZpbmVkXG4gICAgPyAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgcmV0dXJuIHdpdGhBY3RpdmVTcGFuKHBhcmVudFNwYW4sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICA6IChjYWxsYmFjaykgPT4gY2FsbGJhY2soKTtcbn1cblxuZXhwb3J0cy5jb250aW51ZVRyYWNlID0gY29udGludWVUcmFjZTtcbmV4cG9ydHMuc3RhcnRJbmFjdGl2ZVNwYW4gPSBzdGFydEluYWN0aXZlU3BhbjtcbmV4cG9ydHMuc3RhcnROZXdUcmFjZSA9IHN0YXJ0TmV3VHJhY2U7XG5leHBvcnRzLnN0YXJ0U3BhbiA9IHN0YXJ0U3BhbjtcbmV4cG9ydHMuc3RhcnRTcGFuTWFudWFsID0gc3RhcnRTcGFuTWFudWFsO1xuZXhwb3J0cy5zdXBwcmVzc1RyYWNpbmcgPSBzdXBwcmVzc1RyYWNpbmc7XG5leHBvcnRzLndpdGhBY3RpdmVTcGFuID0gd2l0aEFjdGl2ZVNwYW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/trace.js\n')},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/utils.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst object = __webpack_require__(/*! ../utils-hoist/object.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/object.js\");\n\nconst SCOPE_ON_START_SPAN_FIELD = '_sentryScope';\nconst ISOLATION_SCOPE_ON_START_SPAN_FIELD = '_sentryIsolationScope';\n\n/** Store the scope & isolation scope for a span, which can the be used when it is finished. */\nfunction setCapturedScopesOnSpan(span, scope, isolationScope) {\n  if (span) {\n    object.addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);\n    object.addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);\n  }\n}\n\n/**\n * Grabs the scope and isolation scope off a span that were active when the span was started.\n */\nfunction getCapturedScopesOnSpan(span) {\n  return {\n    scope: (span )[SCOPE_ON_START_SPAN_FIELD],\n    isolationScope: (span )[ISOLATION_SCOPE_ON_START_SPAN_FIELD],\n  };\n}\n\nexports.getCapturedScopesOnSpan = getCapturedScopesOnSpan;\nexports.setCapturedScopesOnSpan = setCapturedScopesOnSpan;\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYWNpbmcvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsZUFBZSxtQkFBTyxDQUFDLHNJQUEwQjs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFx0cmFjaW5nXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3Qgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvb2JqZWN0LmpzJyk7XG5cbmNvbnN0IFNDT1BFX09OX1NUQVJUX1NQQU5fRklFTEQgPSAnX3NlbnRyeVNjb3BlJztcbmNvbnN0IElTT0xBVElPTl9TQ09QRV9PTl9TVEFSVF9TUEFOX0ZJRUxEID0gJ19zZW50cnlJc29sYXRpb25TY29wZSc7XG5cbi8qKiBTdG9yZSB0aGUgc2NvcGUgJiBpc29sYXRpb24gc2NvcGUgZm9yIGEgc3Bhbiwgd2hpY2ggY2FuIHRoZSBiZSB1c2VkIHdoZW4gaXQgaXMgZmluaXNoZWQuICovXG5mdW5jdGlvbiBzZXRDYXB0dXJlZFNjb3Blc09uU3BhbihzcGFuLCBzY29wZSwgaXNvbGF0aW9uU2NvcGUpIHtcbiAgaWYgKHNwYW4pIHtcbiAgICBvYmplY3QuYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KHNwYW4sIElTT0xBVElPTl9TQ09QRV9PTl9TVEFSVF9TUEFOX0ZJRUxELCBpc29sYXRpb25TY29wZSk7XG4gICAgb2JqZWN0LmFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eShzcGFuLCBTQ09QRV9PTl9TVEFSVF9TUEFOX0ZJRUxELCBzY29wZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHcmFicyB0aGUgc2NvcGUgYW5kIGlzb2xhdGlvbiBzY29wZSBvZmYgYSBzcGFuIHRoYXQgd2VyZSBhY3RpdmUgd2hlbiB0aGUgc3BhbiB3YXMgc3RhcnRlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4oc3Bhbikge1xuICByZXR1cm4ge1xuICAgIHNjb3BlOiAoc3BhbiApW1NDT1BFX09OX1NUQVJUX1NQQU5fRklFTERdLFxuICAgIGlzb2xhdGlvblNjb3BlOiAoc3BhbiApW0lTT0xBVElPTl9TQ09QRV9PTl9TVEFSVF9TUEFOX0ZJRUxEXSxcbiAgfTtcbn1cblxuZXhwb3J0cy5nZXRDYXB0dXJlZFNjb3Blc09uU3BhbiA9IGdldENhcHR1cmVkU2NvcGVzT25TcGFuO1xuZXhwb3J0cy5zZXRDYXB0dXJlZFNjb3Blc09uU3BhbiA9IHNldENhcHR1cmVkU2NvcGVzT25TcGFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/utils.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/transports/base.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst envelope = __webpack_require__(/*! ../utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst promisebuffer = __webpack_require__(/*! ../utils-hoist/promisebuffer.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/promisebuffer.js\");\nconst ratelimit = __webpack_require__(/*! ../utils-hoist/ratelimit.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/ratelimit.js\");\nconst syncpromise = __webpack_require__(/*! ../utils-hoist/syncpromise.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/syncpromise.js\");\n\nconst DEFAULT_TRANSPORT_BUFFER_SIZE = 64;\n\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\nfunction createTransport(\n  options,\n  makeRequest,\n  buffer = promisebuffer.makePromiseBuffer(\n    options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE,\n  ),\n) {\n  let rateLimits = {};\n  const flush = (timeout) => buffer.drain(timeout);\n\n  function send(envelope$1) {\n    const filteredEnvelopeItems = [];\n\n    // Drop rate limited items from envelope\n    envelope.forEachEnvelopeItem(envelope$1, (item, type) => {\n      const dataCategory = envelope.envelopeItemTypeToDataCategory(type);\n      if (ratelimit.isRateLimited(rateLimits, dataCategory)) {\n        options.recordDroppedEvent('ratelimit_backoff', dataCategory);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    });\n\n    // Skip sending if envelope is empty after filtering out rate limited events\n    if (filteredEnvelopeItems.length === 0) {\n      return syncpromise.resolvedSyncPromise({});\n    }\n\n    const filteredEnvelope = envelope.createEnvelope(envelope$1[0], filteredEnvelopeItems );\n\n    // Creates client report for each item in an envelope\n    const recordEnvelopeLoss = (reason) => {\n      envelope.forEachEnvelopeItem(filteredEnvelope, (item, type) => {\n        options.recordDroppedEvent(reason, envelope.envelopeItemTypeToDataCategory(type));\n      });\n    };\n\n    const requestTask = () =>\n      makeRequest({ body: envelope.serializeEnvelope(filteredEnvelope) }).then(\n        response => {\n          // We don't want to throw on NOK responses, but we want to at least log them\n          if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n            debugBuild.DEBUG_BUILD && logger.logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);\n          }\n\n          rateLimits = ratelimit.updateRateLimits(rateLimits, response);\n          return response;\n        },\n        error => {\n          recordEnvelopeLoss('network_error');\n          debugBuild.DEBUG_BUILD && logger.logger.error('Encountered error running transport request:', error);\n          throw error;\n        },\n      );\n\n    return buffer.add(requestTask).then(\n      result => result,\n      error => {\n        if (error === promisebuffer.SENTRY_BUFFER_FULL_ERROR) {\n          debugBuild.DEBUG_BUILD && logger.logger.error('Skipped sending event because buffer is full.');\n          recordEnvelopeLoss('queue_overflow');\n          return syncpromise.resolvedSyncPromise({});\n        } else {\n          throw error;\n        }\n      },\n    );\n  }\n\n  return {\n    send,\n    flush,\n  };\n}\n\nexports.DEFAULT_TRANSPORT_BUFFER_SIZE = DEFAULT_TRANSPORT_BUFFER_SIZE;\nexports.createTransport = createTransport;\n//# sourceMappingURL=base.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYW5zcG9ydHMvYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxtQkFBbUIsbUJBQU8sQ0FBQyx3SEFBbUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsMElBQTRCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQyxzSUFBMEI7QUFDakQsc0JBQXNCLG1CQUFPLENBQUMsb0pBQWlDO0FBQy9ELGtCQUFrQixtQkFBTyxDQUFDLDRJQUE2QjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyxnSkFBK0I7O0FBRTNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLHFCQUFxQjtBQUNuSDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFx0cmFuc3BvcnRzXFxiYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IGVudmVsb3BlID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvZW52ZWxvcGUuanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuY29uc3QgcHJvbWlzZWJ1ZmZlciA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3Byb21pc2VidWZmZXIuanMnKTtcbmNvbnN0IHJhdGVsaW1pdCA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3JhdGVsaW1pdC5qcycpO1xuY29uc3Qgc3luY3Byb21pc2UgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9zeW5jcHJvbWlzZS5qcycpO1xuXG5jb25zdCBERUZBVUxUX1RSQU5TUE9SVF9CVUZGRVJfU0laRSA9IDY0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBTZW50cnkgYFRyYW5zcG9ydGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIG1ha2VSZXF1ZXN0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zcG9ydChcbiAgb3B0aW9ucyxcbiAgbWFrZVJlcXVlc3QsXG4gIGJ1ZmZlciA9IHByb21pc2VidWZmZXIubWFrZVByb21pc2VCdWZmZXIoXG4gICAgb3B0aW9ucy5idWZmZXJTaXplIHx8IERFRkFVTFRfVFJBTlNQT1JUX0JVRkZFUl9TSVpFLFxuICApLFxuKSB7XG4gIGxldCByYXRlTGltaXRzID0ge307XG4gIGNvbnN0IGZsdXNoID0gKHRpbWVvdXQpID0+IGJ1ZmZlci5kcmFpbih0aW1lb3V0KTtcblxuICBmdW5jdGlvbiBzZW5kKGVudmVsb3BlJDEpIHtcbiAgICBjb25zdCBmaWx0ZXJlZEVudmVsb3BlSXRlbXMgPSBbXTtcblxuICAgIC8vIERyb3AgcmF0ZSBsaW1pdGVkIGl0ZW1zIGZyb20gZW52ZWxvcGVcbiAgICBlbnZlbG9wZS5mb3JFYWNoRW52ZWxvcGVJdGVtKGVudmVsb3BlJDEsIChpdGVtLCB0eXBlKSA9PiB7XG4gICAgICBjb25zdCBkYXRhQ2F0ZWdvcnkgPSBlbnZlbG9wZS5lbnZlbG9wZUl0ZW1UeXBlVG9EYXRhQ2F0ZWdvcnkodHlwZSk7XG4gICAgICBpZiAocmF0ZWxpbWl0LmlzUmF0ZUxpbWl0ZWQocmF0ZUxpbWl0cywgZGF0YUNhdGVnb3J5KSkge1xuICAgICAgICBvcHRpb25zLnJlY29yZERyb3BwZWRFdmVudCgncmF0ZWxpbWl0X2JhY2tvZmYnLCBkYXRhQ2F0ZWdvcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsdGVyZWRFbnZlbG9wZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTa2lwIHNlbmRpbmcgaWYgZW52ZWxvcGUgaXMgZW1wdHkgYWZ0ZXIgZmlsdGVyaW5nIG91dCByYXRlIGxpbWl0ZWQgZXZlbnRzXG4gICAgaWYgKGZpbHRlcmVkRW52ZWxvcGVJdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBzeW5jcHJvbWlzZS5yZXNvbHZlZFN5bmNQcm9taXNlKHt9KTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJlZEVudmVsb3BlID0gZW52ZWxvcGUuY3JlYXRlRW52ZWxvcGUoZW52ZWxvcGUkMVswXSwgZmlsdGVyZWRFbnZlbG9wZUl0ZW1zICk7XG5cbiAgICAvLyBDcmVhdGVzIGNsaWVudCByZXBvcnQgZm9yIGVhY2ggaXRlbSBpbiBhbiBlbnZlbG9wZVxuICAgIGNvbnN0IHJlY29yZEVudmVsb3BlTG9zcyA9IChyZWFzb24pID0+IHtcbiAgICAgIGVudmVsb3BlLmZvckVhY2hFbnZlbG9wZUl0ZW0oZmlsdGVyZWRFbnZlbG9wZSwgKGl0ZW0sIHR5cGUpID0+IHtcbiAgICAgICAgb3B0aW9ucy5yZWNvcmREcm9wcGVkRXZlbnQocmVhc29uLCBlbnZlbG9wZS5lbnZlbG9wZUl0ZW1UeXBlVG9EYXRhQ2F0ZWdvcnkodHlwZSkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlcXVlc3RUYXNrID0gKCkgPT5cbiAgICAgIG1ha2VSZXF1ZXN0KHsgYm9keTogZW52ZWxvcGUuc2VyaWFsaXplRW52ZWxvcGUoZmlsdGVyZWRFbnZlbG9wZSkgfSkudGhlbihcbiAgICAgICAgcmVzcG9uc2UgPT4ge1xuICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gdGhyb3cgb24gTk9LIHJlc3BvbnNlcywgYnV0IHdlIHdhbnQgdG8gYXQgbGVhc3QgbG9nIHRoZW1cbiAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gdW5kZWZpbmVkICYmIChyZXNwb25zZS5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMzAwKSkge1xuICAgICAgICAgICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLndhcm4oYFNlbnRyeSByZXNwb25kZWQgd2l0aCBzdGF0dXMgY29kZSAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9IHRvIHNlbnQgZXZlbnQuYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmF0ZUxpbWl0cyA9IHJhdGVsaW1pdC51cGRhdGVSYXRlTGltaXRzKHJhdGVMaW1pdHMsIHJlc3BvbnNlKTtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICByZWNvcmRFbnZlbG9wZUxvc3MoJ25ldHdvcmtfZXJyb3InKTtcbiAgICAgICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIuZXJyb3IoJ0VuY291bnRlcmVkIGVycm9yIHJ1bm5pbmcgdHJhbnNwb3J0IHJlcXVlc3Q6JywgZXJyb3IpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9LFxuICAgICAgKTtcblxuICAgIHJldHVybiBidWZmZXIuYWRkKHJlcXVlc3RUYXNrKS50aGVuKFxuICAgICAgcmVzdWx0ID0+IHJlc3VsdCxcbiAgICAgIGVycm9yID0+IHtcbiAgICAgICAgaWYgKGVycm9yID09PSBwcm9taXNlYnVmZmVyLlNFTlRSWV9CVUZGRVJfRlVMTF9FUlJPUikge1xuICAgICAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci5lcnJvcignU2tpcHBlZCBzZW5kaW5nIGV2ZW50IGJlY2F1c2UgYnVmZmVyIGlzIGZ1bGwuJyk7XG4gICAgICAgICAgcmVjb3JkRW52ZWxvcGVMb3NzKCdxdWV1ZV9vdmVyZmxvdycpO1xuICAgICAgICAgIHJldHVybiBzeW5jcHJvbWlzZS5yZXNvbHZlZFN5bmNQcm9taXNlKHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzZW5kLFxuICAgIGZsdXNoLFxuICB9O1xufVxuXG5leHBvcnRzLkRFRkFVTFRfVFJBTlNQT1JUX0JVRkZFUl9TSVpFID0gREVGQVVMVF9UUkFOU1BPUlRfQlVGRkVSX1NJWkU7XG5leHBvcnRzLmNyZWF0ZVRyYW5zcG9ydCA9IGNyZWF0ZVRyYW5zcG9ydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/transports/base.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/transports/multiplexed.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst api = __webpack_require__(/*! ../api.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/api.js\");\nconst dsn = __webpack_require__(/*! ../utils-hoist/dsn.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/dsn.js\");\nconst envelope = __webpack_require__(/*! ../utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\n\n/**\n * Gets an event from an envelope.\n *\n * This is only exported for use in the tests\n */\nfunction eventFromEnvelope(env, types) {\n  let event;\n\n  envelope.forEachEnvelopeItem(env, (item, type) => {\n    if (types.includes(type)) {\n      event = Array.isArray(item) ? (item )[1] : undefined;\n    }\n    // bail out if we found an event\n    return !!event;\n  });\n\n  return event;\n}\n\n/**\n * Creates a transport that overrides the release on all events.\n */\nfunction makeOverrideReleaseTransport(\n  createTransport,\n  release,\n) {\n  return options => {\n    const transport = createTransport(options);\n\n    return {\n      ...transport,\n      send: async (envelope) => {\n        const event = eventFromEnvelope(envelope, ['event', 'transaction', 'profile', 'replay_event']);\n\n        if (event) {\n          event.release = release;\n        }\n        return transport.send(envelope);\n      },\n    };\n  };\n}\n\n/** Overrides the DSN in the envelope header  */\nfunction overrideDsn(envelope$1, dsn) {\n  return envelope.createEnvelope(\n    dsn\n      ? {\n          ...envelope$1[0],\n          dsn,\n        }\n      : envelope$1[0],\n    envelope$1[1],\n  );\n}\n\n/**\n * Creates a transport that can send events to different DSNs depending on the envelope contents.\n */\nfunction makeMultiplexedTransport(\n  createTransport,\n  matcher,\n) {\n  return options => {\n    const fallbackTransport = createTransport(options);\n    const otherTransports = new Map();\n\n    function getTransport(dsn$1, release) {\n      // We create a transport for every unique dsn/release combination as there may be code from multiple releases in\n      // use at the same time\n      const key = release ? `${dsn$1}:${release}` : dsn$1;\n\n      let transport = otherTransports.get(key);\n\n      if (!transport) {\n        const validatedDsn = dsn.dsnFromString(dsn$1);\n        if (!validatedDsn) {\n          return undefined;\n        }\n        const url = api.getEnvelopeEndpointWithUrlEncodedAuth(validatedDsn, options.tunnel);\n\n        transport = release\n          ? makeOverrideReleaseTransport(createTransport, release)({ ...options, url })\n          : createTransport({ ...options, url });\n\n        otherTransports.set(key, transport);\n      }\n\n      return [dsn$1, transport];\n    }\n\n    async function send(envelope) {\n      function getEvent(types) {\n        const eventTypes = types?.length ? types : ['event'];\n        return eventFromEnvelope(envelope, eventTypes);\n      }\n\n      const transports = matcher({ envelope, getEvent })\n        .map(result => {\n          if (typeof result === 'string') {\n            return getTransport(result, undefined);\n          } else {\n            return getTransport(result.dsn, result.release);\n          }\n        })\n        .filter((t) => !!t);\n\n      // If we have no transports to send to, use the fallback transport\n      // Don't override the DSN in the header for the fallback transport. '' is falsy\n      const transportsWithFallback = transports.length ? transports : [['', fallbackTransport]];\n\n      const results = (await Promise.all(\n        transportsWithFallback.map(([dsn, transport]) => transport.send(overrideDsn(envelope, dsn))),\n      )) ;\n\n      return results[0];\n    }\n\n    async function flush(timeout) {\n      const allTransports = [...otherTransports.values(), fallbackTransport];\n      const results = await Promise.all(allTransports.map(transport => transport.flush(timeout)));\n      return results.every(r => r);\n    }\n\n    return {\n      send,\n      flush,\n    };\n  };\n}\n\nexports.eventFromEnvelope = eventFromEnvelope;\nexports.makeMultiplexedTransport = makeMultiplexedTransport;\n//# sourceMappingURL=multiplexed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYW5zcG9ydHMvbXVsdGlwbGV4ZWQuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsWUFBWSxtQkFBTyxDQUFDLHdHQUFXO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyxnSUFBdUI7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsMElBQTRCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU0sR0FBRyxRQUFROztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUUsaUJBQWlCO0FBQ3RGLDhCQUE4QixpQkFBaUI7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxvQkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QixnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG9wZW50ZWxlbWV0cnlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcdHJhbnNwb3J0c1xcbXVsdGlwbGV4ZWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGFwaSA9IHJlcXVpcmUoJy4uL2FwaS5qcycpO1xuY29uc3QgZHNuID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvZHNuLmpzJyk7XG5jb25zdCBlbnZlbG9wZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2VudmVsb3BlLmpzJyk7XG5cbi8qKlxuICogR2V0cyBhbiBldmVudCBmcm9tIGFuIGVudmVsb3BlLlxuICpcbiAqIFRoaXMgaXMgb25seSBleHBvcnRlZCBmb3IgdXNlIGluIHRoZSB0ZXN0c1xuICovXG5mdW5jdGlvbiBldmVudEZyb21FbnZlbG9wZShlbnYsIHR5cGVzKSB7XG4gIGxldCBldmVudDtcblxuICBlbnZlbG9wZS5mb3JFYWNoRW52ZWxvcGVJdGVtKGVudiwgKGl0ZW0sIHR5cGUpID0+IHtcbiAgICBpZiAodHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgIGV2ZW50ID0gQXJyYXkuaXNBcnJheShpdGVtKSA/IChpdGVtIClbMV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIGJhaWwgb3V0IGlmIHdlIGZvdW5kIGFuIGV2ZW50XG4gICAgcmV0dXJuICEhZXZlbnQ7XG4gIH0pO1xuXG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNwb3J0IHRoYXQgb3ZlcnJpZGVzIHRoZSByZWxlYXNlIG9uIGFsbCBldmVudHMuXG4gKi9cbmZ1bmN0aW9uIG1ha2VPdmVycmlkZVJlbGVhc2VUcmFuc3BvcnQoXG4gIGNyZWF0ZVRyYW5zcG9ydCxcbiAgcmVsZWFzZSxcbikge1xuICByZXR1cm4gb3B0aW9ucyA9PiB7XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gY3JlYXRlVHJhbnNwb3J0KG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRyYW5zcG9ydCxcbiAgICAgIHNlbmQ6IGFzeW5jIChlbnZlbG9wZSkgPT4ge1xuICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50RnJvbUVudmVsb3BlKGVudmVsb3BlLCBbJ2V2ZW50JywgJ3RyYW5zYWN0aW9uJywgJ3Byb2ZpbGUnLCAncmVwbGF5X2V2ZW50J10pO1xuXG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgIGV2ZW50LnJlbGVhc2UgPSByZWxlYXNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQuc2VuZChlbnZlbG9wZSk7XG4gICAgICB9LFxuICAgIH07XG4gIH07XG59XG5cbi8qKiBPdmVycmlkZXMgdGhlIERTTiBpbiB0aGUgZW52ZWxvcGUgaGVhZGVyICAqL1xuZnVuY3Rpb24gb3ZlcnJpZGVEc24oZW52ZWxvcGUkMSwgZHNuKSB7XG4gIHJldHVybiBlbnZlbG9wZS5jcmVhdGVFbnZlbG9wZShcbiAgICBkc25cbiAgICAgID8ge1xuICAgICAgICAgIC4uLmVudmVsb3BlJDFbMF0sXG4gICAgICAgICAgZHNuLFxuICAgICAgICB9XG4gICAgICA6IGVudmVsb3BlJDFbMF0sXG4gICAgZW52ZWxvcGUkMVsxXSxcbiAgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNwb3J0IHRoYXQgY2FuIHNlbmQgZXZlbnRzIHRvIGRpZmZlcmVudCBEU05zIGRlcGVuZGluZyBvbiB0aGUgZW52ZWxvcGUgY29udGVudHMuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNdWx0aXBsZXhlZFRyYW5zcG9ydChcbiAgY3JlYXRlVHJhbnNwb3J0LFxuICBtYXRjaGVyLFxuKSB7XG4gIHJldHVybiBvcHRpb25zID0+IHtcbiAgICBjb25zdCBmYWxsYmFja1RyYW5zcG9ydCA9IGNyZWF0ZVRyYW5zcG9ydChvcHRpb25zKTtcbiAgICBjb25zdCBvdGhlclRyYW5zcG9ydHMgPSBuZXcgTWFwKCk7XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc3BvcnQoZHNuJDEsIHJlbGVhc2UpIHtcbiAgICAgIC8vIFdlIGNyZWF0ZSBhIHRyYW5zcG9ydCBmb3IgZXZlcnkgdW5pcXVlIGRzbi9yZWxlYXNlIGNvbWJpbmF0aW9uIGFzIHRoZXJlIG1heSBiZSBjb2RlIGZyb20gbXVsdGlwbGUgcmVsZWFzZXMgaW5cbiAgICAgIC8vIHVzZSBhdCB0aGUgc2FtZSB0aW1lXG4gICAgICBjb25zdCBrZXkgPSByZWxlYXNlID8gYCR7ZHNuJDF9OiR7cmVsZWFzZX1gIDogZHNuJDE7XG5cbiAgICAgIGxldCB0cmFuc3BvcnQgPSBvdGhlclRyYW5zcG9ydHMuZ2V0KGtleSk7XG5cbiAgICAgIGlmICghdHJhbnNwb3J0KSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZERzbiA9IGRzbi5kc25Gcm9tU3RyaW5nKGRzbiQxKTtcbiAgICAgICAgaWYgKCF2YWxpZGF0ZWREc24pIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IGFwaS5nZXRFbnZlbG9wZUVuZHBvaW50V2l0aFVybEVuY29kZWRBdXRoKHZhbGlkYXRlZERzbiwgb3B0aW9ucy50dW5uZWwpO1xuXG4gICAgICAgIHRyYW5zcG9ydCA9IHJlbGVhc2VcbiAgICAgICAgICA/IG1ha2VPdmVycmlkZVJlbGVhc2VUcmFuc3BvcnQoY3JlYXRlVHJhbnNwb3J0LCByZWxlYXNlKSh7IC4uLm9wdGlvbnMsIHVybCB9KVxuICAgICAgICAgIDogY3JlYXRlVHJhbnNwb3J0KHsgLi4ub3B0aW9ucywgdXJsIH0pO1xuXG4gICAgICAgIG90aGVyVHJhbnNwb3J0cy5zZXQoa2V5LCB0cmFuc3BvcnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2RzbiQxLCB0cmFuc3BvcnRdO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHNlbmQoZW52ZWxvcGUpIHtcbiAgICAgIGZ1bmN0aW9uIGdldEV2ZW50KHR5cGVzKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50VHlwZXMgPSB0eXBlcz8ubGVuZ3RoID8gdHlwZXMgOiBbJ2V2ZW50J107XG4gICAgICAgIHJldHVybiBldmVudEZyb21FbnZlbG9wZShlbnZlbG9wZSwgZXZlbnRUeXBlcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRyYW5zcG9ydHMgPSBtYXRjaGVyKHsgZW52ZWxvcGUsIGdldEV2ZW50IH0pXG4gICAgICAgIC5tYXAocmVzdWx0ID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUcmFuc3BvcnQocmVzdWx0LCB1bmRlZmluZWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VHJhbnNwb3J0KHJlc3VsdC5kc24sIHJlc3VsdC5yZWxlYXNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKHQpID0+ICEhdCk7XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgbm8gdHJhbnNwb3J0cyB0byBzZW5kIHRvLCB1c2UgdGhlIGZhbGxiYWNrIHRyYW5zcG9ydFxuICAgICAgLy8gRG9uJ3Qgb3ZlcnJpZGUgdGhlIERTTiBpbiB0aGUgaGVhZGVyIGZvciB0aGUgZmFsbGJhY2sgdHJhbnNwb3J0LiAnJyBpcyBmYWxzeVxuICAgICAgY29uc3QgdHJhbnNwb3J0c1dpdGhGYWxsYmFjayA9IHRyYW5zcG9ydHMubGVuZ3RoID8gdHJhbnNwb3J0cyA6IFtbJycsIGZhbGxiYWNrVHJhbnNwb3J0XV07XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSAoYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHRyYW5zcG9ydHNXaXRoRmFsbGJhY2subWFwKChbZHNuLCB0cmFuc3BvcnRdKSA9PiB0cmFuc3BvcnQuc2VuZChvdmVycmlkZURzbihlbnZlbG9wZSwgZHNuKSkpLFxuICAgICAgKSkgO1xuXG4gICAgICByZXR1cm4gcmVzdWx0c1swXTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBmbHVzaCh0aW1lb3V0KSB7XG4gICAgICBjb25zdCBhbGxUcmFuc3BvcnRzID0gWy4uLm90aGVyVHJhbnNwb3J0cy52YWx1ZXMoKSwgZmFsbGJhY2tUcmFuc3BvcnRdO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGFsbFRyYW5zcG9ydHMubWFwKHRyYW5zcG9ydCA9PiB0cmFuc3BvcnQuZmx1c2godGltZW91dCkpKTtcbiAgICAgIHJldHVybiByZXN1bHRzLmV2ZXJ5KHIgPT4gcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbmQsXG4gICAgICBmbHVzaCxcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnRzLmV2ZW50RnJvbUVudmVsb3BlID0gZXZlbnRGcm9tRW52ZWxvcGU7XG5leHBvcnRzLm1ha2VNdWx0aXBsZXhlZFRyYW5zcG9ydCA9IG1ha2VNdWx0aXBsZXhlZFRyYW5zcG9ydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpcGxleGVkLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/transports/multiplexed.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/transports/offline.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst envelope = __webpack_require__(/*! ../utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst ratelimit = __webpack_require__(/*! ../utils-hoist/ratelimit.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/ratelimit.js\");\n\nconst MIN_DELAY = 100; // 100 ms\nconst START_DELAY = 5000; // 5 seconds\nconst MAX_DELAY = 3.6e6; // 1 hour\n\n/**\n * Wraps a transport and stores and retries events when they fail to send.\n *\n * @param createTransport The transport to wrap.\n */\nfunction makeOfflineTransport(\n  createTransport,\n) {\n  function log(...args) {\n    debugBuild.DEBUG_BUILD && logger.logger.info('[Offline]:', ...args);\n  }\n\n  return options => {\n    const transport = createTransport(options);\n\n    if (!options.createStore) {\n      throw new Error('No `createStore` function was provided');\n    }\n\n    const store = options.createStore(options);\n\n    let retryDelay = START_DELAY;\n    let flushTimer;\n\n    function shouldQueue(env, error, retryDelay) {\n      // We want to drop client reports because they can be generated when we retry sending events while offline.\n      if (envelope.envelopeContainsItemType(env, ['client_report'])) {\n        return false;\n      }\n\n      if (options.shouldStore) {\n        return options.shouldStore(env, error, retryDelay);\n      }\n\n      return true;\n    }\n\n    function flushIn(delay) {\n      if (flushTimer) {\n        clearTimeout(flushTimer );\n      }\n\n      flushTimer = setTimeout(async () => {\n        flushTimer = undefined;\n\n        const found = await store.shift();\n        if (found) {\n          log('Attempting to send previously queued event');\n\n          // We should to update the sent_at timestamp to the current time.\n          found[0].sent_at = new Date().toISOString();\n\n          void send(found, true).catch(e => {\n            log('Failed to retry sending', e);\n          });\n        }\n      }, delay) ;\n\n      // We need to unref the timer in node.js, otherwise the node process never exit.\n      if (typeof flushTimer !== 'number' && flushTimer.unref) {\n        flushTimer.unref();\n      }\n    }\n\n    function flushWithBackOff() {\n      if (flushTimer) {\n        return;\n      }\n\n      flushIn(retryDelay);\n\n      retryDelay = Math.min(retryDelay * 2, MAX_DELAY);\n    }\n\n    async function send(envelope$1, isRetry = false) {\n      // We queue all replay envelopes to avoid multiple replay envelopes being sent at the same time. If one fails, we\n      // need to retry them in order.\n      if (!isRetry && envelope.envelopeContainsItemType(envelope$1, ['replay_event', 'replay_recording'])) {\n        await store.push(envelope$1);\n        flushIn(MIN_DELAY);\n        return {};\n      }\n\n      try {\n        if (options.shouldSend && (await options.shouldSend(envelope$1)) === false) {\n          throw new Error('Envelope not sent because `shouldSend` callback returned false');\n        }\n\n        const result = await transport.send(envelope$1);\n\n        let delay = MIN_DELAY;\n\n        if (result) {\n          // If there's a retry-after header, use that as the next delay.\n          if (result.headers?.['retry-after']) {\n            delay = ratelimit.parseRetryAfterHeader(result.headers['retry-after']);\n          } else if (result.headers?.['x-sentry-rate-limits']) {\n            delay = 60000; // 60 seconds\n          } // If we have a server error, return now so we don't flush the queue.\n          else if ((result.statusCode || 0) >= 400) {\n            return result;\n          }\n        }\n\n        flushIn(delay);\n        retryDelay = START_DELAY;\n        return result;\n      } catch (e) {\n        if (await shouldQueue(envelope$1, e , retryDelay)) {\n          // If this envelope was a retry, we want to add it to the front of the queue so it's retried again first.\n          if (isRetry) {\n            await store.unshift(envelope$1);\n          } else {\n            await store.push(envelope$1);\n          }\n          flushWithBackOff();\n          log('Error sending. Event queued.', e );\n          return {};\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    if (options.flushAtStartup) {\n      flushWithBackOff();\n    }\n\n    return {\n      send,\n      flush: timeout => {\n        // If there's no timeout, we should attempt to flush the offline queue.\n        if (timeout === undefined) {\n          retryDelay = START_DELAY;\n          flushIn(MIN_DELAY);\n        }\n\n        return transport.flush(timeout);\n      },\n    };\n  };\n}\n\nexports.MIN_DELAY = MIN_DELAY;\nexports.START_DELAY = START_DELAY;\nexports.makeOfflineTransport = makeOfflineTransport;\n//# sourceMappingURL=offline.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RyYW5zcG9ydHMvb2ZmbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxtQkFBbUIsbUJBQU8sQ0FBQyx3SEFBbUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsMElBQTRCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQyxzSUFBMEI7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMsNElBQTZCOztBQUV2RCx1QkFBdUI7QUFDdkIsMEJBQTBCO0FBQzFCLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiwyQkFBMkI7QUFDM0IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFx0cmFuc3BvcnRzXFxvZmZsaW5lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IGVudmVsb3BlID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvZW52ZWxvcGUuanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuY29uc3QgcmF0ZWxpbWl0ID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvcmF0ZWxpbWl0LmpzJyk7XG5cbmNvbnN0IE1JTl9ERUxBWSA9IDEwMDsgLy8gMTAwIG1zXG5jb25zdCBTVEFSVF9ERUxBWSA9IDUwMDA7IC8vIDUgc2Vjb25kc1xuY29uc3QgTUFYX0RFTEFZID0gMy42ZTY7IC8vIDEgaG91clxuXG4vKipcbiAqIFdyYXBzIGEgdHJhbnNwb3J0IGFuZCBzdG9yZXMgYW5kIHJldHJpZXMgZXZlbnRzIHdoZW4gdGhleSBmYWlsIHRvIHNlbmQuXG4gKlxuICogQHBhcmFtIGNyZWF0ZVRyYW5zcG9ydCBUaGUgdHJhbnNwb3J0IHRvIHdyYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VPZmZsaW5lVHJhbnNwb3J0KFxuICBjcmVhdGVUcmFuc3BvcnQsXG4pIHtcbiAgZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIuaW5mbygnW09mZmxpbmVdOicsIC4uLmFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnMgPT4ge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IGNyZWF0ZVRyYW5zcG9ydChvcHRpb25zKTtcblxuICAgIGlmICghb3B0aW9ucy5jcmVhdGVTdG9yZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBgY3JlYXRlU3RvcmVgIGZ1bmN0aW9uIHdhcyBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3JlID0gb3B0aW9ucy5jcmVhdGVTdG9yZShvcHRpb25zKTtcblxuICAgIGxldCByZXRyeURlbGF5ID0gU1RBUlRfREVMQVk7XG4gICAgbGV0IGZsdXNoVGltZXI7XG5cbiAgICBmdW5jdGlvbiBzaG91bGRRdWV1ZShlbnYsIGVycm9yLCByZXRyeURlbGF5KSB7XG4gICAgICAvLyBXZSB3YW50IHRvIGRyb3AgY2xpZW50IHJlcG9ydHMgYmVjYXVzZSB0aGV5IGNhbiBiZSBnZW5lcmF0ZWQgd2hlbiB3ZSByZXRyeSBzZW5kaW5nIGV2ZW50cyB3aGlsZSBvZmZsaW5lLlxuICAgICAgaWYgKGVudmVsb3BlLmVudmVsb3BlQ29udGFpbnNJdGVtVHlwZShlbnYsIFsnY2xpZW50X3JlcG9ydCddKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnNob3VsZFN0b3JlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnNob3VsZFN0b3JlKGVudiwgZXJyb3IsIHJldHJ5RGVsYXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbHVzaEluKGRlbGF5KSB7XG4gICAgICBpZiAoZmx1c2hUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQoZmx1c2hUaW1lciApO1xuICAgICAgfVxuXG4gICAgICBmbHVzaFRpbWVyID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIGZsdXNoVGltZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgY29uc3QgZm91bmQgPSBhd2FpdCBzdG9yZS5zaGlmdCgpO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICBsb2coJ0F0dGVtcHRpbmcgdG8gc2VuZCBwcmV2aW91c2x5IHF1ZXVlZCBldmVudCcpO1xuXG4gICAgICAgICAgLy8gV2Ugc2hvdWxkIHRvIHVwZGF0ZSB0aGUgc2VudF9hdCB0aW1lc3RhbXAgdG8gdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgICAgICBmb3VuZFswXS5zZW50X2F0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuXG4gICAgICAgICAgdm9pZCBzZW5kKGZvdW5kLCB0cnVlKS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGxvZygnRmFpbGVkIHRvIHJldHJ5IHNlbmRpbmcnLCBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgZGVsYXkpIDtcblxuICAgICAgLy8gV2UgbmVlZCB0byB1bnJlZiB0aGUgdGltZXIgaW4gbm9kZS5qcywgb3RoZXJ3aXNlIHRoZSBub2RlIHByb2Nlc3MgbmV2ZXIgZXhpdC5cbiAgICAgIGlmICh0eXBlb2YgZmx1c2hUaW1lciAhPT0gJ251bWJlcicgJiYgZmx1c2hUaW1lci51bnJlZikge1xuICAgICAgICBmbHVzaFRpbWVyLnVucmVmKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmx1c2hXaXRoQmFja09mZigpIHtcbiAgICAgIGlmIChmbHVzaFRpbWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZmx1c2hJbihyZXRyeURlbGF5KTtcblxuICAgICAgcmV0cnlEZWxheSA9IE1hdGgubWluKHJldHJ5RGVsYXkgKiAyLCBNQVhfREVMQVkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHNlbmQoZW52ZWxvcGUkMSwgaXNSZXRyeSA9IGZhbHNlKSB7XG4gICAgICAvLyBXZSBxdWV1ZSBhbGwgcmVwbGF5IGVudmVsb3BlcyB0byBhdm9pZCBtdWx0aXBsZSByZXBsYXkgZW52ZWxvcGVzIGJlaW5nIHNlbnQgYXQgdGhlIHNhbWUgdGltZS4gSWYgb25lIGZhaWxzLCB3ZVxuICAgICAgLy8gbmVlZCB0byByZXRyeSB0aGVtIGluIG9yZGVyLlxuICAgICAgaWYgKCFpc1JldHJ5ICYmIGVudmVsb3BlLmVudmVsb3BlQ29udGFpbnNJdGVtVHlwZShlbnZlbG9wZSQxLCBbJ3JlcGxheV9ldmVudCcsICdyZXBsYXlfcmVjb3JkaW5nJ10pKSB7XG4gICAgICAgIGF3YWl0IHN0b3JlLnB1c2goZW52ZWxvcGUkMSk7XG4gICAgICAgIGZsdXNoSW4oTUlOX0RFTEFZKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRTZW5kICYmIChhd2FpdCBvcHRpb25zLnNob3VsZFNlbmQoZW52ZWxvcGUkMSkpID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW52ZWxvcGUgbm90IHNlbnQgYmVjYXVzZSBgc2hvdWxkU2VuZGAgY2FsbGJhY2sgcmV0dXJuZWQgZmFsc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRyYW5zcG9ydC5zZW5kKGVudmVsb3BlJDEpO1xuXG4gICAgICAgIGxldCBkZWxheSA9IE1JTl9ERUxBWTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHJldHJ5LWFmdGVyIGhlYWRlciwgdXNlIHRoYXQgYXMgdGhlIG5leHQgZGVsYXkuXG4gICAgICAgICAgaWYgKHJlc3VsdC5oZWFkZXJzPy5bJ3JldHJ5LWFmdGVyJ10pIHtcbiAgICAgICAgICAgIGRlbGF5ID0gcmF0ZWxpbWl0LnBhcnNlUmV0cnlBZnRlckhlYWRlcihyZXN1bHQuaGVhZGVyc1sncmV0cnktYWZ0ZXInXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuaGVhZGVycz8uWyd4LXNlbnRyeS1yYXRlLWxpbWl0cyddKSB7XG4gICAgICAgICAgICBkZWxheSA9IDYwMDAwOyAvLyA2MCBzZWNvbmRzXG4gICAgICAgICAgfSAvLyBJZiB3ZSBoYXZlIGEgc2VydmVyIGVycm9yLCByZXR1cm4gbm93IHNvIHdlIGRvbid0IGZsdXNoIHRoZSBxdWV1ZS5cbiAgICAgICAgICBlbHNlIGlmICgocmVzdWx0LnN0YXR1c0NvZGUgfHwgMCkgPj0gNDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoSW4oZGVsYXkpO1xuICAgICAgICByZXRyeURlbGF5ID0gU1RBUlRfREVMQVk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChhd2FpdCBzaG91bGRRdWV1ZShlbnZlbG9wZSQxLCBlICwgcmV0cnlEZWxheSkpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGVudmVsb3BlIHdhcyBhIHJldHJ5LCB3ZSB3YW50IHRvIGFkZCBpdCB0byB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlIHNvIGl0J3MgcmV0cmllZCBhZ2FpbiBmaXJzdC5cbiAgICAgICAgICBpZiAoaXNSZXRyeSkge1xuICAgICAgICAgICAgYXdhaXQgc3RvcmUudW5zaGlmdChlbnZlbG9wZSQxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgc3RvcmUucHVzaChlbnZlbG9wZSQxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hXaXRoQmFja09mZigpO1xuICAgICAgICAgIGxvZygnRXJyb3Igc2VuZGluZy4gRXZlbnQgcXVldWVkLicsIGUgKTtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZsdXNoQXRTdGFydHVwKSB7XG4gICAgICBmbHVzaFdpdGhCYWNrT2ZmKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbmQsXG4gICAgICBmbHVzaDogdGltZW91dCA9PiB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gdGltZW91dCwgd2Ugc2hvdWxkIGF0dGVtcHQgdG8gZmx1c2ggdGhlIG9mZmxpbmUgcXVldWUuXG4gICAgICAgIGlmICh0aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXRyeURlbGF5ID0gU1RBUlRfREVMQVk7XG4gICAgICAgICAgZmx1c2hJbihNSU5fREVMQVkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydC5mbHVzaCh0aW1lb3V0KTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0cy5NSU5fREVMQVkgPSBNSU5fREVMQVk7XG5leHBvcnRzLlNUQVJUX0RFTEFZID0gU1RBUlRfREVMQVk7XG5leHBvcnRzLm1ha2VPZmZsaW5lVHJhbnNwb3J0ID0gbWFrZU9mZmxpbmVUcmFuc3BvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vZmZsaW5lLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/transports/offline.js\n")},"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/trpc.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst exports$1 = __webpack_require__(/*! ./exports.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/exports.js\");\nconst semanticAttributes = __webpack_require__(/*! ./semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\n__webpack_require__(/*! ./tracing/errors.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/errors.js\");\nconst object = __webpack_require__(/*! ./utils-hoist/object.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/object.js\");\n__webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/debug-build.js\");\n__webpack_require__(/*! ./utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\n__webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst trace = __webpack_require__(/*! ./tracing/trace.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/tracing/trace.js\");\nconst normalize = __webpack_require__(/*! ./utils-hoist/normalize.js */ \"(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/utils-hoist/normalize.js\");\n\nconst trpcCaptureContext = { mechanism: { handled: false, data: { function: 'trpcMiddleware' } } };\n\nfunction captureIfError(nextResult) {\n  // TODO: Set span status based on what TRPCError was encountered\n  if (\n    typeof nextResult === 'object' &&\n    nextResult !== null &&\n    'ok' in nextResult &&\n    !nextResult.ok &&\n    'error' in nextResult\n  ) {\n    exports$1.captureException(nextResult.error, trpcCaptureContext);\n  }\n}\n\n/**\n * Sentry tRPC middleware that captures errors and creates spans for tRPC procedures.\n */\nfunction trpcMiddleware(options = {}) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return async function (opts) {\n    const { path, type, next, rawInput, getRawInput } = opts;\n\n    const client = currentScopes.getClient();\n    const clientOptions = client?.getOptions();\n\n    const trpcContext = {\n      procedure_path: path,\n      procedure_type: type,\n    };\n\n    object.addNonEnumerableProperty(\n      trpcContext,\n      '__sentry_override_normalization_depth__',\n      1 + // 1 for context.input + the normal normalization depth\n        (clientOptions?.normalizeDepth ?? 5), // 5 is a sane depth\n    );\n\n    if (options.attachRpcInput !== undefined ? options.attachRpcInput : clientOptions?.sendDefaultPii) {\n      if (rawInput !== undefined) {\n        trpcContext.input = normalize.normalize(rawInput);\n      }\n\n      if (getRawInput !== undefined && typeof getRawInput === 'function') {\n        try {\n          const rawRes = await getRawInput();\n\n          trpcContext.input = normalize.normalize(rawRes);\n        } catch (err) {\n          // noop\n        }\n      }\n    }\n\n    return currentScopes.withIsolationScope(scope => {\n      scope.setContext('trpc', trpcContext);\n      return trace.startSpanManual(\n        {\n          name: `trpc/${path}`,\n          op: 'rpc.server',\n          attributes: {\n            [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n            [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.rpc.trpc',\n          },\n          forceTransaction: !!options.forceTransaction,\n        },\n        async span => {\n          try {\n            const nextResult = await next();\n            captureIfError(nextResult);\n            span.end();\n            return nextResult;\n          } catch (e) {\n            exports$1.captureException(e, trpcCaptureContext);\n            span.end();\n            throw e;\n          }\n        },\n      ) ;\n    });\n  };\n}\n\nexports.trpcMiddleware = trpcMiddleware;\n//# sourceMappingURL=trpc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvY2pzL3RycGMuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsc0JBQXNCLG1CQUFPLENBQUMsMkhBQW9CO0FBQ2xELGtCQUFrQixtQkFBTyxDQUFDLCtHQUFjO0FBQ3hDLDJCQUEyQixtQkFBTyxDQUFDLHFJQUF5QjtBQUM1RCxtQkFBTyxDQUFDLDZIQUFxQjtBQUM3QixlQUFlLG1CQUFPLENBQUMscUlBQXlCO0FBQ2hELG1CQUFPLENBQUMsdUhBQWtCO0FBQzFCLG1CQUFPLENBQUMsaUlBQXVCO0FBQy9CLG1CQUFPLENBQUMscUlBQXlCO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQywySEFBb0I7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsMklBQTRCOztBQUV0RCw2QkFBNkIsYUFBYSx3QkFBd0I7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBMEM7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcb3BlbnRlbGVtZXRyeVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFx0cnBjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBleHBvcnRzJDEgPSByZXF1aXJlKCcuL2V4cG9ydHMuanMnKTtcbmNvbnN0IHNlbWFudGljQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vc2VtYW50aWNBdHRyaWJ1dGVzLmpzJyk7XG5yZXF1aXJlKCcuL3RyYWNpbmcvZXJyb3JzLmpzJyk7XG5jb25zdCBvYmplY3QgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L29iamVjdC5qcycpO1xucmVxdWlyZSgnLi9kZWJ1Zy1idWlsZC5qcycpO1xucmVxdWlyZSgnLi91dGlscy1ob2lzdC90aW1lLmpzJyk7XG5yZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuY29uc3QgdHJhY2UgPSByZXF1aXJlKCcuL3RyYWNpbmcvdHJhY2UuanMnKTtcbmNvbnN0IG5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3Qvbm9ybWFsaXplLmpzJyk7XG5cbmNvbnN0IHRycGNDYXB0dXJlQ29udGV4dCA9IHsgbWVjaGFuaXNtOiB7IGhhbmRsZWQ6IGZhbHNlLCBkYXRhOiB7IGZ1bmN0aW9uOiAndHJwY01pZGRsZXdhcmUnIH0gfSB9O1xuXG5mdW5jdGlvbiBjYXB0dXJlSWZFcnJvcihuZXh0UmVzdWx0KSB7XG4gIC8vIFRPRE86IFNldCBzcGFuIHN0YXR1cyBiYXNlZCBvbiB3aGF0IFRSUENFcnJvciB3YXMgZW5jb3VudGVyZWRcbiAgaWYgKFxuICAgIHR5cGVvZiBuZXh0UmVzdWx0ID09PSAnb2JqZWN0JyAmJlxuICAgIG5leHRSZXN1bHQgIT09IG51bGwgJiZcbiAgICAnb2snIGluIG5leHRSZXN1bHQgJiZcbiAgICAhbmV4dFJlc3VsdC5vayAmJlxuICAgICdlcnJvcicgaW4gbmV4dFJlc3VsdFxuICApIHtcbiAgICBleHBvcnRzJDEuY2FwdHVyZUV4Y2VwdGlvbihuZXh0UmVzdWx0LmVycm9yLCB0cnBjQ2FwdHVyZUNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogU2VudHJ5IHRSUEMgbWlkZGxld2FyZSB0aGF0IGNhcHR1cmVzIGVycm9ycyBhbmQgY3JlYXRlcyBzcGFucyBmb3IgdFJQQyBwcm9jZWR1cmVzLlxuICovXG5mdW5jdGlvbiB0cnBjTWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAob3B0cykge1xuICAgIGNvbnN0IHsgcGF0aCwgdHlwZSwgbmV4dCwgcmF3SW5wdXQsIGdldFJhd0lucHV0IH0gPSBvcHRzO1xuXG4gICAgY29uc3QgY2xpZW50ID0gY3VycmVudFNjb3Blcy5nZXRDbGllbnQoKTtcbiAgICBjb25zdCBjbGllbnRPcHRpb25zID0gY2xpZW50Py5nZXRPcHRpb25zKCk7XG5cbiAgICBjb25zdCB0cnBjQ29udGV4dCA9IHtcbiAgICAgIHByb2NlZHVyZV9wYXRoOiBwYXRoLFxuICAgICAgcHJvY2VkdXJlX3R5cGU6IHR5cGUsXG4gICAgfTtcblxuICAgIG9iamVjdC5hZGROb25FbnVtZXJhYmxlUHJvcGVydHkoXG4gICAgICB0cnBjQ29udGV4dCxcbiAgICAgICdfX3NlbnRyeV9vdmVycmlkZV9ub3JtYWxpemF0aW9uX2RlcHRoX18nLFxuICAgICAgMSArIC8vIDEgZm9yIGNvbnRleHQuaW5wdXQgKyB0aGUgbm9ybWFsIG5vcm1hbGl6YXRpb24gZGVwdGhcbiAgICAgICAgKGNsaWVudE9wdGlvbnM/Lm5vcm1hbGl6ZURlcHRoID8/IDUpLCAvLyA1IGlzIGEgc2FuZSBkZXB0aFxuICAgICk7XG5cbiAgICBpZiAob3B0aW9ucy5hdHRhY2hScGNJbnB1dCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hdHRhY2hScGNJbnB1dCA6IGNsaWVudE9wdGlvbnM/LnNlbmREZWZhdWx0UGlpKSB7XG4gICAgICBpZiAocmF3SW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cnBjQ29udGV4dC5pbnB1dCA9IG5vcm1hbGl6ZS5ub3JtYWxpemUocmF3SW5wdXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0UmF3SW5wdXQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZ2V0UmF3SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByYXdSZXMgPSBhd2FpdCBnZXRSYXdJbnB1dCgpO1xuXG4gICAgICAgICAgdHJwY0NvbnRleHQuaW5wdXQgPSBub3JtYWxpemUubm9ybWFsaXplKHJhd1Jlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50U2NvcGVzLndpdGhJc29sYXRpb25TY29wZShzY29wZSA9PiB7XG4gICAgICBzY29wZS5zZXRDb250ZXh0KCd0cnBjJywgdHJwY0NvbnRleHQpO1xuICAgICAgcmV0dXJuIHRyYWNlLnN0YXJ0U3Bhbk1hbnVhbChcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IGB0cnBjLyR7cGF0aH1gLFxuICAgICAgICAgIG9wOiAncnBjLnNlcnZlcicsXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06ICdyb3V0ZScsXG4gICAgICAgICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXTogJ2F1dG8ucnBjLnRycGMnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9yY2VUcmFuc2FjdGlvbjogISFvcHRpb25zLmZvcmNlVHJhbnNhY3Rpb24sXG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHNwYW4gPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0UmVzdWx0ID0gYXdhaXQgbmV4dCgpO1xuICAgICAgICAgICAgY2FwdHVyZUlmRXJyb3IobmV4dFJlc3VsdCk7XG4gICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHRSZXN1bHQ7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXhwb3J0cyQxLmNhcHR1cmVFeGNlcHRpb24oZSwgdHJwY0NhcHR1cmVDb250ZXh0KTtcbiAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICkgO1xuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnRzLnRycGNNaWRkbGV3YXJlID0gdHJwY01pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cnBjLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/opentelemetry/node_modules/@sentry/core/build/cjs/trpc.js\n")}};