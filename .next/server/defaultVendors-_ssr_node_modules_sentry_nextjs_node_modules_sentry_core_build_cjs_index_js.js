exports.id="defaultVendors-_ssr_node_modules_sentry_nextjs_node_modules_sentry_core_build_cjs_index_js",exports.ids=["defaultVendors-_ssr_node_modules_sentry_nextjs_node_modules_sentry_core_build_cjs_index_js"],exports.modules={"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/feedback.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\n\n/**\n * Send user feedback to Sentry.\n */\nfunction captureFeedback(\n  params,\n  hint = {},\n  scope = currentScopes.getCurrentScope(),\n) {\n  const { message, name, email, url, source, associatedEventId, tags } = params;\n\n  const feedbackEvent = {\n    contexts: {\n      feedback: {\n        contact_email: email,\n        name,\n        message,\n        url,\n        source,\n        associated_event_id: associatedEventId,\n      },\n    },\n    type: 'feedback',\n    level: 'info',\n    tags,\n  };\n\n  const client = scope?.getClient() || currentScopes.getClient();\n\n  if (client) {\n    client.emit('beforeSendFeedback', feedbackEvent, hint);\n  }\n\n  const eventId = scope.captureEvent(feedbackEvent, hint);\n\n  return eventId;\n}\n\nexports.captureFeedback = captureFeedback;\n//# sourceMappingURL=feedback.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvZmVlZGJhY2suanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsc0JBQXNCLG1CQUFPLENBQUMsb0hBQW9COztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVLDZEQUE2RDs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxmZWVkYmFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgY3VycmVudFNjb3BlcyA9IHJlcXVpcmUoJy4vY3VycmVudFNjb3Blcy5qcycpO1xuXG4vKipcbiAqIFNlbmQgdXNlciBmZWVkYmFjayB0byBTZW50cnkuXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVGZWVkYmFjayhcbiAgcGFyYW1zLFxuICBoaW50ID0ge30sXG4gIHNjb3BlID0gY3VycmVudFNjb3Blcy5nZXRDdXJyZW50U2NvcGUoKSxcbikge1xuICBjb25zdCB7IG1lc3NhZ2UsIG5hbWUsIGVtYWlsLCB1cmwsIHNvdXJjZSwgYXNzb2NpYXRlZEV2ZW50SWQsIHRhZ3MgfSA9IHBhcmFtcztcblxuICBjb25zdCBmZWVkYmFja0V2ZW50ID0ge1xuICAgIGNvbnRleHRzOiB7XG4gICAgICBmZWVkYmFjazoge1xuICAgICAgICBjb250YWN0X2VtYWlsOiBlbWFpbCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgdXJsLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGFzc29jaWF0ZWRfZXZlbnRfaWQ6IGFzc29jaWF0ZWRFdmVudElkLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHR5cGU6ICdmZWVkYmFjaycsXG4gICAgbGV2ZWw6ICdpbmZvJyxcbiAgICB0YWdzLFxuICB9O1xuXG4gIGNvbnN0IGNsaWVudCA9IHNjb3BlPy5nZXRDbGllbnQoKSB8fCBjdXJyZW50U2NvcGVzLmdldENsaWVudCgpO1xuXG4gIGlmIChjbGllbnQpIHtcbiAgICBjbGllbnQuZW1pdCgnYmVmb3JlU2VuZEZlZWRiYWNrJywgZmVlZGJhY2tFdmVudCwgaGludCk7XG4gIH1cblxuICBjb25zdCBldmVudElkID0gc2NvcGUuY2FwdHVyZUV2ZW50KGZlZWRiYWNrRXZlbnQsIGhpbnQpO1xuXG4gIHJldHVybiBldmVudElkO1xufVxuXG5leHBvcnRzLmNhcHR1cmVGZWVkYmFjayA9IGNhcHR1cmVGZWVkYmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZlZWRiYWNrLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/feedback.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/fetch.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst semanticAttributes = __webpack_require__(/*! ./semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\n__webpack_require__(/*! ./tracing/errors.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/errors.js\");\n__webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst is = __webpack_require__(/*! ./utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\n__webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst hasSpansEnabled = __webpack_require__(/*! ./utils/hasSpansEnabled.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/hasSpansEnabled.js\");\nconst spanUtils = __webpack_require__(/*! ./utils/spanUtils.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanUtils.js\");\n__webpack_require__(/*! ./utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst baggage = __webpack_require__(/*! ./utils-hoist/baggage.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/baggage.js\");\nconst sentryNonRecordingSpan = __webpack_require__(/*! ./tracing/sentryNonRecordingSpan.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sentryNonRecordingSpan.js\");\nconst spanstatus = __webpack_require__(/*! ./tracing/spanstatus.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js\");\nconst trace = __webpack_require__(/*! ./tracing/trace.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/trace.js\");\nconst traceData = __webpack_require__(/*! ./utils/traceData.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/traceData.js\");\nconst url = __webpack_require__(/*! ./utils-hoist/url.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/url.js\");\n\n/**\n * Create and track fetch request spans for usage in combination with `addFetchInstrumentationHandler`.\n *\n * @returns Span if a span was created, otherwise void.\n */\nfunction instrumentFetchRequest(\n  handlerData,\n  shouldCreateSpan,\n  shouldAttachHeaders,\n  spans,\n  spanOrigin = 'auto.http.browser',\n) {\n  if (!handlerData.fetchData) {\n    return undefined;\n  }\n\n  const { method, url } = handlerData.fetchData;\n\n  const shouldCreateSpanResult = hasSpansEnabled.hasSpansEnabled() && shouldCreateSpan(url);\n\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      endSpan(span, handlerData);\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n\n  const hasParent = !!spanUtils.getActiveSpan();\n\n  const span =\n    shouldCreateSpanResult && hasParent\n      ? trace.startInactiveSpan(getSpanStartOptions(url, method, spanOrigin))\n      : new sentryNonRecordingSpan.SentryNonRecordingSpan();\n\n  handlerData.fetchData.__span = span.spanContext().spanId;\n  spans[span.spanContext().spanId] = span;\n\n  if (shouldAttachHeaders(handlerData.fetchData.url)) {\n    const request = handlerData.args[0];\n\n    const options = handlerData.args[1] || {};\n\n    const headers = _addTracingHeadersToFetchRequest(\n      request,\n      options,\n      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n      // we do not want to use the span as base for the trace headers,\n      // which means that the headers will be generated from the scope and the sampling decision is deferred\n      hasSpansEnabled.hasSpansEnabled() && hasParent ? span : undefined,\n    );\n    if (headers) {\n      // Ensure this is actually set, if no options have been passed previously\n      handlerData.args[1] = options;\n      options.headers = headers;\n    }\n  }\n\n  const client = currentScopes.getClient();\n\n  if (client) {\n    const fetchHint = {\n      input: handlerData.args,\n      response: handlerData.response,\n      startTimestamp: handlerData.startTimestamp,\n      endTimestamp: handlerData.endTimestamp,\n    } ;\n\n    client.emit('beforeOutgoingRequestSpan', span, fetchHint);\n  }\n\n  return span;\n}\n\n/**\n * Adds sentry-trace and baggage headers to the various forms of fetch headers.\n * exported only for testing purposes\n *\n * When we determine if we should add a baggage header, there are 3 cases:\n * 1. No previous baggage header -> add baggage\n * 2. Previous baggage header has no sentry baggage values -> add our baggage\n * 3. Previous baggage header has sentry baggage values -> do nothing (might have been added manually by users)\n */\n// eslint-disable-next-line complexity -- yup it's this complicated :(\nfunction _addTracingHeadersToFetchRequest(\n  request,\n  fetchOptionsObj\n\n,\n  span,\n) {\n  const traceHeaders = traceData.getTraceData({ span });\n  const sentryTrace = traceHeaders['sentry-trace'];\n  const baggage = traceHeaders.baggage;\n\n  // Nothing to do, when we return undefined here, the original headers will be used\n  if (!sentryTrace) {\n    return undefined;\n  }\n\n  const originalHeaders = fetchOptionsObj.headers || (is.isRequest(request) ? request.headers : undefined);\n\n  if (!originalHeaders) {\n    return { ...traceHeaders };\n  } else if (isHeaders(originalHeaders)) {\n    const newHeaders = new Headers(originalHeaders);\n\n    // We don't want to override manually added sentry headers\n    if (!newHeaders.get('sentry-trace')) {\n      newHeaders.set('sentry-trace', sentryTrace);\n    }\n\n    if (baggage) {\n      const prevBaggageHeader = newHeaders.get('baggage');\n\n      if (!prevBaggageHeader) {\n        newHeaders.set('baggage', baggage);\n      } else if (!baggageHeaderHasSentryBaggageValues(prevBaggageHeader)) {\n        newHeaders.set('baggage', `${prevBaggageHeader},${baggage}`);\n      }\n    }\n\n    return newHeaders;\n  } else if (Array.isArray(originalHeaders)) {\n    const newHeaders = [...originalHeaders];\n\n    if (!originalHeaders.find(header => header[0] === 'sentry-trace')) {\n      newHeaders.push(['sentry-trace', sentryTrace]);\n    }\n\n    const prevBaggageHeaderWithSentryValues = originalHeaders.find(\n      header => header[0] === 'baggage' && baggageHeaderHasSentryBaggageValues(header[1]),\n    );\n\n    if (baggage && !prevBaggageHeaderWithSentryValues) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.push(['baggage', baggage]);\n    }\n\n    return newHeaders ;\n  } else {\n    const existingSentryTraceHeader = 'sentry-trace' in originalHeaders ? originalHeaders['sentry-trace'] : undefined;\n\n    const existingBaggageHeader = 'baggage' in originalHeaders ? originalHeaders.baggage : undefined;\n    const newBaggageHeaders = existingBaggageHeader\n      ? Array.isArray(existingBaggageHeader)\n        ? [...existingBaggageHeader]\n        : [existingBaggageHeader]\n      : [];\n\n    const prevBaggageHeaderWithSentryValues =\n      existingBaggageHeader &&\n      (Array.isArray(existingBaggageHeader)\n        ? existingBaggageHeader.find(headerItem => baggageHeaderHasSentryBaggageValues(headerItem))\n        : baggageHeaderHasSentryBaggageValues(existingBaggageHeader));\n\n    if (baggage && !prevBaggageHeaderWithSentryValues) {\n      newBaggageHeaders.push(baggage);\n    }\n\n    return {\n      ...(originalHeaders ),\n      'sentry-trace': (existingSentryTraceHeader ) ?? sentryTrace,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined,\n    };\n  }\n}\n\nfunction endSpan(span, handlerData) {\n  if (handlerData.response) {\n    spanstatus.setHttpStatus(span, handlerData.response.status);\n\n    const contentLength = handlerData.response?.headers && handlerData.response.headers.get('content-length');\n\n    if (contentLength) {\n      const contentLengthNum = parseInt(contentLength);\n      if (contentLengthNum > 0) {\n        span.setAttribute('http.response_content_length', contentLengthNum);\n      }\n    }\n  } else if (handlerData.error) {\n    span.setStatus({ code: spanstatus.SPAN_STATUS_ERROR, message: 'internal_error' });\n  }\n  span.end();\n}\n\nfunction baggageHeaderHasSentryBaggageValues(baggageHeader) {\n  return baggageHeader.split(',').some(baggageEntry => baggageEntry.trim().startsWith(baggage.SENTRY_BAGGAGE_KEY_PREFIX));\n}\n\nfunction isHeaders(headers) {\n  return typeof Headers !== 'undefined' && is.isInstanceOf(headers, Headers);\n}\n\nfunction getSpanStartOptions(\n  url$1,\n  method,\n  spanOrigin,\n) {\n  const parsedUrl = url.parseStringToURLObject(url$1);\n  return {\n    name: parsedUrl ? `${method} ${url.getSanitizedUrlStringFromUrlObject(parsedUrl)}` : method,\n    attributes: getFetchSpanAttributes(url$1, parsedUrl, method, spanOrigin),\n  };\n}\n\nfunction getFetchSpanAttributes(\n  url$1,\n  parsedUrl,\n  method,\n  spanOrigin,\n) {\n  const attributes = {\n    url: url$1,\n    type: 'fetch',\n    'http.method': method,\n    [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanOrigin,\n    [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client',\n  };\n  if (parsedUrl) {\n    if (!url.isURLObjectRelative(parsedUrl)) {\n      attributes['http.url'] = parsedUrl.href;\n      attributes['server.address'] = parsedUrl.host;\n    }\n    if (parsedUrl.search) {\n      attributes['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      attributes['http.fragment'] = parsedUrl.hash;\n    }\n  }\n  return attributes;\n}\n\nexports._addTracingHeadersToFetchRequest = _addTracingHeadersToFetchRequest;\nexports.instrumentFetchRequest = instrumentFetchRequest;\n//# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvZmV0Y2guanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsc0JBQXNCLG1CQUFPLENBQUMsb0hBQW9CO0FBQ2xELDJCQUEyQixtQkFBTyxDQUFDLDhIQUF5QjtBQUM1RCxtQkFBTyxDQUFDLHNIQUFxQjtBQUM3QixtQkFBTyxDQUFDLGdIQUFrQjtBQUMxQixXQUFXLG1CQUFPLENBQUMsc0hBQXFCO0FBQ3hDLG1CQUFPLENBQUMsOEhBQXlCO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLG9JQUE0QjtBQUM1RCxrQkFBa0IsbUJBQU8sQ0FBQyx3SEFBc0I7QUFDaEQsbUJBQU8sQ0FBQywwSEFBdUI7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsZ0lBQTBCO0FBQ2xELCtCQUErQixtQkFBTyxDQUFDLHNKQUFxQztBQUM1RSxtQkFBbUIsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDcEQsY0FBYyxtQkFBTyxDQUFDLG9IQUFvQjtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyx3SEFBc0I7QUFDaEQsWUFBWSxtQkFBTyxDQUFDLHdIQUFzQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsY0FBYzs7QUFFeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IscUNBQXFDLGtCQUFrQixHQUFHLFFBQVE7QUFDbEU7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oscUJBQXFCLCtEQUErRDtBQUNwRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRLEVBQUUsa0RBQWtEO0FBQ3JGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGZldGNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBzZW1hbnRpY0F0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL3NlbWFudGljQXR0cmlidXRlcy5qcycpO1xucmVxdWlyZSgnLi90cmFjaW5nL2Vycm9ycy5qcycpO1xucmVxdWlyZSgnLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3QgaXMgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2lzLmpzJyk7XG5yZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuY29uc3QgaGFzU3BhbnNFbmFibGVkID0gcmVxdWlyZSgnLi91dGlscy9oYXNTcGFuc0VuYWJsZWQuanMnKTtcbmNvbnN0IHNwYW5VdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvc3BhblV0aWxzLmpzJyk7XG5yZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3RpbWUuanMnKTtcbmNvbnN0IGJhZ2dhZ2UgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2JhZ2dhZ2UuanMnKTtcbmNvbnN0IHNlbnRyeU5vblJlY29yZGluZ1NwYW4gPSByZXF1aXJlKCcuL3RyYWNpbmcvc2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbi5qcycpO1xuY29uc3Qgc3BhbnN0YXR1cyA9IHJlcXVpcmUoJy4vdHJhY2luZy9zcGFuc3RhdHVzLmpzJyk7XG5jb25zdCB0cmFjZSA9IHJlcXVpcmUoJy4vdHJhY2luZy90cmFjZS5qcycpO1xuY29uc3QgdHJhY2VEYXRhID0gcmVxdWlyZSgnLi91dGlscy90cmFjZURhdGEuanMnKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvdXJsLmpzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuZCB0cmFjayBmZXRjaCByZXF1ZXN0IHNwYW5zIGZvciB1c2FnZSBpbiBjb21iaW5hdGlvbiB3aXRoIGBhZGRGZXRjaEluc3RydW1lbnRhdGlvbkhhbmRsZXJgLlxuICpcbiAqIEByZXR1cm5zIFNwYW4gaWYgYSBzcGFuIHdhcyBjcmVhdGVkLCBvdGhlcndpc2Ugdm9pZC5cbiAqL1xuZnVuY3Rpb24gaW5zdHJ1bWVudEZldGNoUmVxdWVzdChcbiAgaGFuZGxlckRhdGEsXG4gIHNob3VsZENyZWF0ZVNwYW4sXG4gIHNob3VsZEF0dGFjaEhlYWRlcnMsXG4gIHNwYW5zLFxuICBzcGFuT3JpZ2luID0gJ2F1dG8uaHR0cC5icm93c2VyJyxcbikge1xuICBpZiAoIWhhbmRsZXJEYXRhLmZldGNoRGF0YSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCB7IG1ldGhvZCwgdXJsIH0gPSBoYW5kbGVyRGF0YS5mZXRjaERhdGE7XG5cbiAgY29uc3Qgc2hvdWxkQ3JlYXRlU3BhblJlc3VsdCA9IGhhc1NwYW5zRW5hYmxlZC5oYXNTcGFuc0VuYWJsZWQoKSAmJiBzaG91bGRDcmVhdGVTcGFuKHVybCk7XG5cbiAgaWYgKGhhbmRsZXJEYXRhLmVuZFRpbWVzdGFtcCAmJiBzaG91bGRDcmVhdGVTcGFuUmVzdWx0KSB7XG4gICAgY29uc3Qgc3BhbklkID0gaGFuZGxlckRhdGEuZmV0Y2hEYXRhLl9fc3BhbjtcbiAgICBpZiAoIXNwYW5JZCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgc3BhbiA9IHNwYW5zW3NwYW5JZF07XG4gICAgaWYgKHNwYW4pIHtcbiAgICAgIGVuZFNwYW4oc3BhbiwgaGFuZGxlckRhdGEpO1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICBkZWxldGUgc3BhbnNbc3BhbklkXTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGhhc1BhcmVudCA9ICEhc3BhblV0aWxzLmdldEFjdGl2ZVNwYW4oKTtcblxuICBjb25zdCBzcGFuID1cbiAgICBzaG91bGRDcmVhdGVTcGFuUmVzdWx0ICYmIGhhc1BhcmVudFxuICAgICAgPyB0cmFjZS5zdGFydEluYWN0aXZlU3BhbihnZXRTcGFuU3RhcnRPcHRpb25zKHVybCwgbWV0aG9kLCBzcGFuT3JpZ2luKSlcbiAgICAgIDogbmV3IHNlbnRyeU5vblJlY29yZGluZ1NwYW4uU2VudHJ5Tm9uUmVjb3JkaW5nU3BhbigpO1xuXG4gIGhhbmRsZXJEYXRhLmZldGNoRGF0YS5fX3NwYW4gPSBzcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkO1xuICBzcGFuc1tzcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkXSA9IHNwYW47XG5cbiAgaWYgKHNob3VsZEF0dGFjaEhlYWRlcnMoaGFuZGxlckRhdGEuZmV0Y2hEYXRhLnVybCkpIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gaGFuZGxlckRhdGEuYXJnc1swXTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBoYW5kbGVyRGF0YS5hcmdzWzFdIHx8IHt9O1xuXG4gICAgY29uc3QgaGVhZGVycyA9IF9hZGRUcmFjaW5nSGVhZGVyc1RvRmV0Y2hSZXF1ZXN0KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICAvLyBJZiBwZXJmb3JtYW5jZSBpcyBkaXNhYmxlZCAoVFdQKSBvciB0aGVyZSdzIG5vIGFjdGl2ZSByb290IHNwYW4gKHBhZ2Vsb2FkL25hdmlnYXRpb24vaW50ZXJhY3Rpb24pLFxuICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gdXNlIHRoZSBzcGFuIGFzIGJhc2UgZm9yIHRoZSB0cmFjZSBoZWFkZXJzLFxuICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB0aGUgaGVhZGVycyB3aWxsIGJlIGdlbmVyYXRlZCBmcm9tIHRoZSBzY29wZSBhbmQgdGhlIHNhbXBsaW5nIGRlY2lzaW9uIGlzIGRlZmVycmVkXG4gICAgICBoYXNTcGFuc0VuYWJsZWQuaGFzU3BhbnNFbmFibGVkKCkgJiYgaGFzUGFyZW50ID8gc3BhbiA6IHVuZGVmaW5lZCxcbiAgICApO1xuICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAvLyBFbnN1cmUgdGhpcyBpcyBhY3R1YWxseSBzZXQsIGlmIG5vIG9wdGlvbnMgaGF2ZSBiZWVuIHBhc3NlZCBwcmV2aW91c2x5XG4gICAgICBoYW5kbGVyRGF0YS5hcmdzWzFdID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2xpZW50ID0gY3VycmVudFNjb3Blcy5nZXRDbGllbnQoKTtcblxuICBpZiAoY2xpZW50KSB7XG4gICAgY29uc3QgZmV0Y2hIaW50ID0ge1xuICAgICAgaW5wdXQ6IGhhbmRsZXJEYXRhLmFyZ3MsXG4gICAgICByZXNwb25zZTogaGFuZGxlckRhdGEucmVzcG9uc2UsXG4gICAgICBzdGFydFRpbWVzdGFtcDogaGFuZGxlckRhdGEuc3RhcnRUaW1lc3RhbXAsXG4gICAgICBlbmRUaW1lc3RhbXA6IGhhbmRsZXJEYXRhLmVuZFRpbWVzdGFtcCxcbiAgICB9IDtcblxuICAgIGNsaWVudC5lbWl0KCdiZWZvcmVPdXRnb2luZ1JlcXVlc3RTcGFuJywgc3BhbiwgZmV0Y2hIaW50KTtcbiAgfVxuXG4gIHJldHVybiBzcGFuO1xufVxuXG4vKipcbiAqIEFkZHMgc2VudHJ5LXRyYWNlIGFuZCBiYWdnYWdlIGhlYWRlcnMgdG8gdGhlIHZhcmlvdXMgZm9ybXMgb2YgZmV0Y2ggaGVhZGVycy5cbiAqIGV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcgcHVycG9zZXNcbiAqXG4gKiBXaGVuIHdlIGRldGVybWluZSBpZiB3ZSBzaG91bGQgYWRkIGEgYmFnZ2FnZSBoZWFkZXIsIHRoZXJlIGFyZSAzIGNhc2VzOlxuICogMS4gTm8gcHJldmlvdXMgYmFnZ2FnZSBoZWFkZXIgLT4gYWRkIGJhZ2dhZ2VcbiAqIDIuIFByZXZpb3VzIGJhZ2dhZ2UgaGVhZGVyIGhhcyBubyBzZW50cnkgYmFnZ2FnZSB2YWx1ZXMgLT4gYWRkIG91ciBiYWdnYWdlXG4gKiAzLiBQcmV2aW91cyBiYWdnYWdlIGhlYWRlciBoYXMgc2VudHJ5IGJhZ2dhZ2UgdmFsdWVzIC0+IGRvIG5vdGhpbmcgKG1pZ2h0IGhhdmUgYmVlbiBhZGRlZCBtYW51YWxseSBieSB1c2VycylcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHkgLS0geXVwIGl0J3MgdGhpcyBjb21wbGljYXRlZCA6KFxuZnVuY3Rpb24gX2FkZFRyYWNpbmdIZWFkZXJzVG9GZXRjaFJlcXVlc3QoXG4gIHJlcXVlc3QsXG4gIGZldGNoT3B0aW9uc09ialxuXG4sXG4gIHNwYW4sXG4pIHtcbiAgY29uc3QgdHJhY2VIZWFkZXJzID0gdHJhY2VEYXRhLmdldFRyYWNlRGF0YSh7IHNwYW4gfSk7XG4gIGNvbnN0IHNlbnRyeVRyYWNlID0gdHJhY2VIZWFkZXJzWydzZW50cnktdHJhY2UnXTtcbiAgY29uc3QgYmFnZ2FnZSA9IHRyYWNlSGVhZGVycy5iYWdnYWdlO1xuXG4gIC8vIE5vdGhpbmcgdG8gZG8sIHdoZW4gd2UgcmV0dXJuIHVuZGVmaW5lZCBoZXJlLCB0aGUgb3JpZ2luYWwgaGVhZGVycyB3aWxsIGJlIHVzZWRcbiAgaWYgKCFzZW50cnlUcmFjZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBvcmlnaW5hbEhlYWRlcnMgPSBmZXRjaE9wdGlvbnNPYmouaGVhZGVycyB8fCAoaXMuaXNSZXF1ZXN0KHJlcXVlc3QpID8gcmVxdWVzdC5oZWFkZXJzIDogdW5kZWZpbmVkKTtcblxuICBpZiAoIW9yaWdpbmFsSGVhZGVycykge1xuICAgIHJldHVybiB7IC4uLnRyYWNlSGVhZGVycyB9O1xuICB9IGVsc2UgaWYgKGlzSGVhZGVycyhvcmlnaW5hbEhlYWRlcnMpKSB7XG4gICAgY29uc3QgbmV3SGVhZGVycyA9IG5ldyBIZWFkZXJzKG9yaWdpbmFsSGVhZGVycyk7XG5cbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIG1hbnVhbGx5IGFkZGVkIHNlbnRyeSBoZWFkZXJzXG4gICAgaWYgKCFuZXdIZWFkZXJzLmdldCgnc2VudHJ5LXRyYWNlJykpIHtcbiAgICAgIG5ld0hlYWRlcnMuc2V0KCdzZW50cnktdHJhY2UnLCBzZW50cnlUcmFjZSk7XG4gICAgfVxuXG4gICAgaWYgKGJhZ2dhZ2UpIHtcbiAgICAgIGNvbnN0IHByZXZCYWdnYWdlSGVhZGVyID0gbmV3SGVhZGVycy5nZXQoJ2JhZ2dhZ2UnKTtcblxuICAgICAgaWYgKCFwcmV2QmFnZ2FnZUhlYWRlcikge1xuICAgICAgICBuZXdIZWFkZXJzLnNldCgnYmFnZ2FnZScsIGJhZ2dhZ2UpO1xuICAgICAgfSBlbHNlIGlmICghYmFnZ2FnZUhlYWRlckhhc1NlbnRyeUJhZ2dhZ2VWYWx1ZXMocHJldkJhZ2dhZ2VIZWFkZXIpKSB7XG4gICAgICAgIG5ld0hlYWRlcnMuc2V0KCdiYWdnYWdlJywgYCR7cHJldkJhZ2dhZ2VIZWFkZXJ9LCR7YmFnZ2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3SGVhZGVycztcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbmFsSGVhZGVycykpIHtcbiAgICBjb25zdCBuZXdIZWFkZXJzID0gWy4uLm9yaWdpbmFsSGVhZGVyc107XG5cbiAgICBpZiAoIW9yaWdpbmFsSGVhZGVycy5maW5kKGhlYWRlciA9PiBoZWFkZXJbMF0gPT09ICdzZW50cnktdHJhY2UnKSkge1xuICAgICAgbmV3SGVhZGVycy5wdXNoKFsnc2VudHJ5LXRyYWNlJywgc2VudHJ5VHJhY2VdKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2QmFnZ2FnZUhlYWRlcldpdGhTZW50cnlWYWx1ZXMgPSBvcmlnaW5hbEhlYWRlcnMuZmluZChcbiAgICAgIGhlYWRlciA9PiBoZWFkZXJbMF0gPT09ICdiYWdnYWdlJyAmJiBiYWdnYWdlSGVhZGVySGFzU2VudHJ5QmFnZ2FnZVZhbHVlcyhoZWFkZXJbMV0pLFxuICAgICk7XG5cbiAgICBpZiAoYmFnZ2FnZSAmJiAhcHJldkJhZ2dhZ2VIZWFkZXJXaXRoU2VudHJ5VmFsdWVzKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgZW50cmllcyB3aXRoIHRoZSBzYW1lIGtleSwgdGhlIGJyb3dzZXIgd2lsbCBtZXJnZSB0aGUgdmFsdWVzIGludG8gYSBzaW5nbGUgcmVxdWVzdCBoZWFkZXIuXG4gICAgICAvLyBJdHMgdGhlcmVmb3JlIHNhZmUgdG8gc2ltcGx5IHB1c2ggYSBcImJhZ2dhZ2VcIiBlbnRyeSwgZXZlbiB0aG91Z2ggdGhlcmUgbWlnaHQgYWxyZWFkeSBiZSBhbm90aGVyIGJhZ2dhZ2UgaGVhZGVyLlxuICAgICAgbmV3SGVhZGVycy5wdXNoKFsnYmFnZ2FnZScsIGJhZ2dhZ2VdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3SGVhZGVycyA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZXhpc3RpbmdTZW50cnlUcmFjZUhlYWRlciA9ICdzZW50cnktdHJhY2UnIGluIG9yaWdpbmFsSGVhZGVycyA/IG9yaWdpbmFsSGVhZGVyc1snc2VudHJ5LXRyYWNlJ10gOiB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBleGlzdGluZ0JhZ2dhZ2VIZWFkZXIgPSAnYmFnZ2FnZScgaW4gb3JpZ2luYWxIZWFkZXJzID8gb3JpZ2luYWxIZWFkZXJzLmJhZ2dhZ2UgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbmV3QmFnZ2FnZUhlYWRlcnMgPSBleGlzdGluZ0JhZ2dhZ2VIZWFkZXJcbiAgICAgID8gQXJyYXkuaXNBcnJheShleGlzdGluZ0JhZ2dhZ2VIZWFkZXIpXG4gICAgICAgID8gWy4uLmV4aXN0aW5nQmFnZ2FnZUhlYWRlcl1cbiAgICAgICAgOiBbZXhpc3RpbmdCYWdnYWdlSGVhZGVyXVxuICAgICAgOiBbXTtcblxuICAgIGNvbnN0IHByZXZCYWdnYWdlSGVhZGVyV2l0aFNlbnRyeVZhbHVlcyA9XG4gICAgICBleGlzdGluZ0JhZ2dhZ2VIZWFkZXIgJiZcbiAgICAgIChBcnJheS5pc0FycmF5KGV4aXN0aW5nQmFnZ2FnZUhlYWRlcilcbiAgICAgICAgPyBleGlzdGluZ0JhZ2dhZ2VIZWFkZXIuZmluZChoZWFkZXJJdGVtID0+IGJhZ2dhZ2VIZWFkZXJIYXNTZW50cnlCYWdnYWdlVmFsdWVzKGhlYWRlckl0ZW0pKVxuICAgICAgICA6IGJhZ2dhZ2VIZWFkZXJIYXNTZW50cnlCYWdnYWdlVmFsdWVzKGV4aXN0aW5nQmFnZ2FnZUhlYWRlcikpO1xuXG4gICAgaWYgKGJhZ2dhZ2UgJiYgIXByZXZCYWdnYWdlSGVhZGVyV2l0aFNlbnRyeVZhbHVlcykge1xuICAgICAgbmV3QmFnZ2FnZUhlYWRlcnMucHVzaChiYWdnYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uKG9yaWdpbmFsSGVhZGVycyApLFxuICAgICAgJ3NlbnRyeS10cmFjZSc6IChleGlzdGluZ1NlbnRyeVRyYWNlSGVhZGVyICkgPz8gc2VudHJ5VHJhY2UsXG4gICAgICBiYWdnYWdlOiBuZXdCYWdnYWdlSGVhZGVycy5sZW5ndGggPiAwID8gbmV3QmFnZ2FnZUhlYWRlcnMuam9pbignLCcpIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kU3BhbihzcGFuLCBoYW5kbGVyRGF0YSkge1xuICBpZiAoaGFuZGxlckRhdGEucmVzcG9uc2UpIHtcbiAgICBzcGFuc3RhdHVzLnNldEh0dHBTdGF0dXMoc3BhbiwgaGFuZGxlckRhdGEucmVzcG9uc2Uuc3RhdHVzKTtcblxuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBoYW5kbGVyRGF0YS5yZXNwb25zZT8uaGVhZGVycyAmJiBoYW5kbGVyRGF0YS5yZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKTtcblxuICAgIGlmIChjb250ZW50TGVuZ3RoKSB7XG4gICAgICBjb25zdCBjb250ZW50TGVuZ3RoTnVtID0gcGFyc2VJbnQoY29udGVudExlbmd0aCk7XG4gICAgICBpZiAoY29udGVudExlbmd0aE51bSA+IDApIHtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoJ2h0dHAucmVzcG9uc2VfY29udGVudF9sZW5ndGgnLCBjb250ZW50TGVuZ3RoTnVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaGFuZGxlckRhdGEuZXJyb3IpIHtcbiAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IHNwYW5zdGF0dXMuU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICdpbnRlcm5hbF9lcnJvcicgfSk7XG4gIH1cbiAgc3Bhbi5lbmQoKTtcbn1cblxuZnVuY3Rpb24gYmFnZ2FnZUhlYWRlckhhc1NlbnRyeUJhZ2dhZ2VWYWx1ZXMoYmFnZ2FnZUhlYWRlcikge1xuICByZXR1cm4gYmFnZ2FnZUhlYWRlci5zcGxpdCgnLCcpLnNvbWUoYmFnZ2FnZUVudHJ5ID0+IGJhZ2dhZ2VFbnRyeS50cmltKCkuc3RhcnRzV2l0aChiYWdnYWdlLlNFTlRSWV9CQUdHQUdFX0tFWV9QUkVGSVgpKTtcbn1cblxuZnVuY3Rpb24gaXNIZWFkZXJzKGhlYWRlcnMpIHtcbiAgcmV0dXJuIHR5cGVvZiBIZWFkZXJzICE9PSAndW5kZWZpbmVkJyAmJiBpcy5pc0luc3RhbmNlT2YoaGVhZGVycywgSGVhZGVycyk7XG59XG5cbmZ1bmN0aW9uIGdldFNwYW5TdGFydE9wdGlvbnMoXG4gIHVybCQxLFxuICBtZXRob2QsXG4gIHNwYW5PcmlnaW4sXG4pIHtcbiAgY29uc3QgcGFyc2VkVXJsID0gdXJsLnBhcnNlU3RyaW5nVG9VUkxPYmplY3QodXJsJDEpO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IHBhcnNlZFVybCA/IGAke21ldGhvZH0gJHt1cmwuZ2V0U2FuaXRpemVkVXJsU3RyaW5nRnJvbVVybE9iamVjdChwYXJzZWRVcmwpfWAgOiBtZXRob2QsXG4gICAgYXR0cmlidXRlczogZ2V0RmV0Y2hTcGFuQXR0cmlidXRlcyh1cmwkMSwgcGFyc2VkVXJsLCBtZXRob2QsIHNwYW5PcmlnaW4pLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRGZXRjaFNwYW5BdHRyaWJ1dGVzKFxuICB1cmwkMSxcbiAgcGFyc2VkVXJsLFxuICBtZXRob2QsXG4gIHNwYW5PcmlnaW4sXG4pIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICB1cmw6IHVybCQxLFxuICAgIHR5cGU6ICdmZXRjaCcsXG4gICAgJ2h0dHAubWV0aG9kJzogbWV0aG9kLFxuICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiBzcGFuT3JpZ2luLFxuICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF06ICdodHRwLmNsaWVudCcsXG4gIH07XG4gIGlmIChwYXJzZWRVcmwpIHtcbiAgICBpZiAoIXVybC5pc1VSTE9iamVjdFJlbGF0aXZlKHBhcnNlZFVybCkpIHtcbiAgICAgIGF0dHJpYnV0ZXNbJ2h0dHAudXJsJ10gPSBwYXJzZWRVcmwuaHJlZjtcbiAgICAgIGF0dHJpYnV0ZXNbJ3NlcnZlci5hZGRyZXNzJ10gPSBwYXJzZWRVcmwuaG9zdDtcbiAgICB9XG4gICAgaWYgKHBhcnNlZFVybC5zZWFyY2gpIHtcbiAgICAgIGF0dHJpYnV0ZXNbJ2h0dHAucXVlcnknXSA9IHBhcnNlZFVybC5zZWFyY2g7XG4gICAgfVxuICAgIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgICAgYXR0cmlidXRlc1snaHR0cC5mcmFnbWVudCddID0gcGFyc2VkVXJsLmhhc2g7XG4gICAgfVxuICB9XG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufVxuXG5leHBvcnRzLl9hZGRUcmFjaW5nSGVhZGVyc1RvRmV0Y2hSZXF1ZXN0ID0gX2FkZFRyYWNpbmdIZWFkZXJzVG9GZXRjaFJlcXVlc3Q7XG5leHBvcnRzLmluc3RydW1lbnRGZXRjaFJlcXVlc3QgPSBpbnN0cnVtZW50RmV0Y2hSZXF1ZXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/fetch.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst errors = __webpack_require__(/*! ./tracing/errors.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/errors.js");\nconst utils = __webpack_require__(/*! ./tracing/utils.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/utils.js");\nconst idleSpan = __webpack_require__(/*! ./tracing/idleSpan.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/idleSpan.js");\nconst sentrySpan = __webpack_require__(/*! ./tracing/sentrySpan.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sentrySpan.js");\nconst sentryNonRecordingSpan = __webpack_require__(/*! ./tracing/sentryNonRecordingSpan.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sentryNonRecordingSpan.js");\nconst spanstatus = __webpack_require__(/*! ./tracing/spanstatus.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js");\nconst trace = __webpack_require__(/*! ./tracing/trace.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/trace.js");\nconst dynamicSamplingContext = __webpack_require__(/*! ./tracing/dynamicSamplingContext.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js");\nconst measurement = __webpack_require__(/*! ./tracing/measurement.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/measurement.js");\nconst sampling = __webpack_require__(/*! ./tracing/sampling.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sampling.js");\nconst logSpans = __webpack_require__(/*! ./tracing/logSpans.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/logSpans.js");\nconst semanticAttributes = __webpack_require__(/*! ./semanticAttributes.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/semanticAttributes.js");\nconst envelope = __webpack_require__(/*! ./envelope.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/envelope.js");\nconst exports$1 = __webpack_require__(/*! ./exports.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/exports.js");\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js");\nconst defaultScopes = __webpack_require__(/*! ./defaultScopes.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/defaultScopes.js");\nconst index = __webpack_require__(/*! ./asyncContext/index.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/asyncContext/index.js");\nconst carrier = __webpack_require__(/*! ./carrier.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/carrier.js");\nconst session = __webpack_require__(/*! ./session.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/session.js");\nconst scope = __webpack_require__(/*! ./scope.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/scope.js");\nconst eventProcessors = __webpack_require__(/*! ./eventProcessors.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/eventProcessors.js");\nconst api = __webpack_require__(/*! ./api.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/api.js");\nconst client = __webpack_require__(/*! ./client.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/client.js");\nconst serverRuntimeClient = __webpack_require__(/*! ./server-runtime-client.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/server-runtime-client.js");\nconst sdk = __webpack_require__(/*! ./sdk.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/sdk.js");\nconst base = __webpack_require__(/*! ./transports/base.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/transports/base.js");\nconst offline = __webpack_require__(/*! ./transports/offline.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/transports/offline.js");\nconst multiplexed = __webpack_require__(/*! ./transports/multiplexed.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/transports/multiplexed.js");\nconst integration = __webpack_require__(/*! ./integration.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js");\nconst applyScopeDataToEvent = __webpack_require__(/*! ./utils/applyScopeDataToEvent.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/applyScopeDataToEvent.js");\nconst prepareEvent = __webpack_require__(/*! ./utils/prepareEvent.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/prepareEvent.js");\nconst checkin = __webpack_require__(/*! ./checkin.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/checkin.js");\nconst hasSpansEnabled = __webpack_require__(/*! ./utils/hasSpansEnabled.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/hasSpansEnabled.js");\nconst isSentryRequestUrl = __webpack_require__(/*! ./utils/isSentryRequestUrl.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/isSentryRequestUrl.js");\nconst handleCallbackErrors = __webpack_require__(/*! ./utils/handleCallbackErrors.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/handleCallbackErrors.js");\nconst parameterize = __webpack_require__(/*! ./utils/parameterize.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/parameterize.js");\nconst ipAddress = __webpack_require__(/*! ./utils/ipAddress.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/ipAddress.js");\nconst spanUtils = __webpack_require__(/*! ./utils/spanUtils.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanUtils.js");\nconst parseSampleRate = __webpack_require__(/*! ./utils/parseSampleRate.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/parseSampleRate.js");\nconst sdkMetadata = __webpack_require__(/*! ./utils/sdkMetadata.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/sdkMetadata.js");\nconst traceData = __webpack_require__(/*! ./utils/traceData.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/traceData.js");\nconst meta = __webpack_require__(/*! ./utils/meta.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/meta.js");\nconst request = __webpack_require__(/*! ./utils/request.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/request.js");\nconst constants = __webpack_require__(/*! ./constants.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/constants.js");\nconst breadcrumbs = __webpack_require__(/*! ./breadcrumbs.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/breadcrumbs.js");\nconst functiontostring = __webpack_require__(/*! ./integrations/functiontostring.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/functiontostring.js");\nconst eventFilters = __webpack_require__(/*! ./integrations/eventFilters.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/eventFilters.js");\nconst linkederrors = __webpack_require__(/*! ./integrations/linkederrors.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/linkederrors.js");\nconst metadata = __webpack_require__(/*! ./integrations/metadata.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/metadata.js");\nconst requestdata = __webpack_require__(/*! ./integrations/requestdata.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/requestdata.js");\nconst captureconsole = __webpack_require__(/*! ./integrations/captureconsole.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/captureconsole.js");\nconst dedupe = __webpack_require__(/*! ./integrations/dedupe.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/dedupe.js");\nconst extraerrordata = __webpack_require__(/*! ./integrations/extraerrordata.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/extraerrordata.js");\nconst rewriteframes = __webpack_require__(/*! ./integrations/rewriteframes.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/rewriteframes.js");\nconst supabase = __webpack_require__(/*! ./integrations/supabase.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/supabase.js");\nconst zoderrors = __webpack_require__(/*! ./integrations/zoderrors.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/zoderrors.js");\nconst thirdPartyErrorsFilter = __webpack_require__(/*! ./integrations/third-party-errors-filter.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/third-party-errors-filter.js");\nconst console = __webpack_require__(/*! ./integrations/console.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/console.js");\nconst profiling = __webpack_require__(/*! ./profiling.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/profiling.js");\nconst fetch = __webpack_require__(/*! ./fetch.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/fetch.js");\nconst trpc = __webpack_require__(/*! ./trpc.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/trpc.js");\nconst mcpServer = __webpack_require__(/*! ./mcp-server.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/mcp-server.js");\nconst feedback = __webpack_require__(/*! ./feedback.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/feedback.js");\nconst exports$2 = __webpack_require__(/*! ./logs/exports.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/exports.js");\nconst consoleIntegration = __webpack_require__(/*! ./logs/console-integration.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/console-integration.js");\nconst aggregateErrors = __webpack_require__(/*! ./utils-hoist/aggregate-errors.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/aggregate-errors.js");\nconst breadcrumbLogLevel = __webpack_require__(/*! ./utils-hoist/breadcrumb-log-level.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/breadcrumb-log-level.js");\nconst browser = __webpack_require__(/*! ./utils-hoist/browser.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/browser.js");\nconst dsn = __webpack_require__(/*! ./utils-hoist/dsn.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/dsn.js");\nconst error = __webpack_require__(/*! ./utils-hoist/error.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/error.js");\nconst worldwide = __webpack_require__(/*! ./utils-hoist/worldwide.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js");\nconst console$1 = __webpack_require__(/*! ./utils-hoist/instrument/console.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/console.js");\nconst fetch$1 = __webpack_require__(/*! ./utils-hoist/instrument/fetch.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/fetch.js");\nconst globalError = __webpack_require__(/*! ./utils-hoist/instrument/globalError.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/globalError.js");\nconst globalUnhandledRejection = __webpack_require__(/*! ./utils-hoist/instrument/globalUnhandledRejection.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/globalUnhandledRejection.js");\nconst handlers = __webpack_require__(/*! ./utils-hoist/instrument/handlers.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/handlers.js");\nconst is = __webpack_require__(/*! ./utils-hoist/is.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/is.js");\nconst isBrowser = __webpack_require__(/*! ./utils-hoist/isBrowser.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/isBrowser.js");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js");\nconst misc = __webpack_require__(/*! ./utils-hoist/misc.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js");\nconst node = __webpack_require__(/*! ./utils-hoist/node.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/node.js");\nconst normalize = __webpack_require__(/*! ./utils-hoist/normalize.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/normalize.js");\nconst object = __webpack_require__(/*! ./utils-hoist/object.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/object.js");\nconst path = __webpack_require__(/*! ./utils-hoist/path.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/path.js");\nconst promisebuffer = __webpack_require__(/*! ./utils-hoist/promisebuffer.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/promisebuffer.js");\nconst severity = __webpack_require__(/*! ./utils-hoist/severity.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/severity.js");\nconst stacktrace = __webpack_require__(/*! ./utils-hoist/stacktrace.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/stacktrace.js");\nconst nodeStackTrace = __webpack_require__(/*! ./utils-hoist/node-stack-trace.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/node-stack-trace.js");\nconst string = __webpack_require__(/*! ./utils-hoist/string.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/string.js");\nconst supports = __webpack_require__(/*! ./utils-hoist/supports.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/supports.js");\nconst syncpromise = __webpack_require__(/*! ./utils-hoist/syncpromise.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/syncpromise.js");\nconst time = __webpack_require__(/*! ./utils-hoist/time.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/time.js");\nconst tracing = __webpack_require__(/*! ./utils-hoist/tracing.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/tracing.js");\nconst env = __webpack_require__(/*! ./utils-hoist/env.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/env.js");\nconst envelope$1 = __webpack_require__(/*! ./utils-hoist/envelope.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js");\nconst clientreport = __webpack_require__(/*! ./utils-hoist/clientreport.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/clientreport.js");\nconst ratelimit = __webpack_require__(/*! ./utils-hoist/ratelimit.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/ratelimit.js");\nconst baggage = __webpack_require__(/*! ./utils-hoist/baggage.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/baggage.js");\nconst url = __webpack_require__(/*! ./utils-hoist/url.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/url.js");\nconst eventbuilder = __webpack_require__(/*! ./utils-hoist/eventbuilder.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/eventbuilder.js");\nconst anr = __webpack_require__(/*! ./utils-hoist/anr.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/anr.js");\nconst lru = __webpack_require__(/*! ./utils-hoist/lru.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/lru.js");\nconst propagationContext = __webpack_require__(/*! ./utils-hoist/propagationContext.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/propagationContext.js");\nconst vercelWaitUntil = __webpack_require__(/*! ./utils-hoist/vercelWaitUntil.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/vercelWaitUntil.js");\nconst version = __webpack_require__(/*! ./utils-hoist/version.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/version.js");\nconst debugIds = __webpack_require__(/*! ./utils-hoist/debug-ids.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/debug-ids.js");\nconst escapeStringForRegex = __webpack_require__(/*! ./utils-hoist/vendor/escapeStringForRegex.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/vendor/escapeStringForRegex.js");\n\n\n\nexports.registerSpanErrorInstrumentation = errors.registerSpanErrorInstrumentation;\nexports.getCapturedScopesOnSpan = utils.getCapturedScopesOnSpan;\nexports.setCapturedScopesOnSpan = utils.setCapturedScopesOnSpan;\nexports.TRACING_DEFAULTS = idleSpan.TRACING_DEFAULTS;\nexports.startIdleSpan = idleSpan.startIdleSpan;\nexports.SentrySpan = sentrySpan.SentrySpan;\nexports.SentryNonRecordingSpan = sentryNonRecordingSpan.SentryNonRecordingSpan;\nexports.SPAN_STATUS_ERROR = spanstatus.SPAN_STATUS_ERROR;\nexports.SPAN_STATUS_OK = spanstatus.SPAN_STATUS_OK;\nexports.SPAN_STATUS_UNSET = spanstatus.SPAN_STATUS_UNSET;\nexports.getSpanStatusFromHttpCode = spanstatus.getSpanStatusFromHttpCode;\nexports.setHttpStatus = spanstatus.setHttpStatus;\nexports.continueTrace = trace.continueTrace;\nexports.startInactiveSpan = trace.startInactiveSpan;\nexports.startNewTrace = trace.startNewTrace;\nexports.startSpan = trace.startSpan;\nexports.startSpanManual = trace.startSpanManual;\nexports.suppressTracing = trace.suppressTracing;\nexports.withActiveSpan = trace.withActiveSpan;\nexports.getDynamicSamplingContextFromClient = dynamicSamplingContext.getDynamicSamplingContextFromClient;\nexports.getDynamicSamplingContextFromScope = dynamicSamplingContext.getDynamicSamplingContextFromScope;\nexports.getDynamicSamplingContextFromSpan = dynamicSamplingContext.getDynamicSamplingContextFromSpan;\nexports.spanToBaggageHeader = dynamicSamplingContext.spanToBaggageHeader;\nexports.setMeasurement = measurement.setMeasurement;\nexports.timedEventsToMeasurements = measurement.timedEventsToMeasurements;\nexports.sampleSpan = sampling.sampleSpan;\nexports.logSpanEnd = logSpans.logSpanEnd;\nexports.logSpanStart = logSpans.logSpanStart;\nexports.SEMANTIC_ATTRIBUTE_CACHE_HIT = semanticAttributes.SEMANTIC_ATTRIBUTE_CACHE_HIT;\nexports.SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = semanticAttributes.SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE;\nexports.SEMANTIC_ATTRIBUTE_CACHE_KEY = semanticAttributes.SEMANTIC_ATTRIBUTE_CACHE_KEY;\nexports.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = semanticAttributes.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME;\nexports.SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD = semanticAttributes.SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD;\nexports.SEMANTIC_ATTRIBUTE_PROFILE_ID = semanticAttributes.SEMANTIC_ATTRIBUTE_PROFILE_ID;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_OP = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE;\nexports.SEMANTIC_ATTRIBUTE_URL_FULL = semanticAttributes.SEMANTIC_ATTRIBUTE_URL_FULL;\nexports.SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE = semanticAttributes.SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE;\nexports.createEventEnvelope = envelope.createEventEnvelope;\nexports.createSessionEnvelope = envelope.createSessionEnvelope;\nexports.createSpanEnvelope = envelope.createSpanEnvelope;\nexports.addEventProcessor = exports$1.addEventProcessor;\nexports.captureCheckIn = exports$1.captureCheckIn;\nexports.captureEvent = exports$1.captureEvent;\nexports.captureException = exports$1.captureException;\nexports.captureMessage = exports$1.captureMessage;\nexports.captureSession = exports$1.captureSession;\nexports.close = exports$1.close;\nexports.endSession = exports$1.endSession;\nexports.flush = exports$1.flush;\nexports.isEnabled = exports$1.isEnabled;\nexports.isInitialized = exports$1.isInitialized;\nexports.lastEventId = exports$1.lastEventId;\nexports.setContext = exports$1.setContext;\nexports.setExtra = exports$1.setExtra;\nexports.setExtras = exports$1.setExtras;\nexports.setTag = exports$1.setTag;\nexports.setTags = exports$1.setTags;\nexports.setUser = exports$1.setUser;\nexports.startSession = exports$1.startSession;\nexports.withMonitor = exports$1.withMonitor;\nexports.getClient = currentScopes.getClient;\nexports.getCurrentScope = currentScopes.getCurrentScope;\nexports.getGlobalScope = currentScopes.getGlobalScope;\nexports.getIsolationScope = currentScopes.getIsolationScope;\nexports.getTraceContextFromScope = currentScopes.getTraceContextFromScope;\nexports.withIsolationScope = currentScopes.withIsolationScope;\nexports.withScope = currentScopes.withScope;\nexports.getDefaultCurrentScope = defaultScopes.getDefaultCurrentScope;\nexports.getDefaultIsolationScope = defaultScopes.getDefaultIsolationScope;\nexports.setAsyncContextStrategy = index.setAsyncContextStrategy;\nexports.getGlobalSingleton = carrier.getGlobalSingleton;\nexports.getMainCarrier = carrier.getMainCarrier;\nexports.closeSession = session.closeSession;\nexports.makeSession = session.makeSession;\nexports.updateSession = session.updateSession;\nexports.Scope = scope.Scope;\nexports.notifyEventProcessors = eventProcessors.notifyEventProcessors;\nexports.getEnvelopeEndpointWithUrlEncodedAuth = api.getEnvelopeEndpointWithUrlEncodedAuth;\nexports.getReportDialogEndpoint = api.getReportDialogEndpoint;\nexports.BaseClient = client.BaseClient;\nexports.Client = client.Client;\nexports.ServerRuntimeClient = serverRuntimeClient.ServerRuntimeClient;\nexports.initAndBind = sdk.initAndBind;\nexports.setCurrentClient = sdk.setCurrentClient;\nexports.createTransport = base.createTransport;\nexports.makeOfflineTransport = offline.makeOfflineTransport;\nexports.makeMultiplexedTransport = multiplexed.makeMultiplexedTransport;\nexports.addIntegration = integration.addIntegration;\nexports.defineIntegration = integration.defineIntegration;\nexports.getIntegrationsToSetup = integration.getIntegrationsToSetup;\nexports.applyScopeDataToEvent = applyScopeDataToEvent.applyScopeDataToEvent;\nexports.mergeScopeData = applyScopeDataToEvent.mergeScopeData;\nexports.prepareEvent = prepareEvent.prepareEvent;\nexports.createCheckInEnvelope = checkin.createCheckInEnvelope;\nexports.hasSpansEnabled = hasSpansEnabled.hasSpansEnabled;\nexports.hasTracingEnabled = hasSpansEnabled.hasTracingEnabled;\nexports.isSentryRequestUrl = isSentryRequestUrl.isSentryRequestUrl;\nexports.handleCallbackErrors = handleCallbackErrors.handleCallbackErrors;\nexports.fmt = parameterize.fmt;\nexports.parameterize = parameterize.parameterize;\nexports.addAutoIpAddressToSession = ipAddress.addAutoIpAddressToSession;\nexports.addAutoIpAddressToUser = ipAddress.addAutoIpAddressToUser;\nexports.addChildSpanToSpan = spanUtils.addChildSpanToSpan;\nexports.convertSpanLinksForEnvelope = spanUtils.convertSpanLinksForEnvelope;\nexports.getActiveSpan = spanUtils.getActiveSpan;\nexports.getRootSpan = spanUtils.getRootSpan;\nexports.getSpanDescendants = spanUtils.getSpanDescendants;\nexports.getStatusMessage = spanUtils.getStatusMessage;\nexports.spanIsSampled = spanUtils.spanIsSampled;\nexports.spanTimeInputToSeconds = spanUtils.spanTimeInputToSeconds;\nexports.spanToJSON = spanUtils.spanToJSON;\nexports.spanToTraceContext = spanUtils.spanToTraceContext;\nexports.spanToTraceHeader = spanUtils.spanToTraceHeader;\nexports.updateSpanName = spanUtils.updateSpanName;\nexports.parseSampleRate = parseSampleRate.parseSampleRate;\nexports.applySdkMetadata = sdkMetadata.applySdkMetadata;\nexports.getTraceData = traceData.getTraceData;\nexports.getTraceMetaTags = meta.getTraceMetaTags;\nexports.extractQueryParamsFromUrl = request.extractQueryParamsFromUrl;\nexports.headersToDict = request.headersToDict;\nexports.httpRequestToRequestData = request.httpRequestToRequestData;\nexports.winterCGHeadersToDict = request.winterCGHeadersToDict;\nexports.winterCGRequestToRequestData = request.winterCGRequestToRequestData;\nexports.DEFAULT_ENVIRONMENT = constants.DEFAULT_ENVIRONMENT;\nexports.addBreadcrumb = breadcrumbs.addBreadcrumb;\nexports.functionToStringIntegration = functiontostring.functionToStringIntegration;\nexports.eventFiltersIntegration = eventFilters.eventFiltersIntegration;\nexports.inboundFiltersIntegration = eventFilters.inboundFiltersIntegration;\nexports.linkedErrorsIntegration = linkederrors.linkedErrorsIntegration;\nexports.moduleMetadataIntegration = metadata.moduleMetadataIntegration;\nexports.requestDataIntegration = requestdata.requestDataIntegration;\nexports.captureConsoleIntegration = captureconsole.captureConsoleIntegration;\nexports.dedupeIntegration = dedupe.dedupeIntegration;\nexports.extraErrorDataIntegration = extraerrordata.extraErrorDataIntegration;\nexports.rewriteFramesIntegration = rewriteframes.rewriteFramesIntegration;\nexports.instrumentSupabaseClient = supabase.instrumentSupabaseClient;\nexports.supabaseIntegration = supabase.supabaseIntegration;\nexports.zodErrorsIntegration = zoderrors.zodErrorsIntegration;\nexports.thirdPartyErrorFilterIntegration = thirdPartyErrorsFilter.thirdPartyErrorFilterIntegration;\nexports.consoleIntegration = console.consoleIntegration;\nexports.profiler = profiling.profiler;\nexports.instrumentFetchRequest = fetch.instrumentFetchRequest;\nexports.trpcMiddleware = trpc.trpcMiddleware;\nexports.wrapMcpServerWithSentry = mcpServer.wrapMcpServerWithSentry;\nexports.captureFeedback = feedback.captureFeedback;\nexports._INTERNAL_captureLog = exports$2._INTERNAL_captureLog;\nexports._INTERNAL_captureSerializedLog = exports$2._INTERNAL_captureSerializedLog;\nexports._INTERNAL_flushLogsBuffer = exports$2._INTERNAL_flushLogsBuffer;\nexports.consoleLoggingIntegration = consoleIntegration.consoleLoggingIntegration;\nexports.applyAggregateErrorsToEvent = aggregateErrors.applyAggregateErrorsToEvent;\nexports.getBreadcrumbLogLevelFromHttpStatusCode = breadcrumbLogLevel.getBreadcrumbLogLevelFromHttpStatusCode;\nexports.getComponentName = browser.getComponentName;\nexports.getLocationHref = browser.getLocationHref;\nexports.htmlTreeAsString = browser.htmlTreeAsString;\nexports.dsnFromString = dsn.dsnFromString;\nexports.dsnToString = dsn.dsnToString;\nexports.makeDsn = dsn.makeDsn;\nexports.SentryError = error.SentryError;\nexports.GLOBAL_OBJ = worldwide.GLOBAL_OBJ;\nexports.addConsoleInstrumentationHandler = console$1.addConsoleInstrumentationHandler;\nexports.addFetchEndInstrumentationHandler = fetch$1.addFetchEndInstrumentationHandler;\nexports.addFetchInstrumentationHandler = fetch$1.addFetchInstrumentationHandler;\nexports.addGlobalErrorInstrumentationHandler = globalError.addGlobalErrorInstrumentationHandler;\nexports.addGlobalUnhandledRejectionInstrumentationHandler = globalUnhandledRejection.addGlobalUnhandledRejectionInstrumentationHandler;\nexports.addHandler = handlers.addHandler;\nexports.maybeInstrument = handlers.maybeInstrument;\nexports.resetInstrumentationHandlers = handlers.resetInstrumentationHandlers;\nexports.triggerHandlers = handlers.triggerHandlers;\nexports.isDOMError = is.isDOMError;\nexports.isDOMException = is.isDOMException;\nexports.isElement = is.isElement;\nexports.isError = is.isError;\nexports.isErrorEvent = is.isErrorEvent;\nexports.isEvent = is.isEvent;\nexports.isInstanceOf = is.isInstanceOf;\nexports.isParameterizedString = is.isParameterizedString;\nexports.isPlainObject = is.isPlainObject;\nexports.isPrimitive = is.isPrimitive;\nexports.isRegExp = is.isRegExp;\nexports.isString = is.isString;\nexports.isSyntheticEvent = is.isSyntheticEvent;\nexports.isThenable = is.isThenable;\nexports.isVueViewModel = is.isVueViewModel;\nexports.isBrowser = isBrowser.isBrowser;\nexports.CONSOLE_LEVELS = logger.CONSOLE_LEVELS;\nexports.consoleSandbox = logger.consoleSandbox;\nexports.logger = logger.logger;\nexports.originalConsoleMethods = logger.originalConsoleMethods;\nexports.addContextToFrame = misc.addContextToFrame;\nexports.addExceptionMechanism = misc.addExceptionMechanism;\nexports.addExceptionTypeValue = misc.addExceptionTypeValue;\nexports.checkOrSetAlreadyCaught = misc.checkOrSetAlreadyCaught;\nexports.getEventDescription = misc.getEventDescription;\nexports.parseSemver = misc.parseSemver;\nexports.uuid4 = misc.uuid4;\nexports.isNodeEnv = node.isNodeEnv;\nexports.loadModule = node.loadModule;\nexports.normalize = normalize.normalize;\nexports.normalizeToSize = normalize.normalizeToSize;\nexports.normalizeUrlToBase = normalize.normalizeUrlToBase;\nexports.addNonEnumerableProperty = object.addNonEnumerableProperty;\nexports.convertToPlainObject = object.convertToPlainObject;\nexports.dropUndefinedKeys = object.dropUndefinedKeys;\nexports.extractExceptionKeysForMessage = object.extractExceptionKeysForMessage;\nexports.fill = object.fill;\nexports.getOriginalFunction = object.getOriginalFunction;\nexports.markFunctionWrapped = object.markFunctionWrapped;\nexports.objectify = object.objectify;\nexports.basename = path.basename;\nexports.dirname = path.dirname;\nexports.isAbsolute = path.isAbsolute;\nexports.join = path.join;\nexports.normalizePath = path.normalizePath;\nexports.relative = path.relative;\nexports.resolve = path.resolve;\nexports.SENTRY_BUFFER_FULL_ERROR = promisebuffer.SENTRY_BUFFER_FULL_ERROR;\nexports.makePromiseBuffer = promisebuffer.makePromiseBuffer;\nexports.severityLevelFromString = severity.severityLevelFromString;\nexports.UNKNOWN_FUNCTION = stacktrace.UNKNOWN_FUNCTION;\nexports.createStackParser = stacktrace.createStackParser;\nexports.getFramesFromEvent = stacktrace.getFramesFromEvent;\nexports.getFunctionName = stacktrace.getFunctionName;\nexports.stackParserFromStackParserOptions = stacktrace.stackParserFromStackParserOptions;\nexports.stripSentryFramesAndReverse = stacktrace.stripSentryFramesAndReverse;\nexports.filenameIsInApp = nodeStackTrace.filenameIsInApp;\nexports.node = nodeStackTrace.node;\nexports.nodeStackLineParser = nodeStackTrace.nodeStackLineParser;\nexports.isMatchingPattern = string.isMatchingPattern;\nexports.safeJoin = string.safeJoin;\nexports.snipLine = string.snipLine;\nexports.stringMatchesSomePattern = string.stringMatchesSomePattern;\nexports.truncate = string.truncate;\nexports.isNativeFunction = supports.isNativeFunction;\nexports.supportsDOMError = supports.supportsDOMError;\nexports.supportsDOMException = supports.supportsDOMException;\nexports.supportsErrorEvent = supports.supportsErrorEvent;\nexports.supportsFetch = supports.supportsFetch;\nexports.supportsHistory = supports.supportsHistory;\nexports.supportsNativeFetch = supports.supportsNativeFetch;\nexports.supportsReferrerPolicy = supports.supportsReferrerPolicy;\nexports.supportsReportingObserver = supports.supportsReportingObserver;\nexports.SyncPromise = syncpromise.SyncPromise;\nexports.rejectedSyncPromise = syncpromise.rejectedSyncPromise;\nexports.resolvedSyncPromise = syncpromise.resolvedSyncPromise;\nexports.browserPerformanceTimeOrigin = time.browserPerformanceTimeOrigin;\nexports.dateTimestampInSeconds = time.dateTimestampInSeconds;\nexports.timestampInSeconds = time.timestampInSeconds;\nexports.TRACEPARENT_REGEXP = tracing.TRACEPARENT_REGEXP;\nexports.extractTraceparentData = tracing.extractTraceparentData;\nexports.generateSentryTraceHeader = tracing.generateSentryTraceHeader;\nexports.propagationContextFromHeaders = tracing.propagationContextFromHeaders;\nexports.getSDKSource = env.getSDKSource;\nexports.isBrowserBundle = env.isBrowserBundle;\nexports.addItemToEnvelope = envelope$1.addItemToEnvelope;\nexports.createAttachmentEnvelopeItem = envelope$1.createAttachmentEnvelopeItem;\nexports.createEnvelope = envelope$1.createEnvelope;\nexports.createEventEnvelopeHeaders = envelope$1.createEventEnvelopeHeaders;\nexports.createSpanEnvelopeItem = envelope$1.createSpanEnvelopeItem;\nexports.envelopeContainsItemType = envelope$1.envelopeContainsItemType;\nexports.envelopeItemTypeToDataCategory = envelope$1.envelopeItemTypeToDataCategory;\nexports.forEachEnvelopeItem = envelope$1.forEachEnvelopeItem;\nexports.getSdkMetadataForEnvelopeHeader = envelope$1.getSdkMetadataForEnvelopeHeader;\nexports.parseEnvelope = envelope$1.parseEnvelope;\nexports.serializeEnvelope = envelope$1.serializeEnvelope;\nexports.createClientReportEnvelope = clientreport.createClientReportEnvelope;\nexports.DEFAULT_RETRY_AFTER = ratelimit.DEFAULT_RETRY_AFTER;\nexports.disabledUntil = ratelimit.disabledUntil;\nexports.isRateLimited = ratelimit.isRateLimited;\nexports.parseRetryAfterHeader = ratelimit.parseRetryAfterHeader;\nexports.updateRateLimits = ratelimit.updateRateLimits;\nexports.MAX_BAGGAGE_STRING_LENGTH = baggage.MAX_BAGGAGE_STRING_LENGTH;\nexports.SENTRY_BAGGAGE_KEY_PREFIX = baggage.SENTRY_BAGGAGE_KEY_PREFIX;\nexports.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = baggage.SENTRY_BAGGAGE_KEY_PREFIX_REGEX;\nexports.baggageHeaderToDynamicSamplingContext = baggage.baggageHeaderToDynamicSamplingContext;\nexports.dynamicSamplingContextToSentryBaggageHeader = baggage.dynamicSamplingContextToSentryBaggageHeader;\nexports.objectToBaggageHeader = baggage.objectToBaggageHeader;\nexports.parseBaggageHeader = baggage.parseBaggageHeader;\nexports.getHttpSpanDetailsFromUrlObject = url.getHttpSpanDetailsFromUrlObject;\nexports.getSanitizedUrlString = url.getSanitizedUrlString;\nexports.getSanitizedUrlStringFromUrlObject = url.getSanitizedUrlStringFromUrlObject;\nexports.isURLObjectRelative = url.isURLObjectRelative;\nexports.parseStringToURLObject = url.parseStringToURLObject;\nexports.parseUrl = url.parseUrl;\nexports.stripUrlQueryAndFragment = url.stripUrlQueryAndFragment;\nexports.eventFromMessage = eventbuilder.eventFromMessage;\nexports.eventFromUnknownInput = eventbuilder.eventFromUnknownInput;\nexports.exceptionFromError = eventbuilder.exceptionFromError;\nexports.parseStackFrames = eventbuilder.parseStackFrames;\nexports.callFrameToStackFrame = anr.callFrameToStackFrame;\nexports.watchdogTimer = anr.watchdogTimer;\nexports.LRUMap = lru.LRUMap;\nexports.generateSpanId = propagationContext.generateSpanId;\nexports.generateTraceId = propagationContext.generateTraceId;\nexports.vercelWaitUntil = vercelWaitUntil.vercelWaitUntil;\nexports.SDK_VERSION = version.SDK_VERSION;\nexports.getDebugImagesForResources = debugIds.getDebugImagesForResources;\nexports.getFilenameToDebugIdMap = debugIds.getFilenameToDebugIdMap;\nexports.escapeStringForRegex = escapeStringForRegex.escapeStringForRegex;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsZUFBZSxtQkFBTyxDQUFDLHNIQUFxQjtBQUM1QyxjQUFjLG1CQUFPLENBQUMsb0hBQW9CO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLDBIQUF1QjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDcEQsK0JBQStCLG1CQUFPLENBQUMsc0pBQXFDO0FBQzVFLG1CQUFtQixtQkFBTyxDQUFDLDhIQUF5QjtBQUNwRCxjQUFjLG1CQUFPLENBQUMsb0hBQW9CO0FBQzFDLCtCQUErQixtQkFBTyxDQUFDLHNKQUFxQztBQUM1RSxvQkFBb0IsbUJBQU8sQ0FBQyxnSUFBMEI7QUFDdEQsaUJBQWlCLG1CQUFPLENBQUMsMEhBQXVCO0FBQ2hELGlCQUFpQixtQkFBTyxDQUFDLDBIQUF1QjtBQUNoRCwyQkFBMkIsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDNUQsaUJBQWlCLG1CQUFPLENBQUMsMEdBQWU7QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMsd0dBQWM7QUFDeEMsc0JBQXNCLG1CQUFPLENBQUMsb0hBQW9CO0FBQ2xELHNCQUFzQixtQkFBTyxDQUFDLG9IQUFvQjtBQUNsRCxjQUFjLG1CQUFPLENBQUMsOEhBQXlCO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLHdHQUFjO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLHdHQUFjO0FBQ3RDLGNBQWMsbUJBQU8sQ0FBQyxvR0FBWTtBQUNsQyx3QkFBd0IsbUJBQU8sQ0FBQyx3SEFBc0I7QUFDdEQsWUFBWSxtQkFBTyxDQUFDLGdHQUFVO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyxzR0FBYTtBQUNwQyw0QkFBNEIsbUJBQU8sQ0FBQyxvSUFBNEI7QUFDaEUsWUFBWSxtQkFBTyxDQUFDLGdHQUFVO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyx3SEFBc0I7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsOEhBQXlCO0FBQ2pELG9CQUFvQixtQkFBTyxDQUFDLHNJQUE2QjtBQUN6RCxvQkFBb0IsbUJBQU8sQ0FBQyxnSEFBa0I7QUFDOUMsOEJBQThCLG1CQUFPLENBQUMsZ0pBQWtDO0FBQ3hFLHFCQUFxQixtQkFBTyxDQUFDLDhIQUF5QjtBQUN0RCxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBYztBQUN0Qyx3QkFBd0IsbUJBQU8sQ0FBQyxvSUFBNEI7QUFDNUQsMkJBQTJCLG1CQUFPLENBQUMsMElBQStCO0FBQ2xFLDZCQUE2QixtQkFBTyxDQUFDLDhJQUFpQztBQUN0RSxxQkFBcUIsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsd0hBQXNCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLHdIQUFzQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQyxvSUFBNEI7QUFDNUQsb0JBQW9CLG1CQUFPLENBQUMsNEhBQXdCO0FBQ3BELGtCQUFrQixtQkFBTyxDQUFDLHdIQUFzQjtBQUNoRCxhQUFhLG1CQUFPLENBQUMsOEdBQWlCO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLG9IQUFvQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyw0R0FBZ0I7QUFDMUMsb0JBQW9CLG1CQUFPLENBQUMsZ0hBQWtCO0FBQzlDLHlCQUF5QixtQkFBTyxDQUFDLG9KQUFvQztBQUNyRSxxQkFBcUIsbUJBQU8sQ0FBQyw0SUFBZ0M7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMsNElBQWdDO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLG9JQUE0QjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQywwSUFBK0I7QUFDM0QsdUJBQXVCLG1CQUFPLENBQUMsZ0pBQWtDO0FBQ2pFLGVBQWUsbUJBQU8sQ0FBQyxnSUFBMEI7QUFDakQsdUJBQXVCLG1CQUFPLENBQUMsZ0pBQWtDO0FBQ2pFLHNCQUFzQixtQkFBTyxDQUFDLDhJQUFpQztBQUMvRCxpQkFBaUIsbUJBQU8sQ0FBQyxvSUFBNEI7QUFDckQsa0JBQWtCLG1CQUFPLENBQUMsc0lBQTZCO0FBQ3ZELCtCQUErQixtQkFBTyxDQUFDLHNLQUE2QztBQUNwRixnQkFBZ0IsbUJBQU8sQ0FBQyxrSUFBMkI7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsNEdBQWdCO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxvR0FBWTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsa0dBQVc7QUFDaEMsa0JBQWtCLG1CQUFPLENBQUMsOEdBQWlCO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLDBHQUFlO0FBQ3hDLGtCQUFrQixtQkFBTyxDQUFDLGtIQUFtQjtBQUM3QywyQkFBMkIsbUJBQU8sQ0FBQywwSUFBK0I7QUFDbEUsd0JBQXdCLG1CQUFPLENBQUMsa0pBQW1DO0FBQ25FLDJCQUEyQixtQkFBTyxDQUFDLDBKQUF1QztBQUMxRSxnQkFBZ0IsbUJBQU8sQ0FBQyxnSUFBMEI7QUFDbEQsWUFBWSxtQkFBTyxDQUFDLHdIQUFzQjtBQUMxQyxjQUFjLG1CQUFPLENBQUMsNEhBQXdCO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLG9JQUE0QjtBQUN0RCxrQkFBa0IsbUJBQU8sQ0FBQyxzSkFBcUM7QUFDL0QsZ0JBQWdCLG1CQUFPLENBQUMsa0pBQW1DO0FBQzNELG9CQUFvQixtQkFBTyxDQUFDLDhKQUF5QztBQUNyRSxpQ0FBaUMsbUJBQU8sQ0FBQyx3TEFBc0Q7QUFDL0YsaUJBQWlCLG1CQUFPLENBQUMsd0pBQXNDO0FBQy9ELFdBQVcsbUJBQU8sQ0FBQyxzSEFBcUI7QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMsb0lBQTRCO0FBQ3RELGVBQWUsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLDBIQUF1QjtBQUM1QyxhQUFhLG1CQUFPLENBQUMsMEhBQXVCO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLG9JQUE0QjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsOEhBQXlCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQywwSEFBdUI7QUFDNUMsc0JBQXNCLG1CQUFPLENBQUMsNElBQWdDO0FBQzlELGlCQUFpQixtQkFBTyxDQUFDLGtJQUEyQjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyxzSUFBNkI7QUFDeEQsdUJBQXVCLG1CQUFPLENBQUMsa0pBQW1DO0FBQ2xFLGVBQWUsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDaEQsaUJBQWlCLG1CQUFPLENBQUMsa0lBQTJCO0FBQ3BELG9CQUFvQixtQkFBTyxDQUFDLHdJQUE4QjtBQUMxRCxhQUFhLG1CQUFPLENBQUMsMEhBQXVCO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLGdJQUEwQjtBQUNsRCxZQUFZLG1CQUFPLENBQUMsd0hBQXNCO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLGtJQUEyQjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQywwSUFBK0I7QUFDNUQsa0JBQWtCLG1CQUFPLENBQUMsb0lBQTRCO0FBQ3RELGdCQUFnQixtQkFBTyxDQUFDLGdJQUEwQjtBQUNsRCxZQUFZLG1CQUFPLENBQUMsd0hBQXNCO0FBQzFDLHFCQUFxQixtQkFBTyxDQUFDLDBJQUErQjtBQUM1RCxZQUFZLG1CQUFPLENBQUMsd0hBQXNCO0FBQzFDLFlBQVksbUJBQU8sQ0FBQyx3SEFBc0I7QUFDMUMsMkJBQTJCLG1CQUFPLENBQUMsc0pBQXFDO0FBQ3hFLHdCQUF3QixtQkFBTyxDQUFDLGdKQUFrQztBQUNsRSxnQkFBZ0IsbUJBQU8sQ0FBQyxnSUFBMEI7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsb0lBQTRCO0FBQ3JELDZCQUE2QixtQkFBTyxDQUFDLHdLQUE4Qzs7OztBQUluRix3Q0FBd0M7QUFDeEMsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQix3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQiw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsaUNBQWlDO0FBQ2pDLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsMkNBQTJDO0FBQzNDLDBDQUEwQztBQUMxQyx5Q0FBeUM7QUFDekMsMkJBQTJCO0FBQzNCLHNCQUFzQjtBQUN0QixpQ0FBaUM7QUFDakMsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsb0NBQW9DO0FBQ3BDLDBDQUEwQztBQUMxQyxvQ0FBb0M7QUFDcEMseUNBQXlDO0FBQ3pDLDhDQUE4QztBQUM5QyxxQ0FBcUM7QUFDckMsa0RBQWtEO0FBQ2xELHlEQUF5RDtBQUN6RCxrREFBa0Q7QUFDbEQsbURBQW1EO0FBQ25ELG9DQUFvQztBQUNwQyx3Q0FBd0M7QUFDeEMsNERBQTREO0FBQzVELDZDQUE2QztBQUM3Qyx3Q0FBd0M7QUFDeEMsbUNBQW1DO0FBQ25DLHlDQUF5QztBQUN6QywyQkFBMkI7QUFDM0IsNkJBQTZCO0FBQzdCLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYixpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2QsZUFBZTtBQUNmLGVBQWU7QUFDZixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6QixnQ0FBZ0M7QUFDaEMsMEJBQTBCO0FBQzFCLGlCQUFpQjtBQUNqQiw4QkFBOEI7QUFDOUIsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQiwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYiw2QkFBNkI7QUFDN0IsNkNBQTZDO0FBQzdDLCtCQUErQjtBQUMvQixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2Qiw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3QixzQkFBc0I7QUFDdEIsb0JBQW9CO0FBQ3BCLDZCQUE2QjtBQUM3Qix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQiw0QkFBNEI7QUFDNUIsV0FBVztBQUNYLG9CQUFvQjtBQUNwQixpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQixtQ0FBbUM7QUFDbkMscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQiw4QkFBOEI7QUFDOUIsa0JBQWtCO0FBQ2xCLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4QixpQ0FBaUM7QUFDakMscUJBQXFCO0FBQ3JCLGdDQUFnQztBQUNoQyw2QkFBNkI7QUFDN0Isb0NBQW9DO0FBQ3BDLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckIsbUNBQW1DO0FBQ25DLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDLHlCQUF5QjtBQUN6QixpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQywyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCLHdDQUF3QztBQUN4QywwQkFBMEI7QUFDMUIsZ0JBQWdCO0FBQ2hCLDhCQUE4QjtBQUM5QixzQkFBc0I7QUFDdEIsK0JBQStCO0FBQy9CLHVCQUF1QjtBQUN2Qiw0QkFBNEI7QUFDNUIsc0NBQXNDO0FBQ3RDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsbUNBQW1DO0FBQ25DLCtDQUErQztBQUMvQyx3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLHdDQUF3QztBQUN4Qyx5Q0FBeUM7QUFDekMsc0NBQXNDO0FBQ3RDLDRDQUE0QztBQUM1Qyx5REFBeUQ7QUFDekQsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QixvQ0FBb0M7QUFDcEMsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixvQkFBb0I7QUFDcEIsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQiw2QkFBNkI7QUFDN0IscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLHdCQUF3QjtBQUN4QixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLGNBQWM7QUFDZCw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsK0JBQStCO0FBQy9CLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkIsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2QiwwQkFBMEI7QUFDMUIsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekIsc0NBQXNDO0FBQ3RDLFlBQVk7QUFDWiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1oscUJBQXFCO0FBQ3JCLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsZ0NBQWdDO0FBQ2hDLHlCQUF5QjtBQUN6QiwrQkFBK0I7QUFDL0Isd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLHlDQUF5QztBQUN6QyxtQ0FBbUM7QUFDbkMsdUJBQXVCO0FBQ3ZCLFlBQVk7QUFDWiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0NBQWdDO0FBQ2hDLGdCQUFnQjtBQUNoQix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0IsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyxtQkFBbUI7QUFDbkIsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQixvQ0FBb0M7QUFDcEMsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyxxQ0FBcUM7QUFDckMsb0JBQW9CO0FBQ3BCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsb0NBQW9DO0FBQ3BDLHNCQUFzQjtBQUN0QixrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQyxzQ0FBc0M7QUFDdEMsMkJBQTJCO0FBQzNCLHVDQUF1QztBQUN2QyxxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLGtDQUFrQztBQUNsQywyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQiw2QkFBNkI7QUFDN0Isd0JBQXdCO0FBQ3hCLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsdUNBQXVDO0FBQ3ZDLDZDQUE2QztBQUM3QyxtREFBbUQ7QUFDbkQsNkJBQTZCO0FBQzdCLDBCQUEwQjtBQUMxQix1Q0FBdUM7QUFDdkMsNkJBQTZCO0FBQzdCLDBDQUEwQztBQUMxQywyQkFBMkI7QUFDM0IsOEJBQThCO0FBQzlCLGdCQUFnQjtBQUNoQixnQ0FBZ0M7QUFDaEMsd0JBQXdCO0FBQ3hCLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLDZCQUE2QjtBQUM3QixxQkFBcUI7QUFDckIsY0FBYztBQUNkLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQixrQ0FBa0M7QUFDbEMsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL3RyYWNpbmcvZXJyb3JzLmpzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdHJhY2luZy91dGlscy5qcycpO1xuY29uc3QgaWRsZVNwYW4gPSByZXF1aXJlKCcuL3RyYWNpbmcvaWRsZVNwYW4uanMnKTtcbmNvbnN0IHNlbnRyeVNwYW4gPSByZXF1aXJlKCcuL3RyYWNpbmcvc2VudHJ5U3Bhbi5qcycpO1xuY29uc3Qgc2VudHJ5Tm9uUmVjb3JkaW5nU3BhbiA9IHJlcXVpcmUoJy4vdHJhY2luZy9zZW50cnlOb25SZWNvcmRpbmdTcGFuLmpzJyk7XG5jb25zdCBzcGFuc3RhdHVzID0gcmVxdWlyZSgnLi90cmFjaW5nL3NwYW5zdGF0dXMuanMnKTtcbmNvbnN0IHRyYWNlID0gcmVxdWlyZSgnLi90cmFjaW5nL3RyYWNlLmpzJyk7XG5jb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gcmVxdWlyZSgnLi90cmFjaW5nL2R5bmFtaWNTYW1wbGluZ0NvbnRleHQuanMnKTtcbmNvbnN0IG1lYXN1cmVtZW50ID0gcmVxdWlyZSgnLi90cmFjaW5nL21lYXN1cmVtZW50LmpzJyk7XG5jb25zdCBzYW1wbGluZyA9IHJlcXVpcmUoJy4vdHJhY2luZy9zYW1wbGluZy5qcycpO1xuY29uc3QgbG9nU3BhbnMgPSByZXF1aXJlKCcuL3RyYWNpbmcvbG9nU3BhbnMuanMnKTtcbmNvbnN0IHNlbWFudGljQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vc2VtYW50aWNBdHRyaWJ1dGVzLmpzJyk7XG5jb25zdCBlbnZlbG9wZSA9IHJlcXVpcmUoJy4vZW52ZWxvcGUuanMnKTtcbmNvbnN0IGV4cG9ydHMkMSA9IHJlcXVpcmUoJy4vZXhwb3J0cy5qcycpO1xuY29uc3QgY3VycmVudFNjb3BlcyA9IHJlcXVpcmUoJy4vY3VycmVudFNjb3Blcy5qcycpO1xuY29uc3QgZGVmYXVsdFNjb3BlcyA9IHJlcXVpcmUoJy4vZGVmYXVsdFNjb3Blcy5qcycpO1xuY29uc3QgaW5kZXggPSByZXF1aXJlKCcuL2FzeW5jQ29udGV4dC9pbmRleC5qcycpO1xuY29uc3QgY2FycmllciA9IHJlcXVpcmUoJy4vY2Fycmllci5qcycpO1xuY29uc3Qgc2Vzc2lvbiA9IHJlcXVpcmUoJy4vc2Vzc2lvbi5qcycpO1xuY29uc3Qgc2NvcGUgPSByZXF1aXJlKCcuL3Njb3BlLmpzJyk7XG5jb25zdCBldmVudFByb2Nlc3NvcnMgPSByZXF1aXJlKCcuL2V2ZW50UHJvY2Vzc29ycy5qcycpO1xuY29uc3QgYXBpID0gcmVxdWlyZSgnLi9hcGkuanMnKTtcbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50LmpzJyk7XG5jb25zdCBzZXJ2ZXJSdW50aW1lQ2xpZW50ID0gcmVxdWlyZSgnLi9zZXJ2ZXItcnVudGltZS1jbGllbnQuanMnKTtcbmNvbnN0IHNkayA9IHJlcXVpcmUoJy4vc2RrLmpzJyk7XG5jb25zdCBiYXNlID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2Jhc2UuanMnKTtcbmNvbnN0IG9mZmxpbmUgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvb2ZmbGluZS5qcycpO1xuY29uc3QgbXVsdGlwbGV4ZWQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvbXVsdGlwbGV4ZWQuanMnKTtcbmNvbnN0IGludGVncmF0aW9uID0gcmVxdWlyZSgnLi9pbnRlZ3JhdGlvbi5qcycpO1xuY29uc3QgYXBwbHlTY29wZURhdGFUb0V2ZW50ID0gcmVxdWlyZSgnLi91dGlscy9hcHBseVNjb3BlRGF0YVRvRXZlbnQuanMnKTtcbmNvbnN0IHByZXBhcmVFdmVudCA9IHJlcXVpcmUoJy4vdXRpbHMvcHJlcGFyZUV2ZW50LmpzJyk7XG5jb25zdCBjaGVja2luID0gcmVxdWlyZSgnLi9jaGVja2luLmpzJyk7XG5jb25zdCBoYXNTcGFuc0VuYWJsZWQgPSByZXF1aXJlKCcuL3V0aWxzL2hhc1NwYW5zRW5hYmxlZC5qcycpO1xuY29uc3QgaXNTZW50cnlSZXF1ZXN0VXJsID0gcmVxdWlyZSgnLi91dGlscy9pc1NlbnRyeVJlcXVlc3RVcmwuanMnKTtcbmNvbnN0IGhhbmRsZUNhbGxiYWNrRXJyb3JzID0gcmVxdWlyZSgnLi91dGlscy9oYW5kbGVDYWxsYmFja0Vycm9ycy5qcycpO1xuY29uc3QgcGFyYW1ldGVyaXplID0gcmVxdWlyZSgnLi91dGlscy9wYXJhbWV0ZXJpemUuanMnKTtcbmNvbnN0IGlwQWRkcmVzcyA9IHJlcXVpcmUoJy4vdXRpbHMvaXBBZGRyZXNzLmpzJyk7XG5jb25zdCBzcGFuVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3NwYW5VdGlscy5qcycpO1xuY29uc3QgcGFyc2VTYW1wbGVSYXRlID0gcmVxdWlyZSgnLi91dGlscy9wYXJzZVNhbXBsZVJhdGUuanMnKTtcbmNvbnN0IHNka01ldGFkYXRhID0gcmVxdWlyZSgnLi91dGlscy9zZGtNZXRhZGF0YS5qcycpO1xuY29uc3QgdHJhY2VEYXRhID0gcmVxdWlyZSgnLi91dGlscy90cmFjZURhdGEuanMnKTtcbmNvbnN0IG1ldGEgPSByZXF1aXJlKCcuL3V0aWxzL21ldGEuanMnKTtcbmNvbnN0IHJlcXVlc3QgPSByZXF1aXJlKCcuL3V0aWxzL3JlcXVlc3QuanMnKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzLmpzJyk7XG5jb25zdCBicmVhZGNydW1icyA9IHJlcXVpcmUoJy4vYnJlYWRjcnVtYnMuanMnKTtcbmNvbnN0IGZ1bmN0aW9udG9zdHJpbmcgPSByZXF1aXJlKCcuL2ludGVncmF0aW9ucy9mdW5jdGlvbnRvc3RyaW5nLmpzJyk7XG5jb25zdCBldmVudEZpbHRlcnMgPSByZXF1aXJlKCcuL2ludGVncmF0aW9ucy9ldmVudEZpbHRlcnMuanMnKTtcbmNvbnN0IGxpbmtlZGVycm9ycyA9IHJlcXVpcmUoJy4vaW50ZWdyYXRpb25zL2xpbmtlZGVycm9ycy5qcycpO1xuY29uc3QgbWV0YWRhdGEgPSByZXF1aXJlKCcuL2ludGVncmF0aW9ucy9tZXRhZGF0YS5qcycpO1xuY29uc3QgcmVxdWVzdGRhdGEgPSByZXF1aXJlKCcuL2ludGVncmF0aW9ucy9yZXF1ZXN0ZGF0YS5qcycpO1xuY29uc3QgY2FwdHVyZWNvbnNvbGUgPSByZXF1aXJlKCcuL2ludGVncmF0aW9ucy9jYXB0dXJlY29uc29sZS5qcycpO1xuY29uc3QgZGVkdXBlID0gcmVxdWlyZSgnLi9pbnRlZ3JhdGlvbnMvZGVkdXBlLmpzJyk7XG5jb25zdCBleHRyYWVycm9yZGF0YSA9IHJlcXVpcmUoJy4vaW50ZWdyYXRpb25zL2V4dHJhZXJyb3JkYXRhLmpzJyk7XG5jb25zdCByZXdyaXRlZnJhbWVzID0gcmVxdWlyZSgnLi9pbnRlZ3JhdGlvbnMvcmV3cml0ZWZyYW1lcy5qcycpO1xuY29uc3Qgc3VwYWJhc2UgPSByZXF1aXJlKCcuL2ludGVncmF0aW9ucy9zdXBhYmFzZS5qcycpO1xuY29uc3Qgem9kZXJyb3JzID0gcmVxdWlyZSgnLi9pbnRlZ3JhdGlvbnMvem9kZXJyb3JzLmpzJyk7XG5jb25zdCB0aGlyZFBhcnR5RXJyb3JzRmlsdGVyID0gcmVxdWlyZSgnLi9pbnRlZ3JhdGlvbnMvdGhpcmQtcGFydHktZXJyb3JzLWZpbHRlci5qcycpO1xuY29uc3QgY29uc29sZSA9IHJlcXVpcmUoJy4vaW50ZWdyYXRpb25zL2NvbnNvbGUuanMnKTtcbmNvbnN0IHByb2ZpbGluZyA9IHJlcXVpcmUoJy4vcHJvZmlsaW5nLmpzJyk7XG5jb25zdCBmZXRjaCA9IHJlcXVpcmUoJy4vZmV0Y2guanMnKTtcbmNvbnN0IHRycGMgPSByZXF1aXJlKCcuL3RycGMuanMnKTtcbmNvbnN0IG1jcFNlcnZlciA9IHJlcXVpcmUoJy4vbWNwLXNlcnZlci5qcycpO1xuY29uc3QgZmVlZGJhY2sgPSByZXF1aXJlKCcuL2ZlZWRiYWNrLmpzJyk7XG5jb25zdCBleHBvcnRzJDIgPSByZXF1aXJlKCcuL2xvZ3MvZXhwb3J0cy5qcycpO1xuY29uc3QgY29uc29sZUludGVncmF0aW9uID0gcmVxdWlyZSgnLi9sb2dzL2NvbnNvbGUtaW50ZWdyYXRpb24uanMnKTtcbmNvbnN0IGFnZ3JlZ2F0ZUVycm9ycyA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvYWdncmVnYXRlLWVycm9ycy5qcycpO1xuY29uc3QgYnJlYWRjcnVtYkxvZ0xldmVsID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9icmVhZGNydW1iLWxvZy1sZXZlbC5qcycpO1xuY29uc3QgYnJvd3NlciA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvYnJvd3Nlci5qcycpO1xuY29uc3QgZHNuID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9kc24uanMnKTtcbmNvbnN0IGVycm9yID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9lcnJvci5qcycpO1xuY29uc3Qgd29ybGR3aWRlID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC93b3JsZHdpZGUuanMnKTtcbmNvbnN0IGNvbnNvbGUkMSA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvaW5zdHJ1bWVudC9jb25zb2xlLmpzJyk7XG5jb25zdCBmZXRjaCQxID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9pbnN0cnVtZW50L2ZldGNoLmpzJyk7XG5jb25zdCBnbG9iYWxFcnJvciA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvaW5zdHJ1bWVudC9nbG9iYWxFcnJvci5qcycpO1xuY29uc3QgZ2xvYmFsVW5oYW5kbGVkUmVqZWN0aW9uID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9pbnN0cnVtZW50L2dsb2JhbFVuaGFuZGxlZFJlamVjdGlvbi5qcycpO1xuY29uc3QgaGFuZGxlcnMgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2luc3RydW1lbnQvaGFuZGxlcnMuanMnKTtcbmNvbnN0IGlzID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9pcy5qcycpO1xuY29uc3QgaXNCcm93c2VyID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9pc0Jyb3dzZXIuanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCBtaXNjID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9taXNjLmpzJyk7XG5jb25zdCBub2RlID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9ub2RlLmpzJyk7XG5jb25zdCBub3JtYWxpemUgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L25vcm1hbGl6ZS5qcycpO1xuY29uc3Qgb2JqZWN0ID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9vYmplY3QuanMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3BhdGguanMnKTtcbmNvbnN0IHByb21pc2VidWZmZXIgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3Byb21pc2VidWZmZXIuanMnKTtcbmNvbnN0IHNldmVyaXR5ID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9zZXZlcml0eS5qcycpO1xuY29uc3Qgc3RhY2t0cmFjZSA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3Qvc3RhY2t0cmFjZS5qcycpO1xuY29uc3Qgbm9kZVN0YWNrVHJhY2UgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L25vZGUtc3RhY2stdHJhY2UuanMnKTtcbmNvbnN0IHN0cmluZyA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3Qvc3RyaW5nLmpzJyk7XG5jb25zdCBzdXBwb3J0cyA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3Qvc3VwcG9ydHMuanMnKTtcbmNvbnN0IHN5bmNwcm9taXNlID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9zeW5jcHJvbWlzZS5qcycpO1xuY29uc3QgdGltZSA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvdGltZS5qcycpO1xuY29uc3QgdHJhY2luZyA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvdHJhY2luZy5qcycpO1xuY29uc3QgZW52ID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9lbnYuanMnKTtcbmNvbnN0IGVudmVsb3BlJDEgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2VudmVsb3BlLmpzJyk7XG5jb25zdCBjbGllbnRyZXBvcnQgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2NsaWVudHJlcG9ydC5qcycpO1xuY29uc3QgcmF0ZWxpbWl0ID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9yYXRlbGltaXQuanMnKTtcbmNvbnN0IGJhZ2dhZ2UgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2JhZ2dhZ2UuanMnKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvdXJsLmpzJyk7XG5jb25zdCBldmVudGJ1aWxkZXIgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L2V2ZW50YnVpbGRlci5qcycpO1xuY29uc3QgYW5yID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9hbnIuanMnKTtcbmNvbnN0IGxydSA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvbHJ1LmpzJyk7XG5jb25zdCBwcm9wYWdhdGlvbkNvbnRleHQgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3Byb3BhZ2F0aW9uQ29udGV4dC5qcycpO1xuY29uc3QgdmVyY2VsV2FpdFVudGlsID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC92ZXJjZWxXYWl0VW50aWwuanMnKTtcbmNvbnN0IHZlcnNpb24gPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3ZlcnNpb24uanMnKTtcbmNvbnN0IGRlYnVnSWRzID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9kZWJ1Zy1pZHMuanMnKTtcbmNvbnN0IGVzY2FwZVN0cmluZ0ZvclJlZ2V4ID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC92ZW5kb3IvZXNjYXBlU3RyaW5nRm9yUmVnZXguanMnKTtcblxuXG5cbmV4cG9ydHMucmVnaXN0ZXJTcGFuRXJyb3JJbnN0cnVtZW50YXRpb24gPSBlcnJvcnMucmVnaXN0ZXJTcGFuRXJyb3JJbnN0cnVtZW50YXRpb247XG5leHBvcnRzLmdldENhcHR1cmVkU2NvcGVzT25TcGFuID0gdXRpbHMuZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW47XG5leHBvcnRzLnNldENhcHR1cmVkU2NvcGVzT25TcGFuID0gdXRpbHMuc2V0Q2FwdHVyZWRTY29wZXNPblNwYW47XG5leHBvcnRzLlRSQUNJTkdfREVGQVVMVFMgPSBpZGxlU3Bhbi5UUkFDSU5HX0RFRkFVTFRTO1xuZXhwb3J0cy5zdGFydElkbGVTcGFuID0gaWRsZVNwYW4uc3RhcnRJZGxlU3BhbjtcbmV4cG9ydHMuU2VudHJ5U3BhbiA9IHNlbnRyeVNwYW4uU2VudHJ5U3BhbjtcbmV4cG9ydHMuU2VudHJ5Tm9uUmVjb3JkaW5nU3BhbiA9IHNlbnRyeU5vblJlY29yZGluZ1NwYW4uU2VudHJ5Tm9uUmVjb3JkaW5nU3BhbjtcbmV4cG9ydHMuU1BBTl9TVEFUVVNfRVJST1IgPSBzcGFuc3RhdHVzLlNQQU5fU1RBVFVTX0VSUk9SO1xuZXhwb3J0cy5TUEFOX1NUQVRVU19PSyA9IHNwYW5zdGF0dXMuU1BBTl9TVEFUVVNfT0s7XG5leHBvcnRzLlNQQU5fU1RBVFVTX1VOU0VUID0gc3BhbnN0YXR1cy5TUEFOX1NUQVRVU19VTlNFVDtcbmV4cG9ydHMuZ2V0U3BhblN0YXR1c0Zyb21IdHRwQ29kZSA9IHNwYW5zdGF0dXMuZ2V0U3BhblN0YXR1c0Zyb21IdHRwQ29kZTtcbmV4cG9ydHMuc2V0SHR0cFN0YXR1cyA9IHNwYW5zdGF0dXMuc2V0SHR0cFN0YXR1cztcbmV4cG9ydHMuY29udGludWVUcmFjZSA9IHRyYWNlLmNvbnRpbnVlVHJhY2U7XG5leHBvcnRzLnN0YXJ0SW5hY3RpdmVTcGFuID0gdHJhY2Uuc3RhcnRJbmFjdGl2ZVNwYW47XG5leHBvcnRzLnN0YXJ0TmV3VHJhY2UgPSB0cmFjZS5zdGFydE5ld1RyYWNlO1xuZXhwb3J0cy5zdGFydFNwYW4gPSB0cmFjZS5zdGFydFNwYW47XG5leHBvcnRzLnN0YXJ0U3Bhbk1hbnVhbCA9IHRyYWNlLnN0YXJ0U3Bhbk1hbnVhbDtcbmV4cG9ydHMuc3VwcHJlc3NUcmFjaW5nID0gdHJhY2Uuc3VwcHJlc3NUcmFjaW5nO1xuZXhwb3J0cy53aXRoQWN0aXZlU3BhbiA9IHRyYWNlLndpdGhBY3RpdmVTcGFuO1xuZXhwb3J0cy5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbUNsaWVudCA9IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21DbGllbnQ7XG5leHBvcnRzLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU2NvcGUgPSBkeW5hbWljU2FtcGxpbmdDb250ZXh0LmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU2NvcGU7XG5leHBvcnRzLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbiA9IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuO1xuZXhwb3J0cy5zcGFuVG9CYWdnYWdlSGVhZGVyID0gZHluYW1pY1NhbXBsaW5nQ29udGV4dC5zcGFuVG9CYWdnYWdlSGVhZGVyO1xuZXhwb3J0cy5zZXRNZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50LnNldE1lYXN1cmVtZW50O1xuZXhwb3J0cy50aW1lZEV2ZW50c1RvTWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnQudGltZWRFdmVudHNUb01lYXN1cmVtZW50cztcbmV4cG9ydHMuc2FtcGxlU3BhbiA9IHNhbXBsaW5nLnNhbXBsZVNwYW47XG5leHBvcnRzLmxvZ1NwYW5FbmQgPSBsb2dTcGFucy5sb2dTcGFuRW5kO1xuZXhwb3J0cy5sb2dTcGFuU3RhcnQgPSBsb2dTcGFucy5sb2dTcGFuU3RhcnQ7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9ISVQgPSBzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX0NBQ0hFX0hJVDtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX0NBQ0hFX0lURU1fU0laRSA9IHNlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfSVRFTV9TSVpFO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfS0VZID0gc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9LRVk7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9FWENMVVNJVkVfVElNRSA9IHNlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfRVhDTFVTSVZFX1RJTUU7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9IVFRQX1JFUVVFU1RfTUVUSE9EID0gc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9IVFRQX1JFUVVFU1RfTUVUSE9EO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfUFJPRklMRV9JRCA9IHNlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfUFJPRklMRV9JRDtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FID0gc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfQ1VTVE9NX1NQQU5fTkFNRTtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9JRExFX1NQQU5fRklOSVNIX1JFQVNPTiA9IHNlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0lETEVfU1BBTl9GSU5JU0hfUkVBU09OO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX01FQVNVUkVNRU5UX1VOSVQgPSBzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9NRUFTVVJFTUVOVF9VTklUO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX01FQVNVUkVNRU5UX1ZBTFVFID0gc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfTUVBU1VSRU1FTlRfVkFMVUU7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1AgPSBzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUDtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU4gPSBzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU47XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUFJFVklPVVNfVFJBQ0VfU0FNUExFX1JBVEUgPSBzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QUkVWSU9VU19UUkFDRV9TQU1QTEVfUkFURTtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURSA9IHNlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRSA9IHNlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRTtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1VSTF9GVUxMID0gc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9VUkxfRlVMTDtcbmV4cG9ydHMuU0VNQU5USUNfTElOS19BVFRSSUJVVEVfTElOS19UWVBFID0gc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0xJTktfQVRUUklCVVRFX0xJTktfVFlQRTtcbmV4cG9ydHMuY3JlYXRlRXZlbnRFbnZlbG9wZSA9IGVudmVsb3BlLmNyZWF0ZUV2ZW50RW52ZWxvcGU7XG5leHBvcnRzLmNyZWF0ZVNlc3Npb25FbnZlbG9wZSA9IGVudmVsb3BlLmNyZWF0ZVNlc3Npb25FbnZlbG9wZTtcbmV4cG9ydHMuY3JlYXRlU3BhbkVudmVsb3BlID0gZW52ZWxvcGUuY3JlYXRlU3BhbkVudmVsb3BlO1xuZXhwb3J0cy5hZGRFdmVudFByb2Nlc3NvciA9IGV4cG9ydHMkMS5hZGRFdmVudFByb2Nlc3NvcjtcbmV4cG9ydHMuY2FwdHVyZUNoZWNrSW4gPSBleHBvcnRzJDEuY2FwdHVyZUNoZWNrSW47XG5leHBvcnRzLmNhcHR1cmVFdmVudCA9IGV4cG9ydHMkMS5jYXB0dXJlRXZlbnQ7XG5leHBvcnRzLmNhcHR1cmVFeGNlcHRpb24gPSBleHBvcnRzJDEuY2FwdHVyZUV4Y2VwdGlvbjtcbmV4cG9ydHMuY2FwdHVyZU1lc3NhZ2UgPSBleHBvcnRzJDEuY2FwdHVyZU1lc3NhZ2U7XG5leHBvcnRzLmNhcHR1cmVTZXNzaW9uID0gZXhwb3J0cyQxLmNhcHR1cmVTZXNzaW9uO1xuZXhwb3J0cy5jbG9zZSA9IGV4cG9ydHMkMS5jbG9zZTtcbmV4cG9ydHMuZW5kU2Vzc2lvbiA9IGV4cG9ydHMkMS5lbmRTZXNzaW9uO1xuZXhwb3J0cy5mbHVzaCA9IGV4cG9ydHMkMS5mbHVzaDtcbmV4cG9ydHMuaXNFbmFibGVkID0gZXhwb3J0cyQxLmlzRW5hYmxlZDtcbmV4cG9ydHMuaXNJbml0aWFsaXplZCA9IGV4cG9ydHMkMS5pc0luaXRpYWxpemVkO1xuZXhwb3J0cy5sYXN0RXZlbnRJZCA9IGV4cG9ydHMkMS5sYXN0RXZlbnRJZDtcbmV4cG9ydHMuc2V0Q29udGV4dCA9IGV4cG9ydHMkMS5zZXRDb250ZXh0O1xuZXhwb3J0cy5zZXRFeHRyYSA9IGV4cG9ydHMkMS5zZXRFeHRyYTtcbmV4cG9ydHMuc2V0RXh0cmFzID0gZXhwb3J0cyQxLnNldEV4dHJhcztcbmV4cG9ydHMuc2V0VGFnID0gZXhwb3J0cyQxLnNldFRhZztcbmV4cG9ydHMuc2V0VGFncyA9IGV4cG9ydHMkMS5zZXRUYWdzO1xuZXhwb3J0cy5zZXRVc2VyID0gZXhwb3J0cyQxLnNldFVzZXI7XG5leHBvcnRzLnN0YXJ0U2Vzc2lvbiA9IGV4cG9ydHMkMS5zdGFydFNlc3Npb247XG5leHBvcnRzLndpdGhNb25pdG9yID0gZXhwb3J0cyQxLndpdGhNb25pdG9yO1xuZXhwb3J0cy5nZXRDbGllbnQgPSBjdXJyZW50U2NvcGVzLmdldENsaWVudDtcbmV4cG9ydHMuZ2V0Q3VycmVudFNjb3BlID0gY3VycmVudFNjb3Blcy5nZXRDdXJyZW50U2NvcGU7XG5leHBvcnRzLmdldEdsb2JhbFNjb3BlID0gY3VycmVudFNjb3Blcy5nZXRHbG9iYWxTY29wZTtcbmV4cG9ydHMuZ2V0SXNvbGF0aW9uU2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldElzb2xhdGlvblNjb3BlO1xuZXhwb3J0cy5nZXRUcmFjZUNvbnRleHRGcm9tU2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldFRyYWNlQ29udGV4dEZyb21TY29wZTtcbmV4cG9ydHMud2l0aElzb2xhdGlvblNjb3BlID0gY3VycmVudFNjb3Blcy53aXRoSXNvbGF0aW9uU2NvcGU7XG5leHBvcnRzLndpdGhTY29wZSA9IGN1cnJlbnRTY29wZXMud2l0aFNjb3BlO1xuZXhwb3J0cy5nZXREZWZhdWx0Q3VycmVudFNjb3BlID0gZGVmYXVsdFNjb3Blcy5nZXREZWZhdWx0Q3VycmVudFNjb3BlO1xuZXhwb3J0cy5nZXREZWZhdWx0SXNvbGF0aW9uU2NvcGUgPSBkZWZhdWx0U2NvcGVzLmdldERlZmF1bHRJc29sYXRpb25TY29wZTtcbmV4cG9ydHMuc2V0QXN5bmNDb250ZXh0U3RyYXRlZ3kgPSBpbmRleC5zZXRBc3luY0NvbnRleHRTdHJhdGVneTtcbmV4cG9ydHMuZ2V0R2xvYmFsU2luZ2xldG9uID0gY2Fycmllci5nZXRHbG9iYWxTaW5nbGV0b247XG5leHBvcnRzLmdldE1haW5DYXJyaWVyID0gY2Fycmllci5nZXRNYWluQ2FycmllcjtcbmV4cG9ydHMuY2xvc2VTZXNzaW9uID0gc2Vzc2lvbi5jbG9zZVNlc3Npb247XG5leHBvcnRzLm1ha2VTZXNzaW9uID0gc2Vzc2lvbi5tYWtlU2Vzc2lvbjtcbmV4cG9ydHMudXBkYXRlU2Vzc2lvbiA9IHNlc3Npb24udXBkYXRlU2Vzc2lvbjtcbmV4cG9ydHMuU2NvcGUgPSBzY29wZS5TY29wZTtcbmV4cG9ydHMubm90aWZ5RXZlbnRQcm9jZXNzb3JzID0gZXZlbnRQcm9jZXNzb3JzLm5vdGlmeUV2ZW50UHJvY2Vzc29ycztcbmV4cG9ydHMuZ2V0RW52ZWxvcGVFbmRwb2ludFdpdGhVcmxFbmNvZGVkQXV0aCA9IGFwaS5nZXRFbnZlbG9wZUVuZHBvaW50V2l0aFVybEVuY29kZWRBdXRoO1xuZXhwb3J0cy5nZXRSZXBvcnREaWFsb2dFbmRwb2ludCA9IGFwaS5nZXRSZXBvcnREaWFsb2dFbmRwb2ludDtcbmV4cG9ydHMuQmFzZUNsaWVudCA9IGNsaWVudC5CYXNlQ2xpZW50O1xuZXhwb3J0cy5DbGllbnQgPSBjbGllbnQuQ2xpZW50O1xuZXhwb3J0cy5TZXJ2ZXJSdW50aW1lQ2xpZW50ID0gc2VydmVyUnVudGltZUNsaWVudC5TZXJ2ZXJSdW50aW1lQ2xpZW50O1xuZXhwb3J0cy5pbml0QW5kQmluZCA9IHNkay5pbml0QW5kQmluZDtcbmV4cG9ydHMuc2V0Q3VycmVudENsaWVudCA9IHNkay5zZXRDdXJyZW50Q2xpZW50O1xuZXhwb3J0cy5jcmVhdGVUcmFuc3BvcnQgPSBiYXNlLmNyZWF0ZVRyYW5zcG9ydDtcbmV4cG9ydHMubWFrZU9mZmxpbmVUcmFuc3BvcnQgPSBvZmZsaW5lLm1ha2VPZmZsaW5lVHJhbnNwb3J0O1xuZXhwb3J0cy5tYWtlTXVsdGlwbGV4ZWRUcmFuc3BvcnQgPSBtdWx0aXBsZXhlZC5tYWtlTXVsdGlwbGV4ZWRUcmFuc3BvcnQ7XG5leHBvcnRzLmFkZEludGVncmF0aW9uID0gaW50ZWdyYXRpb24uYWRkSW50ZWdyYXRpb247XG5leHBvcnRzLmRlZmluZUludGVncmF0aW9uID0gaW50ZWdyYXRpb24uZGVmaW5lSW50ZWdyYXRpb247XG5leHBvcnRzLmdldEludGVncmF0aW9uc1RvU2V0dXAgPSBpbnRlZ3JhdGlvbi5nZXRJbnRlZ3JhdGlvbnNUb1NldHVwO1xuZXhwb3J0cy5hcHBseVNjb3BlRGF0YVRvRXZlbnQgPSBhcHBseVNjb3BlRGF0YVRvRXZlbnQuYXBwbHlTY29wZURhdGFUb0V2ZW50O1xuZXhwb3J0cy5tZXJnZVNjb3BlRGF0YSA9IGFwcGx5U2NvcGVEYXRhVG9FdmVudC5tZXJnZVNjb3BlRGF0YTtcbmV4cG9ydHMucHJlcGFyZUV2ZW50ID0gcHJlcGFyZUV2ZW50LnByZXBhcmVFdmVudDtcbmV4cG9ydHMuY3JlYXRlQ2hlY2tJbkVudmVsb3BlID0gY2hlY2tpbi5jcmVhdGVDaGVja0luRW52ZWxvcGU7XG5leHBvcnRzLmhhc1NwYW5zRW5hYmxlZCA9IGhhc1NwYW5zRW5hYmxlZC5oYXNTcGFuc0VuYWJsZWQ7XG5leHBvcnRzLmhhc1RyYWNpbmdFbmFibGVkID0gaGFzU3BhbnNFbmFibGVkLmhhc1RyYWNpbmdFbmFibGVkO1xuZXhwb3J0cy5pc1NlbnRyeVJlcXVlc3RVcmwgPSBpc1NlbnRyeVJlcXVlc3RVcmwuaXNTZW50cnlSZXF1ZXN0VXJsO1xuZXhwb3J0cy5oYW5kbGVDYWxsYmFja0Vycm9ycyA9IGhhbmRsZUNhbGxiYWNrRXJyb3JzLmhhbmRsZUNhbGxiYWNrRXJyb3JzO1xuZXhwb3J0cy5mbXQgPSBwYXJhbWV0ZXJpemUuZm10O1xuZXhwb3J0cy5wYXJhbWV0ZXJpemUgPSBwYXJhbWV0ZXJpemUucGFyYW1ldGVyaXplO1xuZXhwb3J0cy5hZGRBdXRvSXBBZGRyZXNzVG9TZXNzaW9uID0gaXBBZGRyZXNzLmFkZEF1dG9JcEFkZHJlc3NUb1Nlc3Npb247XG5leHBvcnRzLmFkZEF1dG9JcEFkZHJlc3NUb1VzZXIgPSBpcEFkZHJlc3MuYWRkQXV0b0lwQWRkcmVzc1RvVXNlcjtcbmV4cG9ydHMuYWRkQ2hpbGRTcGFuVG9TcGFuID0gc3BhblV0aWxzLmFkZENoaWxkU3BhblRvU3BhbjtcbmV4cG9ydHMuY29udmVydFNwYW5MaW5rc0ZvckVudmVsb3BlID0gc3BhblV0aWxzLmNvbnZlcnRTcGFuTGlua3NGb3JFbnZlbG9wZTtcbmV4cG9ydHMuZ2V0QWN0aXZlU3BhbiA9IHNwYW5VdGlscy5nZXRBY3RpdmVTcGFuO1xuZXhwb3J0cy5nZXRSb290U3BhbiA9IHNwYW5VdGlscy5nZXRSb290U3BhbjtcbmV4cG9ydHMuZ2V0U3BhbkRlc2NlbmRhbnRzID0gc3BhblV0aWxzLmdldFNwYW5EZXNjZW5kYW50cztcbmV4cG9ydHMuZ2V0U3RhdHVzTWVzc2FnZSA9IHNwYW5VdGlscy5nZXRTdGF0dXNNZXNzYWdlO1xuZXhwb3J0cy5zcGFuSXNTYW1wbGVkID0gc3BhblV0aWxzLnNwYW5Jc1NhbXBsZWQ7XG5leHBvcnRzLnNwYW5UaW1lSW5wdXRUb1NlY29uZHMgPSBzcGFuVXRpbHMuc3BhblRpbWVJbnB1dFRvU2Vjb25kcztcbmV4cG9ydHMuc3BhblRvSlNPTiA9IHNwYW5VdGlscy5zcGFuVG9KU09OO1xuZXhwb3J0cy5zcGFuVG9UcmFjZUNvbnRleHQgPSBzcGFuVXRpbHMuc3BhblRvVHJhY2VDb250ZXh0O1xuZXhwb3J0cy5zcGFuVG9UcmFjZUhlYWRlciA9IHNwYW5VdGlscy5zcGFuVG9UcmFjZUhlYWRlcjtcbmV4cG9ydHMudXBkYXRlU3Bhbk5hbWUgPSBzcGFuVXRpbHMudXBkYXRlU3Bhbk5hbWU7XG5leHBvcnRzLnBhcnNlU2FtcGxlUmF0ZSA9IHBhcnNlU2FtcGxlUmF0ZS5wYXJzZVNhbXBsZVJhdGU7XG5leHBvcnRzLmFwcGx5U2RrTWV0YWRhdGEgPSBzZGtNZXRhZGF0YS5hcHBseVNka01ldGFkYXRhO1xuZXhwb3J0cy5nZXRUcmFjZURhdGEgPSB0cmFjZURhdGEuZ2V0VHJhY2VEYXRhO1xuZXhwb3J0cy5nZXRUcmFjZU1ldGFUYWdzID0gbWV0YS5nZXRUcmFjZU1ldGFUYWdzO1xuZXhwb3J0cy5leHRyYWN0UXVlcnlQYXJhbXNGcm9tVXJsID0gcmVxdWVzdC5leHRyYWN0UXVlcnlQYXJhbXNGcm9tVXJsO1xuZXhwb3J0cy5oZWFkZXJzVG9EaWN0ID0gcmVxdWVzdC5oZWFkZXJzVG9EaWN0O1xuZXhwb3J0cy5odHRwUmVxdWVzdFRvUmVxdWVzdERhdGEgPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0VG9SZXF1ZXN0RGF0YTtcbmV4cG9ydHMud2ludGVyQ0dIZWFkZXJzVG9EaWN0ID0gcmVxdWVzdC53aW50ZXJDR0hlYWRlcnNUb0RpY3Q7XG5leHBvcnRzLndpbnRlckNHUmVxdWVzdFRvUmVxdWVzdERhdGEgPSByZXF1ZXN0LndpbnRlckNHUmVxdWVzdFRvUmVxdWVzdERhdGE7XG5leHBvcnRzLkRFRkFVTFRfRU5WSVJPTk1FTlQgPSBjb25zdGFudHMuREVGQVVMVF9FTlZJUk9OTUVOVDtcbmV4cG9ydHMuYWRkQnJlYWRjcnVtYiA9IGJyZWFkY3J1bWJzLmFkZEJyZWFkY3J1bWI7XG5leHBvcnRzLmZ1bmN0aW9uVG9TdHJpbmdJbnRlZ3JhdGlvbiA9IGZ1bmN0aW9udG9zdHJpbmcuZnVuY3Rpb25Ub1N0cmluZ0ludGVncmF0aW9uO1xuZXhwb3J0cy5ldmVudEZpbHRlcnNJbnRlZ3JhdGlvbiA9IGV2ZW50RmlsdGVycy5ldmVudEZpbHRlcnNJbnRlZ3JhdGlvbjtcbmV4cG9ydHMuaW5ib3VuZEZpbHRlcnNJbnRlZ3JhdGlvbiA9IGV2ZW50RmlsdGVycy5pbmJvdW5kRmlsdGVyc0ludGVncmF0aW9uO1xuZXhwb3J0cy5saW5rZWRFcnJvcnNJbnRlZ3JhdGlvbiA9IGxpbmtlZGVycm9ycy5saW5rZWRFcnJvcnNJbnRlZ3JhdGlvbjtcbmV4cG9ydHMubW9kdWxlTWV0YWRhdGFJbnRlZ3JhdGlvbiA9IG1ldGFkYXRhLm1vZHVsZU1ldGFkYXRhSW50ZWdyYXRpb247XG5leHBvcnRzLnJlcXVlc3REYXRhSW50ZWdyYXRpb24gPSByZXF1ZXN0ZGF0YS5yZXF1ZXN0RGF0YUludGVncmF0aW9uO1xuZXhwb3J0cy5jYXB0dXJlQ29uc29sZUludGVncmF0aW9uID0gY2FwdHVyZWNvbnNvbGUuY2FwdHVyZUNvbnNvbGVJbnRlZ3JhdGlvbjtcbmV4cG9ydHMuZGVkdXBlSW50ZWdyYXRpb24gPSBkZWR1cGUuZGVkdXBlSW50ZWdyYXRpb247XG5leHBvcnRzLmV4dHJhRXJyb3JEYXRhSW50ZWdyYXRpb24gPSBleHRyYWVycm9yZGF0YS5leHRyYUVycm9yRGF0YUludGVncmF0aW9uO1xuZXhwb3J0cy5yZXdyaXRlRnJhbWVzSW50ZWdyYXRpb24gPSByZXdyaXRlZnJhbWVzLnJld3JpdGVGcmFtZXNJbnRlZ3JhdGlvbjtcbmV4cG9ydHMuaW5zdHJ1bWVudFN1cGFiYXNlQ2xpZW50ID0gc3VwYWJhc2UuaW5zdHJ1bWVudFN1cGFiYXNlQ2xpZW50O1xuZXhwb3J0cy5zdXBhYmFzZUludGVncmF0aW9uID0gc3VwYWJhc2Uuc3VwYWJhc2VJbnRlZ3JhdGlvbjtcbmV4cG9ydHMuem9kRXJyb3JzSW50ZWdyYXRpb24gPSB6b2RlcnJvcnMuem9kRXJyb3JzSW50ZWdyYXRpb247XG5leHBvcnRzLnRoaXJkUGFydHlFcnJvckZpbHRlckludGVncmF0aW9uID0gdGhpcmRQYXJ0eUVycm9yc0ZpbHRlci50aGlyZFBhcnR5RXJyb3JGaWx0ZXJJbnRlZ3JhdGlvbjtcbmV4cG9ydHMuY29uc29sZUludGVncmF0aW9uID0gY29uc29sZS5jb25zb2xlSW50ZWdyYXRpb247XG5leHBvcnRzLnByb2ZpbGVyID0gcHJvZmlsaW5nLnByb2ZpbGVyO1xuZXhwb3J0cy5pbnN0cnVtZW50RmV0Y2hSZXF1ZXN0ID0gZmV0Y2guaW5zdHJ1bWVudEZldGNoUmVxdWVzdDtcbmV4cG9ydHMudHJwY01pZGRsZXdhcmUgPSB0cnBjLnRycGNNaWRkbGV3YXJlO1xuZXhwb3J0cy53cmFwTWNwU2VydmVyV2l0aFNlbnRyeSA9IG1jcFNlcnZlci53cmFwTWNwU2VydmVyV2l0aFNlbnRyeTtcbmV4cG9ydHMuY2FwdHVyZUZlZWRiYWNrID0gZmVlZGJhY2suY2FwdHVyZUZlZWRiYWNrO1xuZXhwb3J0cy5fSU5URVJOQUxfY2FwdHVyZUxvZyA9IGV4cG9ydHMkMi5fSU5URVJOQUxfY2FwdHVyZUxvZztcbmV4cG9ydHMuX0lOVEVSTkFMX2NhcHR1cmVTZXJpYWxpemVkTG9nID0gZXhwb3J0cyQyLl9JTlRFUk5BTF9jYXB0dXJlU2VyaWFsaXplZExvZztcbmV4cG9ydHMuX0lOVEVSTkFMX2ZsdXNoTG9nc0J1ZmZlciA9IGV4cG9ydHMkMi5fSU5URVJOQUxfZmx1c2hMb2dzQnVmZmVyO1xuZXhwb3J0cy5jb25zb2xlTG9nZ2luZ0ludGVncmF0aW9uID0gY29uc29sZUludGVncmF0aW9uLmNvbnNvbGVMb2dnaW5nSW50ZWdyYXRpb247XG5leHBvcnRzLmFwcGx5QWdncmVnYXRlRXJyb3JzVG9FdmVudCA9IGFnZ3JlZ2F0ZUVycm9ycy5hcHBseUFnZ3JlZ2F0ZUVycm9yc1RvRXZlbnQ7XG5leHBvcnRzLmdldEJyZWFkY3J1bWJMb2dMZXZlbEZyb21IdHRwU3RhdHVzQ29kZSA9IGJyZWFkY3J1bWJMb2dMZXZlbC5nZXRCcmVhZGNydW1iTG9nTGV2ZWxGcm9tSHR0cFN0YXR1c0NvZGU7XG5leHBvcnRzLmdldENvbXBvbmVudE5hbWUgPSBicm93c2VyLmdldENvbXBvbmVudE5hbWU7XG5leHBvcnRzLmdldExvY2F0aW9uSHJlZiA9IGJyb3dzZXIuZ2V0TG9jYXRpb25IcmVmO1xuZXhwb3J0cy5odG1sVHJlZUFzU3RyaW5nID0gYnJvd3Nlci5odG1sVHJlZUFzU3RyaW5nO1xuZXhwb3J0cy5kc25Gcm9tU3RyaW5nID0gZHNuLmRzbkZyb21TdHJpbmc7XG5leHBvcnRzLmRzblRvU3RyaW5nID0gZHNuLmRzblRvU3RyaW5nO1xuZXhwb3J0cy5tYWtlRHNuID0gZHNuLm1ha2VEc247XG5leHBvcnRzLlNlbnRyeUVycm9yID0gZXJyb3IuU2VudHJ5RXJyb3I7XG5leHBvcnRzLkdMT0JBTF9PQkogPSB3b3JsZHdpZGUuR0xPQkFMX09CSjtcbmV4cG9ydHMuYWRkQ29uc29sZUluc3RydW1lbnRhdGlvbkhhbmRsZXIgPSBjb25zb2xlJDEuYWRkQ29uc29sZUluc3RydW1lbnRhdGlvbkhhbmRsZXI7XG5leHBvcnRzLmFkZEZldGNoRW5kSW5zdHJ1bWVudGF0aW9uSGFuZGxlciA9IGZldGNoJDEuYWRkRmV0Y2hFbmRJbnN0cnVtZW50YXRpb25IYW5kbGVyO1xuZXhwb3J0cy5hZGRGZXRjaEluc3RydW1lbnRhdGlvbkhhbmRsZXIgPSBmZXRjaCQxLmFkZEZldGNoSW5zdHJ1bWVudGF0aW9uSGFuZGxlcjtcbmV4cG9ydHMuYWRkR2xvYmFsRXJyb3JJbnN0cnVtZW50YXRpb25IYW5kbGVyID0gZ2xvYmFsRXJyb3IuYWRkR2xvYmFsRXJyb3JJbnN0cnVtZW50YXRpb25IYW5kbGVyO1xuZXhwb3J0cy5hZGRHbG9iYWxVbmhhbmRsZWRSZWplY3Rpb25JbnN0cnVtZW50YXRpb25IYW5kbGVyID0gZ2xvYmFsVW5oYW5kbGVkUmVqZWN0aW9uLmFkZEdsb2JhbFVuaGFuZGxlZFJlamVjdGlvbkluc3RydW1lbnRhdGlvbkhhbmRsZXI7XG5leHBvcnRzLmFkZEhhbmRsZXIgPSBoYW5kbGVycy5hZGRIYW5kbGVyO1xuZXhwb3J0cy5tYXliZUluc3RydW1lbnQgPSBoYW5kbGVycy5tYXliZUluc3RydW1lbnQ7XG5leHBvcnRzLnJlc2V0SW5zdHJ1bWVudGF0aW9uSGFuZGxlcnMgPSBoYW5kbGVycy5yZXNldEluc3RydW1lbnRhdGlvbkhhbmRsZXJzO1xuZXhwb3J0cy50cmlnZ2VySGFuZGxlcnMgPSBoYW5kbGVycy50cmlnZ2VySGFuZGxlcnM7XG5leHBvcnRzLmlzRE9NRXJyb3IgPSBpcy5pc0RPTUVycm9yO1xuZXhwb3J0cy5pc0RPTUV4Y2VwdGlvbiA9IGlzLmlzRE9NRXhjZXB0aW9uO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpcy5pc0VsZW1lbnQ7XG5leHBvcnRzLmlzRXJyb3IgPSBpcy5pc0Vycm9yO1xuZXhwb3J0cy5pc0Vycm9yRXZlbnQgPSBpcy5pc0Vycm9yRXZlbnQ7XG5leHBvcnRzLmlzRXZlbnQgPSBpcy5pc0V2ZW50O1xuZXhwb3J0cy5pc0luc3RhbmNlT2YgPSBpcy5pc0luc3RhbmNlT2Y7XG5leHBvcnRzLmlzUGFyYW1ldGVyaXplZFN0cmluZyA9IGlzLmlzUGFyYW1ldGVyaXplZFN0cmluZztcbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzLmlzUGxhaW5PYmplY3Q7XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXMuaXNQcmltaXRpdmU7XG5leHBvcnRzLmlzUmVnRXhwID0gaXMuaXNSZWdFeHA7XG5leHBvcnRzLmlzU3RyaW5nID0gaXMuaXNTdHJpbmc7XG5leHBvcnRzLmlzU3ludGhldGljRXZlbnQgPSBpcy5pc1N5bnRoZXRpY0V2ZW50O1xuZXhwb3J0cy5pc1RoZW5hYmxlID0gaXMuaXNUaGVuYWJsZTtcbmV4cG9ydHMuaXNWdWVWaWV3TW9kZWwgPSBpcy5pc1Z1ZVZpZXdNb2RlbDtcbmV4cG9ydHMuaXNCcm93c2VyID0gaXNCcm93c2VyLmlzQnJvd3NlcjtcbmV4cG9ydHMuQ09OU09MRV9MRVZFTFMgPSBsb2dnZXIuQ09OU09MRV9MRVZFTFM7XG5leHBvcnRzLmNvbnNvbGVTYW5kYm94ID0gbG9nZ2VyLmNvbnNvbGVTYW5kYm94O1xuZXhwb3J0cy5sb2dnZXIgPSBsb2dnZXIubG9nZ2VyO1xuZXhwb3J0cy5vcmlnaW5hbENvbnNvbGVNZXRob2RzID0gbG9nZ2VyLm9yaWdpbmFsQ29uc29sZU1ldGhvZHM7XG5leHBvcnRzLmFkZENvbnRleHRUb0ZyYW1lID0gbWlzYy5hZGRDb250ZXh0VG9GcmFtZTtcbmV4cG9ydHMuYWRkRXhjZXB0aW9uTWVjaGFuaXNtID0gbWlzYy5hZGRFeGNlcHRpb25NZWNoYW5pc207XG5leHBvcnRzLmFkZEV4Y2VwdGlvblR5cGVWYWx1ZSA9IG1pc2MuYWRkRXhjZXB0aW9uVHlwZVZhbHVlO1xuZXhwb3J0cy5jaGVja09yU2V0QWxyZWFkeUNhdWdodCA9IG1pc2MuY2hlY2tPclNldEFscmVhZHlDYXVnaHQ7XG5leHBvcnRzLmdldEV2ZW50RGVzY3JpcHRpb24gPSBtaXNjLmdldEV2ZW50RGVzY3JpcHRpb247XG5leHBvcnRzLnBhcnNlU2VtdmVyID0gbWlzYy5wYXJzZVNlbXZlcjtcbmV4cG9ydHMudXVpZDQgPSBtaXNjLnV1aWQ0O1xuZXhwb3J0cy5pc05vZGVFbnYgPSBub2RlLmlzTm9kZUVudjtcbmV4cG9ydHMubG9hZE1vZHVsZSA9IG5vZGUubG9hZE1vZHVsZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplLm5vcm1hbGl6ZTtcbmV4cG9ydHMubm9ybWFsaXplVG9TaXplID0gbm9ybWFsaXplLm5vcm1hbGl6ZVRvU2l6ZTtcbmV4cG9ydHMubm9ybWFsaXplVXJsVG9CYXNlID0gbm9ybWFsaXplLm5vcm1hbGl6ZVVybFRvQmFzZTtcbmV4cG9ydHMuYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gb2JqZWN0LmFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eTtcbmV4cG9ydHMuY29udmVydFRvUGxhaW5PYmplY3QgPSBvYmplY3QuY29udmVydFRvUGxhaW5PYmplY3Q7XG5leHBvcnRzLmRyb3BVbmRlZmluZWRLZXlzID0gb2JqZWN0LmRyb3BVbmRlZmluZWRLZXlzO1xuZXhwb3J0cy5leHRyYWN0RXhjZXB0aW9uS2V5c0Zvck1lc3NhZ2UgPSBvYmplY3QuZXh0cmFjdEV4Y2VwdGlvbktleXNGb3JNZXNzYWdlO1xuZXhwb3J0cy5maWxsID0gb2JqZWN0LmZpbGw7XG5leHBvcnRzLmdldE9yaWdpbmFsRnVuY3Rpb24gPSBvYmplY3QuZ2V0T3JpZ2luYWxGdW5jdGlvbjtcbmV4cG9ydHMubWFya0Z1bmN0aW9uV3JhcHBlZCA9IG9iamVjdC5tYXJrRnVuY3Rpb25XcmFwcGVkO1xuZXhwb3J0cy5vYmplY3RpZnkgPSBvYmplY3Qub2JqZWN0aWZ5O1xuZXhwb3J0cy5iYXNlbmFtZSA9IHBhdGguYmFzZW5hbWU7XG5leHBvcnRzLmRpcm5hbWUgPSBwYXRoLmRpcm5hbWU7XG5leHBvcnRzLmlzQWJzb2x1dGUgPSBwYXRoLmlzQWJzb2x1dGU7XG5leHBvcnRzLmpvaW4gPSBwYXRoLmpvaW47XG5leHBvcnRzLm5vcm1hbGl6ZVBhdGggPSBwYXRoLm5vcm1hbGl6ZVBhdGg7XG5leHBvcnRzLnJlbGF0aXZlID0gcGF0aC5yZWxhdGl2ZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHBhdGgucmVzb2x2ZTtcbmV4cG9ydHMuU0VOVFJZX0JVRkZFUl9GVUxMX0VSUk9SID0gcHJvbWlzZWJ1ZmZlci5TRU5UUllfQlVGRkVSX0ZVTExfRVJST1I7XG5leHBvcnRzLm1ha2VQcm9taXNlQnVmZmVyID0gcHJvbWlzZWJ1ZmZlci5tYWtlUHJvbWlzZUJ1ZmZlcjtcbmV4cG9ydHMuc2V2ZXJpdHlMZXZlbEZyb21TdHJpbmcgPSBzZXZlcml0eS5zZXZlcml0eUxldmVsRnJvbVN0cmluZztcbmV4cG9ydHMuVU5LTk9XTl9GVU5DVElPTiA9IHN0YWNrdHJhY2UuVU5LTk9XTl9GVU5DVElPTjtcbmV4cG9ydHMuY3JlYXRlU3RhY2tQYXJzZXIgPSBzdGFja3RyYWNlLmNyZWF0ZVN0YWNrUGFyc2VyO1xuZXhwb3J0cy5nZXRGcmFtZXNGcm9tRXZlbnQgPSBzdGFja3RyYWNlLmdldEZyYW1lc0Zyb21FdmVudDtcbmV4cG9ydHMuZ2V0RnVuY3Rpb25OYW1lID0gc3RhY2t0cmFjZS5nZXRGdW5jdGlvbk5hbWU7XG5leHBvcnRzLnN0YWNrUGFyc2VyRnJvbVN0YWNrUGFyc2VyT3B0aW9ucyA9IHN0YWNrdHJhY2Uuc3RhY2tQYXJzZXJGcm9tU3RhY2tQYXJzZXJPcHRpb25zO1xuZXhwb3J0cy5zdHJpcFNlbnRyeUZyYW1lc0FuZFJldmVyc2UgPSBzdGFja3RyYWNlLnN0cmlwU2VudHJ5RnJhbWVzQW5kUmV2ZXJzZTtcbmV4cG9ydHMuZmlsZW5hbWVJc0luQXBwID0gbm9kZVN0YWNrVHJhY2UuZmlsZW5hbWVJc0luQXBwO1xuZXhwb3J0cy5ub2RlID0gbm9kZVN0YWNrVHJhY2Uubm9kZTtcbmV4cG9ydHMubm9kZVN0YWNrTGluZVBhcnNlciA9IG5vZGVTdGFja1RyYWNlLm5vZGVTdGFja0xpbmVQYXJzZXI7XG5leHBvcnRzLmlzTWF0Y2hpbmdQYXR0ZXJuID0gc3RyaW5nLmlzTWF0Y2hpbmdQYXR0ZXJuO1xuZXhwb3J0cy5zYWZlSm9pbiA9IHN0cmluZy5zYWZlSm9pbjtcbmV4cG9ydHMuc25pcExpbmUgPSBzdHJpbmcuc25pcExpbmU7XG5leHBvcnRzLnN0cmluZ01hdGNoZXNTb21lUGF0dGVybiA9IHN0cmluZy5zdHJpbmdNYXRjaGVzU29tZVBhdHRlcm47XG5leHBvcnRzLnRydW5jYXRlID0gc3RyaW5nLnRydW5jYXRlO1xuZXhwb3J0cy5pc05hdGl2ZUZ1bmN0aW9uID0gc3VwcG9ydHMuaXNOYXRpdmVGdW5jdGlvbjtcbmV4cG9ydHMuc3VwcG9ydHNET01FcnJvciA9IHN1cHBvcnRzLnN1cHBvcnRzRE9NRXJyb3I7XG5leHBvcnRzLnN1cHBvcnRzRE9NRXhjZXB0aW9uID0gc3VwcG9ydHMuc3VwcG9ydHNET01FeGNlcHRpb247XG5leHBvcnRzLnN1cHBvcnRzRXJyb3JFdmVudCA9IHN1cHBvcnRzLnN1cHBvcnRzRXJyb3JFdmVudDtcbmV4cG9ydHMuc3VwcG9ydHNGZXRjaCA9IHN1cHBvcnRzLnN1cHBvcnRzRmV0Y2g7XG5leHBvcnRzLnN1cHBvcnRzSGlzdG9yeSA9IHN1cHBvcnRzLnN1cHBvcnRzSGlzdG9yeTtcbmV4cG9ydHMuc3VwcG9ydHNOYXRpdmVGZXRjaCA9IHN1cHBvcnRzLnN1cHBvcnRzTmF0aXZlRmV0Y2g7XG5leHBvcnRzLnN1cHBvcnRzUmVmZXJyZXJQb2xpY3kgPSBzdXBwb3J0cy5zdXBwb3J0c1JlZmVycmVyUG9saWN5O1xuZXhwb3J0cy5zdXBwb3J0c1JlcG9ydGluZ09ic2VydmVyID0gc3VwcG9ydHMuc3VwcG9ydHNSZXBvcnRpbmdPYnNlcnZlcjtcbmV4cG9ydHMuU3luY1Byb21pc2UgPSBzeW5jcHJvbWlzZS5TeW5jUHJvbWlzZTtcbmV4cG9ydHMucmVqZWN0ZWRTeW5jUHJvbWlzZSA9IHN5bmNwcm9taXNlLnJlamVjdGVkU3luY1Byb21pc2U7XG5leHBvcnRzLnJlc29sdmVkU3luY1Byb21pc2UgPSBzeW5jcHJvbWlzZS5yZXNvbHZlZFN5bmNQcm9taXNlO1xuZXhwb3J0cy5icm93c2VyUGVyZm9ybWFuY2VUaW1lT3JpZ2luID0gdGltZS5icm93c2VyUGVyZm9ybWFuY2VUaW1lT3JpZ2luO1xuZXhwb3J0cy5kYXRlVGltZXN0YW1wSW5TZWNvbmRzID0gdGltZS5kYXRlVGltZXN0YW1wSW5TZWNvbmRzO1xuZXhwb3J0cy50aW1lc3RhbXBJblNlY29uZHMgPSB0aW1lLnRpbWVzdGFtcEluU2Vjb25kcztcbmV4cG9ydHMuVFJBQ0VQQVJFTlRfUkVHRVhQID0gdHJhY2luZy5UUkFDRVBBUkVOVF9SRUdFWFA7XG5leHBvcnRzLmV4dHJhY3RUcmFjZXBhcmVudERhdGEgPSB0cmFjaW5nLmV4dHJhY3RUcmFjZXBhcmVudERhdGE7XG5leHBvcnRzLmdlbmVyYXRlU2VudHJ5VHJhY2VIZWFkZXIgPSB0cmFjaW5nLmdlbmVyYXRlU2VudHJ5VHJhY2VIZWFkZXI7XG5leHBvcnRzLnByb3BhZ2F0aW9uQ29udGV4dEZyb21IZWFkZXJzID0gdHJhY2luZy5wcm9wYWdhdGlvbkNvbnRleHRGcm9tSGVhZGVycztcbmV4cG9ydHMuZ2V0U0RLU291cmNlID0gZW52LmdldFNES1NvdXJjZTtcbmV4cG9ydHMuaXNCcm93c2VyQnVuZGxlID0gZW52LmlzQnJvd3NlckJ1bmRsZTtcbmV4cG9ydHMuYWRkSXRlbVRvRW52ZWxvcGUgPSBlbnZlbG9wZSQxLmFkZEl0ZW1Ub0VudmVsb3BlO1xuZXhwb3J0cy5jcmVhdGVBdHRhY2htZW50RW52ZWxvcGVJdGVtID0gZW52ZWxvcGUkMS5jcmVhdGVBdHRhY2htZW50RW52ZWxvcGVJdGVtO1xuZXhwb3J0cy5jcmVhdGVFbnZlbG9wZSA9IGVudmVsb3BlJDEuY3JlYXRlRW52ZWxvcGU7XG5leHBvcnRzLmNyZWF0ZUV2ZW50RW52ZWxvcGVIZWFkZXJzID0gZW52ZWxvcGUkMS5jcmVhdGVFdmVudEVudmVsb3BlSGVhZGVycztcbmV4cG9ydHMuY3JlYXRlU3BhbkVudmVsb3BlSXRlbSA9IGVudmVsb3BlJDEuY3JlYXRlU3BhbkVudmVsb3BlSXRlbTtcbmV4cG9ydHMuZW52ZWxvcGVDb250YWluc0l0ZW1UeXBlID0gZW52ZWxvcGUkMS5lbnZlbG9wZUNvbnRhaW5zSXRlbVR5cGU7XG5leHBvcnRzLmVudmVsb3BlSXRlbVR5cGVUb0RhdGFDYXRlZ29yeSA9IGVudmVsb3BlJDEuZW52ZWxvcGVJdGVtVHlwZVRvRGF0YUNhdGVnb3J5O1xuZXhwb3J0cy5mb3JFYWNoRW52ZWxvcGVJdGVtID0gZW52ZWxvcGUkMS5mb3JFYWNoRW52ZWxvcGVJdGVtO1xuZXhwb3J0cy5nZXRTZGtNZXRhZGF0YUZvckVudmVsb3BlSGVhZGVyID0gZW52ZWxvcGUkMS5nZXRTZGtNZXRhZGF0YUZvckVudmVsb3BlSGVhZGVyO1xuZXhwb3J0cy5wYXJzZUVudmVsb3BlID0gZW52ZWxvcGUkMS5wYXJzZUVudmVsb3BlO1xuZXhwb3J0cy5zZXJpYWxpemVFbnZlbG9wZSA9IGVudmVsb3BlJDEuc2VyaWFsaXplRW52ZWxvcGU7XG5leHBvcnRzLmNyZWF0ZUNsaWVudFJlcG9ydEVudmVsb3BlID0gY2xpZW50cmVwb3J0LmNyZWF0ZUNsaWVudFJlcG9ydEVudmVsb3BlO1xuZXhwb3J0cy5ERUZBVUxUX1JFVFJZX0FGVEVSID0gcmF0ZWxpbWl0LkRFRkFVTFRfUkVUUllfQUZURVI7XG5leHBvcnRzLmRpc2FibGVkVW50aWwgPSByYXRlbGltaXQuZGlzYWJsZWRVbnRpbDtcbmV4cG9ydHMuaXNSYXRlTGltaXRlZCA9IHJhdGVsaW1pdC5pc1JhdGVMaW1pdGVkO1xuZXhwb3J0cy5wYXJzZVJldHJ5QWZ0ZXJIZWFkZXIgPSByYXRlbGltaXQucGFyc2VSZXRyeUFmdGVySGVhZGVyO1xuZXhwb3J0cy51cGRhdGVSYXRlTGltaXRzID0gcmF0ZWxpbWl0LnVwZGF0ZVJhdGVMaW1pdHM7XG5leHBvcnRzLk1BWF9CQUdHQUdFX1NUUklOR19MRU5HVEggPSBiYWdnYWdlLk1BWF9CQUdHQUdFX1NUUklOR19MRU5HVEg7XG5leHBvcnRzLlNFTlRSWV9CQUdHQUdFX0tFWV9QUkVGSVggPSBiYWdnYWdlLlNFTlRSWV9CQUdHQUdFX0tFWV9QUkVGSVg7XG5leHBvcnRzLlNFTlRSWV9CQUdHQUdFX0tFWV9QUkVGSVhfUkVHRVggPSBiYWdnYWdlLlNFTlRSWV9CQUdHQUdFX0tFWV9QUkVGSVhfUkVHRVg7XG5leHBvcnRzLmJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSBiYWdnYWdlLmJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQ7XG5leHBvcnRzLmR5bmFtaWNTYW1wbGluZ0NvbnRleHRUb1NlbnRyeUJhZ2dhZ2VIZWFkZXIgPSBiYWdnYWdlLmR5bmFtaWNTYW1wbGluZ0NvbnRleHRUb1NlbnRyeUJhZ2dhZ2VIZWFkZXI7XG5leHBvcnRzLm9iamVjdFRvQmFnZ2FnZUhlYWRlciA9IGJhZ2dhZ2Uub2JqZWN0VG9CYWdnYWdlSGVhZGVyO1xuZXhwb3J0cy5wYXJzZUJhZ2dhZ2VIZWFkZXIgPSBiYWdnYWdlLnBhcnNlQmFnZ2FnZUhlYWRlcjtcbmV4cG9ydHMuZ2V0SHR0cFNwYW5EZXRhaWxzRnJvbVVybE9iamVjdCA9IHVybC5nZXRIdHRwU3BhbkRldGFpbHNGcm9tVXJsT2JqZWN0O1xuZXhwb3J0cy5nZXRTYW5pdGl6ZWRVcmxTdHJpbmcgPSB1cmwuZ2V0U2FuaXRpemVkVXJsU3RyaW5nO1xuZXhwb3J0cy5nZXRTYW5pdGl6ZWRVcmxTdHJpbmdGcm9tVXJsT2JqZWN0ID0gdXJsLmdldFNhbml0aXplZFVybFN0cmluZ0Zyb21VcmxPYmplY3Q7XG5leHBvcnRzLmlzVVJMT2JqZWN0UmVsYXRpdmUgPSB1cmwuaXNVUkxPYmplY3RSZWxhdGl2ZTtcbmV4cG9ydHMucGFyc2VTdHJpbmdUb1VSTE9iamVjdCA9IHVybC5wYXJzZVN0cmluZ1RvVVJMT2JqZWN0O1xuZXhwb3J0cy5wYXJzZVVybCA9IHVybC5wYXJzZVVybDtcbmV4cG9ydHMuc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50ID0gdXJsLnN0cmlwVXJsUXVlcnlBbmRGcmFnbWVudDtcbmV4cG9ydHMuZXZlbnRGcm9tTWVzc2FnZSA9IGV2ZW50YnVpbGRlci5ldmVudEZyb21NZXNzYWdlO1xuZXhwb3J0cy5ldmVudEZyb21Vbmtub3duSW5wdXQgPSBldmVudGJ1aWxkZXIuZXZlbnRGcm9tVW5rbm93bklucHV0O1xuZXhwb3J0cy5leGNlcHRpb25Gcm9tRXJyb3IgPSBldmVudGJ1aWxkZXIuZXhjZXB0aW9uRnJvbUVycm9yO1xuZXhwb3J0cy5wYXJzZVN0YWNrRnJhbWVzID0gZXZlbnRidWlsZGVyLnBhcnNlU3RhY2tGcmFtZXM7XG5leHBvcnRzLmNhbGxGcmFtZVRvU3RhY2tGcmFtZSA9IGFuci5jYWxsRnJhbWVUb1N0YWNrRnJhbWU7XG5leHBvcnRzLndhdGNoZG9nVGltZXIgPSBhbnIud2F0Y2hkb2dUaW1lcjtcbmV4cG9ydHMuTFJVTWFwID0gbHJ1LkxSVU1hcDtcbmV4cG9ydHMuZ2VuZXJhdGVTcGFuSWQgPSBwcm9wYWdhdGlvbkNvbnRleHQuZ2VuZXJhdGVTcGFuSWQ7XG5leHBvcnRzLmdlbmVyYXRlVHJhY2VJZCA9IHByb3BhZ2F0aW9uQ29udGV4dC5nZW5lcmF0ZVRyYWNlSWQ7XG5leHBvcnRzLnZlcmNlbFdhaXRVbnRpbCA9IHZlcmNlbFdhaXRVbnRpbC52ZXJjZWxXYWl0VW50aWw7XG5leHBvcnRzLlNES19WRVJTSU9OID0gdmVyc2lvbi5TREtfVkVSU0lPTjtcbmV4cG9ydHMuZ2V0RGVidWdJbWFnZXNGb3JSZXNvdXJjZXMgPSBkZWJ1Z0lkcy5nZXREZWJ1Z0ltYWdlc0ZvclJlc291cmNlcztcbmV4cG9ydHMuZ2V0RmlsZW5hbWVUb0RlYnVnSWRNYXAgPSBkZWJ1Z0lkcy5nZXRGaWxlbmFtZVRvRGVidWdJZE1hcDtcbmV4cG9ydHMuZXNjYXBlU3RyaW5nRm9yUmVnZXggPSBlc2NhcGVTdHJpbmdGb3JSZWdleC5lc2NhcGVTdHJpbmdGb3JSZWdleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/index.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\n\nconst installedIntegrations = [];\n\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preserve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations) {\n  const integrationsByName = {};\n\n  integrations.forEach((currentInstance) => {\n    const { name } = currentInstance;\n\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.values(integrationsByName);\n}\n\n/** Gets integrations to install */\nfunction getIntegrationsToSetup(options) {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach((integration) => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations;\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    const resolvedUserIntegrations = userIntegrations(defaultIntegrations);\n    integrations = Array.isArray(resolvedUserIntegrations) ? resolvedUserIntegrations : [resolvedUserIntegrations];\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  return filterDuplicates(integrations);\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nfunction setupIntegrations(client, integrations) {\n  const integrationIndex = {};\n\n  integrations.forEach((integration) => {\n    // guard against empty provided integrations\n    if (integration) {\n      setupIntegration(client, integration, integrationIndex);\n    }\n  });\n\n  return integrationIndex;\n}\n\n/**\n * Execute the `afterAllSetup` hooks of the given integrations.\n */\nfunction afterSetupIntegrations(client, integrations) {\n  for (const integration of integrations) {\n    // guard against empty provided integrations\n    if (integration?.afterAllSetup) {\n      integration.afterAllSetup(client);\n    }\n  }\n}\n\n/** Setup a single integration.  */\nfunction setupIntegration(client, integration, integrationIndex) {\n  if (integrationIndex[integration.name]) {\n    debugBuild.DEBUG_BUILD && logger.logger.log(`Integration skipped because it was already installed: ${integration.name}`);\n    return;\n  }\n  integrationIndex[integration.name] = integration;\n\n  // `setupOnce` is only called the first time\n  if (installedIntegrations.indexOf(integration.name) === -1 && typeof integration.setupOnce === 'function') {\n    integration.setupOnce();\n    installedIntegrations.push(integration.name);\n  }\n\n  // `setup` is run for each client\n  if (integration.setup && typeof integration.setup === 'function') {\n    integration.setup(client);\n  }\n\n  if (typeof integration.preprocessEvent === 'function') {\n    const callback = integration.preprocessEvent.bind(integration) ;\n    client.on('preprocessEvent', (event, hint) => callback(event, hint, client));\n  }\n\n  if (typeof integration.processEvent === 'function') {\n    const callback = integration.processEvent.bind(integration) ;\n\n    const processor = Object.assign((event, hint) => callback(event, hint, client), {\n      id: integration.name,\n    });\n\n    client.addEventProcessor(processor);\n  }\n\n  debugBuild.DEBUG_BUILD && logger.logger.log(`Integration installed: ${integration.name}`);\n}\n\n/** Add an integration to the current scope's client. */\nfunction addIntegration(integration) {\n  const client = currentScopes.getClient();\n\n  if (!client) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn(`Cannot add integration \"${integration.name}\" because no SDK Client is available.`);\n    return;\n  }\n\n  client.addIntegration(integration);\n}\n\n/**\n * Define an integration function that can be used to create an integration instance.\n * Note that this by design hides the implementation details of the integration, as they are considered internal.\n */\nfunction defineIntegration(fn) {\n  return fn;\n}\n\nexports.addIntegration = addIntegration;\nexports.afterSetupIntegrations = afterSetupIntegrations;\nexports.defineIntegration = defineIntegration;\nexports.getIntegrationsToSetup = getIntegrationsToSetup;\nexports.installedIntegrations = installedIntegrations;\nexports.setupIntegration = setupIntegration;\nexports.setupIntegrations = setupIntegrations;\n//# sourceMappingURL=integration.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsc0JBQXNCLG1CQUFPLENBQUMsb0hBQW9CO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLGdIQUFrQjtBQUM3QyxlQUFlLG1CQUFPLENBQUMsOEhBQXlCOztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxPQUFPOztBQUVuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsaUJBQWlCO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSx3RUFBd0UsaUJBQWlCO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSxpQkFBaUI7QUFDN0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qiw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0Isd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGludGVncmF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcblxuY29uc3QgaW5zdGFsbGVkSW50ZWdyYXRpb25zID0gW107XG5cbi8qKiBNYXAgb2YgaW50ZWdyYXRpb25zIGFzc2lnbmVkIHRvIGEgY2xpZW50ICovXG5cbi8qKlxuICogUmVtb3ZlIGR1cGxpY2F0ZXMgZnJvbSB0aGUgZ2l2ZW4gYXJyYXksIHByZWZlcnJpbmcgdGhlIGxhc3QgaW5zdGFuY2Ugb2YgYW55IGR1cGxpY2F0ZS4gTm90IGd1YXJhbnRlZWQgdG9cbiAqIHByZXNlcnZlIHRoZSBvcmRlciBvZiBpbnRlZ3JhdGlvbnMgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckR1cGxpY2F0ZXMoaW50ZWdyYXRpb25zKSB7XG4gIGNvbnN0IGludGVncmF0aW9uc0J5TmFtZSA9IHt9O1xuXG4gIGludGVncmF0aW9ucy5mb3JFYWNoKChjdXJyZW50SW5zdGFuY2UpID0+IHtcbiAgICBjb25zdCB7IG5hbWUgfSA9IGN1cnJlbnRJbnN0YW5jZTtcblxuICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSBpbnRlZ3JhdGlvbnNCeU5hbWVbbmFtZV07XG5cbiAgICAvLyBXZSB3YW50IGludGVncmF0aW9ucyBsYXRlciBpbiB0aGUgYXJyYXkgdG8gb3ZlcndyaXRlIGVhcmxpZXIgb25lcyBvZiB0aGUgc2FtZSB0eXBlLCBleGNlcHQgdGhhdCB3ZSBuZXZlciB3YW50IGFcbiAgICAvLyBkZWZhdWx0IGluc3RhbmNlIHRvIG92ZXJ3cml0ZSBhbiBleGlzdGluZyB1c2VyIGluc3RhbmNlXG4gICAgaWYgKGV4aXN0aW5nSW5zdGFuY2UgJiYgIWV4aXN0aW5nSW5zdGFuY2UuaXNEZWZhdWx0SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlLmlzRGVmYXVsdEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZWdyYXRpb25zQnlOYW1lW25hbWVdID0gY3VycmVudEluc3RhbmNlO1xuICB9KTtcblxuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpbnRlZ3JhdGlvbnNCeU5hbWUpO1xufVxuXG4vKiogR2V0cyBpbnRlZ3JhdGlvbnMgdG8gaW5zdGFsbCAqL1xuZnVuY3Rpb24gZ2V0SW50ZWdyYXRpb25zVG9TZXR1cChvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmF1bHRJbnRlZ3JhdGlvbnMgPSBvcHRpb25zLmRlZmF1bHRJbnRlZ3JhdGlvbnMgfHwgW107XG4gIGNvbnN0IHVzZXJJbnRlZ3JhdGlvbnMgPSBvcHRpb25zLmludGVncmF0aW9ucztcblxuICAvLyBXZSBmbGFnIGRlZmF1bHQgaW5zdGFuY2VzLCBzbyB0aGF0IGxhdGVyIHdlIGNhbiB0ZWxsIHRoZW0gYXBhcnQgZnJvbSBhbnkgdXNlci1jcmVhdGVkIGluc3RhbmNlcyBvZiB0aGUgc2FtZSBjbGFzc1xuICBkZWZhdWx0SW50ZWdyYXRpb25zLmZvckVhY2goKGludGVncmF0aW9uKSA9PiB7XG4gICAgaW50ZWdyYXRpb24uaXNEZWZhdWx0SW5zdGFuY2UgPSB0cnVlO1xuICB9KTtcblxuICBsZXQgaW50ZWdyYXRpb25zO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHVzZXJJbnRlZ3JhdGlvbnMpKSB7XG4gICAgaW50ZWdyYXRpb25zID0gWy4uLmRlZmF1bHRJbnRlZ3JhdGlvbnMsIC4uLnVzZXJJbnRlZ3JhdGlvbnNdO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB1c2VySW50ZWdyYXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRVc2VySW50ZWdyYXRpb25zID0gdXNlckludGVncmF0aW9ucyhkZWZhdWx0SW50ZWdyYXRpb25zKTtcbiAgICBpbnRlZ3JhdGlvbnMgPSBBcnJheS5pc0FycmF5KHJlc29sdmVkVXNlckludGVncmF0aW9ucykgPyByZXNvbHZlZFVzZXJJbnRlZ3JhdGlvbnMgOiBbcmVzb2x2ZWRVc2VySW50ZWdyYXRpb25zXTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlZ3JhdGlvbnMgPSBkZWZhdWx0SW50ZWdyYXRpb25zO1xuICB9XG5cbiAgcmV0dXJuIGZpbHRlckR1cGxpY2F0ZXMoaW50ZWdyYXRpb25zKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIGxpc3Qgb2YgaW50ZWdyYXRpb24gaW5zdGFuY2VzIHRoaXMgaW5zdGFsbHMgdGhlbSBhbGwuIFdoZW4gYHdpdGhEZWZhdWx0c2AgaXMgc2V0IHRvIGB0cnVlYCB0aGVuIGFsbCBkZWZhdWx0XG4gKiBpbnRlZ3JhdGlvbnMgYXJlIGFkZGVkIHVubGVzcyB0aGV5IHdlcmUgYWxyZWFkeSBwcm92aWRlZCBiZWZvcmUuXG4gKiBAcGFyYW0gaW50ZWdyYXRpb25zIGFycmF5IG9mIGludGVncmF0aW9uIGluc3RhbmNlc1xuICogQHBhcmFtIHdpdGhEZWZhdWx0IHNob3VsZCBlbmFibGUgZGVmYXVsdCBpbnRlZ3JhdGlvbnNcbiAqL1xuZnVuY3Rpb24gc2V0dXBJbnRlZ3JhdGlvbnMoY2xpZW50LCBpbnRlZ3JhdGlvbnMpIHtcbiAgY29uc3QgaW50ZWdyYXRpb25JbmRleCA9IHt9O1xuXG4gIGludGVncmF0aW9ucy5mb3JFYWNoKChpbnRlZ3JhdGlvbikgPT4ge1xuICAgIC8vIGd1YXJkIGFnYWluc3QgZW1wdHkgcHJvdmlkZWQgaW50ZWdyYXRpb25zXG4gICAgaWYgKGludGVncmF0aW9uKSB7XG4gICAgICBzZXR1cEludGVncmF0aW9uKGNsaWVudCwgaW50ZWdyYXRpb24sIGludGVncmF0aW9uSW5kZXgpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGludGVncmF0aW9uSW5kZXg7XG59XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgYGFmdGVyQWxsU2V0dXBgIGhvb2tzIG9mIHRoZSBnaXZlbiBpbnRlZ3JhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGFmdGVyU2V0dXBJbnRlZ3JhdGlvbnMoY2xpZW50LCBpbnRlZ3JhdGlvbnMpIHtcbiAgZm9yIChjb25zdCBpbnRlZ3JhdGlvbiBvZiBpbnRlZ3JhdGlvbnMpIHtcbiAgICAvLyBndWFyZCBhZ2FpbnN0IGVtcHR5IHByb3ZpZGVkIGludGVncmF0aW9uc1xuICAgIGlmIChpbnRlZ3JhdGlvbj8uYWZ0ZXJBbGxTZXR1cCkge1xuICAgICAgaW50ZWdyYXRpb24uYWZ0ZXJBbGxTZXR1cChjbGllbnQpO1xuICAgIH1cbiAgfVxufVxuXG4vKiogU2V0dXAgYSBzaW5nbGUgaW50ZWdyYXRpb24uICAqL1xuZnVuY3Rpb24gc2V0dXBJbnRlZ3JhdGlvbihjbGllbnQsIGludGVncmF0aW9uLCBpbnRlZ3JhdGlvbkluZGV4KSB7XG4gIGlmIChpbnRlZ3JhdGlvbkluZGV4W2ludGVncmF0aW9uLm5hbWVdKSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLmxvZyhgSW50ZWdyYXRpb24gc2tpcHBlZCBiZWNhdXNlIGl0IHdhcyBhbHJlYWR5IGluc3RhbGxlZDogJHtpbnRlZ3JhdGlvbi5uYW1lfWApO1xuICAgIHJldHVybjtcbiAgfVxuICBpbnRlZ3JhdGlvbkluZGV4W2ludGVncmF0aW9uLm5hbWVdID0gaW50ZWdyYXRpb247XG5cbiAgLy8gYHNldHVwT25jZWAgaXMgb25seSBjYWxsZWQgdGhlIGZpcnN0IHRpbWVcbiAgaWYgKGluc3RhbGxlZEludGVncmF0aW9ucy5pbmRleE9mKGludGVncmF0aW9uLm5hbWUpID09PSAtMSAmJiB0eXBlb2YgaW50ZWdyYXRpb24uc2V0dXBPbmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW50ZWdyYXRpb24uc2V0dXBPbmNlKCk7XG4gICAgaW5zdGFsbGVkSW50ZWdyYXRpb25zLnB1c2goaW50ZWdyYXRpb24ubmFtZSk7XG4gIH1cblxuICAvLyBgc2V0dXBgIGlzIHJ1biBmb3IgZWFjaCBjbGllbnRcbiAgaWYgKGludGVncmF0aW9uLnNldHVwICYmIHR5cGVvZiBpbnRlZ3JhdGlvbi5zZXR1cCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGludGVncmF0aW9uLnNldHVwKGNsaWVudCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGludGVncmF0aW9uLnByZXByb2Nlc3NFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gaW50ZWdyYXRpb24ucHJlcHJvY2Vzc0V2ZW50LmJpbmQoaW50ZWdyYXRpb24pIDtcbiAgICBjbGllbnQub24oJ3ByZXByb2Nlc3NFdmVudCcsIChldmVudCwgaGludCkgPT4gY2FsbGJhY2soZXZlbnQsIGhpbnQsIGNsaWVudCkpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnRlZ3JhdGlvbi5wcm9jZXNzRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IGludGVncmF0aW9uLnByb2Nlc3NFdmVudC5iaW5kKGludGVncmF0aW9uKSA7XG5cbiAgICBjb25zdCBwcm9jZXNzb3IgPSBPYmplY3QuYXNzaWduKChldmVudCwgaGludCkgPT4gY2FsbGJhY2soZXZlbnQsIGhpbnQsIGNsaWVudCksIHtcbiAgICAgIGlkOiBpbnRlZ3JhdGlvbi5uYW1lLFxuICAgIH0pO1xuXG4gICAgY2xpZW50LmFkZEV2ZW50UHJvY2Vzc29yKHByb2Nlc3Nvcik7XG4gIH1cblxuICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIubG9nKGBJbnRlZ3JhdGlvbiBpbnN0YWxsZWQ6ICR7aW50ZWdyYXRpb24ubmFtZX1gKTtcbn1cblxuLyoqIEFkZCBhbiBpbnRlZ3JhdGlvbiB0byB0aGUgY3VycmVudCBzY29wZSdzIGNsaWVudC4gKi9cbmZ1bmN0aW9uIGFkZEludGVncmF0aW9uKGludGVncmF0aW9uKSB7XG4gIGNvbnN0IGNsaWVudCA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG5cbiAgaWYgKCFjbGllbnQpIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybihgQ2Fubm90IGFkZCBpbnRlZ3JhdGlvbiBcIiR7aW50ZWdyYXRpb24ubmFtZX1cIiBiZWNhdXNlIG5vIFNESyBDbGllbnQgaXMgYXZhaWxhYmxlLmApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNsaWVudC5hZGRJbnRlZ3JhdGlvbihpbnRlZ3JhdGlvbik7XG59XG5cbi8qKlxuICogRGVmaW5lIGFuIGludGVncmF0aW9uIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuIGludGVncmF0aW9uIGluc3RhbmNlLlxuICogTm90ZSB0aGF0IHRoaXMgYnkgZGVzaWduIGhpZGVzIHRoZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9mIHRoZSBpbnRlZ3JhdGlvbiwgYXMgdGhleSBhcmUgY29uc2lkZXJlZCBpbnRlcm5hbC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lSW50ZWdyYXRpb24oZm4pIHtcbiAgcmV0dXJuIGZuO1xufVxuXG5leHBvcnRzLmFkZEludGVncmF0aW9uID0gYWRkSW50ZWdyYXRpb247XG5leHBvcnRzLmFmdGVyU2V0dXBJbnRlZ3JhdGlvbnMgPSBhZnRlclNldHVwSW50ZWdyYXRpb25zO1xuZXhwb3J0cy5kZWZpbmVJbnRlZ3JhdGlvbiA9IGRlZmluZUludGVncmF0aW9uO1xuZXhwb3J0cy5nZXRJbnRlZ3JhdGlvbnNUb1NldHVwID0gZ2V0SW50ZWdyYXRpb25zVG9TZXR1cDtcbmV4cG9ydHMuaW5zdGFsbGVkSW50ZWdyYXRpb25zID0gaW5zdGFsbGVkSW50ZWdyYXRpb25zO1xuZXhwb3J0cy5zZXR1cEludGVncmF0aW9uID0gc2V0dXBJbnRlZ3JhdGlvbjtcbmV4cG9ydHMuc2V0dXBJbnRlZ3JhdGlvbnMgPSBzZXR1cEludGVncmF0aW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVncmF0aW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/captureconsole.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst exports$1 = __webpack_require__(/*! ../exports.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/exports.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\");\nconst console = __webpack_require__(/*! ../utils-hoist/instrument/console.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/console.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst misc = __webpack_require__(/*! ../utils-hoist/misc.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js\");\nconst severity = __webpack_require__(/*! ../utils-hoist/severity.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/severity.js\");\nconst string = __webpack_require__(/*! ../utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\nconst worldwide = __webpack_require__(/*! ../utils-hoist/worldwide.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js\");\n\nconst INTEGRATION_NAME = 'CaptureConsole';\n\nconst _captureConsoleIntegration = ((options = {}) => {\n  const levels = options.levels || logger.CONSOLE_LEVELS;\n  const handled = options.handled ?? true;\n\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      if (!('console' in worldwide.GLOBAL_OBJ)) {\n        return;\n      }\n\n      console.addConsoleInstrumentationHandler(({ args, level }) => {\n        if (currentScopes.getClient() !== client || !levels.includes(level)) {\n          return;\n        }\n\n        consoleHandler(args, level, handled);\n      });\n    },\n  };\n}) ;\n\n/**\n * Send Console API calls as Sentry Events.\n */\nconst captureConsoleIntegration = integration.defineIntegration(_captureConsoleIntegration);\n\nfunction consoleHandler(args, level, handled) {\n  const captureContext = {\n    level: severity.severityLevelFromString(level),\n    extra: {\n      arguments: args,\n    },\n  };\n\n  currentScopes.withScope(scope => {\n    scope.addEventProcessor(event => {\n      event.logger = 'console';\n\n      misc.addExceptionMechanism(event, {\n        handled,\n        type: 'console',\n      });\n\n      return event;\n    });\n\n    if (level === 'assert') {\n      if (!args[0]) {\n        const message = `Assertion failed: ${string.safeJoin(args.slice(1), ' ') || 'console.assert'}`;\n        scope.setExtra('arguments', args.slice(1));\n        exports$1.captureMessage(message, captureContext);\n      }\n      return;\n    }\n\n    const error = args.find(arg => arg instanceof Error);\n    if (error) {\n      exports$1.captureException(error, captureContext);\n      return;\n    }\n\n    const message = string.safeJoin(args, ' ');\n    exports$1.captureMessage(message, captureContext);\n  });\n}\n\nexports.captureConsoleIntegration = captureConsoleIntegration;\n//# sourceMappingURL=captureconsole.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb25zL2NhcHR1cmVjb25zb2xlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLHNCQUFzQixtQkFBTyxDQUFDLHFIQUFxQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyx5R0FBZTtBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsdUpBQXNDO0FBQzlELGVBQWUsbUJBQU8sQ0FBQywrSEFBMEI7QUFDakQsYUFBYSxtQkFBTyxDQUFDLDJIQUF3QjtBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQyxtSUFBNEI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLCtIQUEwQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxxSUFBNkI7O0FBRXZEOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsNkNBQTZDLHdEQUF3RDtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxpbnRlZ3JhdGlvbnNcXGNhcHR1cmVjb25zb2xlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi4vY3VycmVudFNjb3Blcy5qcycpO1xuY29uc3QgZXhwb3J0cyQxID0gcmVxdWlyZSgnLi4vZXhwb3J0cy5qcycpO1xuY29uc3QgaW50ZWdyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlZ3JhdGlvbi5qcycpO1xuY29uc3QgY29uc29sZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2luc3RydW1lbnQvY29uc29sZS5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCBtaXNjID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbWlzYy5qcycpO1xuY29uc3Qgc2V2ZXJpdHkgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9zZXZlcml0eS5qcycpO1xuY29uc3Qgc3RyaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvc3RyaW5nLmpzJyk7XG5jb25zdCB3b3JsZHdpZGUgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC93b3JsZHdpZGUuanMnKTtcblxuY29uc3QgSU5URUdSQVRJT05fTkFNRSA9ICdDYXB0dXJlQ29uc29sZSc7XG5cbmNvbnN0IF9jYXB0dXJlQ29uc29sZUludGVncmF0aW9uID0gKChvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgbGV2ZWxzID0gb3B0aW9ucy5sZXZlbHMgfHwgbG9nZ2VyLkNPTlNPTEVfTEVWRUxTO1xuICBjb25zdCBoYW5kbGVkID0gb3B0aW9ucy5oYW5kbGVkID8/IHRydWU7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHNldHVwKGNsaWVudCkge1xuICAgICAgaWYgKCEoJ2NvbnNvbGUnIGluIHdvcmxkd2lkZS5HTE9CQUxfT0JKKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUuYWRkQ29uc29sZUluc3RydW1lbnRhdGlvbkhhbmRsZXIoKHsgYXJncywgbGV2ZWwgfSkgPT4ge1xuICAgICAgICBpZiAoY3VycmVudFNjb3Blcy5nZXRDbGllbnQoKSAhPT0gY2xpZW50IHx8ICFsZXZlbHMuaW5jbHVkZXMobGV2ZWwpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZUhhbmRsZXIoYXJncywgbGV2ZWwsIGhhbmRsZWQpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfTtcbn0pIDtcblxuLyoqXG4gKiBTZW5kIENvbnNvbGUgQVBJIGNhbGxzIGFzIFNlbnRyeSBFdmVudHMuXG4gKi9cbmNvbnN0IGNhcHR1cmVDb25zb2xlSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbihfY2FwdHVyZUNvbnNvbGVJbnRlZ3JhdGlvbik7XG5cbmZ1bmN0aW9uIGNvbnNvbGVIYW5kbGVyKGFyZ3MsIGxldmVsLCBoYW5kbGVkKSB7XG4gIGNvbnN0IGNhcHR1cmVDb250ZXh0ID0ge1xuICAgIGxldmVsOiBzZXZlcml0eS5zZXZlcml0eUxldmVsRnJvbVN0cmluZyhsZXZlbCksXG4gICAgZXh0cmE6IHtcbiAgICAgIGFyZ3VtZW50czogYXJncyxcbiAgICB9LFxuICB9O1xuXG4gIGN1cnJlbnRTY29wZXMud2l0aFNjb3BlKHNjb3BlID0+IHtcbiAgICBzY29wZS5hZGRFdmVudFByb2Nlc3NvcihldmVudCA9PiB7XG4gICAgICBldmVudC5sb2dnZXIgPSAnY29uc29sZSc7XG5cbiAgICAgIG1pc2MuYWRkRXhjZXB0aW9uTWVjaGFuaXNtKGV2ZW50LCB7XG4gICAgICAgIGhhbmRsZWQsXG4gICAgICAgIHR5cGU6ICdjb25zb2xlJyxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfSk7XG5cbiAgICBpZiAobGV2ZWwgPT09ICdhc3NlcnQnKSB7XG4gICAgICBpZiAoIWFyZ3NbMF0pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBBc3NlcnRpb24gZmFpbGVkOiAke3N0cmluZy5zYWZlSm9pbihhcmdzLnNsaWNlKDEpLCAnICcpIHx8ICdjb25zb2xlLmFzc2VydCd9YDtcbiAgICAgICAgc2NvcGUuc2V0RXh0cmEoJ2FyZ3VtZW50cycsIGFyZ3Muc2xpY2UoMSkpO1xuICAgICAgICBleHBvcnRzJDEuY2FwdHVyZU1lc3NhZ2UobWVzc2FnZSwgY2FwdHVyZUNvbnRleHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yID0gYXJncy5maW5kKGFyZyA9PiBhcmcgaW5zdGFuY2VvZiBFcnJvcik7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBleHBvcnRzJDEuY2FwdHVyZUV4Y2VwdGlvbihlcnJvciwgY2FwdHVyZUNvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2UgPSBzdHJpbmcuc2FmZUpvaW4oYXJncywgJyAnKTtcbiAgICBleHBvcnRzJDEuY2FwdHVyZU1lc3NhZ2UobWVzc2FnZSwgY2FwdHVyZUNvbnRleHQpO1xuICB9KTtcbn1cblxuZXhwb3J0cy5jYXB0dXJlQ29uc29sZUludGVncmF0aW9uID0gY2FwdHVyZUNvbnNvbGVJbnRlZ3JhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhcHR1cmVjb25zb2xlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/captureconsole.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/console.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst breadcrumbs = __webpack_require__(/*! ../breadcrumbs.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/breadcrumbs.js\");\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\");\nconst console = __webpack_require__(/*! ../utils-hoist/instrument/console.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/console.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst severity = __webpack_require__(/*! ../utils-hoist/severity.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/severity.js\");\nconst string = __webpack_require__(/*! ../utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\nconst worldwide = __webpack_require__(/*! ../utils-hoist/worldwide.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js\");\n\nconst INTEGRATION_NAME = 'Console';\n\n/**\n * Captures calls to the `console` API as breadcrumbs in Sentry.\n *\n * By default the integration instruments `console.debug`, `console.info`, `console.warn`, `console.error`,\n * `console.log`, `console.trace`, and `console.assert`. You can use the `levels` option to customize which\n * levels are captured.\n *\n * @example\n *\n * ```js\n * Sentry.init({\n *   integrations: [Sentry.consoleIntegration({ levels: ['error', 'warn'] })],\n * });\n * ```\n */\nconst consoleIntegration = integration.defineIntegration((options = {}) => {\n  const levels = new Set(options.levels || logger.CONSOLE_LEVELS);\n\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      console.addConsoleInstrumentationHandler(({ args, level }) => {\n        if (currentScopes.getClient() !== client || !levels.has(level)) {\n          return;\n        }\n\n        addConsoleBreadcrumb(level, args);\n      });\n    },\n  };\n});\n\n/**\n * Capture a console breadcrumb.\n *\n * Exported just for tests.\n */\nfunction addConsoleBreadcrumb(level, args) {\n  const breadcrumb = {\n    category: 'console',\n    data: {\n      arguments: args,\n      logger: 'console',\n    },\n    level: severity.severityLevelFromString(level),\n    message: formatConsoleArgs(args),\n  };\n\n  if (level === 'assert') {\n    if (args[0] === false) {\n      const assertionArgs = args.slice(1);\n      breadcrumb.message =\n        assertionArgs.length > 0 ? `Assertion failed: ${formatConsoleArgs(assertionArgs)}` : 'Assertion failed';\n      breadcrumb.data.arguments = assertionArgs;\n    } else {\n      // Don't capture a breadcrumb for passed assertions\n      return;\n    }\n  }\n\n  breadcrumbs.addBreadcrumb(breadcrumb, {\n    input: args,\n    level,\n  });\n}\n\nfunction formatConsoleArgs(values) {\n  return 'util' in worldwide.GLOBAL_OBJ && typeof (worldwide.GLOBAL_OBJ ).util.format === 'function'\n    ? (worldwide.GLOBAL_OBJ ).util.format(...values)\n    : string.safeJoin(values, ' ');\n}\n\nexports.addConsoleBreadcrumb = addConsoleBreadcrumb;\nexports.consoleIntegration = consoleIntegration;\n//# sourceMappingURL=console.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb25zL2NvbnNvbGUuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsb0JBQW9CLG1CQUFPLENBQUMsaUhBQW1CO0FBQy9DLHNCQUFzQixtQkFBTyxDQUFDLHFIQUFxQjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsdUpBQXNDO0FBQzlELGVBQWUsbUJBQU8sQ0FBQywrSEFBMEI7QUFDakQsaUJBQWlCLG1CQUFPLENBQUMsbUlBQTRCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQywrSEFBMEI7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMscUlBQTZCOztBQUV2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDJCQUEyQjtBQUMzRSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxpQ0FBaUM7QUFDekY7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGludGVncmF0aW9uc1xcY29uc29sZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgYnJlYWRjcnVtYnMgPSByZXF1aXJlKCcuLi9icmVhZGNydW1icy5qcycpO1xuY29uc3QgY3VycmVudFNjb3BlcyA9IHJlcXVpcmUoJy4uL2N1cnJlbnRTY29wZXMuanMnKTtcbmNvbnN0IGludGVncmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZWdyYXRpb24uanMnKTtcbmNvbnN0IGNvbnNvbGUgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9pbnN0cnVtZW50L2NvbnNvbGUuanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuY29uc3Qgc2V2ZXJpdHkgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9zZXZlcml0eS5qcycpO1xuY29uc3Qgc3RyaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvc3RyaW5nLmpzJyk7XG5jb25zdCB3b3JsZHdpZGUgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC93b3JsZHdpZGUuanMnKTtcblxuY29uc3QgSU5URUdSQVRJT05fTkFNRSA9ICdDb25zb2xlJztcblxuLyoqXG4gKiBDYXB0dXJlcyBjYWxscyB0byB0aGUgYGNvbnNvbGVgIEFQSSBhcyBicmVhZGNydW1icyBpbiBTZW50cnkuXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgaW50ZWdyYXRpb24gaW5zdHJ1bWVudHMgYGNvbnNvbGUuZGVidWdgLCBgY29uc29sZS5pbmZvYCwgYGNvbnNvbGUud2FybmAsIGBjb25zb2xlLmVycm9yYCxcbiAqIGBjb25zb2xlLmxvZ2AsIGBjb25zb2xlLnRyYWNlYCwgYW5kIGBjb25zb2xlLmFzc2VydGAuIFlvdSBjYW4gdXNlIHRoZSBgbGV2ZWxzYCBvcHRpb24gdG8gY3VzdG9taXplIHdoaWNoXG4gKiBsZXZlbHMgYXJlIGNhcHR1cmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIFNlbnRyeS5pbml0KHtcbiAqICAgaW50ZWdyYXRpb25zOiBbU2VudHJ5LmNvbnNvbGVJbnRlZ3JhdGlvbih7IGxldmVsczogWydlcnJvcicsICd3YXJuJ10gfSldLFxuICogfSk7XG4gKiBgYGBcbiAqL1xuY29uc3QgY29uc29sZUludGVncmF0aW9uID0gaW50ZWdyYXRpb24uZGVmaW5lSW50ZWdyYXRpb24oKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBsZXZlbHMgPSBuZXcgU2V0KG9wdGlvbnMubGV2ZWxzIHx8IGxvZ2dlci5DT05TT0xFX0xFVkVMUyk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHNldHVwKGNsaWVudCkge1xuICAgICAgY29uc29sZS5hZGRDb25zb2xlSW5zdHJ1bWVudGF0aW9uSGFuZGxlcigoeyBhcmdzLCBsZXZlbCB9KSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50U2NvcGVzLmdldENsaWVudCgpICE9PSBjbGllbnQgfHwgIWxldmVscy5oYXMobGV2ZWwpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkQ29uc29sZUJyZWFkY3J1bWIobGV2ZWwsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfTtcbn0pO1xuXG4vKipcbiAqIENhcHR1cmUgYSBjb25zb2xlIGJyZWFkY3J1bWIuXG4gKlxuICogRXhwb3J0ZWQganVzdCBmb3IgdGVzdHMuXG4gKi9cbmZ1bmN0aW9uIGFkZENvbnNvbGVCcmVhZGNydW1iKGxldmVsLCBhcmdzKSB7XG4gIGNvbnN0IGJyZWFkY3J1bWIgPSB7XG4gICAgY2F0ZWdvcnk6ICdjb25zb2xlJyxcbiAgICBkYXRhOiB7XG4gICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICBsb2dnZXI6ICdjb25zb2xlJyxcbiAgICB9LFxuICAgIGxldmVsOiBzZXZlcml0eS5zZXZlcml0eUxldmVsRnJvbVN0cmluZyhsZXZlbCksXG4gICAgbWVzc2FnZTogZm9ybWF0Q29uc29sZUFyZ3MoYXJncyksXG4gIH07XG5cbiAgaWYgKGxldmVsID09PSAnYXNzZXJ0Jykge1xuICAgIGlmIChhcmdzWzBdID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgYXNzZXJ0aW9uQXJncyA9IGFyZ3Muc2xpY2UoMSk7XG4gICAgICBicmVhZGNydW1iLm1lc3NhZ2UgPVxuICAgICAgICBhc3NlcnRpb25BcmdzLmxlbmd0aCA+IDAgPyBgQXNzZXJ0aW9uIGZhaWxlZDogJHtmb3JtYXRDb25zb2xlQXJncyhhc3NlcnRpb25BcmdzKX1gIDogJ0Fzc2VydGlvbiBmYWlsZWQnO1xuICAgICAgYnJlYWRjcnVtYi5kYXRhLmFyZ3VtZW50cyA9IGFzc2VydGlvbkFyZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERvbid0IGNhcHR1cmUgYSBicmVhZGNydW1iIGZvciBwYXNzZWQgYXNzZXJ0aW9uc1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGJyZWFkY3J1bWJzLmFkZEJyZWFkY3J1bWIoYnJlYWRjcnVtYiwge1xuICAgIGlucHV0OiBhcmdzLFxuICAgIGxldmVsLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0Q29uc29sZUFyZ3ModmFsdWVzKSB7XG4gIHJldHVybiAndXRpbCcgaW4gd29ybGR3aWRlLkdMT0JBTF9PQkogJiYgdHlwZW9mICh3b3JsZHdpZGUuR0xPQkFMX09CSiApLnV0aWwuZm9ybWF0ID09PSAnZnVuY3Rpb24nXG4gICAgPyAod29ybGR3aWRlLkdMT0JBTF9PQkogKS51dGlsLmZvcm1hdCguLi52YWx1ZXMpXG4gICAgOiBzdHJpbmcuc2FmZUpvaW4odmFsdWVzLCAnICcpO1xufVxuXG5leHBvcnRzLmFkZENvbnNvbGVCcmVhZGNydW1iID0gYWRkQ29uc29sZUJyZWFkY3J1bWI7XG5leHBvcnRzLmNvbnNvbGVJbnRlZ3JhdGlvbiA9IGNvbnNvbGVJbnRlZ3JhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnNvbGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/console.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/dedupe.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst stacktrace = __webpack_require__(/*! ../utils-hoist/stacktrace.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/stacktrace.js\");\n\nconst INTEGRATION_NAME = 'Dedupe';\n\nconst _dedupeIntegration = (() => {\n  let previousEvent;\n\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(currentEvent) {\n      // We want to ignore any non-error type events, e.g. transactions or replays\n      // These should never be deduped, and also not be compared against as _previousEvent.\n      if (currentEvent.type) {\n        return currentEvent;\n      }\n\n      // Juuust in case something goes wrong\n      try {\n        if (_shouldDropEvent(currentEvent, previousEvent)) {\n          debugBuild.DEBUG_BUILD && logger.logger.warn('Event dropped due to being a duplicate of previously captured event.');\n          return null;\n        }\n      } catch (_oO) {} // eslint-disable-line no-empty\n\n      return (previousEvent = currentEvent);\n    },\n  };\n}) ;\n\n/**\n * Deduplication filter.\n */\nconst dedupeIntegration = integration.defineIntegration(_dedupeIntegration);\n\n/** only exported for tests. */\nfunction _shouldDropEvent(currentEvent, previousEvent) {\n  if (!previousEvent) {\n    return false;\n  }\n\n  if (_isSameMessageEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  if (_isSameExceptionEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _isSameMessageEvent(currentEvent, previousEvent) {\n  const currentMessage = currentEvent.message;\n  const previousMessage = previousEvent.message;\n\n  // If neither event has a message property, they were both exceptions, so bail out\n  if (!currentMessage && !previousMessage) {\n    return false;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {\n    return false;\n  }\n\n  if (currentMessage !== previousMessage) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction _isSameExceptionEvent(currentEvent, previousEvent) {\n  const previousException = _getExceptionFromEvent(previousEvent);\n  const currentException = _getExceptionFromEvent(currentEvent);\n\n  if (!previousException || !currentException) {\n    return false;\n  }\n\n  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction _isSameStacktrace(currentEvent, previousEvent) {\n  let currentFrames = stacktrace.getFramesFromEvent(currentEvent);\n  let previousFrames = stacktrace.getFramesFromEvent(previousEvent);\n\n  // If neither event has a stacktrace, they are assumed to be the same\n  if (!currentFrames && !previousFrames) {\n    return true;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {\n    return false;\n  }\n\n  currentFrames = currentFrames ;\n  previousFrames = previousFrames ;\n\n  // If number of frames differ, they are not the same\n  if (previousFrames.length !== currentFrames.length) {\n    return false;\n  }\n\n  // Otherwise, compare the two\n  for (let i = 0; i < previousFrames.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const frameA = previousFrames[i];\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const frameB = currentFrames[i];\n\n    if (\n      frameA.filename !== frameB.filename ||\n      frameA.lineno !== frameB.lineno ||\n      frameA.colno !== frameB.colno ||\n      frameA.function !== frameB.function\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction _isSameFingerprint(currentEvent, previousEvent) {\n  let currentFingerprint = currentEvent.fingerprint;\n  let previousFingerprint = previousEvent.fingerprint;\n\n  // If neither event has a fingerprint, they are assumed to be the same\n  if (!currentFingerprint && !previousFingerprint) {\n    return true;\n  }\n\n  // If only one event has a fingerprint, but not the other one, they are not the same\n  if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {\n    return false;\n  }\n\n  currentFingerprint = currentFingerprint ;\n  previousFingerprint = previousFingerprint ;\n\n  // Otherwise, compare the two\n  try {\n    return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n  } catch (_oO) {\n    return false;\n  }\n}\n\nfunction _getExceptionFromEvent(event) {\n  return event.exception?.values && event.exception.values[0];\n}\n\nexports._shouldDropEvent = _shouldDropEvent;\nexports.dedupeIntegration = dedupeIntegration;\n//# sourceMappingURL=dedupe.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb25zL2RlZHVwZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxtQkFBbUIsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsaUhBQW1CO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQywrSEFBMEI7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsdUlBQThCOztBQUV6RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxlQUFlOztBQUV2QjtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcaW50ZWdyYXRpb25zXFxkZWR1cGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3QgaW50ZWdyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlZ3JhdGlvbi5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCBzdGFja3RyYWNlID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvc3RhY2t0cmFjZS5qcycpO1xuXG5jb25zdCBJTlRFR1JBVElPTl9OQU1FID0gJ0RlZHVwZSc7XG5cbmNvbnN0IF9kZWR1cGVJbnRlZ3JhdGlvbiA9ICgoKSA9PiB7XG4gIGxldCBwcmV2aW91c0V2ZW50O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogSU5URUdSQVRJT05fTkFNRSxcbiAgICBwcm9jZXNzRXZlbnQoY3VycmVudEV2ZW50KSB7XG4gICAgICAvLyBXZSB3YW50IHRvIGlnbm9yZSBhbnkgbm9uLWVycm9yIHR5cGUgZXZlbnRzLCBlLmcuIHRyYW5zYWN0aW9ucyBvciByZXBsYXlzXG4gICAgICAvLyBUaGVzZSBzaG91bGQgbmV2ZXIgYmUgZGVkdXBlZCwgYW5kIGFsc28gbm90IGJlIGNvbXBhcmVkIGFnYWluc3QgYXMgX3ByZXZpb3VzRXZlbnQuXG4gICAgICBpZiAoY3VycmVudEV2ZW50LnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRFdmVudDtcbiAgICAgIH1cblxuICAgICAgLy8gSnV1dXN0IGluIGNhc2Ugc29tZXRoaW5nIGdvZXMgd3JvbmdcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfc2hvdWxkRHJvcEV2ZW50KGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkpIHtcbiAgICAgICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybignRXZlbnQgZHJvcHBlZCBkdWUgdG8gYmVpbmcgYSBkdXBsaWNhdGUgb2YgcHJldmlvdXNseSBjYXB0dXJlZCBldmVudC4nKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX29PKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG5cbiAgICAgIHJldHVybiAocHJldmlvdXNFdmVudCA9IGN1cnJlbnRFdmVudCk7XG4gICAgfSxcbiAgfTtcbn0pIDtcblxuLyoqXG4gKiBEZWR1cGxpY2F0aW9uIGZpbHRlci5cbiAqL1xuY29uc3QgZGVkdXBlSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbihfZGVkdXBlSW50ZWdyYXRpb24pO1xuXG4vKiogb25seSBleHBvcnRlZCBmb3IgdGVzdHMuICovXG5mdW5jdGlvbiBfc2hvdWxkRHJvcEV2ZW50KGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkge1xuICBpZiAoIXByZXZpb3VzRXZlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoX2lzU2FtZU1lc3NhZ2VFdmVudChjdXJyZW50RXZlbnQsIHByZXZpb3VzRXZlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoX2lzU2FtZUV4Y2VwdGlvbkV2ZW50KGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX2lzU2FtZU1lc3NhZ2VFdmVudChjdXJyZW50RXZlbnQsIHByZXZpb3VzRXZlbnQpIHtcbiAgY29uc3QgY3VycmVudE1lc3NhZ2UgPSBjdXJyZW50RXZlbnQubWVzc2FnZTtcbiAgY29uc3QgcHJldmlvdXNNZXNzYWdlID0gcHJldmlvdXNFdmVudC5tZXNzYWdlO1xuXG4gIC8vIElmIG5laXRoZXIgZXZlbnQgaGFzIGEgbWVzc2FnZSBwcm9wZXJ0eSwgdGhleSB3ZXJlIGJvdGggZXhjZXB0aW9ucywgc28gYmFpbCBvdXRcbiAgaWYgKCFjdXJyZW50TWVzc2FnZSAmJiAhcHJldmlvdXNNZXNzYWdlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgb25seSBvbmUgZXZlbnQgaGFzIGEgc3RhY2t0cmFjZSwgYnV0IG5vdCB0aGUgb3RoZXIgb25lLCB0aGV5IGFyZSBub3QgdGhlIHNhbWVcbiAgaWYgKChjdXJyZW50TWVzc2FnZSAmJiAhcHJldmlvdXNNZXNzYWdlKSB8fCAoIWN1cnJlbnRNZXNzYWdlICYmIHByZXZpb3VzTWVzc2FnZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoY3VycmVudE1lc3NhZ2UgIT09IHByZXZpb3VzTWVzc2FnZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghX2lzU2FtZUZpbmdlcnByaW50KGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIV9pc1NhbWVTdGFja3RyYWNlKGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX2lzU2FtZUV4Y2VwdGlvbkV2ZW50KGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkge1xuICBjb25zdCBwcmV2aW91c0V4Y2VwdGlvbiA9IF9nZXRFeGNlcHRpb25Gcm9tRXZlbnQocHJldmlvdXNFdmVudCk7XG4gIGNvbnN0IGN1cnJlbnRFeGNlcHRpb24gPSBfZ2V0RXhjZXB0aW9uRnJvbUV2ZW50KGN1cnJlbnRFdmVudCk7XG5cbiAgaWYgKCFwcmV2aW91c0V4Y2VwdGlvbiB8fCAhY3VycmVudEV4Y2VwdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcmV2aW91c0V4Y2VwdGlvbi50eXBlICE9PSBjdXJyZW50RXhjZXB0aW9uLnR5cGUgfHwgcHJldmlvdXNFeGNlcHRpb24udmFsdWUgIT09IGN1cnJlbnRFeGNlcHRpb24udmFsdWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIV9pc1NhbWVGaW5nZXJwcmludChjdXJyZW50RXZlbnQsIHByZXZpb3VzRXZlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFfaXNTYW1lU3RhY2t0cmFjZShjdXJyZW50RXZlbnQsIHByZXZpb3VzRXZlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIF9pc1NhbWVTdGFja3RyYWNlKGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkge1xuICBsZXQgY3VycmVudEZyYW1lcyA9IHN0YWNrdHJhY2UuZ2V0RnJhbWVzRnJvbUV2ZW50KGN1cnJlbnRFdmVudCk7XG4gIGxldCBwcmV2aW91c0ZyYW1lcyA9IHN0YWNrdHJhY2UuZ2V0RnJhbWVzRnJvbUV2ZW50KHByZXZpb3VzRXZlbnQpO1xuXG4gIC8vIElmIG5laXRoZXIgZXZlbnQgaGFzIGEgc3RhY2t0cmFjZSwgdGhleSBhcmUgYXNzdW1lZCB0byBiZSB0aGUgc2FtZVxuICBpZiAoIWN1cnJlbnRGcmFtZXMgJiYgIXByZXZpb3VzRnJhbWVzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJZiBvbmx5IG9uZSBldmVudCBoYXMgYSBzdGFja3RyYWNlLCBidXQgbm90IHRoZSBvdGhlciBvbmUsIHRoZXkgYXJlIG5vdCB0aGUgc2FtZVxuICBpZiAoKGN1cnJlbnRGcmFtZXMgJiYgIXByZXZpb3VzRnJhbWVzKSB8fCAoIWN1cnJlbnRGcmFtZXMgJiYgcHJldmlvdXNGcmFtZXMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY3VycmVudEZyYW1lcyA9IGN1cnJlbnRGcmFtZXMgO1xuICBwcmV2aW91c0ZyYW1lcyA9IHByZXZpb3VzRnJhbWVzIDtcblxuICAvLyBJZiBudW1iZXIgb2YgZnJhbWVzIGRpZmZlciwgdGhleSBhcmUgbm90IHRoZSBzYW1lXG4gIGlmIChwcmV2aW91c0ZyYW1lcy5sZW5ndGggIT09IGN1cnJlbnRGcmFtZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBjb21wYXJlIHRoZSB0d29cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2aW91c0ZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgY29uc3QgZnJhbWVBID0gcHJldmlvdXNGcmFtZXNbaV07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBjb25zdCBmcmFtZUIgPSBjdXJyZW50RnJhbWVzW2ldO1xuXG4gICAgaWYgKFxuICAgICAgZnJhbWVBLmZpbGVuYW1lICE9PSBmcmFtZUIuZmlsZW5hbWUgfHxcbiAgICAgIGZyYW1lQS5saW5lbm8gIT09IGZyYW1lQi5saW5lbm8gfHxcbiAgICAgIGZyYW1lQS5jb2xubyAhPT0gZnJhbWVCLmNvbG5vIHx8XG4gICAgICBmcmFtZUEuZnVuY3Rpb24gIT09IGZyYW1lQi5mdW5jdGlvblxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBfaXNTYW1lRmluZ2VycHJpbnQoY3VycmVudEV2ZW50LCBwcmV2aW91c0V2ZW50KSB7XG4gIGxldCBjdXJyZW50RmluZ2VycHJpbnQgPSBjdXJyZW50RXZlbnQuZmluZ2VycHJpbnQ7XG4gIGxldCBwcmV2aW91c0ZpbmdlcnByaW50ID0gcHJldmlvdXNFdmVudC5maW5nZXJwcmludDtcblxuICAvLyBJZiBuZWl0aGVyIGV2ZW50IGhhcyBhIGZpbmdlcnByaW50LCB0aGV5IGFyZSBhc3N1bWVkIHRvIGJlIHRoZSBzYW1lXG4gIGlmICghY3VycmVudEZpbmdlcnByaW50ICYmICFwcmV2aW91c0ZpbmdlcnByaW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJZiBvbmx5IG9uZSBldmVudCBoYXMgYSBmaW5nZXJwcmludCwgYnV0IG5vdCB0aGUgb3RoZXIgb25lLCB0aGV5IGFyZSBub3QgdGhlIHNhbWVcbiAgaWYgKChjdXJyZW50RmluZ2VycHJpbnQgJiYgIXByZXZpb3VzRmluZ2VycHJpbnQpIHx8ICghY3VycmVudEZpbmdlcnByaW50ICYmIHByZXZpb3VzRmluZ2VycHJpbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY3VycmVudEZpbmdlcnByaW50ID0gY3VycmVudEZpbmdlcnByaW50IDtcbiAgcHJldmlvdXNGaW5nZXJwcmludCA9IHByZXZpb3VzRmluZ2VycHJpbnQgO1xuXG4gIC8vIE90aGVyd2lzZSwgY29tcGFyZSB0aGUgdHdvXG4gIHRyeSB7XG4gICAgcmV0dXJuICEhKGN1cnJlbnRGaW5nZXJwcmludC5qb2luKCcnKSA9PT0gcHJldmlvdXNGaW5nZXJwcmludC5qb2luKCcnKSk7XG4gIH0gY2F0Y2ggKF9vTykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0RXhjZXB0aW9uRnJvbUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5leGNlcHRpb24/LnZhbHVlcyAmJiBldmVudC5leGNlcHRpb24udmFsdWVzWzBdO1xufVxuXG5leHBvcnRzLl9zaG91bGREcm9wRXZlbnQgPSBfc2hvdWxkRHJvcEV2ZW50O1xuZXhwb3J0cy5kZWR1cGVJbnRlZ3JhdGlvbiA9IGRlZHVwZUludGVncmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVkdXBlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/dedupe.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/eventFilters.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\");\nconst eventUtils = __webpack_require__(/*! ../utils/eventUtils.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/eventUtils.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst misc = __webpack_require__(/*! ../utils-hoist/misc.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js\");\nconst string = __webpack_require__(/*! ../utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\n\n// \"Script error.\" is hard coded into browsers for errors that it can't read.\n// this is the result of a script being pulled in from an external domain and CORS.\nconst DEFAULT_IGNORE_ERRORS = [\n  /^Script error\\.?$/,\n  /^Javascript error: Script error\\.? on line 0$/,\n  /^ResizeObserver loop completed with undelivered notifications.$/, // The browser logs this when a ResizeObserver handler takes a bit longer. Usually this is not an actual issue though. It indicates slowness.\n  /^Cannot redefine property: googletag$/, // This is thrown when google tag manager is used in combination with an ad blocker\n  /^Can't find variable: gmo$/, // Error from Google Search App https://issuetracker.google.com/issues/396043331\n  /^undefined is not an object \\(evaluating 'a\\.[A-Z]'\\)$/, // Random error that happens but not actionable or noticeable to end-users.\n  'can\\'t redefine non-configurable property \"solana\"', // Probably a browser extension or custom browser (Brave) throwing this error\n  \"vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)\", // Error thrown by GTM, seemingly not affecting end-users\n  \"Can't find variable: _AutofillCallbackHandler\", // Unactionable error in instagram webview https://developers.facebook.com/community/threads/320013549791141/\n  /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\\d+, MethodName:simulateEvent, ParamCount:\\d+$/, // unactionable error from CEFSharp, a .NET library that embeds chromium in .NET apps\n  /^Java exception was raised during method invocation$/, // error from Facebook Mobile browser (https://github.com/getsentry/sentry-javascript/issues/15065)\n];\n\n/** Options for the EventFilters integration */\n\nconst INTEGRATION_NAME = 'EventFilters';\n\n/**\n * An integration that filters out events (errors and transactions) based on:\n *\n * - (Errors) A curated list of known low-value or irrelevant errors (see {@link DEFAULT_IGNORE_ERRORS})\n * - (Errors) A list of error messages or urls/filenames passed in via\n *   - Top level Sentry.init options (`ignoreErrors`, `denyUrls`, `allowUrls`)\n *   - The same options passed to the integration directly via @param options\n * - (Transactions/Spans) A list of root span (transaction) names passed in via\n *   - Top level Sentry.init option (`ignoreTransactions`)\n *   - The same option passed to the integration directly via @param options\n *\n * Events filtered by this integration will not be sent to Sentry.\n */\nconst eventFiltersIntegration = integration.defineIntegration((options = {}) => {\n  let mergedOptions;\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      const clientOptions = client.getOptions();\n      mergedOptions = _mergeOptions(options, clientOptions);\n    },\n    processEvent(event, _hint, client) {\n      if (!mergedOptions) {\n        const clientOptions = client.getOptions();\n        mergedOptions = _mergeOptions(options, clientOptions);\n      }\n      return _shouldDropEvent(event, mergedOptions) ? null : event;\n    },\n  };\n});\n\n/**\n * An integration that filters out events (errors and transactions) based on:\n *\n * - (Errors) A curated list of known low-value or irrelevant errors (see {@link DEFAULT_IGNORE_ERRORS})\n * - (Errors) A list of error messages or urls/filenames passed in via\n *   - Top level Sentry.init options (`ignoreErrors`, `denyUrls`, `allowUrls`)\n *   - The same options passed to the integration directly via @param options\n * - (Transactions/Spans) A list of root span (transaction) names passed in via\n *   - Top level Sentry.init option (`ignoreTransactions`)\n *   - The same option passed to the integration directly via @param options\n *\n * Events filtered by this integration will not be sent to Sentry.\n *\n * @deprecated this integration was renamed and will be removed in a future major version.\n * Use `eventFiltersIntegration` instead.\n */\nconst inboundFiltersIntegration = integration.defineIntegration(((options = {}) => {\n  return {\n    ...eventFiltersIntegration(options),\n    name: 'InboundFilters',\n  };\n}) );\n\nfunction _mergeOptions(\n  internalOptions = {},\n  clientOptions = {},\n) {\n  return {\n    allowUrls: [...(internalOptions.allowUrls || []), ...(clientOptions.allowUrls || [])],\n    denyUrls: [...(internalOptions.denyUrls || []), ...(clientOptions.denyUrls || [])],\n    ignoreErrors: [\n      ...(internalOptions.ignoreErrors || []),\n      ...(clientOptions.ignoreErrors || []),\n      ...(internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS),\n    ],\n    ignoreTransactions: [...(internalOptions.ignoreTransactions || []), ...(clientOptions.ignoreTransactions || [])],\n  };\n}\n\nfunction _shouldDropEvent(event, options) {\n  if (!event.type) {\n    // Filter errors\n    if (_isIgnoredError(event, options.ignoreErrors)) {\n      debugBuild.DEBUG_BUILD &&\n        logger.logger.warn(\n          `Event dropped due to being matched by \\`ignoreErrors\\` option.\\nEvent: ${misc.getEventDescription(event)}`,\n        );\n      return true;\n    }\n    if (_isUselessError(event)) {\n      debugBuild.DEBUG_BUILD &&\n        logger.logger.warn(\n          `Event dropped due to not having an error message, error type or stacktrace.\\nEvent: ${misc.getEventDescription(\n            event,\n          )}`,\n        );\n      return true;\n    }\n    if (_isDeniedUrl(event, options.denyUrls)) {\n      debugBuild.DEBUG_BUILD &&\n        logger.logger.warn(\n          `Event dropped due to being matched by \\`denyUrls\\` option.\\nEvent: ${misc.getEventDescription(\n            event,\n          )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n        );\n      return true;\n    }\n    if (!_isAllowedUrl(event, options.allowUrls)) {\n      debugBuild.DEBUG_BUILD &&\n        logger.logger.warn(\n          `Event dropped due to not being matched by \\`allowUrls\\` option.\\nEvent: ${misc.getEventDescription(\n            event,\n          )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n        );\n      return true;\n    }\n  } else if (event.type === 'transaction') {\n    // Filter transactions\n\n    if (_isIgnoredTransaction(event, options.ignoreTransactions)) {\n      debugBuild.DEBUG_BUILD &&\n        logger.logger.warn(\n          `Event dropped due to being matched by \\`ignoreTransactions\\` option.\\nEvent: ${misc.getEventDescription(event)}`,\n        );\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction _isIgnoredError(event, ignoreErrors) {\n  if (!ignoreErrors?.length) {\n    return false;\n  }\n\n  return eventUtils.getPossibleEventMessages(event).some(message => string.stringMatchesSomePattern(message, ignoreErrors));\n}\n\nfunction _isIgnoredTransaction(event, ignoreTransactions) {\n  if (!ignoreTransactions?.length) {\n    return false;\n  }\n\n  const name = event.transaction;\n  return name ? string.stringMatchesSomePattern(name, ignoreTransactions) : false;\n}\n\nfunction _isDeniedUrl(event, denyUrls) {\n  if (!denyUrls?.length) {\n    return false;\n  }\n  const url = _getEventFilterUrl(event);\n  return !url ? false : string.stringMatchesSomePattern(url, denyUrls);\n}\n\nfunction _isAllowedUrl(event, allowUrls) {\n  if (!allowUrls?.length) {\n    return true;\n  }\n  const url = _getEventFilterUrl(event);\n  return !url ? true : string.stringMatchesSomePattern(url, allowUrls);\n}\n\nfunction _getLastValidUrl(frames = []) {\n  for (let i = frames.length - 1; i >= 0; i--) {\n    const frame = frames[i];\n\n    if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {\n      return frame.filename || null;\n    }\n  }\n\n  return null;\n}\n\nfunction _getEventFilterUrl(event) {\n  try {\n    // If there are linked exceptions or exception aggregates we only want to match against the top frame of the \"root\" (the main exception)\n    // The root always comes last in linked exceptions\n    const rootException = [...(event.exception?.values ?? [])]\n      .reverse()\n      .find(value => value.mechanism?.parent_id === undefined && value.stacktrace?.frames?.length);\n    const frames = rootException?.stacktrace?.frames;\n    return frames ? _getLastValidUrl(frames) : null;\n  } catch (oO) {\n    debugBuild.DEBUG_BUILD && logger.logger.error(`Cannot extract url for event ${misc.getEventDescription(event)}`);\n    return null;\n  }\n}\n\nfunction _isUselessError(event) {\n  // We only want to consider events for dropping that actually have recorded exception values.\n  if (!event.exception?.values?.length) {\n    return false;\n  }\n\n  return (\n    // No top-level message\n    !event.message &&\n    // There are no exception values that have a stacktrace, a non-generic-Error type or value\n    !event.exception.values.some(value => value.stacktrace || (value.type && value.type !== 'Error') || value.value)\n  );\n}\n\nexports.eventFiltersIntegration = eventFiltersIntegration;\nexports.inboundFiltersIntegration = inboundFiltersIntegration;\n//# sourceMappingURL=eventFilters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb25zL2V2ZW50RmlsdGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxtQkFBbUIsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsaUhBQW1CO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLDJIQUF3QjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsK0hBQTBCO0FBQ2pELGFBQWEsbUJBQU8sQ0FBQywySEFBd0I7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLCtIQUEwQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSw0QkFBNEI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSw0QkFBNEI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixnQ0FBZ0M7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBLFlBQVksVUFBVSwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0EsWUFBWSxVQUFVLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGdDQUFnQztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixrRkFBa0YsZ0NBQWdDO0FBQ2xIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxpbnRlZ3JhdGlvbnNcXGV2ZW50RmlsdGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgZGVidWdCdWlsZCA9IHJlcXVpcmUoJy4uL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBpbnRlZ3JhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVncmF0aW9uLmpzJyk7XG5jb25zdCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnRVdGlscy5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCBtaXNjID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbWlzYy5qcycpO1xuY29uc3Qgc3RyaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvc3RyaW5nLmpzJyk7XG5cbi8vIFwiU2NyaXB0IGVycm9yLlwiIGlzIGhhcmQgY29kZWQgaW50byBicm93c2VycyBmb3IgZXJyb3JzIHRoYXQgaXQgY2FuJ3QgcmVhZC5cbi8vIHRoaXMgaXMgdGhlIHJlc3VsdCBvZiBhIHNjcmlwdCBiZWluZyBwdWxsZWQgaW4gZnJvbSBhbiBleHRlcm5hbCBkb21haW4gYW5kIENPUlMuXG5jb25zdCBERUZBVUxUX0lHTk9SRV9FUlJPUlMgPSBbXG4gIC9eU2NyaXB0IGVycm9yXFwuPyQvLFxuICAvXkphdmFzY3JpcHQgZXJyb3I6IFNjcmlwdCBlcnJvclxcLj8gb24gbGluZSAwJC8sXG4gIC9eUmVzaXplT2JzZXJ2ZXIgbG9vcCBjb21wbGV0ZWQgd2l0aCB1bmRlbGl2ZXJlZCBub3RpZmljYXRpb25zLiQvLCAvLyBUaGUgYnJvd3NlciBsb2dzIHRoaXMgd2hlbiBhIFJlc2l6ZU9ic2VydmVyIGhhbmRsZXIgdGFrZXMgYSBiaXQgbG9uZ2VyLiBVc3VhbGx5IHRoaXMgaXMgbm90IGFuIGFjdHVhbCBpc3N1ZSB0aG91Z2guIEl0IGluZGljYXRlcyBzbG93bmVzcy5cbiAgL15DYW5ub3QgcmVkZWZpbmUgcHJvcGVydHk6IGdvb2dsZXRhZyQvLCAvLyBUaGlzIGlzIHRocm93biB3aGVuIGdvb2dsZSB0YWcgbWFuYWdlciBpcyB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYW4gYWQgYmxvY2tlclxuICAvXkNhbid0IGZpbmQgdmFyaWFibGU6IGdtbyQvLCAvLyBFcnJvciBmcm9tIEdvb2dsZSBTZWFyY2ggQXBwIGh0dHBzOi8vaXNzdWV0cmFja2VyLmdvb2dsZS5jb20vaXNzdWVzLzM5NjA0MzMzMVxuICAvXnVuZGVmaW5lZCBpcyBub3QgYW4gb2JqZWN0IFxcKGV2YWx1YXRpbmcgJ2FcXC5bQS1aXSdcXCkkLywgLy8gUmFuZG9tIGVycm9yIHRoYXQgaGFwcGVucyBidXQgbm90IGFjdGlvbmFibGUgb3Igbm90aWNlYWJsZSB0byBlbmQtdXNlcnMuXG4gICdjYW5cXCd0IHJlZGVmaW5lIG5vbi1jb25maWd1cmFibGUgcHJvcGVydHkgXCJzb2xhbmFcIicsIC8vIFByb2JhYmx5IGEgYnJvd3NlciBleHRlbnNpb24gb3IgY3VzdG9tIGJyb3dzZXIgKEJyYXZlKSB0aHJvd2luZyB0aGlzIGVycm9yXG4gIFwidnYoKS5nZXRSZXN0cmljdGlvbnMgaXMgbm90IGEgZnVuY3Rpb24uIChJbiAndnYoKS5nZXRSZXN0cmljdGlvbnMoMSxhKScsICd2digpLmdldFJlc3RyaWN0aW9ucycgaXMgdW5kZWZpbmVkKVwiLCAvLyBFcnJvciB0aHJvd24gYnkgR1RNLCBzZWVtaW5nbHkgbm90IGFmZmVjdGluZyBlbmQtdXNlcnNcbiAgXCJDYW4ndCBmaW5kIHZhcmlhYmxlOiBfQXV0b2ZpbGxDYWxsYmFja0hhbmRsZXJcIiwgLy8gVW5hY3Rpb25hYmxlIGVycm9yIGluIGluc3RhZ3JhbSB3ZWJ2aWV3IGh0dHBzOi8vZGV2ZWxvcGVycy5mYWNlYm9vay5jb20vY29tbXVuaXR5L3RocmVhZHMvMzIwMDEzNTQ5NzkxMTQxL1xuICAvXk5vbi1FcnJvciBwcm9taXNlIHJlamVjdGlvbiBjYXB0dXJlZCB3aXRoIHZhbHVlOiBPYmplY3QgTm90IEZvdW5kIE1hdGNoaW5nIElkOlxcZCssIE1ldGhvZE5hbWU6c2ltdWxhdGVFdmVudCwgUGFyYW1Db3VudDpcXGQrJC8sIC8vIHVuYWN0aW9uYWJsZSBlcnJvciBmcm9tIENFRlNoYXJwLCBhIC5ORVQgbGlicmFyeSB0aGF0IGVtYmVkcyBjaHJvbWl1bSBpbiAuTkVUIGFwcHNcbiAgL15KYXZhIGV4Y2VwdGlvbiB3YXMgcmFpc2VkIGR1cmluZyBtZXRob2QgaW52b2NhdGlvbiQvLCAvLyBlcnJvciBmcm9tIEZhY2Vib29rIE1vYmlsZSBicm93c2VyIChodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8xNTA2NSlcbl07XG5cbi8qKiBPcHRpb25zIGZvciB0aGUgRXZlbnRGaWx0ZXJzIGludGVncmF0aW9uICovXG5cbmNvbnN0IElOVEVHUkFUSU9OX05BTUUgPSAnRXZlbnRGaWx0ZXJzJztcblxuLyoqXG4gKiBBbiBpbnRlZ3JhdGlvbiB0aGF0IGZpbHRlcnMgb3V0IGV2ZW50cyAoZXJyb3JzIGFuZCB0cmFuc2FjdGlvbnMpIGJhc2VkIG9uOlxuICpcbiAqIC0gKEVycm9ycykgQSBjdXJhdGVkIGxpc3Qgb2Yga25vd24gbG93LXZhbHVlIG9yIGlycmVsZXZhbnQgZXJyb3JzIChzZWUge0BsaW5rIERFRkFVTFRfSUdOT1JFX0VSUk9SU30pXG4gKiAtIChFcnJvcnMpIEEgbGlzdCBvZiBlcnJvciBtZXNzYWdlcyBvciB1cmxzL2ZpbGVuYW1lcyBwYXNzZWQgaW4gdmlhXG4gKiAgIC0gVG9wIGxldmVsIFNlbnRyeS5pbml0IG9wdGlvbnMgKGBpZ25vcmVFcnJvcnNgLCBgZGVueVVybHNgLCBgYWxsb3dVcmxzYClcbiAqICAgLSBUaGUgc2FtZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgaW50ZWdyYXRpb24gZGlyZWN0bHkgdmlhIEBwYXJhbSBvcHRpb25zXG4gKiAtIChUcmFuc2FjdGlvbnMvU3BhbnMpIEEgbGlzdCBvZiByb290IHNwYW4gKHRyYW5zYWN0aW9uKSBuYW1lcyBwYXNzZWQgaW4gdmlhXG4gKiAgIC0gVG9wIGxldmVsIFNlbnRyeS5pbml0IG9wdGlvbiAoYGlnbm9yZVRyYW5zYWN0aW9uc2ApXG4gKiAgIC0gVGhlIHNhbWUgb3B0aW9uIHBhc3NlZCB0byB0aGUgaW50ZWdyYXRpb24gZGlyZWN0bHkgdmlhIEBwYXJhbSBvcHRpb25zXG4gKlxuICogRXZlbnRzIGZpbHRlcmVkIGJ5IHRoaXMgaW50ZWdyYXRpb24gd2lsbCBub3QgYmUgc2VudCB0byBTZW50cnkuXG4gKi9cbmNvbnN0IGV2ZW50RmlsdGVyc0ludGVncmF0aW9uID0gaW50ZWdyYXRpb24uZGVmaW5lSW50ZWdyYXRpb24oKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBsZXQgbWVyZ2VkT3B0aW9ucztcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHNldHVwKGNsaWVudCkge1xuICAgICAgY29uc3QgY2xpZW50T3B0aW9ucyA9IGNsaWVudC5nZXRPcHRpb25zKCk7XG4gICAgICBtZXJnZWRPcHRpb25zID0gX21lcmdlT3B0aW9ucyhvcHRpb25zLCBjbGllbnRPcHRpb25zKTtcbiAgICB9LFxuICAgIHByb2Nlc3NFdmVudChldmVudCwgX2hpbnQsIGNsaWVudCkge1xuICAgICAgaWYgKCFtZXJnZWRPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBjbGllbnQuZ2V0T3B0aW9ucygpO1xuICAgICAgICBtZXJnZWRPcHRpb25zID0gX21lcmdlT3B0aW9ucyhvcHRpb25zLCBjbGllbnRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfc2hvdWxkRHJvcEV2ZW50KGV2ZW50LCBtZXJnZWRPcHRpb25zKSA/IG51bGwgOiBldmVudDtcbiAgICB9LFxuICB9O1xufSk7XG5cbi8qKlxuICogQW4gaW50ZWdyYXRpb24gdGhhdCBmaWx0ZXJzIG91dCBldmVudHMgKGVycm9ycyBhbmQgdHJhbnNhY3Rpb25zKSBiYXNlZCBvbjpcbiAqXG4gKiAtIChFcnJvcnMpIEEgY3VyYXRlZCBsaXN0IG9mIGtub3duIGxvdy12YWx1ZSBvciBpcnJlbGV2YW50IGVycm9ycyAoc2VlIHtAbGluayBERUZBVUxUX0lHTk9SRV9FUlJPUlN9KVxuICogLSAoRXJyb3JzKSBBIGxpc3Qgb2YgZXJyb3IgbWVzc2FnZXMgb3IgdXJscy9maWxlbmFtZXMgcGFzc2VkIGluIHZpYVxuICogICAtIFRvcCBsZXZlbCBTZW50cnkuaW5pdCBvcHRpb25zIChgaWdub3JlRXJyb3JzYCwgYGRlbnlVcmxzYCwgYGFsbG93VXJsc2ApXG4gKiAgIC0gVGhlIHNhbWUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGludGVncmF0aW9uIGRpcmVjdGx5IHZpYSBAcGFyYW0gb3B0aW9uc1xuICogLSAoVHJhbnNhY3Rpb25zL1NwYW5zKSBBIGxpc3Qgb2Ygcm9vdCBzcGFuICh0cmFuc2FjdGlvbikgbmFtZXMgcGFzc2VkIGluIHZpYVxuICogICAtIFRvcCBsZXZlbCBTZW50cnkuaW5pdCBvcHRpb24gKGBpZ25vcmVUcmFuc2FjdGlvbnNgKVxuICogICAtIFRoZSBzYW1lIG9wdGlvbiBwYXNzZWQgdG8gdGhlIGludGVncmF0aW9uIGRpcmVjdGx5IHZpYSBAcGFyYW0gb3B0aW9uc1xuICpcbiAqIEV2ZW50cyBmaWx0ZXJlZCBieSB0aGlzIGludGVncmF0aW9uIHdpbGwgbm90IGJlIHNlbnQgdG8gU2VudHJ5LlxuICpcbiAqIEBkZXByZWNhdGVkIHRoaXMgaW50ZWdyYXRpb24gd2FzIHJlbmFtZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciB2ZXJzaW9uLlxuICogVXNlIGBldmVudEZpbHRlcnNJbnRlZ3JhdGlvbmAgaW5zdGVhZC5cbiAqL1xuY29uc3QgaW5ib3VuZEZpbHRlcnNJbnRlZ3JhdGlvbiA9IGludGVncmF0aW9uLmRlZmluZUludGVncmF0aW9uKCgob3B0aW9ucyA9IHt9KSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uZXZlbnRGaWx0ZXJzSW50ZWdyYXRpb24ob3B0aW9ucyksXG4gICAgbmFtZTogJ0luYm91bmRGaWx0ZXJzJyxcbiAgfTtcbn0pICk7XG5cbmZ1bmN0aW9uIF9tZXJnZU9wdGlvbnMoXG4gIGludGVybmFsT3B0aW9ucyA9IHt9LFxuICBjbGllbnRPcHRpb25zID0ge30sXG4pIHtcbiAgcmV0dXJuIHtcbiAgICBhbGxvd1VybHM6IFsuLi4oaW50ZXJuYWxPcHRpb25zLmFsbG93VXJscyB8fCBbXSksIC4uLihjbGllbnRPcHRpb25zLmFsbG93VXJscyB8fCBbXSldLFxuICAgIGRlbnlVcmxzOiBbLi4uKGludGVybmFsT3B0aW9ucy5kZW55VXJscyB8fCBbXSksIC4uLihjbGllbnRPcHRpb25zLmRlbnlVcmxzIHx8IFtdKV0sXG4gICAgaWdub3JlRXJyb3JzOiBbXG4gICAgICAuLi4oaW50ZXJuYWxPcHRpb25zLmlnbm9yZUVycm9ycyB8fCBbXSksXG4gICAgICAuLi4oY2xpZW50T3B0aW9ucy5pZ25vcmVFcnJvcnMgfHwgW10pLFxuICAgICAgLi4uKGludGVybmFsT3B0aW9ucy5kaXNhYmxlRXJyb3JEZWZhdWx0cyA/IFtdIDogREVGQVVMVF9JR05PUkVfRVJST1JTKSxcbiAgICBdLFxuICAgIGlnbm9yZVRyYW5zYWN0aW9uczogWy4uLihpbnRlcm5hbE9wdGlvbnMuaWdub3JlVHJhbnNhY3Rpb25zIHx8IFtdKSwgLi4uKGNsaWVudE9wdGlvbnMuaWdub3JlVHJhbnNhY3Rpb25zIHx8IFtdKV0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIF9zaG91bGREcm9wRXZlbnQoZXZlbnQsIG9wdGlvbnMpIHtcbiAgaWYgKCFldmVudC50eXBlKSB7XG4gICAgLy8gRmlsdGVyIGVycm9yc1xuICAgIGlmIChfaXNJZ25vcmVkRXJyb3IoZXZlbnQsIG9wdGlvbnMuaWdub3JlRXJyb3JzKSkge1xuICAgICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJlxuICAgICAgICBsb2dnZXIubG9nZ2VyLndhcm4oXG4gICAgICAgICAgYEV2ZW50IGRyb3BwZWQgZHVlIHRvIGJlaW5nIG1hdGNoZWQgYnkgXFxgaWdub3JlRXJyb3JzXFxgIG9wdGlvbi5cXG5FdmVudDogJHttaXNjLmdldEV2ZW50RGVzY3JpcHRpb24oZXZlbnQpfWAsXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKF9pc1VzZWxlc3NFcnJvcihldmVudCkpIHtcbiAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiZcbiAgICAgICAgbG9nZ2VyLmxvZ2dlci53YXJuKFxuICAgICAgICAgIGBFdmVudCBkcm9wcGVkIGR1ZSB0byBub3QgaGF2aW5nIGFuIGVycm9yIG1lc3NhZ2UsIGVycm9yIHR5cGUgb3Igc3RhY2t0cmFjZS5cXG5FdmVudDogJHttaXNjLmdldEV2ZW50RGVzY3JpcHRpb24oXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICApfWAsXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKF9pc0RlbmllZFVybChldmVudCwgb3B0aW9ucy5kZW55VXJscykpIHtcbiAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiZcbiAgICAgICAgbG9nZ2VyLmxvZ2dlci53YXJuKFxuICAgICAgICAgIGBFdmVudCBkcm9wcGVkIGR1ZSB0byBiZWluZyBtYXRjaGVkIGJ5IFxcYGRlbnlVcmxzXFxgIG9wdGlvbi5cXG5FdmVudDogJHttaXNjLmdldEV2ZW50RGVzY3JpcHRpb24oXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICApfS5cXG5Vcmw6ICR7X2dldEV2ZW50RmlsdGVyVXJsKGV2ZW50KX1gLFxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghX2lzQWxsb3dlZFVybChldmVudCwgb3B0aW9ucy5hbGxvd1VybHMpKSB7XG4gICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmXG4gICAgICAgIGxvZ2dlci5sb2dnZXIud2FybihcbiAgICAgICAgICBgRXZlbnQgZHJvcHBlZCBkdWUgdG8gbm90IGJlaW5nIG1hdGNoZWQgYnkgXFxgYWxsb3dVcmxzXFxgIG9wdGlvbi5cXG5FdmVudDogJHttaXNjLmdldEV2ZW50RGVzY3JpcHRpb24oXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICApfS5cXG5Vcmw6ICR7X2dldEV2ZW50RmlsdGVyVXJsKGV2ZW50KX1gLFxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICd0cmFuc2FjdGlvbicpIHtcbiAgICAvLyBGaWx0ZXIgdHJhbnNhY3Rpb25zXG5cbiAgICBpZiAoX2lzSWdub3JlZFRyYW5zYWN0aW9uKGV2ZW50LCBvcHRpb25zLmlnbm9yZVRyYW5zYWN0aW9ucykpIHtcbiAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiZcbiAgICAgICAgbG9nZ2VyLmxvZ2dlci53YXJuKFxuICAgICAgICAgIGBFdmVudCBkcm9wcGVkIGR1ZSB0byBiZWluZyBtYXRjaGVkIGJ5IFxcYGlnbm9yZVRyYW5zYWN0aW9uc1xcYCBvcHRpb24uXFxuRXZlbnQ6ICR7bWlzYy5nZXRFdmVudERlc2NyaXB0aW9uKGV2ZW50KX1gLFxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX2lzSWdub3JlZEVycm9yKGV2ZW50LCBpZ25vcmVFcnJvcnMpIHtcbiAgaWYgKCFpZ25vcmVFcnJvcnM/Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBldmVudFV0aWxzLmdldFBvc3NpYmxlRXZlbnRNZXNzYWdlcyhldmVudCkuc29tZShtZXNzYWdlID0+IHN0cmluZy5zdHJpbmdNYXRjaGVzU29tZVBhdHRlcm4obWVzc2FnZSwgaWdub3JlRXJyb3JzKSk7XG59XG5cbmZ1bmN0aW9uIF9pc0lnbm9yZWRUcmFuc2FjdGlvbihldmVudCwgaWdub3JlVHJhbnNhY3Rpb25zKSB7XG4gIGlmICghaWdub3JlVHJhbnNhY3Rpb25zPy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBuYW1lID0gZXZlbnQudHJhbnNhY3Rpb247XG4gIHJldHVybiBuYW1lID8gc3RyaW5nLnN0cmluZ01hdGNoZXNTb21lUGF0dGVybihuYW1lLCBpZ25vcmVUcmFuc2FjdGlvbnMpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9pc0RlbmllZFVybChldmVudCwgZGVueVVybHMpIHtcbiAgaWYgKCFkZW55VXJscz8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHVybCA9IF9nZXRFdmVudEZpbHRlclVybChldmVudCk7XG4gIHJldHVybiAhdXJsID8gZmFsc2UgOiBzdHJpbmcuc3RyaW5nTWF0Y2hlc1NvbWVQYXR0ZXJuKHVybCwgZGVueVVybHMpO1xufVxuXG5mdW5jdGlvbiBfaXNBbGxvd2VkVXJsKGV2ZW50LCBhbGxvd1VybHMpIHtcbiAgaWYgKCFhbGxvd1VybHM/Lmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHVybCA9IF9nZXRFdmVudEZpbHRlclVybChldmVudCk7XG4gIHJldHVybiAhdXJsID8gdHJ1ZSA6IHN0cmluZy5zdHJpbmdNYXRjaGVzU29tZVBhdHRlcm4odXJsLCBhbGxvd1VybHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0TGFzdFZhbGlkVXJsKGZyYW1lcyA9IFtdKSB7XG4gIGZvciAobGV0IGkgPSBmcmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tpXTtcblxuICAgIGlmIChmcmFtZSAmJiBmcmFtZS5maWxlbmFtZSAhPT0gJzxhbm9ueW1vdXM+JyAmJiBmcmFtZS5maWxlbmFtZSAhPT0gJ1tuYXRpdmUgY29kZV0nKSB7XG4gICAgICByZXR1cm4gZnJhbWUuZmlsZW5hbWUgfHwgbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gX2dldEV2ZW50RmlsdGVyVXJsKGV2ZW50KSB7XG4gIHRyeSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIGxpbmtlZCBleGNlcHRpb25zIG9yIGV4Y2VwdGlvbiBhZ2dyZWdhdGVzIHdlIG9ubHkgd2FudCB0byBtYXRjaCBhZ2FpbnN0IHRoZSB0b3AgZnJhbWUgb2YgdGhlIFwicm9vdFwiICh0aGUgbWFpbiBleGNlcHRpb24pXG4gICAgLy8gVGhlIHJvb3QgYWx3YXlzIGNvbWVzIGxhc3QgaW4gbGlua2VkIGV4Y2VwdGlvbnNcbiAgICBjb25zdCByb290RXhjZXB0aW9uID0gWy4uLihldmVudC5leGNlcHRpb24/LnZhbHVlcyA/PyBbXSldXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAuZmluZCh2YWx1ZSA9PiB2YWx1ZS5tZWNoYW5pc20/LnBhcmVudF9pZCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlLnN0YWNrdHJhY2U/LmZyYW1lcz8ubGVuZ3RoKTtcbiAgICBjb25zdCBmcmFtZXMgPSByb290RXhjZXB0aW9uPy5zdGFja3RyYWNlPy5mcmFtZXM7XG4gICAgcmV0dXJuIGZyYW1lcyA/IF9nZXRMYXN0VmFsaWRVcmwoZnJhbWVzKSA6IG51bGw7XG4gIH0gY2F0Y2ggKG9PKSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLmVycm9yKGBDYW5ub3QgZXh0cmFjdCB1cmwgZm9yIGV2ZW50ICR7bWlzYy5nZXRFdmVudERlc2NyaXB0aW9uKGV2ZW50KX1gKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaXNVc2VsZXNzRXJyb3IoZXZlbnQpIHtcbiAgLy8gV2Ugb25seSB3YW50IHRvIGNvbnNpZGVyIGV2ZW50cyBmb3IgZHJvcHBpbmcgdGhhdCBhY3R1YWxseSBoYXZlIHJlY29yZGVkIGV4Y2VwdGlvbiB2YWx1ZXMuXG4gIGlmICghZXZlbnQuZXhjZXB0aW9uPy52YWx1ZXM/Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgLy8gTm8gdG9wLWxldmVsIG1lc3NhZ2VcbiAgICAhZXZlbnQubWVzc2FnZSAmJlxuICAgIC8vIFRoZXJlIGFyZSBubyBleGNlcHRpb24gdmFsdWVzIHRoYXQgaGF2ZSBhIHN0YWNrdHJhY2UsIGEgbm9uLWdlbmVyaWMtRXJyb3IgdHlwZSBvciB2YWx1ZVxuICAgICFldmVudC5leGNlcHRpb24udmFsdWVzLnNvbWUodmFsdWUgPT4gdmFsdWUuc3RhY2t0cmFjZSB8fCAodmFsdWUudHlwZSAmJiB2YWx1ZS50eXBlICE9PSAnRXJyb3InKSB8fCB2YWx1ZS52YWx1ZSlcbiAgKTtcbn1cblxuZXhwb3J0cy5ldmVudEZpbHRlcnNJbnRlZ3JhdGlvbiA9IGV2ZW50RmlsdGVyc0ludGVncmF0aW9uO1xuZXhwb3J0cy5pbmJvdW5kRmlsdGVyc0ludGVncmF0aW9uID0gaW5ib3VuZEZpbHRlcnNJbnRlZ3JhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50RmlsdGVycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/eventFilters.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/extraerrordata.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\");\nconst is = __webpack_require__(/*! ../utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst normalize = __webpack_require__(/*! ../utils-hoist/normalize.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/normalize.js\");\nconst object = __webpack_require__(/*! ../utils-hoist/object.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/object.js\");\nconst string = __webpack_require__(/*! ../utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\n\nconst INTEGRATION_NAME = 'ExtraErrorData';\n\n/**\n * Extract additional data for from original exceptions.\n */\nconst _extraErrorDataIntegration = ((options = {}) => {\n  const { depth = 3, captureErrorCause = true } = options;\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(event, hint, client) {\n      const { maxValueLength = 250 } = client.getOptions();\n      return _enhanceEventWithErrorData(event, hint, depth, captureErrorCause, maxValueLength);\n    },\n  };\n}) ;\n\nconst extraErrorDataIntegration = integration.defineIntegration(_extraErrorDataIntegration);\n\nfunction _enhanceEventWithErrorData(\n  event,\n  hint = {},\n  depth,\n  captureErrorCause,\n  maxValueLength,\n) {\n  if (!hint.originalException || !is.isError(hint.originalException)) {\n    return event;\n  }\n  const exceptionName = (hint.originalException ).name || hint.originalException.constructor.name;\n\n  const errorData = _extractErrorData(hint.originalException , captureErrorCause, maxValueLength);\n\n  if (errorData) {\n    const contexts = {\n      ...event.contexts,\n    };\n\n    const normalizedErrorData = normalize.normalize(errorData, depth);\n\n    if (is.isPlainObject(normalizedErrorData)) {\n      // We mark the error data as \"already normalized\" here, because we don't want other normalization procedures to\n      // potentially truncate the data we just already normalized, with a certain depth setting.\n      object.addNonEnumerableProperty(normalizedErrorData, '__sentry_skip_normalization__', true);\n      contexts[exceptionName] = normalizedErrorData;\n    }\n\n    return {\n      ...event,\n      contexts,\n    };\n  }\n\n  return event;\n}\n\n/**\n * Extract extra information from the Error object\n */\nfunction _extractErrorData(\n  error,\n  captureErrorCause,\n  maxValueLength,\n) {\n  // We are trying to enhance already existing event, so no harm done if it won't succeed\n  try {\n    const nativeKeys = [\n      'name',\n      'message',\n      'stack',\n      'line',\n      'column',\n      'fileName',\n      'lineNumber',\n      'columnNumber',\n      'toJSON',\n    ];\n\n    const extraErrorInfo = {};\n\n    // We want only enumerable properties, thus `getOwnPropertyNames` is redundant here, as we filter keys anyway.\n    for (const key of Object.keys(error)) {\n      if (nativeKeys.indexOf(key) !== -1) {\n        continue;\n      }\n      const value = error[key];\n      extraErrorInfo[key] = is.isError(value) || typeof value === 'string' ? string.truncate(`${value}`, maxValueLength) : value;\n    }\n\n    // Error.cause is a standard property that is non enumerable, we therefore need to access it separately.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause\n    if (captureErrorCause && error.cause !== undefined) {\n      extraErrorInfo.cause = is.isError(error.cause) ? error.cause.toString() : error.cause;\n    }\n\n    // Check if someone attached `toJSON` method to grab even more properties (eg. axios is doing that)\n    if (typeof error.toJSON === 'function') {\n      const serializedError = error.toJSON() ;\n\n      for (const key of Object.keys(serializedError)) {\n        const value = serializedError[key];\n        extraErrorInfo[key] = is.isError(value) ? value.toString() : value;\n      }\n    }\n\n    return extraErrorInfo;\n  } catch (oO) {\n    debugBuild.DEBUG_BUILD && logger.logger.error('Unable to extract extra data from the Error object:', oO);\n  }\n\n  return null;\n}\n\nexports.extraErrorDataIntegration = extraErrorDataIntegration;\n//# sourceMappingURL=extraerrordata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb25zL2V4dHJhZXJyb3JkYXRhLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLG1CQUFtQixtQkFBTyxDQUFDLGlIQUFtQjtBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDL0MsV0FBVyxtQkFBTyxDQUFDLHVIQUFzQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMsK0hBQTBCO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLHFJQUE2QjtBQUN2RCxlQUFlLG1CQUFPLENBQUMsK0hBQTBCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQywrSEFBMEI7O0FBRWpEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLHNDQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxNQUFNO0FBQ3RHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGludGVncmF0aW9uc1xcZXh0cmFlcnJvcmRhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3QgaW50ZWdyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlZ3JhdGlvbi5qcycpO1xuY29uc3QgaXMgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9pcy5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCBub3JtYWxpemUgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9ub3JtYWxpemUuanMnKTtcbmNvbnN0IG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L29iamVjdC5qcycpO1xuY29uc3Qgc3RyaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvc3RyaW5nLmpzJyk7XG5cbmNvbnN0IElOVEVHUkFUSU9OX05BTUUgPSAnRXh0cmFFcnJvckRhdGEnO1xuXG4vKipcbiAqIEV4dHJhY3QgYWRkaXRpb25hbCBkYXRhIGZvciBmcm9tIG9yaWdpbmFsIGV4Y2VwdGlvbnMuXG4gKi9cbmNvbnN0IF9leHRyYUVycm9yRGF0YUludGVncmF0aW9uID0gKChvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBkZXB0aCA9IDMsIGNhcHR1cmVFcnJvckNhdXNlID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHByb2Nlc3NFdmVudChldmVudCwgaGludCwgY2xpZW50KSB7XG4gICAgICBjb25zdCB7IG1heFZhbHVlTGVuZ3RoID0gMjUwIH0gPSBjbGllbnQuZ2V0T3B0aW9ucygpO1xuICAgICAgcmV0dXJuIF9lbmhhbmNlRXZlbnRXaXRoRXJyb3JEYXRhKGV2ZW50LCBoaW50LCBkZXB0aCwgY2FwdHVyZUVycm9yQ2F1c2UsIG1heFZhbHVlTGVuZ3RoKTtcbiAgICB9LFxuICB9O1xufSkgO1xuXG5jb25zdCBleHRyYUVycm9yRGF0YUludGVncmF0aW9uID0gaW50ZWdyYXRpb24uZGVmaW5lSW50ZWdyYXRpb24oX2V4dHJhRXJyb3JEYXRhSW50ZWdyYXRpb24pO1xuXG5mdW5jdGlvbiBfZW5oYW5jZUV2ZW50V2l0aEVycm9yRGF0YShcbiAgZXZlbnQsXG4gIGhpbnQgPSB7fSxcbiAgZGVwdGgsXG4gIGNhcHR1cmVFcnJvckNhdXNlLFxuICBtYXhWYWx1ZUxlbmd0aCxcbikge1xuICBpZiAoIWhpbnQub3JpZ2luYWxFeGNlcHRpb24gfHwgIWlzLmlzRXJyb3IoaGludC5vcmlnaW5hbEV4Y2VwdGlvbikpIHtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgY29uc3QgZXhjZXB0aW9uTmFtZSA9IChoaW50Lm9yaWdpbmFsRXhjZXB0aW9uICkubmFtZSB8fCBoaW50Lm9yaWdpbmFsRXhjZXB0aW9uLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgY29uc3QgZXJyb3JEYXRhID0gX2V4dHJhY3RFcnJvckRhdGEoaGludC5vcmlnaW5hbEV4Y2VwdGlvbiAsIGNhcHR1cmVFcnJvckNhdXNlLCBtYXhWYWx1ZUxlbmd0aCk7XG5cbiAgaWYgKGVycm9yRGF0YSkge1xuICAgIGNvbnN0IGNvbnRleHRzID0ge1xuICAgICAgLi4uZXZlbnQuY29udGV4dHMsXG4gICAgfTtcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWRFcnJvckRhdGEgPSBub3JtYWxpemUubm9ybWFsaXplKGVycm9yRGF0YSwgZGVwdGgpO1xuXG4gICAgaWYgKGlzLmlzUGxhaW5PYmplY3Qobm9ybWFsaXplZEVycm9yRGF0YSkpIHtcbiAgICAgIC8vIFdlIG1hcmsgdGhlIGVycm9yIGRhdGEgYXMgXCJhbHJlYWR5IG5vcm1hbGl6ZWRcIiBoZXJlLCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgb3RoZXIgbm9ybWFsaXphdGlvbiBwcm9jZWR1cmVzIHRvXG4gICAgICAvLyBwb3RlbnRpYWxseSB0cnVuY2F0ZSB0aGUgZGF0YSB3ZSBqdXN0IGFscmVhZHkgbm9ybWFsaXplZCwgd2l0aCBhIGNlcnRhaW4gZGVwdGggc2V0dGluZy5cbiAgICAgIG9iamVjdC5hZGROb25FbnVtZXJhYmxlUHJvcGVydHkobm9ybWFsaXplZEVycm9yRGF0YSwgJ19fc2VudHJ5X3NraXBfbm9ybWFsaXphdGlvbl9fJywgdHJ1ZSk7XG4gICAgICBjb250ZXh0c1tleGNlcHRpb25OYW1lXSA9IG5vcm1hbGl6ZWRFcnJvckRhdGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmV2ZW50LFxuICAgICAgY29udGV4dHMsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGV4dHJhIGluZm9ybWF0aW9uIGZyb20gdGhlIEVycm9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBfZXh0cmFjdEVycm9yRGF0YShcbiAgZXJyb3IsXG4gIGNhcHR1cmVFcnJvckNhdXNlLFxuICBtYXhWYWx1ZUxlbmd0aCxcbikge1xuICAvLyBXZSBhcmUgdHJ5aW5nIHRvIGVuaGFuY2UgYWxyZWFkeSBleGlzdGluZyBldmVudCwgc28gbm8gaGFybSBkb25lIGlmIGl0IHdvbid0IHN1Y2NlZWRcbiAgdHJ5IHtcbiAgICBjb25zdCBuYXRpdmVLZXlzID0gW1xuICAgICAgJ25hbWUnLFxuICAgICAgJ21lc3NhZ2UnLFxuICAgICAgJ3N0YWNrJyxcbiAgICAgICdsaW5lJyxcbiAgICAgICdjb2x1bW4nLFxuICAgICAgJ2ZpbGVOYW1lJyxcbiAgICAgICdsaW5lTnVtYmVyJyxcbiAgICAgICdjb2x1bW5OdW1iZXInLFxuICAgICAgJ3RvSlNPTicsXG4gICAgXTtcblxuICAgIGNvbnN0IGV4dHJhRXJyb3JJbmZvID0ge307XG5cbiAgICAvLyBXZSB3YW50IG9ubHkgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLCB0aHVzIGBnZXRPd25Qcm9wZXJ0eU5hbWVzYCBpcyByZWR1bmRhbnQgaGVyZSwgYXMgd2UgZmlsdGVyIGtleXMgYW55d2F5LlxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGVycm9yKSkge1xuICAgICAgaWYgKG5hdGl2ZUtleXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gZXJyb3Jba2V5XTtcbiAgICAgIGV4dHJhRXJyb3JJbmZvW2tleV0gPSBpcy5pc0Vycm9yKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3RyaW5nLnRydW5jYXRlKGAke3ZhbHVlfWAsIG1heFZhbHVlTGVuZ3RoKSA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8vIEVycm9yLmNhdXNlIGlzIGEgc3RhbmRhcmQgcHJvcGVydHkgdGhhdCBpcyBub24gZW51bWVyYWJsZSwgd2UgdGhlcmVmb3JlIG5lZWQgdG8gYWNjZXNzIGl0IHNlcGFyYXRlbHkuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IvY2F1c2VcbiAgICBpZiAoY2FwdHVyZUVycm9yQ2F1c2UgJiYgZXJyb3IuY2F1c2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZXh0cmFFcnJvckluZm8uY2F1c2UgPSBpcy5pc0Vycm9yKGVycm9yLmNhdXNlKSA/IGVycm9yLmNhdXNlLnRvU3RyaW5nKCkgOiBlcnJvci5jYXVzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBzb21lb25lIGF0dGFjaGVkIGB0b0pTT05gIG1ldGhvZCB0byBncmFiIGV2ZW4gbW9yZSBwcm9wZXJ0aWVzIChlZy4gYXhpb3MgaXMgZG9pbmcgdGhhdClcbiAgICBpZiAodHlwZW9mIGVycm9yLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZEVycm9yID0gZXJyb3IudG9KU09OKCkgO1xuXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzZXJpYWxpemVkRXJyb3IpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2VyaWFsaXplZEVycm9yW2tleV07XG4gICAgICAgIGV4dHJhRXJyb3JJbmZvW2tleV0gPSBpcy5pc0Vycm9yKHZhbHVlKSA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXh0cmFFcnJvckluZm87XG4gIH0gY2F0Y2ggKG9PKSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLmVycm9yKCdVbmFibGUgdG8gZXh0cmFjdCBleHRyYSBkYXRhIGZyb20gdGhlIEVycm9yIG9iamVjdDonLCBvTyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5leHRyYUVycm9yRGF0YUludGVncmF0aW9uID0gZXh0cmFFcnJvckRhdGFJbnRlZ3JhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhZXJyb3JkYXRhLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/extraerrordata.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/functiontostring.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js");\nconst integration = __webpack_require__(/*! ../integration.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js");\nconst object = __webpack_require__(/*! ../utils-hoist/object.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/object.js");\n\nlet originalFunctionToString;\n\nconst INTEGRATION_NAME = \'FunctionToString\';\n\nconst SETUP_CLIENTS = new WeakMap();\n\nconst _functionToStringIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      originalFunctionToString = Function.prototype.toString;\n\n      // intrinsics (like Function.prototype) might be immutable in some environments\n      // e.g. Node with --frozen-intrinsics, XS (an embedded JavaScript engine) or SES (a JavaScript proposal)\n      try {\n        Function.prototype.toString = function ( ...args) {\n          const originalFunction = object.getOriginalFunction(this);\n          const context =\n            SETUP_CLIENTS.has(currentScopes.getClient() ) && originalFunction !== undefined ? originalFunction : this;\n          return originalFunctionToString.apply(context, args);\n        };\n      } catch {\n        // ignore errors here, just don\'t patch this\n      }\n    },\n    setup(client) {\n      SETUP_CLIENTS.set(client, true);\n    },\n  };\n}) ;\n\n/**\n * Patch toString calls to return proper name for wrapped functions.\n *\n * ```js\n * Sentry.init({\n *   integrations: [\n *     functionToStringIntegration(),\n *   ],\n * });\n * ```\n */\nconst functionToStringIntegration = integration.defineIntegration(_functionToStringIntegration);\n\nexports.functionToStringIntegration = functionToStringIntegration;\n//# sourceMappingURL=functiontostring.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb25zL2Z1bmN0aW9udG9zdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsc0JBQXNCLG1CQUFPLENBQUMscUhBQXFCO0FBQ25ELG9CQUFvQixtQkFBTyxDQUFDLGlIQUFtQjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsK0hBQTBCOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcaW50ZWdyYXRpb25zXFxmdW5jdGlvbnRvc3RyaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi4vY3VycmVudFNjb3Blcy5qcycpO1xuY29uc3QgaW50ZWdyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlZ3JhdGlvbi5qcycpO1xuY29uc3Qgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvb2JqZWN0LmpzJyk7XG5cbmxldCBvcmlnaW5hbEZ1bmN0aW9uVG9TdHJpbmc7XG5cbmNvbnN0IElOVEVHUkFUSU9OX05BTUUgPSAnRnVuY3Rpb25Ub1N0cmluZyc7XG5cbmNvbnN0IFNFVFVQX0NMSUVOVFMgPSBuZXcgV2Vha01hcCgpO1xuXG5jb25zdCBfZnVuY3Rpb25Ub1N0cmluZ0ludGVncmF0aW9uID0gKCgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHNldHVwT25jZSgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgIG9yaWdpbmFsRnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuICAgICAgLy8gaW50cmluc2ljcyAobGlrZSBGdW5jdGlvbi5wcm90b3R5cGUpIG1pZ2h0IGJlIGltbXV0YWJsZSBpbiBzb21lIGVudmlyb25tZW50c1xuICAgICAgLy8gZS5nLiBOb2RlIHdpdGggLS1mcm96ZW4taW50cmluc2ljcywgWFMgKGFuIGVtYmVkZGVkIEphdmFTY3JpcHQgZW5naW5lKSBvciBTRVMgKGEgSmF2YVNjcmlwdCBwcm9wb3NhbClcbiAgICAgIHRyeSB7XG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICggLi4uYXJncykge1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRnVuY3Rpb24gPSBvYmplY3QuZ2V0T3JpZ2luYWxGdW5jdGlvbih0aGlzKTtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID1cbiAgICAgICAgICAgIFNFVFVQX0NMSUVOVFMuaGFzKGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCkgKSAmJiBvcmlnaW5hbEZ1bmN0aW9uICE9PSB1bmRlZmluZWQgPyBvcmlnaW5hbEZ1bmN0aW9uIDogdGhpcztcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvblRvU3RyaW5nLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIGlnbm9yZSBlcnJvcnMgaGVyZSwganVzdCBkb24ndCBwYXRjaCB0aGlzXG4gICAgICB9XG4gICAgfSxcbiAgICBzZXR1cChjbGllbnQpIHtcbiAgICAgIFNFVFVQX0NMSUVOVFMuc2V0KGNsaWVudCwgdHJ1ZSk7XG4gICAgfSxcbiAgfTtcbn0pIDtcblxuLyoqXG4gKiBQYXRjaCB0b1N0cmluZyBjYWxscyB0byByZXR1cm4gcHJvcGVyIG5hbWUgZm9yIHdyYXBwZWQgZnVuY3Rpb25zLlxuICpcbiAqIGBgYGpzXG4gKiBTZW50cnkuaW5pdCh7XG4gKiAgIGludGVncmF0aW9uczogW1xuICogICAgIGZ1bmN0aW9uVG9TdHJpbmdJbnRlZ3JhdGlvbigpLFxuICogICBdLFxuICogfSk7XG4gKiBgYGBcbiAqL1xuY29uc3QgZnVuY3Rpb25Ub1N0cmluZ0ludGVncmF0aW9uID0gaW50ZWdyYXRpb24uZGVmaW5lSW50ZWdyYXRpb24oX2Z1bmN0aW9uVG9TdHJpbmdJbnRlZ3JhdGlvbik7XG5cbmV4cG9ydHMuZnVuY3Rpb25Ub1N0cmluZ0ludGVncmF0aW9uID0gZnVuY3Rpb25Ub1N0cmluZ0ludGVncmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb250b3N0cmluZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/functiontostring.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/linkederrors.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\");\nconst aggregateErrors = __webpack_require__(/*! ../utils-hoist/aggregate-errors.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/aggregate-errors.js\");\nconst eventbuilder = __webpack_require__(/*! ../utils-hoist/eventbuilder.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/eventbuilder.js\");\n\nconst DEFAULT_KEY = 'cause';\nconst DEFAULT_LIMIT = 5;\n\nconst INTEGRATION_NAME = 'LinkedErrors';\n\nconst _linkedErrorsIntegration = ((options = {}) => {\n  const limit = options.limit || DEFAULT_LIMIT;\n  const key = options.key || DEFAULT_KEY;\n\n  return {\n    name: INTEGRATION_NAME,\n    preprocessEvent(event, hint, client) {\n      const options = client.getOptions();\n\n      aggregateErrors.applyAggregateErrorsToEvent(eventbuilder.exceptionFromError, options.stackParser, key, limit, event, hint);\n    },\n  };\n}) ;\n\nconst linkedErrorsIntegration = integration.defineIntegration(_linkedErrorsIntegration);\n\nexports.linkedErrorsIntegration = linkedErrorsIntegration;\n//# sourceMappingURL=linkederrors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb25zL2xpbmtlZGVycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxvQkFBb0IsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDL0Msd0JBQXdCLG1CQUFPLENBQUMsbUpBQW9DO0FBQ3BFLHFCQUFxQixtQkFBTyxDQUFDLDJJQUFnQzs7QUFFN0Q7QUFDQTs7QUFFQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsK0JBQStCO0FBQy9CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcaW50ZWdyYXRpb25zXFxsaW5rZWRlcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGludGVncmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZWdyYXRpb24uanMnKTtcbmNvbnN0IGFnZ3JlZ2F0ZUVycm9ycyA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2FnZ3JlZ2F0ZS1lcnJvcnMuanMnKTtcbmNvbnN0IGV2ZW50YnVpbGRlciA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2V2ZW50YnVpbGRlci5qcycpO1xuXG5jb25zdCBERUZBVUxUX0tFWSA9ICdjYXVzZSc7XG5jb25zdCBERUZBVUxUX0xJTUlUID0gNTtcblxuY29uc3QgSU5URUdSQVRJT05fTkFNRSA9ICdMaW5rZWRFcnJvcnMnO1xuXG5jb25zdCBfbGlua2VkRXJyb3JzSW50ZWdyYXRpb24gPSAoKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBsaW1pdCA9IG9wdGlvbnMubGltaXQgfHwgREVGQVVMVF9MSU1JVDtcbiAgY29uc3Qga2V5ID0gb3B0aW9ucy5rZXkgfHwgREVGQVVMVF9LRVk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHByZXByb2Nlc3NFdmVudChldmVudCwgaGludCwgY2xpZW50KSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gY2xpZW50LmdldE9wdGlvbnMoKTtcblxuICAgICAgYWdncmVnYXRlRXJyb3JzLmFwcGx5QWdncmVnYXRlRXJyb3JzVG9FdmVudChldmVudGJ1aWxkZXIuZXhjZXB0aW9uRnJvbUVycm9yLCBvcHRpb25zLnN0YWNrUGFyc2VyLCBrZXksIGxpbWl0LCBldmVudCwgaGludCk7XG4gICAgfSxcbiAgfTtcbn0pIDtcblxuY29uc3QgbGlua2VkRXJyb3JzSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbihfbGlua2VkRXJyb3JzSW50ZWdyYXRpb24pO1xuXG5leHBvcnRzLmxpbmtlZEVycm9yc0ludGVncmF0aW9uID0gbGlua2VkRXJyb3JzSW50ZWdyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rZWRlcnJvcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/linkederrors.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/metadata.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\");\nconst metadata = __webpack_require__(/*! ../metadata.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/metadata.js\");\nconst envelope = __webpack_require__(/*! ../utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\n\n/**\n * Adds module metadata to stack frames.\n *\n * Metadata can be injected by the Sentry bundler plugins using the `moduleMetadata` config option.\n *\n * When this integration is added, the metadata passed to the bundler plugin is added to the stack frames of all events\n * under the `module_metadata` property. This can be used to help in tagging or routing of events from different teams\n * our sources\n */\nconst moduleMetadataIntegration = integration.defineIntegration(() => {\n  return {\n    name: 'ModuleMetadata',\n    setup(client) {\n      // We need to strip metadata from stack frames before sending them to Sentry since these are client side only.\n      client.on('beforeEnvelope', envelope$1 => {\n        envelope.forEachEnvelopeItem(envelope$1, (item, type) => {\n          if (type === 'event') {\n            const event = Array.isArray(item) ? (item )[1] : undefined;\n\n            if (event) {\n              metadata.stripMetadataFromStackFrames(event);\n              item[1] = event;\n            }\n          }\n        });\n      });\n\n      client.on('applyFrameMetadata', event => {\n        // Only apply stack frame metadata to error events\n        if (event.type) {\n          return;\n        }\n\n        const stackParser = client.getOptions().stackParser;\n        metadata.addMetadataToStackFrames(stackParser, event);\n      });\n    },\n  };\n});\n\nexports.moduleMetadataIntegration = moduleMetadataIntegration;\n//# sourceMappingURL=metadata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb25zL21ldGFkYXRhLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLG9CQUFvQixtQkFBTyxDQUFDLGlIQUFtQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQywyR0FBZ0I7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsbUlBQTRCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVELGlDQUFpQztBQUNqQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGludGVncmF0aW9uc1xcbWV0YWRhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGludGVncmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZWdyYXRpb24uanMnKTtcbmNvbnN0IG1ldGFkYXRhID0gcmVxdWlyZSgnLi4vbWV0YWRhdGEuanMnKTtcbmNvbnN0IGVudmVsb3BlID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvZW52ZWxvcGUuanMnKTtcblxuLyoqXG4gKiBBZGRzIG1vZHVsZSBtZXRhZGF0YSB0byBzdGFjayBmcmFtZXMuXG4gKlxuICogTWV0YWRhdGEgY2FuIGJlIGluamVjdGVkIGJ5IHRoZSBTZW50cnkgYnVuZGxlciBwbHVnaW5zIHVzaW5nIHRoZSBgbW9kdWxlTWV0YWRhdGFgIGNvbmZpZyBvcHRpb24uXG4gKlxuICogV2hlbiB0aGlzIGludGVncmF0aW9uIGlzIGFkZGVkLCB0aGUgbWV0YWRhdGEgcGFzc2VkIHRvIHRoZSBidW5kbGVyIHBsdWdpbiBpcyBhZGRlZCB0byB0aGUgc3RhY2sgZnJhbWVzIG9mIGFsbCBldmVudHNcbiAqIHVuZGVyIHRoZSBgbW9kdWxlX21ldGFkYXRhYCBwcm9wZXJ0eS4gVGhpcyBjYW4gYmUgdXNlZCB0byBoZWxwIGluIHRhZ2dpbmcgb3Igcm91dGluZyBvZiBldmVudHMgZnJvbSBkaWZmZXJlbnQgdGVhbXNcbiAqIG91ciBzb3VyY2VzXG4gKi9cbmNvbnN0IG1vZHVsZU1ldGFkYXRhSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbigoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ01vZHVsZU1ldGFkYXRhJyxcbiAgICBzZXR1cChjbGllbnQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gc3RyaXAgbWV0YWRhdGEgZnJvbSBzdGFjayBmcmFtZXMgYmVmb3JlIHNlbmRpbmcgdGhlbSB0byBTZW50cnkgc2luY2UgdGhlc2UgYXJlIGNsaWVudCBzaWRlIG9ubHkuXG4gICAgICBjbGllbnQub24oJ2JlZm9yZUVudmVsb3BlJywgZW52ZWxvcGUkMSA9PiB7XG4gICAgICAgIGVudmVsb3BlLmZvckVhY2hFbnZlbG9wZUl0ZW0oZW52ZWxvcGUkMSwgKGl0ZW0sIHR5cGUpID0+IHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2V2ZW50Jykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gKGl0ZW0gKVsxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICAgIG1ldGFkYXRhLnN0cmlwTWV0YWRhdGFGcm9tU3RhY2tGcmFtZXMoZXZlbnQpO1xuICAgICAgICAgICAgICBpdGVtWzFdID0gZXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBjbGllbnQub24oJ2FwcGx5RnJhbWVNZXRhZGF0YScsIGV2ZW50ID0+IHtcbiAgICAgICAgLy8gT25seSBhcHBseSBzdGFjayBmcmFtZSBtZXRhZGF0YSB0byBlcnJvciBldmVudHNcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFja1BhcnNlciA9IGNsaWVudC5nZXRPcHRpb25zKCkuc3RhY2tQYXJzZXI7XG4gICAgICAgIG1ldGFkYXRhLmFkZE1ldGFkYXRhVG9TdGFja0ZyYW1lcyhzdGFja1BhcnNlciwgZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfTtcbn0pO1xuXG5leHBvcnRzLm1vZHVsZU1ldGFkYXRhSW50ZWdyYXRpb24gPSBtb2R1bGVNZXRhZGF0YUludGVncmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/metadata.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/requestdata.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst integration = __webpack_require__(/*! ../integration.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js");\nconst cookie = __webpack_require__(/*! ../utils/cookie.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/cookie.js");\nconst getIpAddress = __webpack_require__(/*! ../vendor/getIpAddress.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/vendor/getIpAddress.js");\n\n// TODO(v10): Change defaults based on `sendDefaultPii`\nconst DEFAULT_INCLUDE = {\n  cookies: true,\n  data: true,\n  headers: true,\n  query_string: true,\n  url: true,\n};\n\nconst INTEGRATION_NAME = \'RequestData\';\n\nconst _requestDataIntegration = ((options = {}) => {\n  const include = {\n    ...DEFAULT_INCLUDE,\n    ...options.include,\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(event, _hint, client) {\n      const { sdkProcessingMetadata = {} } = event;\n      const { normalizedRequest, ipAddress } = sdkProcessingMetadata;\n\n      const includeWithDefaultPiiApplied = {\n        ...include,\n        ip: include.ip ?? client.getOptions().sendDefaultPii,\n      };\n\n      if (normalizedRequest) {\n        addNormalizedRequestDataToEvent(event, normalizedRequest, { ipAddress }, includeWithDefaultPiiApplied);\n      }\n\n      return event;\n    },\n  };\n}) ;\n\n/**\n * Add data about a request to an event. Primarily for use in Node-based SDKs, but included in `@sentry/core`\n * so it can be used in cross-platform SDKs like `@sentry/nextjs`.\n */\nconst requestDataIntegration = integration.defineIntegration(_requestDataIntegration);\n\n/**\n * Add already normalized request data to an event.\n * This mutates the passed in event.\n */\nfunction addNormalizedRequestDataToEvent(\n  event,\n  req,\n  // Data that should not go into `event.request` but is somehow related to requests\n  additionalData,\n  include,\n) {\n  event.request = {\n    ...event.request,\n    ...extractNormalizedRequestData(req, include),\n  };\n\n  if (include.ip) {\n    const ip = (req.headers && getIpAddress.getClientIPAddress(req.headers)) || additionalData.ipAddress;\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip,\n      };\n    }\n  }\n}\n\nfunction extractNormalizedRequestData(\n  normalizedRequest,\n  include,\n) {\n  const requestData = {};\n  const headers = { ...normalizedRequest.headers };\n\n  if (include.headers) {\n    requestData.headers = headers;\n\n    // Remove the Cookie header in case cookie data should not be included in the event\n    if (!include.cookies) {\n      delete (headers ).cookie;\n    }\n\n    // Remove IP headers in case IP data should not be included in the event\n    if (!include.ip) {\n      getIpAddress.ipHeaderNames.forEach(ipHeaderName => {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete (headers )[ipHeaderName];\n      });\n    }\n  }\n\n  requestData.method = normalizedRequest.method;\n\n  if (include.url) {\n    requestData.url = normalizedRequest.url;\n  }\n\n  if (include.cookies) {\n    const cookies = normalizedRequest.cookies || (headers?.cookie ? cookie.parseCookie(headers.cookie) : undefined);\n    requestData.cookies = cookies || {};\n  }\n\n  if (include.query_string) {\n    requestData.query_string = normalizedRequest.query_string;\n  }\n\n  if (include.data) {\n    requestData.data = normalizedRequest.data;\n  }\n\n  return requestData;\n}\n\nexports.requestDataIntegration = requestDataIntegration;\n//# sourceMappingURL=requestdata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb25zL3JlcXVlc3RkYXRhLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLG9CQUFvQixtQkFBTyxDQUFDLGlIQUFtQjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsbUhBQW9CO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLGlJQUEyQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0MsY0FBYywrQkFBK0I7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FLFdBQVc7QUFDL0U7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcaW50ZWdyYXRpb25zXFxyZXF1ZXN0ZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgaW50ZWdyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlZ3JhdGlvbi5qcycpO1xuY29uc3QgY29va2llID0gcmVxdWlyZSgnLi4vdXRpbHMvY29va2llLmpzJyk7XG5jb25zdCBnZXRJcEFkZHJlc3MgPSByZXF1aXJlKCcuLi92ZW5kb3IvZ2V0SXBBZGRyZXNzLmpzJyk7XG5cbi8vIFRPRE8odjEwKTogQ2hhbmdlIGRlZmF1bHRzIGJhc2VkIG9uIGBzZW5kRGVmYXVsdFBpaWBcbmNvbnN0IERFRkFVTFRfSU5DTFVERSA9IHtcbiAgY29va2llczogdHJ1ZSxcbiAgZGF0YTogdHJ1ZSxcbiAgaGVhZGVyczogdHJ1ZSxcbiAgcXVlcnlfc3RyaW5nOiB0cnVlLFxuICB1cmw6IHRydWUsXG59O1xuXG5jb25zdCBJTlRFR1JBVElPTl9OQU1FID0gJ1JlcXVlc3REYXRhJztcblxuY29uc3QgX3JlcXVlc3REYXRhSW50ZWdyYXRpb24gPSAoKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBpbmNsdWRlID0ge1xuICAgIC4uLkRFRkFVTFRfSU5DTFVERSxcbiAgICAuLi5vcHRpb25zLmluY2x1ZGUsXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHByb2Nlc3NFdmVudChldmVudCwgX2hpbnQsIGNsaWVudCkge1xuICAgICAgY29uc3QgeyBzZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7fSB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCB7IG5vcm1hbGl6ZWRSZXF1ZXN0LCBpcEFkZHJlc3MgfSA9IHNka1Byb2Nlc3NpbmdNZXRhZGF0YTtcblxuICAgICAgY29uc3QgaW5jbHVkZVdpdGhEZWZhdWx0UGlpQXBwbGllZCA9IHtcbiAgICAgICAgLi4uaW5jbHVkZSxcbiAgICAgICAgaXA6IGluY2x1ZGUuaXAgPz8gY2xpZW50LmdldE9wdGlvbnMoKS5zZW5kRGVmYXVsdFBpaSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChub3JtYWxpemVkUmVxdWVzdCkge1xuICAgICAgICBhZGROb3JtYWxpemVkUmVxdWVzdERhdGFUb0V2ZW50KGV2ZW50LCBub3JtYWxpemVkUmVxdWVzdCwgeyBpcEFkZHJlc3MgfSwgaW5jbHVkZVdpdGhEZWZhdWx0UGlpQXBwbGllZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9LFxuICB9O1xufSkgO1xuXG4vKipcbiAqIEFkZCBkYXRhIGFib3V0IGEgcmVxdWVzdCB0byBhbiBldmVudC4gUHJpbWFyaWx5IGZvciB1c2UgaW4gTm9kZS1iYXNlZCBTREtzLCBidXQgaW5jbHVkZWQgaW4gYEBzZW50cnkvY29yZWBcbiAqIHNvIGl0IGNhbiBiZSB1c2VkIGluIGNyb3NzLXBsYXRmb3JtIFNES3MgbGlrZSBgQHNlbnRyeS9uZXh0anNgLlxuICovXG5jb25zdCByZXF1ZXN0RGF0YUludGVncmF0aW9uID0gaW50ZWdyYXRpb24uZGVmaW5lSW50ZWdyYXRpb24oX3JlcXVlc3REYXRhSW50ZWdyYXRpb24pO1xuXG4vKipcbiAqIEFkZCBhbHJlYWR5IG5vcm1hbGl6ZWQgcmVxdWVzdCBkYXRhIHRvIGFuIGV2ZW50LlxuICogVGhpcyBtdXRhdGVzIHRoZSBwYXNzZWQgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGFkZE5vcm1hbGl6ZWRSZXF1ZXN0RGF0YVRvRXZlbnQoXG4gIGV2ZW50LFxuICByZXEsXG4gIC8vIERhdGEgdGhhdCBzaG91bGQgbm90IGdvIGludG8gYGV2ZW50LnJlcXVlc3RgIGJ1dCBpcyBzb21laG93IHJlbGF0ZWQgdG8gcmVxdWVzdHNcbiAgYWRkaXRpb25hbERhdGEsXG4gIGluY2x1ZGUsXG4pIHtcbiAgZXZlbnQucmVxdWVzdCA9IHtcbiAgICAuLi5ldmVudC5yZXF1ZXN0LFxuICAgIC4uLmV4dHJhY3ROb3JtYWxpemVkUmVxdWVzdERhdGEocmVxLCBpbmNsdWRlKSxcbiAgfTtcblxuICBpZiAoaW5jbHVkZS5pcCkge1xuICAgIGNvbnN0IGlwID0gKHJlcS5oZWFkZXJzICYmIGdldElwQWRkcmVzcy5nZXRDbGllbnRJUEFkZHJlc3MocmVxLmhlYWRlcnMpKSB8fCBhZGRpdGlvbmFsRGF0YS5pcEFkZHJlc3M7XG4gICAgaWYgKGlwKSB7XG4gICAgICBldmVudC51c2VyID0ge1xuICAgICAgICAuLi5ldmVudC51c2VyLFxuICAgICAgICBpcF9hZGRyZXNzOiBpcCxcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3ROb3JtYWxpemVkUmVxdWVzdERhdGEoXG4gIG5vcm1hbGl6ZWRSZXF1ZXN0LFxuICBpbmNsdWRlLFxuKSB7XG4gIGNvbnN0IHJlcXVlc3REYXRhID0ge307XG4gIGNvbnN0IGhlYWRlcnMgPSB7IC4uLm5vcm1hbGl6ZWRSZXF1ZXN0LmhlYWRlcnMgfTtcblxuICBpZiAoaW5jbHVkZS5oZWFkZXJzKSB7XG4gICAgcmVxdWVzdERhdGEuaGVhZGVycyA9IGhlYWRlcnM7XG5cbiAgICAvLyBSZW1vdmUgdGhlIENvb2tpZSBoZWFkZXIgaW4gY2FzZSBjb29raWUgZGF0YSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHRoZSBldmVudFxuICAgIGlmICghaW5jbHVkZS5jb29raWVzKSB7XG4gICAgICBkZWxldGUgKGhlYWRlcnMgKS5jb29raWU7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIElQIGhlYWRlcnMgaW4gY2FzZSBJUCBkYXRhIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIGV2ZW50XG4gICAgaWYgKCFpbmNsdWRlLmlwKSB7XG4gICAgICBnZXRJcEFkZHJlc3MuaXBIZWFkZXJOYW1lcy5mb3JFYWNoKGlwSGVhZGVyTmFtZSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgICAgZGVsZXRlIChoZWFkZXJzIClbaXBIZWFkZXJOYW1lXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3REYXRhLm1ldGhvZCA9IG5vcm1hbGl6ZWRSZXF1ZXN0Lm1ldGhvZDtcblxuICBpZiAoaW5jbHVkZS51cmwpIHtcbiAgICByZXF1ZXN0RGF0YS51cmwgPSBub3JtYWxpemVkUmVxdWVzdC51cmw7XG4gIH1cblxuICBpZiAoaW5jbHVkZS5jb29raWVzKSB7XG4gICAgY29uc3QgY29va2llcyA9IG5vcm1hbGl6ZWRSZXF1ZXN0LmNvb2tpZXMgfHwgKGhlYWRlcnM/LmNvb2tpZSA/IGNvb2tpZS5wYXJzZUNvb2tpZShoZWFkZXJzLmNvb2tpZSkgOiB1bmRlZmluZWQpO1xuICAgIHJlcXVlc3REYXRhLmNvb2tpZXMgPSBjb29raWVzIHx8IHt9O1xuICB9XG5cbiAgaWYgKGluY2x1ZGUucXVlcnlfc3RyaW5nKSB7XG4gICAgcmVxdWVzdERhdGEucXVlcnlfc3RyaW5nID0gbm9ybWFsaXplZFJlcXVlc3QucXVlcnlfc3RyaW5nO1xuICB9XG5cbiAgaWYgKGluY2x1ZGUuZGF0YSkge1xuICAgIHJlcXVlc3REYXRhLmRhdGEgPSBub3JtYWxpemVkUmVxdWVzdC5kYXRhO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVlc3REYXRhO1xufVxuXG5leHBvcnRzLnJlcXVlc3REYXRhSW50ZWdyYXRpb24gPSByZXF1ZXN0RGF0YUludGVncmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdGRhdGEuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/requestdata.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/rewriteframes.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\");\nconst path = __webpack_require__(/*! ../utils-hoist/path.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/path.js\");\nconst worldwide = __webpack_require__(/*! ../utils-hoist/worldwide.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js\");\n\nconst INTEGRATION_NAME = 'RewriteFrames';\n\n/**\n * Rewrite event frames paths.\n */\nconst rewriteFramesIntegration = integration.defineIntegration((options = {}) => {\n  const root = options.root;\n  const prefix = options.prefix || 'app:///';\n\n  const isBrowser = 'window' in worldwide.GLOBAL_OBJ && !!worldwide.GLOBAL_OBJ.window;\n\n  const iteratee = options.iteratee || generateIteratee({ isBrowser, root, prefix });\n\n  /** Process an exception event. */\n  function _processExceptionsEvent(event) {\n    try {\n      return {\n        ...event,\n        exception: {\n          ...event.exception,\n          // The check for this is performed inside `process` call itself, safe to skip here\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          values: event.exception.values.map(value => ({\n            ...value,\n            ...(value.stacktrace && { stacktrace: _processStacktrace(value.stacktrace) }),\n          })),\n        },\n      };\n    } catch (_oO) {\n      return event;\n    }\n  }\n\n  /** Process a stack trace. */\n  function _processStacktrace(stacktrace) {\n    return {\n      ...stacktrace,\n      frames: stacktrace?.frames && stacktrace.frames.map(f => iteratee(f)),\n    };\n  }\n\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(originalEvent) {\n      let processedEvent = originalEvent;\n\n      if (originalEvent.exception && Array.isArray(originalEvent.exception.values)) {\n        processedEvent = _processExceptionsEvent(processedEvent);\n      }\n\n      return processedEvent;\n    },\n  };\n});\n\n/**\n * Exported only for tests.\n */\nfunction generateIteratee({\n  isBrowser,\n  root,\n  prefix,\n}\n\n) {\n  return (frame) => {\n    if (!frame.filename) {\n      return frame;\n    }\n\n    // Determine if this is a Windows frame by checking for a Windows-style prefix such as `C:\\`\n    const isWindowsFrame =\n      /^[a-zA-Z]:\\\\/.test(frame.filename) ||\n      // or the presence of a backslash without a forward slash (which are not allowed on Windows)\n      (frame.filename.includes('\\\\') && !frame.filename.includes('/'));\n\n    // Check if the frame filename begins with `/`\n    const startsWithSlash = /^\\//.test(frame.filename);\n\n    if (isBrowser) {\n      if (root) {\n        const oldFilename = frame.filename;\n        if (oldFilename.indexOf(root) === 0) {\n          frame.filename = oldFilename.replace(root, prefix);\n        }\n      }\n    } else {\n      if (isWindowsFrame || startsWithSlash) {\n        const filename = isWindowsFrame\n          ? frame.filename\n              .replace(/^[a-zA-Z]:/, '') // remove Windows-style prefix\n              .replace(/\\\\/g, '/') // replace all `\\\\` instances with `/`\n          : frame.filename;\n        const base = root ? path.relative(root, filename) : path.basename(filename);\n        frame.filename = `${prefix}${base}`;\n      }\n    }\n\n    return frame;\n  };\n}\n\nexports.generateIteratee = generateIteratee;\nexports.rewriteFramesIntegration = rewriteFramesIntegration;\n//# sourceMappingURL=rewriteframes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb25zL3Jld3JpdGVmcmFtZXMuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsb0JBQW9CLG1CQUFPLENBQUMsaUhBQW1CO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQywySEFBd0I7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMscUlBQTZCOztBQUV2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTs7QUFFQTs7QUFFQSwwREFBMEQseUJBQXlCOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtEQUFrRDtBQUN4RixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxFQUFFLEtBQUs7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXGludGVncmF0aW9uc1xccmV3cml0ZWZyYW1lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgaW50ZWdyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlZ3JhdGlvbi5qcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3BhdGguanMnKTtcbmNvbnN0IHdvcmxkd2lkZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3dvcmxkd2lkZS5qcycpO1xuXG5jb25zdCBJTlRFR1JBVElPTl9OQU1FID0gJ1Jld3JpdGVGcmFtZXMnO1xuXG4vKipcbiAqIFJld3JpdGUgZXZlbnQgZnJhbWVzIHBhdGhzLlxuICovXG5jb25zdCByZXdyaXRlRnJhbWVzSW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbigob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHJvb3QgPSBvcHRpb25zLnJvb3Q7XG4gIGNvbnN0IHByZWZpeCA9IG9wdGlvbnMucHJlZml4IHx8ICdhcHA6Ly8vJztcblxuICBjb25zdCBpc0Jyb3dzZXIgPSAnd2luZG93JyBpbiB3b3JsZHdpZGUuR0xPQkFMX09CSiAmJiAhIXdvcmxkd2lkZS5HTE9CQUxfT0JKLndpbmRvdztcblxuICBjb25zdCBpdGVyYXRlZSA9IG9wdGlvbnMuaXRlcmF0ZWUgfHwgZ2VuZXJhdGVJdGVyYXRlZSh7IGlzQnJvd3Nlciwgcm9vdCwgcHJlZml4IH0pO1xuXG4gIC8qKiBQcm9jZXNzIGFuIGV4Y2VwdGlvbiBldmVudC4gKi9cbiAgZnVuY3Rpb24gX3Byb2Nlc3NFeGNlcHRpb25zRXZlbnQoZXZlbnQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIGV4Y2VwdGlvbjoge1xuICAgICAgICAgIC4uLmV2ZW50LmV4Y2VwdGlvbixcbiAgICAgICAgICAvLyBUaGUgY2hlY2sgZm9yIHRoaXMgaXMgcGVyZm9ybWVkIGluc2lkZSBgcHJvY2Vzc2AgY2FsbCBpdHNlbGYsIHNhZmUgdG8gc2tpcCBoZXJlXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICB2YWx1ZXM6IGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXMubWFwKHZhbHVlID0+ICh7XG4gICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgIC4uLih2YWx1ZS5zdGFja3RyYWNlICYmIHsgc3RhY2t0cmFjZTogX3Byb2Nlc3NTdGFja3RyYWNlKHZhbHVlLnN0YWNrdHJhY2UpIH0pLFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoX29PKSB7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICB9XG5cbiAgLyoqIFByb2Nlc3MgYSBzdGFjayB0cmFjZS4gKi9cbiAgZnVuY3Rpb24gX3Byb2Nlc3NTdGFja3RyYWNlKHN0YWNrdHJhY2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhY2t0cmFjZSxcbiAgICAgIGZyYW1lczogc3RhY2t0cmFjZT8uZnJhbWVzICYmIHN0YWNrdHJhY2UuZnJhbWVzLm1hcChmID0+IGl0ZXJhdGVlKGYpKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHByb2Nlc3NFdmVudChvcmlnaW5hbEV2ZW50KSB7XG4gICAgICBsZXQgcHJvY2Vzc2VkRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuXG4gICAgICBpZiAob3JpZ2luYWxFdmVudC5leGNlcHRpb24gJiYgQXJyYXkuaXNBcnJheShvcmlnaW5hbEV2ZW50LmV4Y2VwdGlvbi52YWx1ZXMpKSB7XG4gICAgICAgIHByb2Nlc3NlZEV2ZW50ID0gX3Byb2Nlc3NFeGNlcHRpb25zRXZlbnQocHJvY2Vzc2VkRXZlbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvY2Vzc2VkRXZlbnQ7XG4gICAgfSxcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RzLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUl0ZXJhdGVlKHtcbiAgaXNCcm93c2VyLFxuICByb290LFxuICBwcmVmaXgsXG59XG5cbikge1xuICByZXR1cm4gKGZyYW1lKSA9PiB7XG4gICAgaWYgKCFmcmFtZS5maWxlbmFtZSkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBpZiB0aGlzIGlzIGEgV2luZG93cyBmcmFtZSBieSBjaGVja2luZyBmb3IgYSBXaW5kb3dzLXN0eWxlIHByZWZpeCBzdWNoIGFzIGBDOlxcYFxuICAgIGNvbnN0IGlzV2luZG93c0ZyYW1lID1cbiAgICAgIC9eW2EtekEtWl06XFxcXC8udGVzdChmcmFtZS5maWxlbmFtZSkgfHxcbiAgICAgIC8vIG9yIHRoZSBwcmVzZW5jZSBvZiBhIGJhY2tzbGFzaCB3aXRob3V0IGEgZm9yd2FyZCBzbGFzaCAod2hpY2ggYXJlIG5vdCBhbGxvd2VkIG9uIFdpbmRvd3MpXG4gICAgICAoZnJhbWUuZmlsZW5hbWUuaW5jbHVkZXMoJ1xcXFwnKSAmJiAhZnJhbWUuZmlsZW5hbWUuaW5jbHVkZXMoJy8nKSk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgZnJhbWUgZmlsZW5hbWUgYmVnaW5zIHdpdGggYC9gXG4gICAgY29uc3Qgc3RhcnRzV2l0aFNsYXNoID0gL15cXC8vLnRlc3QoZnJhbWUuZmlsZW5hbWUpO1xuXG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgY29uc3Qgb2xkRmlsZW5hbWUgPSBmcmFtZS5maWxlbmFtZTtcbiAgICAgICAgaWYgKG9sZEZpbGVuYW1lLmluZGV4T2Yocm9vdCkgPT09IDApIHtcbiAgICAgICAgICBmcmFtZS5maWxlbmFtZSA9IG9sZEZpbGVuYW1lLnJlcGxhY2Uocm9vdCwgcHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNXaW5kb3dzRnJhbWUgfHwgc3RhcnRzV2l0aFNsYXNoKSB7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gaXNXaW5kb3dzRnJhbWVcbiAgICAgICAgICA/IGZyYW1lLmZpbGVuYW1lXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9eW2EtekEtWl06LywgJycpIC8vIHJlbW92ZSBXaW5kb3dzLXN0eWxlIHByZWZpeFxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCAnLycpIC8vIHJlcGxhY2UgYWxsIGBcXFxcYCBpbnN0YW5jZXMgd2l0aCBgL2BcbiAgICAgICAgICA6IGZyYW1lLmZpbGVuYW1lO1xuICAgICAgICBjb25zdCBiYXNlID0gcm9vdCA/IHBhdGgucmVsYXRpdmUocm9vdCwgZmlsZW5hbWUpIDogcGF0aC5iYXNlbmFtZShmaWxlbmFtZSk7XG4gICAgICAgIGZyYW1lLmZpbGVuYW1lID0gYCR7cHJlZml4fSR7YmFzZX1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmcmFtZTtcbiAgfTtcbn1cblxuZXhwb3J0cy5nZW5lcmF0ZUl0ZXJhdGVlID0gZ2VuZXJhdGVJdGVyYXRlZTtcbmV4cG9ydHMucmV3cml0ZUZyYW1lc0ludGVncmF0aW9uID0gcmV3cml0ZUZyYW1lc0ludGVncmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV3cml0ZWZyYW1lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/rewriteframes.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/supabase.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst breadcrumbs = __webpack_require__(/*! ../breadcrumbs.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/breadcrumbs.js\");\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst exports$1 = __webpack_require__(/*! ../exports.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/exports.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\n__webpack_require__(/*! ../tracing/errors.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/errors.js\");\nconst is = __webpack_require__(/*! ../utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\n__webpack_require__(/*! ../utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst spanstatus = __webpack_require__(/*! ../tracing/spanstatus.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js\");\nconst trace = __webpack_require__(/*! ../tracing/trace.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/trace.js\");\n\n// Based on Kamil Og\xf3rek's work on:\n// https://github.com/supabase-community/sentry-integration-js\n\n\nconst AUTH_OPERATIONS_TO_INSTRUMENT = [\n  'reauthenticate',\n  'signInAnonymously',\n  'signInWithOAuth',\n  'signInWithIdToken',\n  'signInWithOtp',\n  'signInWithPassword',\n  'signInWithSSO',\n  'signOut',\n  'signUp',\n  'verifyOtp',\n];\n\nconst AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT = [\n  'createUser',\n  'deleteUser',\n  'listUsers',\n  'getUserById',\n  'updateUserById',\n  'inviteUserByEmail',\n];\n\nconst FILTER_MAPPINGS = {\n  eq: 'eq',\n  neq: 'neq',\n  gt: 'gt',\n  gte: 'gte',\n  lt: 'lt',\n  lte: 'lte',\n  like: 'like',\n  'like(all)': 'likeAllOf',\n  'like(any)': 'likeAnyOf',\n  ilike: 'ilike',\n  'ilike(all)': 'ilikeAllOf',\n  'ilike(any)': 'ilikeAnyOf',\n  is: 'is',\n  in: 'in',\n  cs: 'contains',\n  cd: 'containedBy',\n  sr: 'rangeGt',\n  nxl: 'rangeGte',\n  sl: 'rangeLt',\n  nxr: 'rangeLte',\n  adj: 'rangeAdjacent',\n  ov: 'overlaps',\n  fts: '',\n  plfts: 'plain',\n  phfts: 'phrase',\n  wfts: 'websearch',\n  not: 'not',\n};\n\nconst DB_OPERATIONS_TO_INSTRUMENT = ['select', 'insert', 'upsert', 'update', 'delete'];\n\nfunction markAsInstrumented(fn) {\n  try {\n    (fn ).__SENTRY_INSTRUMENTED__ = true;\n  } catch {\n    // ignore errors here\n  }\n}\n\nfunction isInstrumented(fn) {\n  try {\n    return (fn ).__SENTRY_INSTRUMENTED__;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Extracts the database operation type from the HTTP method and headers\n * @param method - The HTTP method of the request\n * @param headers - The request headers\n * @returns The database operation type ('select', 'insert', 'upsert', 'update', or 'delete')\n */\nfunction extractOperation(method, headers = {}) {\n  switch (method) {\n    case 'GET': {\n      return 'select';\n    }\n    case 'POST': {\n      if (headers['Prefer']?.includes('resolution=')) {\n        return 'upsert';\n      } else {\n        return 'insert';\n      }\n    }\n    case 'PATCH': {\n      return 'update';\n    }\n    case 'DELETE': {\n      return 'delete';\n    }\n    default: {\n      return '<unknown-op>';\n    }\n  }\n}\n\n/**\n * Translates Supabase filter parameters into readable method names for tracing\n * @param key - The filter key from the URL search parameters\n * @param query - The filter value from the URL search parameters\n * @returns A string representation of the filter as a method call\n */\nfunction translateFiltersIntoMethods(key, query) {\n  if (query === '' || query === '*') {\n    return 'select(*)';\n  }\n\n  if (key === 'select') {\n    return `select(${query})`;\n  }\n\n  if (key === 'or' || key.endsWith('.or')) {\n    return `${key}${query}`;\n  }\n\n  const [filter, ...value] = query.split('.');\n\n  let method;\n  // Handle optional `configPart` of the filter\n  if (filter?.startsWith('fts')) {\n    method = 'textSearch';\n  } else if (filter?.startsWith('plfts')) {\n    method = 'textSearch[plain]';\n  } else if (filter?.startsWith('phfts')) {\n    method = 'textSearch[phrase]';\n  } else if (filter?.startsWith('wfts')) {\n    method = 'textSearch[websearch]';\n  } else {\n    method = (filter && FILTER_MAPPINGS[filter ]) || 'filter';\n  }\n\n  return `${method}(${key}, ${value.join('.')})`;\n}\n\nfunction instrumentAuthOperation(operation, isAdmin = false) {\n  return new Proxy(operation, {\n    apply(target, thisArg, argumentsList) {\n      return trace.startSpan(\n        {\n          name: `auth ${isAdmin ? '(admin) ' : ''}${operation.name}`,\n          attributes: {\n            [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',\n            [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db',\n            'db.system': 'postgresql',\n            'db.operation': `auth.${isAdmin ? 'admin.' : ''}${operation.name}`,\n          },\n        },\n        span => {\n          return Reflect.apply(target, thisArg, argumentsList)\n            .then((res) => {\n              if (res && typeof res === 'object' && 'error' in res && res.error) {\n                span.setStatus({ code: spanstatus.SPAN_STATUS_ERROR });\n\n                exports$1.captureException(res.error, {\n                  mechanism: {\n                    handled: false,\n                  },\n                });\n              } else {\n                span.setStatus({ code: spanstatus.SPAN_STATUS_OK });\n              }\n\n              span.end();\n              return res;\n            })\n            .catch((err) => {\n              span.setStatus({ code: spanstatus.SPAN_STATUS_ERROR });\n              span.end();\n\n              exports$1.captureException(err, {\n                mechanism: {\n                  handled: false,\n                },\n              });\n\n              throw err;\n            })\n            .then(...argumentsList);\n        },\n      );\n    },\n  });\n}\n\nfunction instrumentSupabaseAuthClient(supabaseClientInstance) {\n  const auth = supabaseClientInstance.auth;\n\n  if (!auth || isInstrumented(supabaseClientInstance.auth)) {\n    return;\n  }\n\n  for (const operation of AUTH_OPERATIONS_TO_INSTRUMENT) {\n    const authOperation = auth[operation];\n\n    if (!authOperation) {\n      continue;\n    }\n\n    if (typeof supabaseClientInstance.auth[operation] === 'function') {\n      supabaseClientInstance.auth[operation] = instrumentAuthOperation(authOperation);\n    }\n  }\n\n  for (const operation of AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT) {\n    const authOperation = auth.admin[operation];\n\n    if (!authOperation) {\n      continue;\n    }\n\n    if (typeof supabaseClientInstance.auth.admin[operation] === 'function') {\n      supabaseClientInstance.auth.admin[operation] = instrumentAuthOperation(authOperation, true);\n    }\n  }\n\n  markAsInstrumented(supabaseClientInstance.auth);\n}\n\nfunction instrumentSupabaseClientConstructor(SupabaseClient) {\n  if (isInstrumented((SupabaseClient ).prototype.from)) {\n    return;\n  }\n\n  (SupabaseClient ).prototype.from = new Proxy(\n    (SupabaseClient ).prototype.from,\n    {\n      apply(target, thisArg, argumentsList) {\n        const rv = Reflect.apply(target, thisArg, argumentsList);\n        const PostgRESTQueryBuilder = (rv ).constructor;\n\n        instrumentPostgRESTQueryBuilder(PostgRESTQueryBuilder );\n\n        return rv;\n      },\n    },\n  );\n\n  markAsInstrumented((SupabaseClient ).prototype.from);\n}\n\nfunction instrumentPostgRESTFilterBuilder(PostgRESTFilterBuilder) {\n  if (isInstrumented((PostgRESTFilterBuilder.prototype ).then)) {\n    return;\n  }\n\n  (PostgRESTFilterBuilder.prototype ).then = new Proxy(\n    (PostgRESTFilterBuilder.prototype ).then,\n    {\n      apply(target, thisArg, argumentsList) {\n        const operations = DB_OPERATIONS_TO_INSTRUMENT;\n        const typedThis = thisArg ;\n        const operation = extractOperation(typedThis.method, typedThis.headers);\n\n        if (!operations.includes(operation)) {\n          return Reflect.apply(target, thisArg, argumentsList);\n        }\n\n        if (!typedThis?.url?.pathname || typeof typedThis.url.pathname !== 'string') {\n          return Reflect.apply(target, thisArg, argumentsList);\n        }\n\n        const pathParts = typedThis.url.pathname.split('/');\n        const table = pathParts.length > 0 ? pathParts[pathParts.length - 1] : '';\n\n        const queryItems = [];\n        for (const [key, value] of typedThis.url.searchParams.entries()) {\n          // It's possible to have multiple entries for the same key, eg. `id=eq.7&id=eq.3`,\n          // so we need to use array instead of object to collect them.\n          queryItems.push(translateFiltersIntoMethods(key, value));\n        }\n        const body = Object.create(null);\n        if (is.isPlainObject(typedThis.body)) {\n          for (const [key, value] of Object.entries(typedThis.body)) {\n            body[key] = value;\n          }\n        }\n\n        // Adding operation to the beginning of the description if it's not a `select` operation\n        // For example, it can be an `insert` or `update` operation but the query can be `select(...)`\n        // For `select` operations, we don't need repeat it in the description\n        const description = `${operation === 'select' ? '' : `${operation}${body ? '(...) ' : ''}`}${queryItems.join(\n          ' ',\n        )} from(${table})`;\n\n        const attributes = {\n          'db.table': table,\n          'db.schema': typedThis.schema,\n          'db.url': typedThis.url.origin,\n          'db.sdk': typedThis.headers['X-Client-Info'],\n          'db.system': 'postgresql',\n          'db.operation': operation,\n          [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',\n          [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db',\n        };\n\n        if (queryItems.length) {\n          attributes['db.query'] = queryItems;\n        }\n\n        if (Object.keys(body).length) {\n          attributes['db.body'] = body;\n        }\n\n        return trace.startSpan(\n          {\n            name: description,\n            attributes,\n          },\n          span => {\n            return (Reflect.apply(target, thisArg, []) )\n              .then(\n                (res) => {\n                  if (span) {\n                    if (res && typeof res === 'object' && 'status' in res) {\n                      spanstatus.setHttpStatus(span, res.status || 500);\n                    }\n                    span.end();\n                  }\n\n                  if (res.error) {\n                    const err = new Error(res.error.message) ;\n                    if (res.error.code) {\n                      err.code = res.error.code;\n                    }\n                    if (res.error.details) {\n                      err.details = res.error.details;\n                    }\n\n                    const supabaseContext = {};\n                    if (queryItems.length) {\n                      supabaseContext.query = queryItems;\n                    }\n                    if (Object.keys(body).length) {\n                      supabaseContext.body = body;\n                    }\n\n                    exports$1.captureException(err, {\n                      contexts: {\n                        supabase: supabaseContext,\n                      },\n                    });\n                  }\n\n                  const breadcrumb = {\n                    type: 'supabase',\n                    category: `db.${operation}`,\n                    message: description,\n                  };\n\n                  const data = {};\n\n                  if (queryItems.length) {\n                    data.query = queryItems;\n                  }\n\n                  if (Object.keys(body).length) {\n                    data.body = body;\n                  }\n\n                  if (Object.keys(data).length) {\n                    breadcrumb.data = data;\n                  }\n\n                  breadcrumbs.addBreadcrumb(breadcrumb);\n\n                  return res;\n                },\n                (err) => {\n                  if (span) {\n                    spanstatus.setHttpStatus(span, 500);\n                    span.end();\n                  }\n                  throw err;\n                },\n              )\n              .then(...argumentsList);\n          },\n        );\n      },\n    },\n  );\n\n  markAsInstrumented((PostgRESTFilterBuilder.prototype ).then);\n}\n\nfunction instrumentPostgRESTQueryBuilder(PostgRESTQueryBuilder) {\n  // We need to wrap _all_ operations despite them sharing the same `PostgRESTFilterBuilder`\n  // constructor, as we don't know which method will be called first, and we don't want to miss any calls.\n  for (const operation of DB_OPERATIONS_TO_INSTRUMENT) {\n    if (isInstrumented((PostgRESTQueryBuilder.prototype )[operation])) {\n      continue;\n    }\n\n    (PostgRESTQueryBuilder.prototype )[operation ] = new Proxy(\n      (PostgRESTQueryBuilder.prototype )[operation ],\n      {\n        apply(target, thisArg, argumentsList) {\n          const rv = Reflect.apply(target, thisArg, argumentsList);\n          const PostgRESTFilterBuilder = (rv ).constructor;\n\n          debugBuild.DEBUG_BUILD && logger.logger.log(`Instrumenting ${operation} operation's PostgRESTFilterBuilder`);\n\n          instrumentPostgRESTFilterBuilder(PostgRESTFilterBuilder);\n\n          return rv;\n        },\n      },\n    );\n\n    markAsInstrumented((PostgRESTQueryBuilder.prototype )[operation]);\n  }\n}\n\nconst instrumentSupabaseClient = (supabaseClient) => {\n  if (!supabaseClient) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('Supabase integration was not installed because no Supabase client was provided.');\n    return;\n  }\n  const SupabaseClientConstructor =\n    supabaseClient.constructor === Function ? supabaseClient : supabaseClient.constructor;\n\n  instrumentSupabaseClientConstructor(SupabaseClientConstructor);\n  instrumentSupabaseAuthClient(supabaseClient );\n};\n\nconst INTEGRATION_NAME = 'Supabase';\n\nconst _supabaseIntegration = ((supabaseClient) => {\n  return {\n    setupOnce() {\n      instrumentSupabaseClient(supabaseClient);\n    },\n    name: INTEGRATION_NAME,\n  };\n}) ;\n\nconst supabaseIntegration = integration.defineIntegration((options) => {\n  return _supabaseIntegration(options.supabaseClient);\n}) ;\n\nexports.DB_OPERATIONS_TO_INSTRUMENT = DB_OPERATIONS_TO_INSTRUMENT;\nexports.FILTER_MAPPINGS = FILTER_MAPPINGS;\nexports.extractOperation = extractOperation;\nexports.instrumentSupabaseClient = instrumentSupabaseClient;\nexports.supabaseIntegration = supabaseIntegration;\nexports.translateFiltersIntoMethods = translateFiltersIntoMethods;\n//# sourceMappingURL=supabase.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb25zL3N1cGFiYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLG9CQUFvQixtQkFBTyxDQUFDLGlIQUFtQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDOUMsa0JBQWtCLG1CQUFPLENBQUMseUdBQWU7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsaUhBQW1CO0FBQy9DLDJCQUEyQixtQkFBTyxDQUFDLCtIQUEwQjtBQUM3RCxtQkFBTyxDQUFDLHVIQUFzQjtBQUM5QixXQUFXLG1CQUFPLENBQUMsdUhBQXNCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQywrSEFBMEI7QUFDakQsbUJBQU8sQ0FBQywySEFBd0I7QUFDaEMsbUJBQW1CLG1CQUFPLENBQUMsK0hBQTBCO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyxxSEFBcUI7O0FBRTNDO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7O0FBRUE7QUFDQSxjQUFjLElBQUksRUFBRSxNQUFNO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsWUFBWSxPQUFPLEdBQUcsSUFBSSxJQUFJLGdCQUFnQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQixFQUFFLGVBQWU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0JBQXdCLEVBQUUsZUFBZTtBQUM3RSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9DQUFvQzs7QUFFckU7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsaUNBQWlDLGlDQUFpQztBQUNsRTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsK0JBQStCLG9DQUFvQztBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTs7QUFFZjtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUNBQWlDLFVBQVUsRUFBRSxxQkFBcUIsRUFBRSxFQUFFO0FBQ3JHO0FBQ0EsV0FBVyxPQUFPLE1BQU07O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1RUFBdUUsV0FBVzs7QUFFbEY7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQsbUNBQW1DO0FBQ25DLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLDJCQUEyQjtBQUMzQixtQ0FBbUM7QUFDbkMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxpbnRlZ3JhdGlvbnNcXHN1cGFiYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBicmVhZGNydW1icyA9IHJlcXVpcmUoJy4uL2JyZWFkY3J1bWJzLmpzJyk7XG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IGV4cG9ydHMkMSA9IHJlcXVpcmUoJy4uL2V4cG9ydHMuanMnKTtcbmNvbnN0IGludGVncmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZWdyYXRpb24uanMnKTtcbmNvbnN0IHNlbWFudGljQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4uL3NlbWFudGljQXR0cmlidXRlcy5qcycpO1xucmVxdWlyZSgnLi4vdHJhY2luZy9lcnJvcnMuanMnKTtcbmNvbnN0IGlzID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvaXMuanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xucmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvdGltZS5qcycpO1xuY29uc3Qgc3BhbnN0YXR1cyA9IHJlcXVpcmUoJy4uL3RyYWNpbmcvc3BhbnN0YXR1cy5qcycpO1xuY29uc3QgdHJhY2UgPSByZXF1aXJlKCcuLi90cmFjaW5nL3RyYWNlLmpzJyk7XG5cbi8vIEJhc2VkIG9uIEthbWlsIE9nw7NyZWsncyB3b3JrIG9uOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlLWNvbW11bml0eS9zZW50cnktaW50ZWdyYXRpb24tanNcblxuXG5jb25zdCBBVVRIX09QRVJBVElPTlNfVE9fSU5TVFJVTUVOVCA9IFtcbiAgJ3JlYXV0aGVudGljYXRlJyxcbiAgJ3NpZ25JbkFub255bW91c2x5JyxcbiAgJ3NpZ25JbldpdGhPQXV0aCcsXG4gICdzaWduSW5XaXRoSWRUb2tlbicsXG4gICdzaWduSW5XaXRoT3RwJyxcbiAgJ3NpZ25JbldpdGhQYXNzd29yZCcsXG4gICdzaWduSW5XaXRoU1NPJyxcbiAgJ3NpZ25PdXQnLFxuICAnc2lnblVwJyxcbiAgJ3ZlcmlmeU90cCcsXG5dO1xuXG5jb25zdCBBVVRIX0FETUlOX09QRVJBVElPTlNfVE9fSU5TVFJVTUVOVCA9IFtcbiAgJ2NyZWF0ZVVzZXInLFxuICAnZGVsZXRlVXNlcicsXG4gICdsaXN0VXNlcnMnLFxuICAnZ2V0VXNlckJ5SWQnLFxuICAndXBkYXRlVXNlckJ5SWQnLFxuICAnaW52aXRlVXNlckJ5RW1haWwnLFxuXTtcblxuY29uc3QgRklMVEVSX01BUFBJTkdTID0ge1xuICBlcTogJ2VxJyxcbiAgbmVxOiAnbmVxJyxcbiAgZ3Q6ICdndCcsXG4gIGd0ZTogJ2d0ZScsXG4gIGx0OiAnbHQnLFxuICBsdGU6ICdsdGUnLFxuICBsaWtlOiAnbGlrZScsXG4gICdsaWtlKGFsbCknOiAnbGlrZUFsbE9mJyxcbiAgJ2xpa2UoYW55KSc6ICdsaWtlQW55T2YnLFxuICBpbGlrZTogJ2lsaWtlJyxcbiAgJ2lsaWtlKGFsbCknOiAnaWxpa2VBbGxPZicsXG4gICdpbGlrZShhbnkpJzogJ2lsaWtlQW55T2YnLFxuICBpczogJ2lzJyxcbiAgaW46ICdpbicsXG4gIGNzOiAnY29udGFpbnMnLFxuICBjZDogJ2NvbnRhaW5lZEJ5JyxcbiAgc3I6ICdyYW5nZUd0JyxcbiAgbnhsOiAncmFuZ2VHdGUnLFxuICBzbDogJ3JhbmdlTHQnLFxuICBueHI6ICdyYW5nZUx0ZScsXG4gIGFkajogJ3JhbmdlQWRqYWNlbnQnLFxuICBvdjogJ292ZXJsYXBzJyxcbiAgZnRzOiAnJyxcbiAgcGxmdHM6ICdwbGFpbicsXG4gIHBoZnRzOiAncGhyYXNlJyxcbiAgd2Z0czogJ3dlYnNlYXJjaCcsXG4gIG5vdDogJ25vdCcsXG59O1xuXG5jb25zdCBEQl9PUEVSQVRJT05TX1RPX0lOU1RSVU1FTlQgPSBbJ3NlbGVjdCcsICdpbnNlcnQnLCAndXBzZXJ0JywgJ3VwZGF0ZScsICdkZWxldGUnXTtcblxuZnVuY3Rpb24gbWFya0FzSW5zdHJ1bWVudGVkKGZuKSB7XG4gIHRyeSB7XG4gICAgKGZuICkuX19TRU5UUllfSU5TVFJVTUVOVEVEX18gPSB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICAvLyBpZ25vcmUgZXJyb3JzIGhlcmVcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luc3RydW1lbnRlZChmbikge1xuICB0cnkge1xuICAgIHJldHVybiAoZm4gKS5fX1NFTlRSWV9JTlNUUlVNRU5URURfXztcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGRhdGFiYXNlIG9wZXJhdGlvbiB0eXBlIGZyb20gdGhlIEhUVFAgbWV0aG9kIGFuZCBoZWFkZXJzXG4gKiBAcGFyYW0gbWV0aG9kIC0gVGhlIEhUVFAgbWV0aG9kIG9mIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0gaGVhZGVycyAtIFRoZSByZXF1ZXN0IGhlYWRlcnNcbiAqIEByZXR1cm5zIFRoZSBkYXRhYmFzZSBvcGVyYXRpb24gdHlwZSAoJ3NlbGVjdCcsICdpbnNlcnQnLCAndXBzZXJ0JywgJ3VwZGF0ZScsIG9yICdkZWxldGUnKVxuICovXG5mdW5jdGlvbiBleHRyYWN0T3BlcmF0aW9uKG1ldGhvZCwgaGVhZGVycyA9IHt9KSB7XG4gIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgY2FzZSAnR0VUJzoge1xuICAgICAgcmV0dXJuICdzZWxlY3QnO1xuICAgIH1cbiAgICBjYXNlICdQT1NUJzoge1xuICAgICAgaWYgKGhlYWRlcnNbJ1ByZWZlciddPy5pbmNsdWRlcygncmVzb2x1dGlvbj0nKSkge1xuICAgICAgICByZXR1cm4gJ3Vwc2VydCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ2luc2VydCc7XG4gICAgICB9XG4gICAgfVxuICAgIGNhc2UgJ1BBVENIJzoge1xuICAgICAgcmV0dXJuICd1cGRhdGUnO1xuICAgIH1cbiAgICBjYXNlICdERUxFVEUnOiB7XG4gICAgICByZXR1cm4gJ2RlbGV0ZSc7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiAnPHVua25vd24tb3A+JztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2xhdGVzIFN1cGFiYXNlIGZpbHRlciBwYXJhbWV0ZXJzIGludG8gcmVhZGFibGUgbWV0aG9kIG5hbWVzIGZvciB0cmFjaW5nXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGZpbHRlciBrZXkgZnJvbSB0aGUgVVJMIHNlYXJjaCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgZmlsdGVyIHZhbHVlIGZyb20gdGhlIFVSTCBzZWFyY2ggcGFyYW1ldGVyc1xuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGZpbHRlciBhcyBhIG1ldGhvZCBjYWxsXG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0ZUZpbHRlcnNJbnRvTWV0aG9kcyhrZXksIHF1ZXJ5KSB7XG4gIGlmIChxdWVyeSA9PT0gJycgfHwgcXVlcnkgPT09ICcqJykge1xuICAgIHJldHVybiAnc2VsZWN0KCopJztcbiAgfVxuXG4gIGlmIChrZXkgPT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGBzZWxlY3QoJHtxdWVyeX0pYDtcbiAgfVxuXG4gIGlmIChrZXkgPT09ICdvcicgfHwga2V5LmVuZHNXaXRoKCcub3InKSkge1xuICAgIHJldHVybiBgJHtrZXl9JHtxdWVyeX1gO1xuICB9XG5cbiAgY29uc3QgW2ZpbHRlciwgLi4udmFsdWVdID0gcXVlcnkuc3BsaXQoJy4nKTtcblxuICBsZXQgbWV0aG9kO1xuICAvLyBIYW5kbGUgb3B0aW9uYWwgYGNvbmZpZ1BhcnRgIG9mIHRoZSBmaWx0ZXJcbiAgaWYgKGZpbHRlcj8uc3RhcnRzV2l0aCgnZnRzJykpIHtcbiAgICBtZXRob2QgPSAndGV4dFNlYXJjaCc7XG4gIH0gZWxzZSBpZiAoZmlsdGVyPy5zdGFydHNXaXRoKCdwbGZ0cycpKSB7XG4gICAgbWV0aG9kID0gJ3RleHRTZWFyY2hbcGxhaW5dJztcbiAgfSBlbHNlIGlmIChmaWx0ZXI/LnN0YXJ0c1dpdGgoJ3BoZnRzJykpIHtcbiAgICBtZXRob2QgPSAndGV4dFNlYXJjaFtwaHJhc2VdJztcbiAgfSBlbHNlIGlmIChmaWx0ZXI/LnN0YXJ0c1dpdGgoJ3dmdHMnKSkge1xuICAgIG1ldGhvZCA9ICd0ZXh0U2VhcmNoW3dlYnNlYXJjaF0nO1xuICB9IGVsc2Uge1xuICAgIG1ldGhvZCA9IChmaWx0ZXIgJiYgRklMVEVSX01BUFBJTkdTW2ZpbHRlciBdKSB8fCAnZmlsdGVyJztcbiAgfVxuXG4gIHJldHVybiBgJHttZXRob2R9KCR7a2V5fSwgJHt2YWx1ZS5qb2luKCcuJyl9KWA7XG59XG5cbmZ1bmN0aW9uIGluc3RydW1lbnRBdXRoT3BlcmF0aW9uKG9wZXJhdGlvbiwgaXNBZG1pbiA9IGZhbHNlKSB7XG4gIHJldHVybiBuZXcgUHJveHkob3BlcmF0aW9uLCB7XG4gICAgYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG4gICAgICByZXR1cm4gdHJhY2Uuc3RhcnRTcGFuKFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogYGF1dGggJHtpc0FkbWluID8gJyhhZG1pbikgJyA6ICcnfSR7b3BlcmF0aW9uLm5hbWV9YCxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXTogJ2F1dG8uZGIuc3VwYWJhc2UnLFxuICAgICAgICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXTogJ2RiJyxcbiAgICAgICAgICAgICdkYi5zeXN0ZW0nOiAncG9zdGdyZXNxbCcsXG4gICAgICAgICAgICAnZGIub3BlcmF0aW9uJzogYGF1dGguJHtpc0FkbWluID8gJ2FkbWluLicgOiAnJ30ke29wZXJhdGlvbi5uYW1lfWAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgc3BhbiA9PiB7XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KVxuICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICdlcnJvcicgaW4gcmVzICYmIHJlcy5lcnJvcikge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogc3BhbnN0YXR1cy5TUEFOX1NUQVRVU19FUlJPUiB9KTtcblxuICAgICAgICAgICAgICAgIGV4cG9ydHMkMS5jYXB0dXJlRXhjZXB0aW9uKHJlcy5lcnJvciwge1xuICAgICAgICAgICAgICAgICAgbWVjaGFuaXNtOiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IHNwYW5zdGF0dXMuU1BBTl9TVEFUVVNfT0sgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogc3BhbnN0YXR1cy5TUEFOX1NUQVRVU19FUlJPUiB9KTtcbiAgICAgICAgICAgICAgc3Bhbi5lbmQoKTtcblxuICAgICAgICAgICAgICBleHBvcnRzJDEuY2FwdHVyZUV4Y2VwdGlvbihlcnIsIHtcbiAgICAgICAgICAgICAgICBtZWNoYW5pc206IHtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbiguLi5hcmd1bWVudHNMaXN0KTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc3RydW1lbnRTdXBhYmFzZUF1dGhDbGllbnQoc3VwYWJhc2VDbGllbnRJbnN0YW5jZSkge1xuICBjb25zdCBhdXRoID0gc3VwYWJhc2VDbGllbnRJbnN0YW5jZS5hdXRoO1xuXG4gIGlmICghYXV0aCB8fCBpc0luc3RydW1lbnRlZChzdXBhYmFzZUNsaWVudEluc3RhbmNlLmF1dGgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChjb25zdCBvcGVyYXRpb24gb2YgQVVUSF9PUEVSQVRJT05TX1RPX0lOU1RSVU1FTlQpIHtcbiAgICBjb25zdCBhdXRoT3BlcmF0aW9uID0gYXV0aFtvcGVyYXRpb25dO1xuXG4gICAgaWYgKCFhdXRoT3BlcmF0aW9uKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHN1cGFiYXNlQ2xpZW50SW5zdGFuY2UuYXV0aFtvcGVyYXRpb25dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdXBhYmFzZUNsaWVudEluc3RhbmNlLmF1dGhbb3BlcmF0aW9uXSA9IGluc3RydW1lbnRBdXRoT3BlcmF0aW9uKGF1dGhPcGVyYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIEFVVEhfQURNSU5fT1BFUkFUSU9OU19UT19JTlNUUlVNRU5UKSB7XG4gICAgY29uc3QgYXV0aE9wZXJhdGlvbiA9IGF1dGguYWRtaW5bb3BlcmF0aW9uXTtcblxuICAgIGlmICghYXV0aE9wZXJhdGlvbikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzdXBhYmFzZUNsaWVudEluc3RhbmNlLmF1dGguYWRtaW5bb3BlcmF0aW9uXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3VwYWJhc2VDbGllbnRJbnN0YW5jZS5hdXRoLmFkbWluW29wZXJhdGlvbl0gPSBpbnN0cnVtZW50QXV0aE9wZXJhdGlvbihhdXRoT3BlcmF0aW9uLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBtYXJrQXNJbnN0cnVtZW50ZWQoc3VwYWJhc2VDbGllbnRJbnN0YW5jZS5hdXRoKTtcbn1cblxuZnVuY3Rpb24gaW5zdHJ1bWVudFN1cGFiYXNlQ2xpZW50Q29uc3RydWN0b3IoU3VwYWJhc2VDbGllbnQpIHtcbiAgaWYgKGlzSW5zdHJ1bWVudGVkKChTdXBhYmFzZUNsaWVudCApLnByb3RvdHlwZS5mcm9tKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIChTdXBhYmFzZUNsaWVudCApLnByb3RvdHlwZS5mcm9tID0gbmV3IFByb3h5KFxuICAgIChTdXBhYmFzZUNsaWVudCApLnByb3RvdHlwZS5mcm9tLFxuICAgIHtcbiAgICAgIGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICBjb25zdCBydiA9IFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgY29uc3QgUG9zdGdSRVNUUXVlcnlCdWlsZGVyID0gKHJ2ICkuY29uc3RydWN0b3I7XG5cbiAgICAgICAgaW5zdHJ1bWVudFBvc3RnUkVTVFF1ZXJ5QnVpbGRlcihQb3N0Z1JFU1RRdWVyeUJ1aWxkZXIgKTtcblxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9LFxuICAgIH0sXG4gICk7XG5cbiAgbWFya0FzSW5zdHJ1bWVudGVkKChTdXBhYmFzZUNsaWVudCApLnByb3RvdHlwZS5mcm9tKTtcbn1cblxuZnVuY3Rpb24gaW5zdHJ1bWVudFBvc3RnUkVTVEZpbHRlckJ1aWxkZXIoUG9zdGdSRVNURmlsdGVyQnVpbGRlcikge1xuICBpZiAoaXNJbnN0cnVtZW50ZWQoKFBvc3RnUkVTVEZpbHRlckJ1aWxkZXIucHJvdG90eXBlICkudGhlbikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAoUG9zdGdSRVNURmlsdGVyQnVpbGRlci5wcm90b3R5cGUgKS50aGVuID0gbmV3IFByb3h5KFxuICAgIChQb3N0Z1JFU1RGaWx0ZXJCdWlsZGVyLnByb3RvdHlwZSApLnRoZW4sXG4gICAge1xuICAgICAgYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBEQl9PUEVSQVRJT05TX1RPX0lOU1RSVU1FTlQ7XG4gICAgICAgIGNvbnN0IHR5cGVkVGhpcyA9IHRoaXNBcmcgO1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBleHRyYWN0T3BlcmF0aW9uKHR5cGVkVGhpcy5tZXRob2QsIHR5cGVkVGhpcy5oZWFkZXJzKTtcblxuICAgICAgICBpZiAoIW9wZXJhdGlvbnMuaW5jbHVkZXMob3BlcmF0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXR5cGVkVGhpcz8udXJsPy5wYXRobmFtZSB8fCB0eXBlb2YgdHlwZWRUaGlzLnVybC5wYXRobmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGF0aFBhcnRzID0gdHlwZWRUaGlzLnVybC5wYXRobmFtZS5zcGxpdCgnLycpO1xuICAgICAgICBjb25zdCB0YWJsZSA9IHBhdGhQYXJ0cy5sZW5ndGggPiAwID8gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXSA6ICcnO1xuXG4gICAgICAgIGNvbnN0IHF1ZXJ5SXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdHlwZWRUaGlzLnVybC5zZWFyY2hQYXJhbXMuZW50cmllcygpKSB7XG4gICAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGVudHJpZXMgZm9yIHRoZSBzYW1lIGtleSwgZWcuIGBpZD1lcS43JmlkPWVxLjNgLFxuICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gdXNlIGFycmF5IGluc3RlYWQgb2Ygb2JqZWN0IHRvIGNvbGxlY3QgdGhlbS5cbiAgICAgICAgICBxdWVyeUl0ZW1zLnB1c2godHJhbnNsYXRlRmlsdGVyc0ludG9NZXRob2RzKGtleSwgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKGlzLmlzUGxhaW5PYmplY3QodHlwZWRUaGlzLmJvZHkpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModHlwZWRUaGlzLmJvZHkpKSB7XG4gICAgICAgICAgICBib2R5W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGRpbmcgb3BlcmF0aW9uIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRlc2NyaXB0aW9uIGlmIGl0J3Mgbm90IGEgYHNlbGVjdGAgb3BlcmF0aW9uXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCBpdCBjYW4gYmUgYW4gYGluc2VydGAgb3IgYHVwZGF0ZWAgb3BlcmF0aW9uIGJ1dCB0aGUgcXVlcnkgY2FuIGJlIGBzZWxlY3QoLi4uKWBcbiAgICAgICAgLy8gRm9yIGBzZWxlY3RgIG9wZXJhdGlvbnMsIHdlIGRvbid0IG5lZWQgcmVwZWF0IGl0IGluIHRoZSBkZXNjcmlwdGlvblxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGAke29wZXJhdGlvbiA9PT0gJ3NlbGVjdCcgPyAnJyA6IGAke29wZXJhdGlvbn0ke2JvZHkgPyAnKC4uLikgJyA6ICcnfWB9JHtxdWVyeUl0ZW1zLmpvaW4oXG4gICAgICAgICAgJyAnLFxuICAgICAgICApfSBmcm9tKCR7dGFibGV9KWA7XG5cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAnZGIudGFibGUnOiB0YWJsZSxcbiAgICAgICAgICAnZGIuc2NoZW1hJzogdHlwZWRUaGlzLnNjaGVtYSxcbiAgICAgICAgICAnZGIudXJsJzogdHlwZWRUaGlzLnVybC5vcmlnaW4sXG4gICAgICAgICAgJ2RiLnNkayc6IHR5cGVkVGhpcy5oZWFkZXJzWydYLUNsaWVudC1JbmZvJ10sXG4gICAgICAgICAgJ2RiLnN5c3RlbSc6ICdwb3N0Z3Jlc3FsJyxcbiAgICAgICAgICAnZGIub3BlcmF0aW9uJzogb3BlcmF0aW9uLFxuICAgICAgICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnYXV0by5kYi5zdXBhYmFzZScsXG4gICAgICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXTogJ2RiJyxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocXVlcnlJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzWydkYi5xdWVyeSddID0gcXVlcnlJdGVtcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhib2R5KS5sZW5ndGgpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzWydkYi5ib2R5J10gPSBib2R5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyYWNlLnN0YXJ0U3BhbihcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzcGFuID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIFtdKSApXG4gICAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAgIChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgJ3N0YXR1cycgaW4gcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3BhbnN0YXR1cy5zZXRIdHRwU3RhdHVzKHNwYW4sIHJlcy5zdGF0dXMgfHwgNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihyZXMuZXJyb3IubWVzc2FnZSkgO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmVycm9yLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSA9IHJlcy5lcnJvci5jb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMuZXJyb3IuZGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICAgIGVyci5kZXRhaWxzID0gcmVzLmVycm9yLmRldGFpbHM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdXBhYmFzZUNvbnRleHQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5SXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3VwYWJhc2VDb250ZXh0LnF1ZXJ5ID0gcXVlcnlJdGVtcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYm9keSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3VwYWJhc2VDb250ZXh0LmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cyQxLmNhcHR1cmVFeGNlcHRpb24oZXJyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cGFiYXNlOiBzdXBhYmFzZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGJyZWFkY3J1bWIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdXBhYmFzZScsXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBgZGIuJHtvcGVyYXRpb259YCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0ge307XG5cbiAgICAgICAgICAgICAgICAgIGlmIChxdWVyeUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnF1ZXJ5ID0gcXVlcnlJdGVtcztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGJvZHkpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFkY3J1bWIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFkY3J1bWJzLmFkZEJyZWFkY3J1bWIoYnJlYWRjcnVtYik7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoc3Bhbikge1xuICAgICAgICAgICAgICAgICAgICBzcGFuc3RhdHVzLnNldEh0dHBTdGF0dXMoc3BhbiwgNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC50aGVuKC4uLmFyZ3VtZW50c0xpc3QpO1xuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgIH0sXG4gICk7XG5cbiAgbWFya0FzSW5zdHJ1bWVudGVkKChQb3N0Z1JFU1RGaWx0ZXJCdWlsZGVyLnByb3RvdHlwZSApLnRoZW4pO1xufVxuXG5mdW5jdGlvbiBpbnN0cnVtZW50UG9zdGdSRVNUUXVlcnlCdWlsZGVyKFBvc3RnUkVTVFF1ZXJ5QnVpbGRlcikge1xuICAvLyBXZSBuZWVkIHRvIHdyYXAgX2FsbF8gb3BlcmF0aW9ucyBkZXNwaXRlIHRoZW0gc2hhcmluZyB0aGUgc2FtZSBgUG9zdGdSRVNURmlsdGVyQnVpbGRlcmBcbiAgLy8gY29uc3RydWN0b3IsIGFzIHdlIGRvbid0IGtub3cgd2hpY2ggbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGZpcnN0LCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBtaXNzIGFueSBjYWxscy5cbiAgZm9yIChjb25zdCBvcGVyYXRpb24gb2YgREJfT1BFUkFUSU9OU19UT19JTlNUUlVNRU5UKSB7XG4gICAgaWYgKGlzSW5zdHJ1bWVudGVkKChQb3N0Z1JFU1RRdWVyeUJ1aWxkZXIucHJvdG90eXBlIClbb3BlcmF0aW9uXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIChQb3N0Z1JFU1RRdWVyeUJ1aWxkZXIucHJvdG90eXBlIClbb3BlcmF0aW9uIF0gPSBuZXcgUHJveHkoXG4gICAgICAoUG9zdGdSRVNUUXVlcnlCdWlsZGVyLnByb3RvdHlwZSApW29wZXJhdGlvbiBdLFxuICAgICAge1xuICAgICAgICBhcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgICAgICBjb25zdCBydiA9IFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgICBjb25zdCBQb3N0Z1JFU1RGaWx0ZXJCdWlsZGVyID0gKHJ2ICkuY29uc3RydWN0b3I7XG5cbiAgICAgICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIubG9nKGBJbnN0cnVtZW50aW5nICR7b3BlcmF0aW9ufSBvcGVyYXRpb24ncyBQb3N0Z1JFU1RGaWx0ZXJCdWlsZGVyYCk7XG5cbiAgICAgICAgICBpbnN0cnVtZW50UG9zdGdSRVNURmlsdGVyQnVpbGRlcihQb3N0Z1JFU1RGaWx0ZXJCdWlsZGVyKTtcblxuICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIG1hcmtBc0luc3RydW1lbnRlZCgoUG9zdGdSRVNUUXVlcnlCdWlsZGVyLnByb3RvdHlwZSApW29wZXJhdGlvbl0pO1xuICB9XG59XG5cbmNvbnN0IGluc3RydW1lbnRTdXBhYmFzZUNsaWVudCA9IChzdXBhYmFzZUNsaWVudCkgPT4ge1xuICBpZiAoIXN1cGFiYXNlQ2xpZW50KSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLndhcm4oJ1N1cGFiYXNlIGludGVncmF0aW9uIHdhcyBub3QgaW5zdGFsbGVkIGJlY2F1c2Ugbm8gU3VwYWJhc2UgY2xpZW50IHdhcyBwcm92aWRlZC4nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgU3VwYWJhc2VDbGllbnRDb25zdHJ1Y3RvciA9XG4gICAgc3VwYWJhc2VDbGllbnQuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uID8gc3VwYWJhc2VDbGllbnQgOiBzdXBhYmFzZUNsaWVudC5jb25zdHJ1Y3RvcjtcblxuICBpbnN0cnVtZW50U3VwYWJhc2VDbGllbnRDb25zdHJ1Y3RvcihTdXBhYmFzZUNsaWVudENvbnN0cnVjdG9yKTtcbiAgaW5zdHJ1bWVudFN1cGFiYXNlQXV0aENsaWVudChzdXBhYmFzZUNsaWVudCApO1xufTtcblxuY29uc3QgSU5URUdSQVRJT05fTkFNRSA9ICdTdXBhYmFzZSc7XG5cbmNvbnN0IF9zdXBhYmFzZUludGVncmF0aW9uID0gKChzdXBhYmFzZUNsaWVudCkgPT4ge1xuICByZXR1cm4ge1xuICAgIHNldHVwT25jZSgpIHtcbiAgICAgIGluc3RydW1lbnRTdXBhYmFzZUNsaWVudChzdXBhYmFzZUNsaWVudCk7XG4gICAgfSxcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICB9O1xufSkgO1xuXG5jb25zdCBzdXBhYmFzZUludGVncmF0aW9uID0gaW50ZWdyYXRpb24uZGVmaW5lSW50ZWdyYXRpb24oKG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIF9zdXBhYmFzZUludGVncmF0aW9uKG9wdGlvbnMuc3VwYWJhc2VDbGllbnQpO1xufSkgO1xuXG5leHBvcnRzLkRCX09QRVJBVElPTlNfVE9fSU5TVFJVTUVOVCA9IERCX09QRVJBVElPTlNfVE9fSU5TVFJVTUVOVDtcbmV4cG9ydHMuRklMVEVSX01BUFBJTkdTID0gRklMVEVSX01BUFBJTkdTO1xuZXhwb3J0cy5leHRyYWN0T3BlcmF0aW9uID0gZXh0cmFjdE9wZXJhdGlvbjtcbmV4cG9ydHMuaW5zdHJ1bWVudFN1cGFiYXNlQ2xpZW50ID0gaW5zdHJ1bWVudFN1cGFiYXNlQ2xpZW50O1xuZXhwb3J0cy5zdXBhYmFzZUludGVncmF0aW9uID0gc3VwYWJhc2VJbnRlZ3JhdGlvbjtcbmV4cG9ydHMudHJhbnNsYXRlRmlsdGVyc0ludG9NZXRob2RzID0gdHJhbnNsYXRlRmlsdGVyc0ludG9NZXRob2RzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3VwYWJhc2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/supabase.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/third-party-errors-filter.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\");\nconst metadata = __webpack_require__(/*! ../metadata.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/metadata.js\");\nconst envelope = __webpack_require__(/*! ../utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\nconst stacktrace = __webpack_require__(/*! ../utils-hoist/stacktrace.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/stacktrace.js\");\n\n/**\n * This integration allows you to filter out, or tag error events that do not come from user code marked with a bundle key via the Sentry bundler plugins.\n */\nconst thirdPartyErrorFilterIntegration = integration.defineIntegration((options) => {\n  return {\n    name: 'ThirdPartyErrorsFilter',\n    setup(client) {\n      // We need to strip metadata from stack frames before sending them to Sentry since these are client side only.\n      // TODO(lforst): Move this cleanup logic into a more central place in the SDK.\n      client.on('beforeEnvelope', envelope$1 => {\n        envelope.forEachEnvelopeItem(envelope$1, (item, type) => {\n          if (type === 'event') {\n            const event = Array.isArray(item) ? (item )[1] : undefined;\n\n            if (event) {\n              metadata.stripMetadataFromStackFrames(event);\n              item[1] = event;\n            }\n          }\n        });\n      });\n\n      client.on('applyFrameMetadata', event => {\n        // Only apply stack frame metadata to error events\n        if (event.type) {\n          return;\n        }\n\n        const stackParser = client.getOptions().stackParser;\n        metadata.addMetadataToStackFrames(stackParser, event);\n      });\n    },\n\n    processEvent(event) {\n      const frameKeys = getBundleKeysForAllFramesWithFilenames(event);\n\n      if (frameKeys) {\n        const arrayMethod =\n          options.behaviour === 'drop-error-if-contains-third-party-frames' ||\n          options.behaviour === 'apply-tag-if-contains-third-party-frames'\n            ? 'some'\n            : 'every';\n\n        const behaviourApplies = frameKeys[arrayMethod](keys => !keys.some(key => options.filterKeys.includes(key)));\n\n        if (behaviourApplies) {\n          const shouldDrop =\n            options.behaviour === 'drop-error-if-contains-third-party-frames' ||\n            options.behaviour === 'drop-error-if-exclusively-contains-third-party-frames';\n          if (shouldDrop) {\n            return null;\n          } else {\n            event.tags = {\n              ...event.tags,\n              third_party_code: true,\n            };\n          }\n        }\n      }\n\n      return event;\n    },\n  };\n});\n\nfunction getBundleKeysForAllFramesWithFilenames(event) {\n  const frames = stacktrace.getFramesFromEvent(event);\n\n  if (!frames) {\n    return undefined;\n  }\n\n  return (\n    frames\n      // Exclude frames without a filename since these are likely native code or built-ins\n      .filter(frame => !!frame.filename)\n      .map(frame => {\n        if (frame.module_metadata) {\n          return Object.keys(frame.module_metadata)\n            .filter(key => key.startsWith(BUNDLER_PLUGIN_APP_KEY_PREFIX))\n            .map(key => key.slice(BUNDLER_PLUGIN_APP_KEY_PREFIX.length));\n        }\n        return [];\n      })\n  );\n}\n\nconst BUNDLER_PLUGIN_APP_KEY_PREFIX = '_sentryBundlerPluginAppKey:';\n\nexports.thirdPartyErrorFilterIntegration = thirdPartyErrorFilterIntegration;\n//# sourceMappingURL=third-party-errors-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb25zL3RoaXJkLXBhcnR5LWVycm9ycy1maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsb0JBQW9CLG1CQUFPLENBQUMsaUhBQW1CO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLDJHQUFnQjtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQyxtSUFBNEI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsdUlBQThCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsd0NBQXdDO0FBQ3hDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcaW50ZWdyYXRpb25zXFx0aGlyZC1wYXJ0eS1lcnJvcnMtZmlsdGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBpbnRlZ3JhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVncmF0aW9uLmpzJyk7XG5jb25zdCBtZXRhZGF0YSA9IHJlcXVpcmUoJy4uL21ldGFkYXRhLmpzJyk7XG5jb25zdCBlbnZlbG9wZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2VudmVsb3BlLmpzJyk7XG5jb25zdCBzdGFja3RyYWNlID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvc3RhY2t0cmFjZS5qcycpO1xuXG4vKipcbiAqIFRoaXMgaW50ZWdyYXRpb24gYWxsb3dzIHlvdSB0byBmaWx0ZXIgb3V0LCBvciB0YWcgZXJyb3IgZXZlbnRzIHRoYXQgZG8gbm90IGNvbWUgZnJvbSB1c2VyIGNvZGUgbWFya2VkIHdpdGggYSBidW5kbGUga2V5IHZpYSB0aGUgU2VudHJ5IGJ1bmRsZXIgcGx1Z2lucy5cbiAqL1xuY29uc3QgdGhpcmRQYXJ0eUVycm9yRmlsdGVySW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbi5kZWZpbmVJbnRlZ3JhdGlvbigob3B0aW9ucykgPT4ge1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdUaGlyZFBhcnR5RXJyb3JzRmlsdGVyJyxcbiAgICBzZXR1cChjbGllbnQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gc3RyaXAgbWV0YWRhdGEgZnJvbSBzdGFjayBmcmFtZXMgYmVmb3JlIHNlbmRpbmcgdGhlbSB0byBTZW50cnkgc2luY2UgdGhlc2UgYXJlIGNsaWVudCBzaWRlIG9ubHkuXG4gICAgICAvLyBUT0RPKGxmb3JzdCk6IE1vdmUgdGhpcyBjbGVhbnVwIGxvZ2ljIGludG8gYSBtb3JlIGNlbnRyYWwgcGxhY2UgaW4gdGhlIFNESy5cbiAgICAgIGNsaWVudC5vbignYmVmb3JlRW52ZWxvcGUnLCBlbnZlbG9wZSQxID0+IHtcbiAgICAgICAgZW52ZWxvcGUuZm9yRWFjaEVudmVsb3BlSXRlbShlbnZlbG9wZSQxLCAoaXRlbSwgdHlwZSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnZXZlbnQnKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyAoaXRlbSApWzFdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgbWV0YWRhdGEuc3RyaXBNZXRhZGF0YUZyb21TdGFja0ZyYW1lcyhldmVudCk7XG4gICAgICAgICAgICAgIGl0ZW1bMV0gPSBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNsaWVudC5vbignYXBwbHlGcmFtZU1ldGFkYXRhJywgZXZlbnQgPT4ge1xuICAgICAgICAvLyBPbmx5IGFwcGx5IHN0YWNrIGZyYW1lIG1ldGFkYXRhIHRvIGVycm9yIGV2ZW50c1xuICAgICAgICBpZiAoZXZlbnQudHlwZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YWNrUGFyc2VyID0gY2xpZW50LmdldE9wdGlvbnMoKS5zdGFja1BhcnNlcjtcbiAgICAgICAgbWV0YWRhdGEuYWRkTWV0YWRhdGFUb1N0YWNrRnJhbWVzKHN0YWNrUGFyc2VyLCBldmVudCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcHJvY2Vzc0V2ZW50KGV2ZW50KSB7XG4gICAgICBjb25zdCBmcmFtZUtleXMgPSBnZXRCdW5kbGVLZXlzRm9yQWxsRnJhbWVzV2l0aEZpbGVuYW1lcyhldmVudCk7XG5cbiAgICAgIGlmIChmcmFtZUtleXMpIHtcbiAgICAgICAgY29uc3QgYXJyYXlNZXRob2QgPVxuICAgICAgICAgIG9wdGlvbnMuYmVoYXZpb3VyID09PSAnZHJvcC1lcnJvci1pZi1jb250YWlucy10aGlyZC1wYXJ0eS1mcmFtZXMnIHx8XG4gICAgICAgICAgb3B0aW9ucy5iZWhhdmlvdXIgPT09ICdhcHBseS10YWctaWYtY29udGFpbnMtdGhpcmQtcGFydHktZnJhbWVzJ1xuICAgICAgICAgICAgPyAnc29tZSdcbiAgICAgICAgICAgIDogJ2V2ZXJ5JztcblxuICAgICAgICBjb25zdCBiZWhhdmlvdXJBcHBsaWVzID0gZnJhbWVLZXlzW2FycmF5TWV0aG9kXShrZXlzID0+ICFrZXlzLnNvbWUoa2V5ID0+IG9wdGlvbnMuZmlsdGVyS2V5cy5pbmNsdWRlcyhrZXkpKSk7XG5cbiAgICAgICAgaWYgKGJlaGF2aW91ckFwcGxpZXMpIHtcbiAgICAgICAgICBjb25zdCBzaG91bGREcm9wID1cbiAgICAgICAgICAgIG9wdGlvbnMuYmVoYXZpb3VyID09PSAnZHJvcC1lcnJvci1pZi1jb250YWlucy10aGlyZC1wYXJ0eS1mcmFtZXMnIHx8XG4gICAgICAgICAgICBvcHRpb25zLmJlaGF2aW91ciA9PT0gJ2Ryb3AtZXJyb3ItaWYtZXhjbHVzaXZlbHktY29udGFpbnMtdGhpcmQtcGFydHktZnJhbWVzJztcbiAgICAgICAgICBpZiAoc2hvdWxkRHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50LnRhZ3MgPSB7XG4gICAgICAgICAgICAgIC4uLmV2ZW50LnRhZ3MsXG4gICAgICAgICAgICAgIHRoaXJkX3BhcnR5X2NvZGU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfSxcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRCdW5kbGVLZXlzRm9yQWxsRnJhbWVzV2l0aEZpbGVuYW1lcyhldmVudCkge1xuICBjb25zdCBmcmFtZXMgPSBzdGFja3RyYWNlLmdldEZyYW1lc0Zyb21FdmVudChldmVudCk7XG5cbiAgaWYgKCFmcmFtZXMpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBmcmFtZXNcbiAgICAgIC8vIEV4Y2x1ZGUgZnJhbWVzIHdpdGhvdXQgYSBmaWxlbmFtZSBzaW5jZSB0aGVzZSBhcmUgbGlrZWx5IG5hdGl2ZSBjb2RlIG9yIGJ1aWx0LWluc1xuICAgICAgLmZpbHRlcihmcmFtZSA9PiAhIWZyYW1lLmZpbGVuYW1lKVxuICAgICAgLm1hcChmcmFtZSA9PiB7XG4gICAgICAgIGlmIChmcmFtZS5tb2R1bGVfbWV0YWRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZnJhbWUubW9kdWxlX21ldGFkYXRhKVxuICAgICAgICAgICAgLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoQlVORExFUl9QTFVHSU5fQVBQX0tFWV9QUkVGSVgpKVxuICAgICAgICAgICAgLm1hcChrZXkgPT4ga2V5LnNsaWNlKEJVTkRMRVJfUExVR0lOX0FQUF9LRVlfUFJFRklYLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0pXG4gICk7XG59XG5cbmNvbnN0IEJVTkRMRVJfUExVR0lOX0FQUF9LRVlfUFJFRklYID0gJ19zZW50cnlCdW5kbGVyUGx1Z2luQXBwS2V5Oic7XG5cbmV4cG9ydHMudGhpcmRQYXJ0eUVycm9yRmlsdGVySW50ZWdyYXRpb24gPSB0aGlyZFBhcnR5RXJyb3JGaWx0ZXJJbnRlZ3JhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRoaXJkLXBhcnR5LWVycm9ycy1maWx0ZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/third-party-errors-filter.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/zoderrors.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\");\nconst is = __webpack_require__(/*! ../utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst string = __webpack_require__(/*! ../utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\n\nconst DEFAULT_LIMIT = 10;\nconst INTEGRATION_NAME = 'ZodErrors';\n\n/**\n * Simplified ZodIssue type definition\n */\n\nfunction originalExceptionIsZodError(originalException) {\n  return (\n    is.isError(originalException) &&\n    originalException.name === 'ZodError' &&\n    Array.isArray((originalException ).issues)\n  );\n}\n\n/**\n * Formats child objects or arrays to a string\n * that is preserved when sent to Sentry.\n *\n * Without this, we end up with something like this in Sentry:\n *\n * [\n *  [Object],\n *  [Object],\n *  [Object],\n *  [Object]\n * ]\n */\nfunction flattenIssue(issue) {\n  return {\n    ...issue,\n    path: 'path' in issue && Array.isArray(issue.path) ? issue.path.join('.') : undefined,\n    keys: 'keys' in issue ? JSON.stringify(issue.keys) : undefined,\n    unionErrors: 'unionErrors' in issue ? JSON.stringify(issue.unionErrors) : undefined,\n  };\n}\n\n/**\n * Takes ZodError issue path array and returns a flattened version as a string.\n * This makes it easier to display paths within a Sentry error message.\n *\n * Array indexes are normalized to reduce duplicate entries\n *\n * @param path ZodError issue path\n * @returns flattened path\n *\n * @example\n * flattenIssuePath([0, 'foo', 1, 'bar']) // -> '<array>.foo.<array>.bar'\n */\nfunction flattenIssuePath(path) {\n  return path\n    .map(p => {\n      if (typeof p === 'number') {\n        return '<array>';\n      } else {\n        return p;\n      }\n    })\n    .join('.');\n}\n\n/**\n * Zod error message is a stringified version of ZodError.issues\n * This doesn't display well in the Sentry UI. Replace it with something shorter.\n */\nfunction formatIssueMessage(zodError) {\n  const errorKeyMap = new Set();\n  for (const iss of zodError.issues) {\n    const issuePath = flattenIssuePath(iss.path);\n    if (issuePath.length > 0) {\n      errorKeyMap.add(issuePath);\n    }\n  }\n\n  const errorKeys = Array.from(errorKeyMap);\n  if (errorKeys.length === 0) {\n    // If there are no keys, then we're likely validating the root\n    // variable rather than a key within an object. This attempts\n    // to extract what type it was that failed to validate.\n    // For example, z.string().parse(123) would return \"string\" here.\n    let rootExpectedType = 'variable';\n    if (zodError.issues.length > 0) {\n      const iss = zodError.issues[0];\n      if (iss !== undefined && 'expected' in iss && typeof iss.expected === 'string') {\n        rootExpectedType = iss.expected;\n      }\n    }\n    return `Failed to validate ${rootExpectedType}`;\n  }\n  return `Failed to validate keys: ${string.truncate(errorKeys.join(', '), 100)}`;\n}\n\n/**\n * Applies ZodError issues to an event extra and replaces the error message\n */\nfunction applyZodErrorsToEvent(\n  limit,\n  saveZodIssuesAsAttachment = false,\n  event,\n  hint,\n) {\n  if (\n    !event.exception?.values ||\n    !hint.originalException ||\n    !originalExceptionIsZodError(hint.originalException) ||\n    hint.originalException.issues.length === 0\n  ) {\n    return event;\n  }\n\n  try {\n    const issuesToFlatten = saveZodIssuesAsAttachment\n      ? hint.originalException.issues\n      : hint.originalException.issues.slice(0, limit);\n    const flattenedIssues = issuesToFlatten.map(flattenIssue);\n\n    if (saveZodIssuesAsAttachment) {\n      // Sometimes having the full error details can be helpful.\n      // Attachments have much higher limits, so we can include the full list of issues.\n      if (!Array.isArray(hint.attachments)) {\n        hint.attachments = [];\n      }\n      hint.attachments.push({\n        filename: 'zod_issues.json',\n        data: JSON.stringify({\n          issues: flattenedIssues,\n        }),\n      });\n    }\n\n    return {\n      ...event,\n      exception: {\n        ...event.exception,\n        values: [\n          {\n            ...event.exception.values[0],\n            value: formatIssueMessage(hint.originalException),\n          },\n          ...event.exception.values.slice(1),\n        ],\n      },\n      extra: {\n        ...event.extra,\n        'zoderror.issues': flattenedIssues.slice(0, limit),\n      },\n    };\n  } catch (e) {\n    // Hopefully we never throw errors here, but record it\n    // with the event just in case.\n    return {\n      ...event,\n      extra: {\n        ...event.extra,\n        'zoderrors sentry integration parse error': {\n          message: 'an exception was thrown while processing ZodError within applyZodErrorsToEvent()',\n          error: e instanceof Error ? `${e.name}: ${e.message}\\n${e.stack}` : 'unknown',\n        },\n      },\n    };\n  }\n}\n\nconst _zodErrorsIntegration = ((options = {}) => {\n  const limit = options.limit ?? DEFAULT_LIMIT;\n\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(originalEvent, hint) {\n      const processedEvent = applyZodErrorsToEvent(limit, options.saveZodIssuesAsAttachment, originalEvent, hint);\n      return processedEvent;\n    },\n  };\n}) ;\n\n/**\n * Sentry integration to process Zod errors, making them easier to work with in Sentry.\n */\nconst zodErrorsIntegration = integration.defineIntegration(_zodErrorsIntegration);\n\nexports.applyZodErrorsToEvent = applyZodErrorsToEvent;\nexports.flattenIssue = flattenIssue;\nexports.flattenIssuePath = flattenIssuePath;\nexports.formatIssueMessage = formatIssueMessage;\nexports.zodErrorsIntegration = zodErrorsIntegration;\n//# sourceMappingURL=zoderrors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvaW50ZWdyYXRpb25zL3pvZGVycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxvQkFBb0IsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDL0MsV0FBVyxtQkFBTyxDQUFDLHVIQUFzQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMsK0hBQTBCOztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBLHFDQUFxQywyQ0FBMkM7QUFDaEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTyxJQUFJLFVBQVUsSUFBSSxRQUFRO0FBQzFFLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0Isb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcaW50ZWdyYXRpb25zXFx6b2RlcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGludGVncmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZWdyYXRpb24uanMnKTtcbmNvbnN0IGlzID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvaXMuanMnKTtcbmNvbnN0IHN0cmluZyA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3N0cmluZy5qcycpO1xuXG5jb25zdCBERUZBVUxUX0xJTUlUID0gMTA7XG5jb25zdCBJTlRFR1JBVElPTl9OQU1FID0gJ1pvZEVycm9ycyc7XG5cbi8qKlxuICogU2ltcGxpZmllZCBab2RJc3N1ZSB0eXBlIGRlZmluaXRpb25cbiAqL1xuXG5mdW5jdGlvbiBvcmlnaW5hbEV4Y2VwdGlvbklzWm9kRXJyb3Iob3JpZ2luYWxFeGNlcHRpb24pIHtcbiAgcmV0dXJuIChcbiAgICBpcy5pc0Vycm9yKG9yaWdpbmFsRXhjZXB0aW9uKSAmJlxuICAgIG9yaWdpbmFsRXhjZXB0aW9uLm5hbWUgPT09ICdab2RFcnJvcicgJiZcbiAgICBBcnJheS5pc0FycmF5KChvcmlnaW5hbEV4Y2VwdGlvbiApLmlzc3VlcylcbiAgKTtcbn1cblxuLyoqXG4gKiBGb3JtYXRzIGNoaWxkIG9iamVjdHMgb3IgYXJyYXlzIHRvIGEgc3RyaW5nXG4gKiB0aGF0IGlzIHByZXNlcnZlZCB3aGVuIHNlbnQgdG8gU2VudHJ5LlxuICpcbiAqIFdpdGhvdXQgdGhpcywgd2UgZW5kIHVwIHdpdGggc29tZXRoaW5nIGxpa2UgdGhpcyBpbiBTZW50cnk6XG4gKlxuICogW1xuICogIFtPYmplY3RdLFxuICogIFtPYmplY3RdLFxuICogIFtPYmplY3RdLFxuICogIFtPYmplY3RdXG4gKiBdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5Jc3N1ZShpc3N1ZSkge1xuICByZXR1cm4ge1xuICAgIC4uLmlzc3VlLFxuICAgIHBhdGg6ICdwYXRoJyBpbiBpc3N1ZSAmJiBBcnJheS5pc0FycmF5KGlzc3VlLnBhdGgpID8gaXNzdWUucGF0aC5qb2luKCcuJykgOiB1bmRlZmluZWQsXG4gICAga2V5czogJ2tleXMnIGluIGlzc3VlID8gSlNPTi5zdHJpbmdpZnkoaXNzdWUua2V5cykgOiB1bmRlZmluZWQsXG4gICAgdW5pb25FcnJvcnM6ICd1bmlvbkVycm9ycycgaW4gaXNzdWUgPyBKU09OLnN0cmluZ2lmeShpc3N1ZS51bmlvbkVycm9ycykgOiB1bmRlZmluZWQsXG4gIH07XG59XG5cbi8qKlxuICogVGFrZXMgWm9kRXJyb3IgaXNzdWUgcGF0aCBhcnJheSBhbmQgcmV0dXJucyBhIGZsYXR0ZW5lZCB2ZXJzaW9uIGFzIGEgc3RyaW5nLlxuICogVGhpcyBtYWtlcyBpdCBlYXNpZXIgdG8gZGlzcGxheSBwYXRocyB3aXRoaW4gYSBTZW50cnkgZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBBcnJheSBpbmRleGVzIGFyZSBub3JtYWxpemVkIHRvIHJlZHVjZSBkdXBsaWNhdGUgZW50cmllc1xuICpcbiAqIEBwYXJhbSBwYXRoIFpvZEVycm9yIGlzc3VlIHBhdGhcbiAqIEByZXR1cm5zIGZsYXR0ZW5lZCBwYXRoXG4gKlxuICogQGV4YW1wbGVcbiAqIGZsYXR0ZW5Jc3N1ZVBhdGgoWzAsICdmb28nLCAxLCAnYmFyJ10pIC8vIC0+ICc8YXJyYXk+LmZvby48YXJyYXk+LmJhcidcbiAqL1xuZnVuY3Rpb24gZmxhdHRlbklzc3VlUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoXG4gICAgLm1hcChwID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuICc8YXJyYXk+JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmpvaW4oJy4nKTtcbn1cblxuLyoqXG4gKiBab2QgZXJyb3IgbWVzc2FnZSBpcyBhIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgWm9kRXJyb3IuaXNzdWVzXG4gKiBUaGlzIGRvZXNuJ3QgZGlzcGxheSB3ZWxsIGluIHRoZSBTZW50cnkgVUkuIFJlcGxhY2UgaXQgd2l0aCBzb21ldGhpbmcgc2hvcnRlci5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0SXNzdWVNZXNzYWdlKHpvZEVycm9yKSB7XG4gIGNvbnN0IGVycm9yS2V5TWFwID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IGlzcyBvZiB6b2RFcnJvci5pc3N1ZXMpIHtcbiAgICBjb25zdCBpc3N1ZVBhdGggPSBmbGF0dGVuSXNzdWVQYXRoKGlzcy5wYXRoKTtcbiAgICBpZiAoaXNzdWVQYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgIGVycm9yS2V5TWFwLmFkZChpc3N1ZVBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVycm9yS2V5cyA9IEFycmF5LmZyb20oZXJyb3JLZXlNYXApO1xuICBpZiAoZXJyb3JLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyBrZXlzLCB0aGVuIHdlJ3JlIGxpa2VseSB2YWxpZGF0aW5nIHRoZSByb290XG4gICAgLy8gdmFyaWFibGUgcmF0aGVyIHRoYW4gYSBrZXkgd2l0aGluIGFuIG9iamVjdC4gVGhpcyBhdHRlbXB0c1xuICAgIC8vIHRvIGV4dHJhY3Qgd2hhdCB0eXBlIGl0IHdhcyB0aGF0IGZhaWxlZCB0byB2YWxpZGF0ZS5cbiAgICAvLyBGb3IgZXhhbXBsZSwgei5zdHJpbmcoKS5wYXJzZSgxMjMpIHdvdWxkIHJldHVybiBcInN0cmluZ1wiIGhlcmUuXG4gICAgbGV0IHJvb3RFeHBlY3RlZFR5cGUgPSAndmFyaWFibGUnO1xuICAgIGlmICh6b2RFcnJvci5pc3N1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaXNzID0gem9kRXJyb3IuaXNzdWVzWzBdO1xuICAgICAgaWYgKGlzcyAhPT0gdW5kZWZpbmVkICYmICdleHBlY3RlZCcgaW4gaXNzICYmIHR5cGVvZiBpc3MuZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJvb3RFeHBlY3RlZFR5cGUgPSBpc3MuZXhwZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgRmFpbGVkIHRvIHZhbGlkYXRlICR7cm9vdEV4cGVjdGVkVHlwZX1gO1xuICB9XG4gIHJldHVybiBgRmFpbGVkIHRvIHZhbGlkYXRlIGtleXM6ICR7c3RyaW5nLnRydW5jYXRlKGVycm9yS2V5cy5qb2luKCcsICcpLCAxMDApfWA7XG59XG5cbi8qKlxuICogQXBwbGllcyBab2RFcnJvciBpc3N1ZXMgdG8gYW4gZXZlbnQgZXh0cmEgYW5kIHJlcGxhY2VzIHRoZSBlcnJvciBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Wm9kRXJyb3JzVG9FdmVudChcbiAgbGltaXQsXG4gIHNhdmVab2RJc3N1ZXNBc0F0dGFjaG1lbnQgPSBmYWxzZSxcbiAgZXZlbnQsXG4gIGhpbnQsXG4pIHtcbiAgaWYgKFxuICAgICFldmVudC5leGNlcHRpb24/LnZhbHVlcyB8fFxuICAgICFoaW50Lm9yaWdpbmFsRXhjZXB0aW9uIHx8XG4gICAgIW9yaWdpbmFsRXhjZXB0aW9uSXNab2RFcnJvcihoaW50Lm9yaWdpbmFsRXhjZXB0aW9uKSB8fFxuICAgIGhpbnQub3JpZ2luYWxFeGNlcHRpb24uaXNzdWVzLmxlbmd0aCA9PT0gMFxuICApIHtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGlzc3Vlc1RvRmxhdHRlbiA9IHNhdmVab2RJc3N1ZXNBc0F0dGFjaG1lbnRcbiAgICAgID8gaGludC5vcmlnaW5hbEV4Y2VwdGlvbi5pc3N1ZXNcbiAgICAgIDogaGludC5vcmlnaW5hbEV4Y2VwdGlvbi5pc3N1ZXMuc2xpY2UoMCwgbGltaXQpO1xuICAgIGNvbnN0IGZsYXR0ZW5lZElzc3VlcyA9IGlzc3Vlc1RvRmxhdHRlbi5tYXAoZmxhdHRlbklzc3VlKTtcblxuICAgIGlmIChzYXZlWm9kSXNzdWVzQXNBdHRhY2htZW50KSB7XG4gICAgICAvLyBTb21ldGltZXMgaGF2aW5nIHRoZSBmdWxsIGVycm9yIGRldGFpbHMgY2FuIGJlIGhlbHBmdWwuXG4gICAgICAvLyBBdHRhY2htZW50cyBoYXZlIG11Y2ggaGlnaGVyIGxpbWl0cywgc28gd2UgY2FuIGluY2x1ZGUgdGhlIGZ1bGwgbGlzdCBvZiBpc3N1ZXMuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGludC5hdHRhY2htZW50cykpIHtcbiAgICAgICAgaGludC5hdHRhY2htZW50cyA9IFtdO1xuICAgICAgfVxuICAgICAgaGludC5hdHRhY2htZW50cy5wdXNoKHtcbiAgICAgICAgZmlsZW5hbWU6ICd6b2RfaXNzdWVzLmpzb24nLFxuICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaXNzdWVzOiBmbGF0dGVuZWRJc3N1ZXMsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmV2ZW50LFxuICAgICAgZXhjZXB0aW9uOiB7XG4gICAgICAgIC4uLmV2ZW50LmV4Y2VwdGlvbixcbiAgICAgICAgdmFsdWVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uZXZlbnQuZXhjZXB0aW9uLnZhbHVlc1swXSxcbiAgICAgICAgICAgIHZhbHVlOiBmb3JtYXRJc3N1ZU1lc3NhZ2UoaGludC5vcmlnaW5hbEV4Y2VwdGlvbiksXG4gICAgICAgICAgfSxcbiAgICAgICAgICAuLi5ldmVudC5leGNlcHRpb24udmFsdWVzLnNsaWNlKDEpLFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIGV4dHJhOiB7XG4gICAgICAgIC4uLmV2ZW50LmV4dHJhLFxuICAgICAgICAnem9kZXJyb3IuaXNzdWVzJzogZmxhdHRlbmVkSXNzdWVzLnNsaWNlKDAsIGxpbWl0KSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEhvcGVmdWxseSB3ZSBuZXZlciB0aHJvdyBlcnJvcnMgaGVyZSwgYnV0IHJlY29yZCBpdFxuICAgIC8vIHdpdGggdGhlIGV2ZW50IGp1c3QgaW4gY2FzZS5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZXZlbnQsXG4gICAgICBleHRyYToge1xuICAgICAgICAuLi5ldmVudC5leHRyYSxcbiAgICAgICAgJ3pvZGVycm9ycyBzZW50cnkgaW50ZWdyYXRpb24gcGFyc2UgZXJyb3InOiB7XG4gICAgICAgICAgbWVzc2FnZTogJ2FuIGV4Y2VwdGlvbiB3YXMgdGhyb3duIHdoaWxlIHByb2Nlc3NpbmcgWm9kRXJyb3Igd2l0aGluIGFwcGx5Wm9kRXJyb3JzVG9FdmVudCgpJyxcbiAgICAgICAgICBlcnJvcjogZSBpbnN0YW5jZW9mIEVycm9yID8gYCR7ZS5uYW1lfTogJHtlLm1lc3NhZ2V9XFxuJHtlLnN0YWNrfWAgOiAndW5rbm93bicsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cblxuY29uc3QgX3pvZEVycm9yc0ludGVncmF0aW9uID0gKChvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgbGltaXQgPSBvcHRpb25zLmxpbWl0ID8/IERFRkFVTFRfTElNSVQ7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHByb2Nlc3NFdmVudChvcmlnaW5hbEV2ZW50LCBoaW50KSB7XG4gICAgICBjb25zdCBwcm9jZXNzZWRFdmVudCA9IGFwcGx5Wm9kRXJyb3JzVG9FdmVudChsaW1pdCwgb3B0aW9ucy5zYXZlWm9kSXNzdWVzQXNBdHRhY2htZW50LCBvcmlnaW5hbEV2ZW50LCBoaW50KTtcbiAgICAgIHJldHVybiBwcm9jZXNzZWRFdmVudDtcbiAgICB9LFxuICB9O1xufSkgO1xuXG4vKipcbiAqIFNlbnRyeSBpbnRlZ3JhdGlvbiB0byBwcm9jZXNzIFpvZCBlcnJvcnMsIG1ha2luZyB0aGVtIGVhc2llciB0byB3b3JrIHdpdGggaW4gU2VudHJ5LlxuICovXG5jb25zdCB6b2RFcnJvcnNJbnRlZ3JhdGlvbiA9IGludGVncmF0aW9uLmRlZmluZUludGVncmF0aW9uKF96b2RFcnJvcnNJbnRlZ3JhdGlvbik7XG5cbmV4cG9ydHMuYXBwbHlab2RFcnJvcnNUb0V2ZW50ID0gYXBwbHlab2RFcnJvcnNUb0V2ZW50O1xuZXhwb3J0cy5mbGF0dGVuSXNzdWUgPSBmbGF0dGVuSXNzdWU7XG5leHBvcnRzLmZsYXR0ZW5Jc3N1ZVBhdGggPSBmbGF0dGVuSXNzdWVQYXRoO1xuZXhwb3J0cy5mb3JtYXRJc3N1ZU1lc3NhZ2UgPSBmb3JtYXRJc3N1ZU1lc3NhZ2U7XG5leHBvcnRzLnpvZEVycm9yc0ludGVncmF0aW9uID0gem9kRXJyb3JzSW50ZWdyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD16b2RlcnJvcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integrations/zoderrors.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/console-integration.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst integration = __webpack_require__(/*! ../integration.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/integration.js\");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\nconst console = __webpack_require__(/*! ../utils-hoist/instrument/console.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/console.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst string = __webpack_require__(/*! ../utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\nconst worldwide = __webpack_require__(/*! ../utils-hoist/worldwide.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js\");\nconst exports$1 = __webpack_require__(/*! ./exports.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/exports.js\");\n\nconst INTEGRATION_NAME = 'ConsoleLogs';\n\nconst DEFAULT_ATTRIBUTES = {\n  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.console.logging',\n};\n\nconst _consoleLoggingIntegration = ((options = {}) => {\n  const levels = options.levels || logger.CONSOLE_LEVELS;\n\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      if (!client.getOptions()._experiments?.enableLogs) {\n        debugBuild.DEBUG_BUILD && logger.logger.warn('`_experiments.enableLogs` is not enabled, ConsoleLogs integration disabled');\n        return;\n      }\n\n      console.addConsoleInstrumentationHandler(({ args, level }) => {\n        if (currentScopes.getClient() !== client || !levels.includes(level)) {\n          return;\n        }\n\n        if (level === 'assert') {\n          if (!args[0]) {\n            const followingArgs = args.slice(1);\n            const message =\n              followingArgs.length > 0 ? `Assertion failed: ${formatConsoleArgs(followingArgs)}` : 'Assertion failed';\n            exports$1._INTERNAL_captureLog({ level: 'error', message, attributes: DEFAULT_ATTRIBUTES });\n          }\n          return;\n        }\n\n        const isLevelLog = level === 'log';\n        exports$1._INTERNAL_captureLog({\n          level: isLevelLog ? 'info' : level,\n          message: formatConsoleArgs(args),\n          severityNumber: isLevelLog ? 10 : undefined,\n          attributes: DEFAULT_ATTRIBUTES,\n        });\n      });\n    },\n  };\n}) ;\n\n/**\n * Captures calls to the `console` API as logs in Sentry. Requires `_experiments.enableLogs` to be enabled.\n *\n * @experimental This feature is experimental and may be changed or removed in future versions.\n *\n * By default the integration instruments `console.debug`, `console.info`, `console.warn`, `console.error`,\n * `console.log`, `console.trace`, and `console.assert`. You can use the `levels` option to customize which\n * levels are captured.\n *\n * @example\n *\n * ```ts\n * import * as Sentry from '@sentry/browser';\n *\n * Sentry.init({\n *   integrations: [Sentry.consoleLoggingIntegration({ levels: ['error', 'warn'] })],\n * });\n * ```\n */\nconst consoleLoggingIntegration = integration.defineIntegration(_consoleLoggingIntegration);\n\nfunction formatConsoleArgs(values) {\n  return 'util' in worldwide.GLOBAL_OBJ && typeof (worldwide.GLOBAL_OBJ ).util.format === 'function'\n    ? (worldwide.GLOBAL_OBJ ).util.format(...values)\n    : string.safeJoin(values, ' ');\n}\n\nexports.consoleLoggingIntegration = consoleLoggingIntegration;\n//# sourceMappingURL=console-integration.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvbG9ncy9jb25zb2xlLWludGVncmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLHNCQUFzQixtQkFBTyxDQUFDLHFIQUFxQjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsaUhBQW1CO0FBQy9DLDJCQUEyQixtQkFBTyxDQUFDLCtIQUEwQjtBQUM3RCxnQkFBZ0IsbUJBQU8sQ0FBQyx1SkFBc0M7QUFDOUQsZUFBZSxtQkFBTyxDQUFDLCtIQUEwQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsK0hBQTBCO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLHFJQUE2QjtBQUN2RCxrQkFBa0IsbUJBQU8sQ0FBQyw2R0FBYzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUNBQWlDO0FBQy9GLDZDQUE2Qyx5REFBeUQ7QUFDdEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkJBQTJCO0FBQ2xGLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxsb2dzXFxjb25zb2xlLWludGVncmF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi4vY3VycmVudFNjb3Blcy5qcycpO1xuY29uc3QgZGVidWdCdWlsZCA9IHJlcXVpcmUoJy4uL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBpbnRlZ3JhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVncmF0aW9uLmpzJyk7XG5jb25zdCBzZW1hbnRpY0F0dHJpYnV0ZXMgPSByZXF1aXJlKCcuLi9zZW1hbnRpY0F0dHJpYnV0ZXMuanMnKTtcbmNvbnN0IGNvbnNvbGUgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9pbnN0cnVtZW50L2NvbnNvbGUuanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuY29uc3Qgc3RyaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvc3RyaW5nLmpzJyk7XG5jb25zdCB3b3JsZHdpZGUgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC93b3JsZHdpZGUuanMnKTtcbmNvbnN0IGV4cG9ydHMkMSA9IHJlcXVpcmUoJy4vZXhwb3J0cy5qcycpO1xuXG5jb25zdCBJTlRFR1JBVElPTl9OQU1FID0gJ0NvbnNvbGVMb2dzJztcblxuY29uc3QgREVGQVVMVF9BVFRSSUJVVEVTID0ge1xuICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXTogJ2F1dG8uY29uc29sZS5sb2dnaW5nJyxcbn07XG5cbmNvbnN0IF9jb25zb2xlTG9nZ2luZ0ludGVncmF0aW9uID0gKChvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgbGV2ZWxzID0gb3B0aW9ucy5sZXZlbHMgfHwgbG9nZ2VyLkNPTlNPTEVfTEVWRUxTO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogSU5URUdSQVRJT05fTkFNRSxcbiAgICBzZXR1cChjbGllbnQpIHtcbiAgICAgIGlmICghY2xpZW50LmdldE9wdGlvbnMoKS5fZXhwZXJpbWVudHM/LmVuYWJsZUxvZ3MpIHtcbiAgICAgICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLndhcm4oJ2BfZXhwZXJpbWVudHMuZW5hYmxlTG9nc2AgaXMgbm90IGVuYWJsZWQsIENvbnNvbGVMb2dzIGludGVncmF0aW9uIGRpc2FibGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5hZGRDb25zb2xlSW5zdHJ1bWVudGF0aW9uSGFuZGxlcigoeyBhcmdzLCBsZXZlbCB9KSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50U2NvcGVzLmdldENsaWVudCgpICE9PSBjbGllbnQgfHwgIWxldmVscy5pbmNsdWRlcyhsZXZlbCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGV2ZWwgPT09ICdhc3NlcnQnKSB7XG4gICAgICAgICAgaWYgKCFhcmdzWzBdKSB7XG4gICAgICAgICAgICBjb25zdCBmb2xsb3dpbmdBcmdzID0gYXJncy5zbGljZSgxKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICAgICBmb2xsb3dpbmdBcmdzLmxlbmd0aCA+IDAgPyBgQXNzZXJ0aW9uIGZhaWxlZDogJHtmb3JtYXRDb25zb2xlQXJncyhmb2xsb3dpbmdBcmdzKX1gIDogJ0Fzc2VydGlvbiBmYWlsZWQnO1xuICAgICAgICAgICAgZXhwb3J0cyQxLl9JTlRFUk5BTF9jYXB0dXJlTG9nKHsgbGV2ZWw6ICdlcnJvcicsIG1lc3NhZ2UsIGF0dHJpYnV0ZXM6IERFRkFVTFRfQVRUUklCVVRFUyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNMZXZlbExvZyA9IGxldmVsID09PSAnbG9nJztcbiAgICAgICAgZXhwb3J0cyQxLl9JTlRFUk5BTF9jYXB0dXJlTG9nKHtcbiAgICAgICAgICBsZXZlbDogaXNMZXZlbExvZyA/ICdpbmZvJyA6IGxldmVsLFxuICAgICAgICAgIG1lc3NhZ2U6IGZvcm1hdENvbnNvbGVBcmdzKGFyZ3MpLFxuICAgICAgICAgIHNldmVyaXR5TnVtYmVyOiBpc0xldmVsTG9nID8gMTAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgYXR0cmlidXRlczogREVGQVVMVF9BVFRSSUJVVEVTLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIH07XG59KSA7XG5cbi8qKlxuICogQ2FwdHVyZXMgY2FsbHMgdG8gdGhlIGBjb25zb2xlYCBBUEkgYXMgbG9ncyBpbiBTZW50cnkuIFJlcXVpcmVzIGBfZXhwZXJpbWVudHMuZW5hYmxlTG9nc2AgdG8gYmUgZW5hYmxlZC5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgZmVhdHVyZSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBiZSBjaGFuZ2VkIG9yIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxuICpcbiAqIEJ5IGRlZmF1bHQgdGhlIGludGVncmF0aW9uIGluc3RydW1lbnRzIGBjb25zb2xlLmRlYnVnYCwgYGNvbnNvbGUuaW5mb2AsIGBjb25zb2xlLndhcm5gLCBgY29uc29sZS5lcnJvcmAsXG4gKiBgY29uc29sZS5sb2dgLCBgY29uc29sZS50cmFjZWAsIGFuZCBgY29uc29sZS5hc3NlcnRgLiBZb3UgY2FuIHVzZSB0aGUgYGxldmVsc2Agb3B0aW9uIHRvIGN1c3RvbWl6ZSB3aGljaFxuICogbGV2ZWxzIGFyZSBjYXB0dXJlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgKiBhcyBTZW50cnkgZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbiAqXG4gKiBTZW50cnkuaW5pdCh7XG4gKiAgIGludGVncmF0aW9uczogW1NlbnRyeS5jb25zb2xlTG9nZ2luZ0ludGVncmF0aW9uKHsgbGV2ZWxzOiBbJ2Vycm9yJywgJ3dhcm4nXSB9KV0sXG4gKiB9KTtcbiAqIGBgYFxuICovXG5jb25zdCBjb25zb2xlTG9nZ2luZ0ludGVncmF0aW9uID0gaW50ZWdyYXRpb24uZGVmaW5lSW50ZWdyYXRpb24oX2NvbnNvbGVMb2dnaW5nSW50ZWdyYXRpb24pO1xuXG5mdW5jdGlvbiBmb3JtYXRDb25zb2xlQXJncyh2YWx1ZXMpIHtcbiAgcmV0dXJuICd1dGlsJyBpbiB3b3JsZHdpZGUuR0xPQkFMX09CSiAmJiB0eXBlb2YgKHdvcmxkd2lkZS5HTE9CQUxfT0JKICkudXRpbC5mb3JtYXQgPT09ICdmdW5jdGlvbidcbiAgICA/ICh3b3JsZHdpZGUuR0xPQkFMX09CSiApLnV0aWwuZm9ybWF0KC4uLnZhbHVlcylcbiAgICA6IHN0cmluZy5zYWZlSm9pbih2YWx1ZXMsICcgJyk7XG59XG5cbmV4cG9ydHMuY29uc29sZUxvZ2dpbmdJbnRlZ3JhdGlvbiA9IGNvbnNvbGVMb2dnaW5nSW50ZWdyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zb2xlLWludGVncmF0aW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/console-integration.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/constants.js":(__unused_webpack_module,exports)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\n/**\n * Maps a log severity level to a log severity number.\n *\n * @see LogSeverityLevel\n */\nconst SEVERITY_TEXT_TO_SEVERITY_NUMBER = {\n  trace: 1,\n  debug: 5,\n  info: 9,\n  warn: 13,\n  error: 17,\n  fatal: 21,\n};\n\nexports.SEVERITY_TEXT_TO_SEVERITY_NUMBER = SEVERITY_TEXT_TO_SEVERITY_NUMBER;\n//# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvbG9ncy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcbG9nc1xcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG4vKipcbiAqIE1hcHMgYSBsb2cgc2V2ZXJpdHkgbGV2ZWwgdG8gYSBsb2cgc2V2ZXJpdHkgbnVtYmVyLlxuICpcbiAqIEBzZWUgTG9nU2V2ZXJpdHlMZXZlbFxuICovXG5jb25zdCBTRVZFUklUWV9URVhUX1RPX1NFVkVSSVRZX05VTUJFUiA9IHtcbiAgdHJhY2U6IDEsXG4gIGRlYnVnOiA1LFxuICBpbmZvOiA5LFxuICB3YXJuOiAxMyxcbiAgZXJyb3I6IDE3LFxuICBmYXRhbDogMjEsXG59O1xuXG5leHBvcnRzLlNFVkVSSVRZX1RFWFRfVE9fU0VWRVJJVFlfTlVNQkVSID0gU0VWRVJJVFlfVEVYVF9UT19TRVZFUklUWV9OVU1CRVI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/constants.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/envelope.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst dsn = __webpack_require__(/*! ../utils-hoist/dsn.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/dsn.js\");\nconst envelope = __webpack_require__(/*! ../utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\n\n/**\n * Creates a log container envelope item for a list of logs.\n *\n * @param items - The logs to include in the envelope.\n * @returns The created log container envelope item.\n */\nfunction createLogContainerEnvelopeItem(items) {\n  return [\n    {\n      type: 'log',\n      item_count: items.length,\n      content_type: 'application/vnd.sentry.items.log+json',\n    },\n    {\n      items,\n    },\n  ];\n}\n\n/**\n * Creates an envelope for a list of logs.\n *\n * Logs from multiple traces can be included in the same envelope.\n *\n * @param logs - The logs to include in the envelope.\n * @param metadata - The metadata to include in the envelope.\n * @param tunnel - The tunnel to include in the envelope.\n * @param dsn - The DSN to include in the envelope.\n * @returns The created envelope.\n */\nfunction createLogEnvelope(\n  logs,\n  metadata,\n  tunnel,\n  dsn$1,\n) {\n  const headers = {};\n\n  if (metadata?.sdk) {\n    headers.sdk = {\n      name: metadata.sdk.name,\n      version: metadata.sdk.version,\n    };\n  }\n\n  if (!!tunnel && !!dsn$1) {\n    headers.dsn = dsn.dsnToString(dsn$1);\n  }\n\n  return envelope.createEnvelope(headers, [createLogContainerEnvelopeItem(logs)]);\n}\n\nexports.createLogContainerEnvelopeItem = createLogContainerEnvelopeItem;\nexports.createLogEnvelope = createLogEnvelope;\n//# sourceMappingURL=envelope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvbG9ncy9lbnZlbG9wZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxZQUFZLG1CQUFPLENBQUMseUhBQXVCO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLG1JQUE0Qjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0Qyx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxsb2dzXFxlbnZlbG9wZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgZHNuID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvZHNuLmpzJyk7XG5jb25zdCBlbnZlbG9wZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2VudmVsb3BlLmpzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGxvZyBjb250YWluZXIgZW52ZWxvcGUgaXRlbSBmb3IgYSBsaXN0IG9mIGxvZ3MuXG4gKlxuICogQHBhcmFtIGl0ZW1zIC0gVGhlIGxvZ3MgdG8gaW5jbHVkZSBpbiB0aGUgZW52ZWxvcGUuXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBsb2cgY29udGFpbmVyIGVudmVsb3BlIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxvZ0NvbnRhaW5lckVudmVsb3BlSXRlbShpdGVtcykge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHR5cGU6ICdsb2cnLFxuICAgICAgaXRlbV9jb3VudDogaXRlbXMubGVuZ3RoLFxuICAgICAgY29udGVudF90eXBlOiAnYXBwbGljYXRpb24vdm5kLnNlbnRyeS5pdGVtcy5sb2cranNvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICBpdGVtcyxcbiAgICB9LFxuICBdO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW52ZWxvcGUgZm9yIGEgbGlzdCBvZiBsb2dzLlxuICpcbiAqIExvZ3MgZnJvbSBtdWx0aXBsZSB0cmFjZXMgY2FuIGJlIGluY2x1ZGVkIGluIHRoZSBzYW1lIGVudmVsb3BlLlxuICpcbiAqIEBwYXJhbSBsb2dzIC0gVGhlIGxvZ3MgdG8gaW5jbHVkZSBpbiB0aGUgZW52ZWxvcGUuXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBUaGUgbWV0YWRhdGEgdG8gaW5jbHVkZSBpbiB0aGUgZW52ZWxvcGUuXG4gKiBAcGFyYW0gdHVubmVsIC0gVGhlIHR1bm5lbCB0byBpbmNsdWRlIGluIHRoZSBlbnZlbG9wZS5cbiAqIEBwYXJhbSBkc24gLSBUaGUgRFNOIHRvIGluY2x1ZGUgaW4gdGhlIGVudmVsb3BlLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgZW52ZWxvcGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxvZ0VudmVsb3BlKFxuICBsb2dzLFxuICBtZXRhZGF0YSxcbiAgdHVubmVsLFxuICBkc24kMSxcbikge1xuICBjb25zdCBoZWFkZXJzID0ge307XG5cbiAgaWYgKG1ldGFkYXRhPy5zZGspIHtcbiAgICBoZWFkZXJzLnNkayA9IHtcbiAgICAgIG5hbWU6IG1ldGFkYXRhLnNkay5uYW1lLFxuICAgICAgdmVyc2lvbjogbWV0YWRhdGEuc2RrLnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIGlmICghIXR1bm5lbCAmJiAhIWRzbiQxKSB7XG4gICAgaGVhZGVycy5kc24gPSBkc24uZHNuVG9TdHJpbmcoZHNuJDEpO1xuICB9XG5cbiAgcmV0dXJuIGVudmVsb3BlLmNyZWF0ZUVudmVsb3BlKGhlYWRlcnMsIFtjcmVhdGVMb2dDb250YWluZXJFbnZlbG9wZUl0ZW0obG9ncyldKTtcbn1cblxuZXhwb3J0cy5jcmVhdGVMb2dDb250YWluZXJFbnZlbG9wZUl0ZW0gPSBjcmVhdGVMb2dDb250YWluZXJFbnZlbG9wZUl0ZW07XG5leHBvcnRzLmNyZWF0ZUxvZ0VudmVsb3BlID0gY3JlYXRlTG9nRW52ZWxvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnZlbG9wZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/envelope.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/exports.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst client = __webpack_require__(/*! ../client.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/client.js\");\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst applyScopeDataToEvent = __webpack_require__(/*! ../utils/applyScopeDataToEvent.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/applyScopeDataToEvent.js\");\nconst spanOnScope = __webpack_require__(/*! ../utils/spanOnScope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanOnScope.js\");\nconst is = __webpack_require__(/*! ../utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst time = __webpack_require__(/*! ../utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst worldwide = __webpack_require__(/*! ../utils-hoist/worldwide.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js\");\nconst constants = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/constants.js\");\nconst envelope = __webpack_require__(/*! ./envelope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/envelope.js\");\n\nconst MAX_LOG_BUFFER_SIZE = 100;\n\n// The reference to the Client <> LogBuffer map is stored to ensure it's always the same\nworldwide.GLOBAL_OBJ._sentryClientToLogBufferMap = new WeakMap();\n\n/**\n * Converts a log attribute to a serialized log attribute.\n *\n * @param key - The key of the log attribute.\n * @param value - The value of the log attribute.\n * @returns The serialized log attribute.\n */\nfunction logAttributeToSerializedLogAttribute(value) {\n  switch (typeof value) {\n    case 'number':\n      if (Number.isInteger(value)) {\n        return {\n          value,\n          type: 'integer',\n        };\n      }\n      return {\n        value,\n        type: 'double',\n      };\n    case 'boolean':\n      return {\n        value,\n        type: 'boolean',\n      };\n    case 'string':\n      return {\n        value,\n        type: 'string',\n      };\n    default: {\n      let stringValue = '';\n      try {\n        stringValue = JSON.stringify(value) ?? '';\n      } catch {\n        // Do nothing\n      }\n      return {\n        value: stringValue,\n        type: 'string',\n      };\n    }\n  }\n}\n\n/**\n * Sets a log attribute if the value exists and the attribute key is not already present.\n *\n * @param logAttributes - The log attributes object to modify.\n * @param key - The attribute key to set.\n * @param value - The value to set (only sets if truthy and key not present).\n * @param setEvenIfPresent - Whether to set the attribute if it is present. Defaults to true.\n */\nfunction setLogAttribute(\n  logAttributes,\n  key,\n  value,\n  setEvenIfPresent = true,\n) {\n  if (value && (!logAttributes[key] || setEvenIfPresent)) {\n    logAttributes[key] = value;\n  }\n}\n\n/**\n * Captures a serialized log event and adds it to the log buffer for the given client.\n *\n * @param client - A client. Uses the current client if not provided.\n * @param serializedLog - The serialized log event to capture.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nfunction _INTERNAL_captureSerializedLog(client, serializedLog) {\n  const logBuffer = _INTERNAL_getLogBuffer(client);\n  if (logBuffer === undefined) {\n    worldwide.GLOBAL_OBJ._sentryClientToLogBufferMap?.set(client, [serializedLog]);\n  } else {\n    worldwide.GLOBAL_OBJ._sentryClientToLogBufferMap?.set(client, [...logBuffer, serializedLog]);\n    if (logBuffer.length >= MAX_LOG_BUFFER_SIZE) {\n      _INTERNAL_flushLogsBuffer(client, logBuffer);\n    }\n  }\n}\n\n/**\n * Captures a log event and sends it to Sentry.\n *\n * @param log - The log event to capture.\n * @param scope - A scope. Uses the current scope if not provided.\n * @param client - A client. Uses the current client if not provided.\n * @param captureSerializedLog - A function to capture the serialized log.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nfunction _INTERNAL_captureLog(\n  beforeLog,\n  client$1 = currentScopes.getClient(),\n  currentScope = currentScopes.getCurrentScope(),\n  captureSerializedLog = _INTERNAL_captureSerializedLog,\n) {\n  if (!client$1) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('No client available to capture log.');\n    return;\n  }\n\n  const { _experiments, release, environment } = client$1.getOptions();\n  const { enableLogs = false, beforeSendLog } = _experiments ?? {};\n  if (!enableLogs) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('logging option not enabled, log will not be captured.');\n    return;\n  }\n\n  const [, traceContext] = client._getTraceInfoFromScope(client$1, currentScope);\n\n  const processedLogAttributes = {\n    ...beforeLog.attributes,\n  };\n\n  const {\n    user: { id, email, username },\n  } = getMergedScopeData(currentScope);\n  setLogAttribute(processedLogAttributes, 'user.id', id, false);\n  setLogAttribute(processedLogAttributes, 'user.email', email, false);\n  setLogAttribute(processedLogAttributes, 'user.name', username, false);\n\n  setLogAttribute(processedLogAttributes, 'sentry.release', release);\n  setLogAttribute(processedLogAttributes, 'sentry.environment', environment);\n\n  const { name, version } = client$1.getSdkMetadata()?.sdk ?? {};\n  setLogAttribute(processedLogAttributes, 'sentry.sdk.name', name);\n  setLogAttribute(processedLogAttributes, 'sentry.sdk.version', version);\n\n  const beforeLogMessage = beforeLog.message;\n  if (is.isParameterizedString(beforeLogMessage)) {\n    const { __sentry_template_string__, __sentry_template_values__ = [] } = beforeLogMessage;\n    processedLogAttributes['sentry.message.template'] = __sentry_template_string__;\n    __sentry_template_values__.forEach((param, index) => {\n      processedLogAttributes[`sentry.message.parameter.${index}`] = param;\n    });\n  }\n\n  const span = spanOnScope._getSpanForScope(currentScope);\n  // Add the parent span ID to the log attributes for trace context\n  setLogAttribute(processedLogAttributes, 'sentry.trace.parent_span_id', span?.spanContext().spanId);\n\n  const processedLog = { ...beforeLog, attributes: processedLogAttributes };\n\n  client$1.emit('beforeCaptureLog', processedLog);\n\n  const log = beforeSendLog ? beforeSendLog(processedLog) : processedLog;\n  if (!log) {\n    client$1.recordDroppedEvent('before_send', 'log_item', 1);\n    debugBuild.DEBUG_BUILD && logger.logger.warn('beforeSendLog returned null, log will not be captured.');\n    return;\n  }\n\n  const { level, message, attributes = {}, severityNumber } = log;\n\n  const serializedLog = {\n    timestamp: time.timestampInSeconds(),\n    level,\n    body: message,\n    trace_id: traceContext?.trace_id,\n    severity_number: severityNumber ?? constants.SEVERITY_TEXT_TO_SEVERITY_NUMBER[level],\n    attributes: Object.keys(attributes).reduce(\n      (acc, key) => {\n        acc[key] = logAttributeToSerializedLogAttribute(attributes[key]);\n        return acc;\n      },\n      {} ,\n    ),\n  };\n\n  captureSerializedLog(client$1, serializedLog);\n\n  client$1.emit('afterCaptureLog', log);\n}\n\n/**\n * Flushes the logs buffer to Sentry.\n *\n * @param client - A client.\n * @param maybeLogBuffer - A log buffer. Uses the log buffer for the given client if not provided.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nfunction _INTERNAL_flushLogsBuffer(client, maybeLogBuffer) {\n  const logBuffer = maybeLogBuffer ?? _INTERNAL_getLogBuffer(client) ?? [];\n  if (logBuffer.length === 0) {\n    return;\n  }\n\n  const clientOptions = client.getOptions();\n  const envelope$1 = envelope.createLogEnvelope(logBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());\n\n  // Clear the log buffer after envelopes have been constructed.\n  worldwide.GLOBAL_OBJ._sentryClientToLogBufferMap?.set(client, []);\n\n  client.emit('flushLogs');\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope$1);\n}\n\n/**\n * Returns the log buffer for a given client.\n *\n * Exported for testing purposes.\n *\n * @param client - The client to get the log buffer for.\n * @returns The log buffer for the given client.\n */\nfunction _INTERNAL_getLogBuffer(client) {\n  return worldwide.GLOBAL_OBJ._sentryClientToLogBufferMap?.get(client);\n}\n\n/**\n * Get the scope data for the current scope after merging with the\n * global scope and isolation scope.\n *\n * @param currentScope - The current scope.\n * @returns The scope data.\n */\nfunction getMergedScopeData(currentScope) {\n  const scopeData = currentScopes.getGlobalScope().getScopeData();\n  applyScopeDataToEvent.mergeScopeData(scopeData, currentScopes.getIsolationScope().getScopeData());\n  applyScopeDataToEvent.mergeScopeData(scopeData, currentScope.getScopeData());\n  return scopeData;\n}\n\nexports._INTERNAL_captureLog = _INTERNAL_captureLog;\nexports._INTERNAL_captureSerializedLog = _INTERNAL_captureSerializedLog;\nexports._INTERNAL_flushLogsBuffer = _INTERNAL_flushLogsBuffer;\nexports._INTERNAL_getLogBuffer = _INTERNAL_getLogBuffer;\nexports.logAttributeToSerializedLogAttribute = logAttributeToSerializedLogAttribute;\n//# sourceMappingURL=exports.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvbG9ncy9leHBvcnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLGVBQWUsbUJBQU8sQ0FBQyx1R0FBYztBQUNyQyxzQkFBc0IsbUJBQU8sQ0FBQyxxSEFBcUI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsaUhBQW1CO0FBQzlDLDhCQUE4QixtQkFBTyxDQUFDLGlKQUFtQztBQUN6RSxvQkFBb0IsbUJBQU8sQ0FBQyw2SEFBeUI7QUFDckQsV0FBVyxtQkFBTyxDQUFDLHVIQUFzQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMsK0hBQTBCO0FBQ2pELGFBQWEsbUJBQU8sQ0FBQywySEFBd0I7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMscUlBQTZCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLGlIQUFnQjtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQywrR0FBZTs7QUFFeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQ0FBcUM7QUFDL0MsVUFBVSxvQ0FBb0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksOERBQThEO0FBQzFFO0FBQ0E7QUFDQSx5REFBeUQsTUFBTTtBQUMvRCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsK0JBQStCLG1CQUFtQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QixzQ0FBc0M7QUFDdEMsaUNBQWlDO0FBQ2pDLDhCQUE4QjtBQUM5Qiw0Q0FBNEM7QUFDNUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxsb2dzXFxleHBvcnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQuanMnKTtcbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IGFwcGx5U2NvcGVEYXRhVG9FdmVudCA9IHJlcXVpcmUoJy4uL3V0aWxzL2FwcGx5U2NvcGVEYXRhVG9FdmVudC5qcycpO1xuY29uc3Qgc3Bhbk9uU2NvcGUgPSByZXF1aXJlKCcuLi91dGlscy9zcGFuT25TY29wZS5qcycpO1xuY29uc3QgaXMgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9pcy5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCB0aW1lID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvdGltZS5qcycpO1xuY29uc3Qgd29ybGR3aWRlID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvd29ybGR3aWRlLmpzJyk7XG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy5qcycpO1xuY29uc3QgZW52ZWxvcGUgPSByZXF1aXJlKCcuL2VudmVsb3BlLmpzJyk7XG5cbmNvbnN0IE1BWF9MT0dfQlVGRkVSX1NJWkUgPSAxMDA7XG5cbi8vIFRoZSByZWZlcmVuY2UgdG8gdGhlIENsaWVudCA8PiBMb2dCdWZmZXIgbWFwIGlzIHN0b3JlZCB0byBlbnN1cmUgaXQncyBhbHdheXMgdGhlIHNhbWVcbndvcmxkd2lkZS5HTE9CQUxfT0JKLl9zZW50cnlDbGllbnRUb0xvZ0J1ZmZlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQ29udmVydHMgYSBsb2cgYXR0cmlidXRlIHRvIGEgc2VyaWFsaXplZCBsb2cgYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBsb2cgYXR0cmlidXRlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBsb2cgYXR0cmlidXRlLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgbG9nIGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gbG9nQXR0cmlidXRlVG9TZXJpYWxpemVkTG9nQXR0cmlidXRlKHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlOiAnZG91YmxlJyxcbiAgICAgIH07XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgfTtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgfTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZXQgc3RyaW5nVmFsdWUgPSAnJztcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmluZ1ZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpID8/ICcnO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBzdHJpbmdWYWx1ZSxcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNldHMgYSBsb2cgYXR0cmlidXRlIGlmIHRoZSB2YWx1ZSBleGlzdHMgYW5kIHRoZSBhdHRyaWJ1dGUga2V5IGlzIG5vdCBhbHJlYWR5IHByZXNlbnQuXG4gKlxuICogQHBhcmFtIGxvZ0F0dHJpYnV0ZXMgLSBUaGUgbG9nIGF0dHJpYnV0ZXMgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSBrZXkgLSBUaGUgYXR0cmlidXRlIGtleSB0byBzZXQuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0IChvbmx5IHNldHMgaWYgdHJ1dGh5IGFuZCBrZXkgbm90IHByZXNlbnQpLlxuICogQHBhcmFtIHNldEV2ZW5JZlByZXNlbnQgLSBXaGV0aGVyIHRvIHNldCB0aGUgYXR0cmlidXRlIGlmIGl0IGlzIHByZXNlbnQuIERlZmF1bHRzIHRvIHRydWUuXG4gKi9cbmZ1bmN0aW9uIHNldExvZ0F0dHJpYnV0ZShcbiAgbG9nQXR0cmlidXRlcyxcbiAga2V5LFxuICB2YWx1ZSxcbiAgc2V0RXZlbklmUHJlc2VudCA9IHRydWUsXG4pIHtcbiAgaWYgKHZhbHVlICYmICghbG9nQXR0cmlidXRlc1trZXldIHx8IHNldEV2ZW5JZlByZXNlbnQpKSB7XG4gICAgbG9nQXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBDYXB0dXJlcyBhIHNlcmlhbGl6ZWQgbG9nIGV2ZW50IGFuZCBhZGRzIGl0IHRvIHRoZSBsb2cgYnVmZmVyIGZvciB0aGUgZ2l2ZW4gY2xpZW50LlxuICpcbiAqIEBwYXJhbSBjbGllbnQgLSBBIGNsaWVudC4gVXNlcyB0aGUgY3VycmVudCBjbGllbnQgaWYgbm90IHByb3ZpZGVkLlxuICogQHBhcmFtIHNlcmlhbGl6ZWRMb2cgLSBUaGUgc2VyaWFsaXplZCBsb2cgZXZlbnQgdG8gY2FwdHVyZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIHdpbGwgZXhwZXJpZW5jZSBicmVha2luZyBjaGFuZ2VzLiBUaGlzIGlzIG5vdCB5ZXQgcGFydCBvZlxuICogdGhlIHN0YWJsZSBTZW50cnkgU0RLIEFQSSBhbmQgY2FuIGJlIGNoYW5nZWQgb3IgcmVtb3ZlZCB3aXRob3V0IHdhcm5pbmcuXG4gKi9cbmZ1bmN0aW9uIF9JTlRFUk5BTF9jYXB0dXJlU2VyaWFsaXplZExvZyhjbGllbnQsIHNlcmlhbGl6ZWRMb2cpIHtcbiAgY29uc3QgbG9nQnVmZmVyID0gX0lOVEVSTkFMX2dldExvZ0J1ZmZlcihjbGllbnQpO1xuICBpZiAobG9nQnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICB3b3JsZHdpZGUuR0xPQkFMX09CSi5fc2VudHJ5Q2xpZW50VG9Mb2dCdWZmZXJNYXA/LnNldChjbGllbnQsIFtzZXJpYWxpemVkTG9nXSk7XG4gIH0gZWxzZSB7XG4gICAgd29ybGR3aWRlLkdMT0JBTF9PQkouX3NlbnRyeUNsaWVudFRvTG9nQnVmZmVyTWFwPy5zZXQoY2xpZW50LCBbLi4ubG9nQnVmZmVyLCBzZXJpYWxpemVkTG9nXSk7XG4gICAgaWYgKGxvZ0J1ZmZlci5sZW5ndGggPj0gTUFYX0xPR19CVUZGRVJfU0laRSkge1xuICAgICAgX0lOVEVSTkFMX2ZsdXNoTG9nc0J1ZmZlcihjbGllbnQsIGxvZ0J1ZmZlcik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2FwdHVyZXMgYSBsb2cgZXZlbnQgYW5kIHNlbmRzIGl0IHRvIFNlbnRyeS5cbiAqXG4gKiBAcGFyYW0gbG9nIC0gVGhlIGxvZyBldmVudCB0byBjYXB0dXJlLlxuICogQHBhcmFtIHNjb3BlIC0gQSBzY29wZS4gVXNlcyB0aGUgY3VycmVudCBzY29wZSBpZiBub3QgcHJvdmlkZWQuXG4gKiBAcGFyYW0gY2xpZW50IC0gQSBjbGllbnQuIFVzZXMgdGhlIGN1cnJlbnQgY2xpZW50IGlmIG5vdCBwcm92aWRlZC5cbiAqIEBwYXJhbSBjYXB0dXJlU2VyaWFsaXplZExvZyAtIEEgZnVuY3Rpb24gdG8gY2FwdHVyZSB0aGUgc2VyaWFsaXplZCBsb2cuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldGhvZCB3aWxsIGV4cGVyaWVuY2UgYnJlYWtpbmcgY2hhbmdlcy4gVGhpcyBpcyBub3QgeWV0IHBhcnQgb2ZcbiAqIHRoZSBzdGFibGUgU2VudHJ5IFNESyBBUEkgYW5kIGNhbiBiZSBjaGFuZ2VkIG9yIHJlbW92ZWQgd2l0aG91dCB3YXJuaW5nLlxuICovXG5mdW5jdGlvbiBfSU5URVJOQUxfY2FwdHVyZUxvZyhcbiAgYmVmb3JlTG9nLFxuICBjbGllbnQkMSA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCksXG4gIGN1cnJlbnRTY29wZSA9IGN1cnJlbnRTY29wZXMuZ2V0Q3VycmVudFNjb3BlKCksXG4gIGNhcHR1cmVTZXJpYWxpemVkTG9nID0gX0lOVEVSTkFMX2NhcHR1cmVTZXJpYWxpemVkTG9nLFxuKSB7XG4gIGlmICghY2xpZW50JDEpIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybignTm8gY2xpZW50IGF2YWlsYWJsZSB0byBjYXB0dXJlIGxvZy4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7IF9leHBlcmltZW50cywgcmVsZWFzZSwgZW52aXJvbm1lbnQgfSA9IGNsaWVudCQxLmdldE9wdGlvbnMoKTtcbiAgY29uc3QgeyBlbmFibGVMb2dzID0gZmFsc2UsIGJlZm9yZVNlbmRMb2cgfSA9IF9leHBlcmltZW50cyA/PyB7fTtcbiAgaWYgKCFlbmFibGVMb2dzKSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLndhcm4oJ2xvZ2dpbmcgb3B0aW9uIG5vdCBlbmFibGVkLCBsb2cgd2lsbCBub3QgYmUgY2FwdHVyZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgWywgdHJhY2VDb250ZXh0XSA9IGNsaWVudC5fZ2V0VHJhY2VJbmZvRnJvbVNjb3BlKGNsaWVudCQxLCBjdXJyZW50U2NvcGUpO1xuXG4gIGNvbnN0IHByb2Nlc3NlZExvZ0F0dHJpYnV0ZXMgPSB7XG4gICAgLi4uYmVmb3JlTG9nLmF0dHJpYnV0ZXMsXG4gIH07XG5cbiAgY29uc3Qge1xuICAgIHVzZXI6IHsgaWQsIGVtYWlsLCB1c2VybmFtZSB9LFxuICB9ID0gZ2V0TWVyZ2VkU2NvcGVEYXRhKGN1cnJlbnRTY29wZSk7XG4gIHNldExvZ0F0dHJpYnV0ZShwcm9jZXNzZWRMb2dBdHRyaWJ1dGVzLCAndXNlci5pZCcsIGlkLCBmYWxzZSk7XG4gIHNldExvZ0F0dHJpYnV0ZShwcm9jZXNzZWRMb2dBdHRyaWJ1dGVzLCAndXNlci5lbWFpbCcsIGVtYWlsLCBmYWxzZSk7XG4gIHNldExvZ0F0dHJpYnV0ZShwcm9jZXNzZWRMb2dBdHRyaWJ1dGVzLCAndXNlci5uYW1lJywgdXNlcm5hbWUsIGZhbHNlKTtcblxuICBzZXRMb2dBdHRyaWJ1dGUocHJvY2Vzc2VkTG9nQXR0cmlidXRlcywgJ3NlbnRyeS5yZWxlYXNlJywgcmVsZWFzZSk7XG4gIHNldExvZ0F0dHJpYnV0ZShwcm9jZXNzZWRMb2dBdHRyaWJ1dGVzLCAnc2VudHJ5LmVudmlyb25tZW50JywgZW52aXJvbm1lbnQpO1xuXG4gIGNvbnN0IHsgbmFtZSwgdmVyc2lvbiB9ID0gY2xpZW50JDEuZ2V0U2RrTWV0YWRhdGEoKT8uc2RrID8/IHt9O1xuICBzZXRMb2dBdHRyaWJ1dGUocHJvY2Vzc2VkTG9nQXR0cmlidXRlcywgJ3NlbnRyeS5zZGsubmFtZScsIG5hbWUpO1xuICBzZXRMb2dBdHRyaWJ1dGUocHJvY2Vzc2VkTG9nQXR0cmlidXRlcywgJ3NlbnRyeS5zZGsudmVyc2lvbicsIHZlcnNpb24pO1xuXG4gIGNvbnN0IGJlZm9yZUxvZ01lc3NhZ2UgPSBiZWZvcmVMb2cubWVzc2FnZTtcbiAgaWYgKGlzLmlzUGFyYW1ldGVyaXplZFN0cmluZyhiZWZvcmVMb2dNZXNzYWdlKSkge1xuICAgIGNvbnN0IHsgX19zZW50cnlfdGVtcGxhdGVfc3RyaW5nX18sIF9fc2VudHJ5X3RlbXBsYXRlX3ZhbHVlc19fID0gW10gfSA9IGJlZm9yZUxvZ01lc3NhZ2U7XG4gICAgcHJvY2Vzc2VkTG9nQXR0cmlidXRlc1snc2VudHJ5Lm1lc3NhZ2UudGVtcGxhdGUnXSA9IF9fc2VudHJ5X3RlbXBsYXRlX3N0cmluZ19fO1xuICAgIF9fc2VudHJ5X3RlbXBsYXRlX3ZhbHVlc19fLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgcHJvY2Vzc2VkTG9nQXR0cmlidXRlc1tgc2VudHJ5Lm1lc3NhZ2UucGFyYW1ldGVyLiR7aW5kZXh9YF0gPSBwYXJhbTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHNwYW4gPSBzcGFuT25TY29wZS5fZ2V0U3BhbkZvclNjb3BlKGN1cnJlbnRTY29wZSk7XG4gIC8vIEFkZCB0aGUgcGFyZW50IHNwYW4gSUQgdG8gdGhlIGxvZyBhdHRyaWJ1dGVzIGZvciB0cmFjZSBjb250ZXh0XG4gIHNldExvZ0F0dHJpYnV0ZShwcm9jZXNzZWRMb2dBdHRyaWJ1dGVzLCAnc2VudHJ5LnRyYWNlLnBhcmVudF9zcGFuX2lkJywgc3Bhbj8uc3BhbkNvbnRleHQoKS5zcGFuSWQpO1xuXG4gIGNvbnN0IHByb2Nlc3NlZExvZyA9IHsgLi4uYmVmb3JlTG9nLCBhdHRyaWJ1dGVzOiBwcm9jZXNzZWRMb2dBdHRyaWJ1dGVzIH07XG5cbiAgY2xpZW50JDEuZW1pdCgnYmVmb3JlQ2FwdHVyZUxvZycsIHByb2Nlc3NlZExvZyk7XG5cbiAgY29uc3QgbG9nID0gYmVmb3JlU2VuZExvZyA/IGJlZm9yZVNlbmRMb2cocHJvY2Vzc2VkTG9nKSA6IHByb2Nlc3NlZExvZztcbiAgaWYgKCFsb2cpIHtcbiAgICBjbGllbnQkMS5yZWNvcmREcm9wcGVkRXZlbnQoJ2JlZm9yZV9zZW5kJywgJ2xvZ19pdGVtJywgMSk7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLndhcm4oJ2JlZm9yZVNlbmRMb2cgcmV0dXJuZWQgbnVsbCwgbG9nIHdpbGwgbm90IGJlIGNhcHR1cmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHsgbGV2ZWwsIG1lc3NhZ2UsIGF0dHJpYnV0ZXMgPSB7fSwgc2V2ZXJpdHlOdW1iZXIgfSA9IGxvZztcblxuICBjb25zdCBzZXJpYWxpemVkTG9nID0ge1xuICAgIHRpbWVzdGFtcDogdGltZS50aW1lc3RhbXBJblNlY29uZHMoKSxcbiAgICBsZXZlbCxcbiAgICBib2R5OiBtZXNzYWdlLFxuICAgIHRyYWNlX2lkOiB0cmFjZUNvbnRleHQ/LnRyYWNlX2lkLFxuICAgIHNldmVyaXR5X251bWJlcjogc2V2ZXJpdHlOdW1iZXIgPz8gY29uc3RhbnRzLlNFVkVSSVRZX1RFWFRfVE9fU0VWRVJJVFlfTlVNQkVSW2xldmVsXSxcbiAgICBhdHRyaWJ1dGVzOiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgYWNjW2tleV0gPSBsb2dBdHRyaWJ1dGVUb1NlcmlhbGl6ZWRMb2dBdHRyaWJ1dGUoYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7fSAsXG4gICAgKSxcbiAgfTtcblxuICBjYXB0dXJlU2VyaWFsaXplZExvZyhjbGllbnQkMSwgc2VyaWFsaXplZExvZyk7XG5cbiAgY2xpZW50JDEuZW1pdCgnYWZ0ZXJDYXB0dXJlTG9nJywgbG9nKTtcbn1cblxuLyoqXG4gKiBGbHVzaGVzIHRoZSBsb2dzIGJ1ZmZlciB0byBTZW50cnkuXG4gKlxuICogQHBhcmFtIGNsaWVudCAtIEEgY2xpZW50LlxuICogQHBhcmFtIG1heWJlTG9nQnVmZmVyIC0gQSBsb2cgYnVmZmVyLiBVc2VzIHRoZSBsb2cgYnVmZmVyIGZvciB0aGUgZ2l2ZW4gY2xpZW50IGlmIG5vdCBwcm92aWRlZC5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIHdpbGwgZXhwZXJpZW5jZSBicmVha2luZyBjaGFuZ2VzLiBUaGlzIGlzIG5vdCB5ZXQgcGFydCBvZlxuICogdGhlIHN0YWJsZSBTZW50cnkgU0RLIEFQSSBhbmQgY2FuIGJlIGNoYW5nZWQgb3IgcmVtb3ZlZCB3aXRob3V0IHdhcm5pbmcuXG4gKi9cbmZ1bmN0aW9uIF9JTlRFUk5BTF9mbHVzaExvZ3NCdWZmZXIoY2xpZW50LCBtYXliZUxvZ0J1ZmZlcikge1xuICBjb25zdCBsb2dCdWZmZXIgPSBtYXliZUxvZ0J1ZmZlciA/PyBfSU5URVJOQUxfZ2V0TG9nQnVmZmVyKGNsaWVudCkgPz8gW107XG4gIGlmIChsb2dCdWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY2xpZW50T3B0aW9ucyA9IGNsaWVudC5nZXRPcHRpb25zKCk7XG4gIGNvbnN0IGVudmVsb3BlJDEgPSBlbnZlbG9wZS5jcmVhdGVMb2dFbnZlbG9wZShsb2dCdWZmZXIsIGNsaWVudE9wdGlvbnMuX21ldGFkYXRhLCBjbGllbnRPcHRpb25zLnR1bm5lbCwgY2xpZW50LmdldERzbigpKTtcblxuICAvLyBDbGVhciB0aGUgbG9nIGJ1ZmZlciBhZnRlciBlbnZlbG9wZXMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkLlxuICB3b3JsZHdpZGUuR0xPQkFMX09CSi5fc2VudHJ5Q2xpZW50VG9Mb2dCdWZmZXJNYXA/LnNldChjbGllbnQsIFtdKTtcblxuICBjbGllbnQuZW1pdCgnZmx1c2hMb2dzJyk7XG5cbiAgLy8gc2VuZEVudmVsb3BlIHNob3VsZCBub3QgdGhyb3dcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICBjbGllbnQuc2VuZEVudmVsb3BlKGVudmVsb3BlJDEpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvZyBidWZmZXIgZm9yIGEgZ2l2ZW4gY2xpZW50LlxuICpcbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICpcbiAqIEBwYXJhbSBjbGllbnQgLSBUaGUgY2xpZW50IHRvIGdldCB0aGUgbG9nIGJ1ZmZlciBmb3IuXG4gKiBAcmV0dXJucyBUaGUgbG9nIGJ1ZmZlciBmb3IgdGhlIGdpdmVuIGNsaWVudC5cbiAqL1xuZnVuY3Rpb24gX0lOVEVSTkFMX2dldExvZ0J1ZmZlcihjbGllbnQpIHtcbiAgcmV0dXJuIHdvcmxkd2lkZS5HTE9CQUxfT0JKLl9zZW50cnlDbGllbnRUb0xvZ0J1ZmZlck1hcD8uZ2V0KGNsaWVudCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzY29wZSBkYXRhIGZvciB0aGUgY3VycmVudCBzY29wZSBhZnRlciBtZXJnaW5nIHdpdGggdGhlXG4gKiBnbG9iYWwgc2NvcGUgYW5kIGlzb2xhdGlvbiBzY29wZS5cbiAqXG4gKiBAcGFyYW0gY3VycmVudFNjb3BlIC0gVGhlIGN1cnJlbnQgc2NvcGUuXG4gKiBAcmV0dXJucyBUaGUgc2NvcGUgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWVyZ2VkU2NvcGVEYXRhKGN1cnJlbnRTY29wZSkge1xuICBjb25zdCBzY29wZURhdGEgPSBjdXJyZW50U2NvcGVzLmdldEdsb2JhbFNjb3BlKCkuZ2V0U2NvcGVEYXRhKCk7XG4gIGFwcGx5U2NvcGVEYXRhVG9FdmVudC5tZXJnZVNjb3BlRGF0YShzY29wZURhdGEsIGN1cnJlbnRTY29wZXMuZ2V0SXNvbGF0aW9uU2NvcGUoKS5nZXRTY29wZURhdGEoKSk7XG4gIGFwcGx5U2NvcGVEYXRhVG9FdmVudC5tZXJnZVNjb3BlRGF0YShzY29wZURhdGEsIGN1cnJlbnRTY29wZS5nZXRTY29wZURhdGEoKSk7XG4gIHJldHVybiBzY29wZURhdGE7XG59XG5cbmV4cG9ydHMuX0lOVEVSTkFMX2NhcHR1cmVMb2cgPSBfSU5URVJOQUxfY2FwdHVyZUxvZztcbmV4cG9ydHMuX0lOVEVSTkFMX2NhcHR1cmVTZXJpYWxpemVkTG9nID0gX0lOVEVSTkFMX2NhcHR1cmVTZXJpYWxpemVkTG9nO1xuZXhwb3J0cy5fSU5URVJOQUxfZmx1c2hMb2dzQnVmZmVyID0gX0lOVEVSTkFMX2ZsdXNoTG9nc0J1ZmZlcjtcbmV4cG9ydHMuX0lOVEVSTkFMX2dldExvZ0J1ZmZlciA9IF9JTlRFUk5BTF9nZXRMb2dCdWZmZXI7XG5leHBvcnRzLmxvZ0F0dHJpYnV0ZVRvU2VyaWFsaXplZExvZ0F0dHJpYnV0ZSA9IGxvZ0F0dHJpYnV0ZVRvU2VyaWFsaXplZExvZ0F0dHJpYnV0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cG9ydHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/exports.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/mcp-server.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst semanticAttributes = __webpack_require__(/*! ./semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\n__webpack_require__(/*! ./tracing/errors.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/errors.js\");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\n__webpack_require__(/*! ./utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst spanUtils = __webpack_require__(/*! ./utils/spanUtils.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanUtils.js\");\nconst trace = __webpack_require__(/*! ./tracing/trace.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/trace.js\");\n\nconst wrappedMcpServerInstances = new WeakSet();\n\n/**\n * Wraps a MCP Server instance from the `@modelcontextprotocol/sdk` package with Sentry instrumentation.\n *\n * Compatible with versions `^1.9.0` of the `@modelcontextprotocol/sdk` package.\n */\n// We are exposing this API for non-node runtimes that cannot rely on auto-instrumentation.\nfunction wrapMcpServerWithSentry(mcpServerInstance) {\n  if (wrappedMcpServerInstances.has(mcpServerInstance)) {\n    return mcpServerInstance;\n  }\n\n  if (!isMcpServerInstance(mcpServerInstance)) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('Did not patch MCP server. Interface is incompatible.');\n    return mcpServerInstance;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  mcpServerInstance.connect = new Proxy(mcpServerInstance.connect, {\n    apply(target, thisArg, argArray) {\n      const [transport, ...restArgs] = argArray ;\n\n      if (!transport.onclose) {\n        transport.onclose = () => {\n          if (transport.sessionId) {\n            handleTransportOnClose(transport.sessionId);\n          }\n        };\n      }\n\n      if (!transport.onmessage) {\n        transport.onmessage = jsonRpcMessage => {\n          if (transport.sessionId && isJsonRPCMessageWithRequestId(jsonRpcMessage)) {\n            handleTransportOnMessage(transport.sessionId, jsonRpcMessage.id);\n          }\n        };\n      }\n\n      const patchedTransport = new Proxy(transport, {\n        set(target, key, value) {\n          if (key === 'onmessage') {\n            target[key] = new Proxy(value, {\n              apply(onMessageTarget, onMessageThisArg, onMessageArgArray) {\n                const [jsonRpcMessage] = onMessageArgArray;\n                if (transport.sessionId && isJsonRPCMessageWithRequestId(jsonRpcMessage)) {\n                  handleTransportOnMessage(transport.sessionId, jsonRpcMessage.id);\n                }\n                return Reflect.apply(onMessageTarget, onMessageThisArg, onMessageArgArray);\n              },\n            });\n          } else if (key === 'onclose') {\n            target[key] = new Proxy(value, {\n              apply(onCloseTarget, onCloseThisArg, onCloseArgArray) {\n                if (transport.sessionId) {\n                  handleTransportOnClose(transport.sessionId);\n                }\n                return Reflect.apply(onCloseTarget, onCloseThisArg, onCloseArgArray);\n              },\n            });\n          } else {\n            target[key ] = value;\n          }\n          return true;\n        },\n      });\n\n      return Reflect.apply(target, thisArg, [patchedTransport, ...restArgs]);\n    },\n  });\n\n  mcpServerInstance.resource = new Proxy(mcpServerInstance.resource, {\n    apply(target, thisArg, argArray) {\n      const resourceName = argArray[0];\n      const resourceHandler = argArray[argArray.length - 1];\n\n      if (typeof resourceName !== 'string' || typeof resourceHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n\n      const wrappedResourceHandler = new Proxy(resourceHandler, {\n        apply(resourceHandlerTarget, resourceHandlerThisArg, resourceHandlerArgArray) {\n          const extraHandlerDataWithRequestId = resourceHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return trace.startSpan(\n              {\n                name: `mcp-server/resource:${resourceName}`,\n                forceTransaction: true,\n                attributes: {\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                  'mcp_server.resource': resourceName,\n                },\n              },\n              () => resourceHandlerTarget.apply(resourceHandlerThisArg, resourceHandlerArgArray),\n            );\n          });\n        },\n      });\n\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedResourceHandler]);\n    },\n  });\n\n  mcpServerInstance.tool = new Proxy(mcpServerInstance.tool, {\n    apply(target, thisArg, argArray) {\n      const toolName = argArray[0];\n      const toolHandler = argArray[argArray.length - 1];\n\n      if (typeof toolName !== 'string' || typeof toolHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n\n      const wrappedToolHandler = new Proxy(toolHandler, {\n        apply(toolHandlerTarget, toolHandlerThisArg, toolHandlerArgArray) {\n          const extraHandlerDataWithRequestId = toolHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return trace.startSpan(\n              {\n                name: `mcp-server/tool:${toolName}`,\n                forceTransaction: true,\n                attributes: {\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                  'mcp_server.tool': toolName,\n                },\n              },\n              () => toolHandlerTarget.apply(toolHandlerThisArg, toolHandlerArgArray),\n            );\n          });\n        },\n      });\n\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedToolHandler]);\n    },\n  });\n\n  mcpServerInstance.prompt = new Proxy(mcpServerInstance.prompt, {\n    apply(target, thisArg, argArray) {\n      const promptName = argArray[0];\n      const promptHandler = argArray[argArray.length - 1];\n\n      if (typeof promptName !== 'string' || typeof promptHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n\n      const wrappedPromptHandler = new Proxy(promptHandler, {\n        apply(promptHandlerTarget, promptHandlerThisArg, promptHandlerArgArray) {\n          const extraHandlerDataWithRequestId = promptHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return trace.startSpan(\n              {\n                name: `mcp-server/prompt:${promptName}`,\n                forceTransaction: true,\n                attributes: {\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                  [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                  'mcp_server.prompt': promptName,\n                },\n              },\n              () => promptHandlerTarget.apply(promptHandlerThisArg, promptHandlerArgArray),\n            );\n          });\n        },\n      });\n\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedPromptHandler]);\n    },\n  });\n\n  wrappedMcpServerInstances.add(mcpServerInstance);\n\n  return mcpServerInstance ;\n}\n\nfunction isMcpServerInstance(mcpServerInstance) {\n  return (\n    typeof mcpServerInstance === 'object' &&\n    mcpServerInstance !== null &&\n    'resource' in mcpServerInstance &&\n    typeof mcpServerInstance.resource === 'function' &&\n    'tool' in mcpServerInstance &&\n    typeof mcpServerInstance.tool === 'function' &&\n    'prompt' in mcpServerInstance &&\n    typeof mcpServerInstance.prompt === 'function' &&\n    'connect' in mcpServerInstance &&\n    typeof mcpServerInstance.connect === 'function'\n  );\n}\n\nfunction isJsonRPCMessageWithRequestId(target) {\n  return (\n    typeof target === 'object' &&\n    target !== null &&\n    'id' in target &&\n    (typeof target.id === 'number' || typeof target.id === 'string')\n  );\n}\n\n// Note that not all versions of the MCP library have `requestId` as a field on the extra data.\nfunction isExtraHandlerDataWithRequestId(target) {\n  return (\n    typeof target === 'object' &&\n    target !== null &&\n    'sessionId' in target &&\n    typeof target.sessionId === 'string' &&\n    'requestId' in target &&\n    (typeof target.requestId === 'number' || typeof target.requestId === 'string')\n  );\n}\n\nconst sessionAndRequestToRequestParentSpanMap = new Map();\n\nfunction handleTransportOnClose(sessionId) {\n  sessionAndRequestToRequestParentSpanMap.delete(sessionId);\n}\n\nfunction handleTransportOnMessage(sessionId, requestId) {\n  const activeSpan = spanUtils.getActiveSpan();\n  if (activeSpan) {\n    const requestIdToSpanMap = sessionAndRequestToRequestParentSpanMap.get(sessionId) ?? new Map();\n    requestIdToSpanMap.set(requestId, activeSpan);\n    sessionAndRequestToRequestParentSpanMap.set(sessionId, requestIdToSpanMap);\n  }\n}\n\nfunction associateContextWithRequestSpan(\n  extraHandlerData,\n  cb,\n) {\n  if (extraHandlerData) {\n    const { sessionId, requestId } = extraHandlerData;\n    const requestIdSpanMap = sessionAndRequestToRequestParentSpanMap.get(sessionId);\n\n    if (!requestIdSpanMap) {\n      return cb();\n    }\n\n    const span = requestIdSpanMap.get(requestId);\n    if (!span) {\n      return cb();\n    }\n\n    // remove the span from the map so it can be garbage collected\n    requestIdSpanMap.delete(requestId);\n    return trace.withActiveSpan(span, () => {\n      return cb();\n    });\n  }\n\n  return cb();\n}\n\nexports.wrapMcpServerWithSentry = wrapMcpServerWithSentry;\n//# sourceMappingURL=mcp-server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvbWNwLXNlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxtQkFBbUIsbUJBQU8sQ0FBQyxnSEFBa0I7QUFDN0MsMkJBQTJCLG1CQUFPLENBQUMsOEhBQXlCO0FBQzVELG1CQUFPLENBQUMsc0hBQXFCO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDaEQsbUJBQU8sQ0FBQywwSEFBdUI7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsd0hBQXNCO0FBQ2hELGNBQWMsbUJBQU8sQ0FBQyxvSEFBb0I7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0IiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxtY3Atc2VydmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3Qgc2VtYW50aWNBdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9zZW1hbnRpY0F0dHJpYnV0ZXMuanMnKTtcbnJlcXVpcmUoJy4vdHJhY2luZy9lcnJvcnMuanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5yZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3RpbWUuanMnKTtcbmNvbnN0IHNwYW5VdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvc3BhblV0aWxzLmpzJyk7XG5jb25zdCB0cmFjZSA9IHJlcXVpcmUoJy4vdHJhY2luZy90cmFjZS5qcycpO1xuXG5jb25zdCB3cmFwcGVkTWNwU2VydmVySW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKTtcblxuLyoqXG4gKiBXcmFwcyBhIE1DUCBTZXJ2ZXIgaW5zdGFuY2UgZnJvbSB0aGUgYEBtb2RlbGNvbnRleHRwcm90b2NvbC9zZGtgIHBhY2thZ2Ugd2l0aCBTZW50cnkgaW5zdHJ1bWVudGF0aW9uLlxuICpcbiAqIENvbXBhdGlibGUgd2l0aCB2ZXJzaW9ucyBgXjEuOS4wYCBvZiB0aGUgYEBtb2RlbGNvbnRleHRwcm90b2NvbC9zZGtgIHBhY2thZ2UuXG4gKi9cbi8vIFdlIGFyZSBleHBvc2luZyB0aGlzIEFQSSBmb3Igbm9uLW5vZGUgcnVudGltZXMgdGhhdCBjYW5ub3QgcmVseSBvbiBhdXRvLWluc3RydW1lbnRhdGlvbi5cbmZ1bmN0aW9uIHdyYXBNY3BTZXJ2ZXJXaXRoU2VudHJ5KG1jcFNlcnZlckluc3RhbmNlKSB7XG4gIGlmICh3cmFwcGVkTWNwU2VydmVySW5zdGFuY2VzLmhhcyhtY3BTZXJ2ZXJJbnN0YW5jZSkpIHtcbiAgICByZXR1cm4gbWNwU2VydmVySW5zdGFuY2U7XG4gIH1cblxuICBpZiAoIWlzTWNwU2VydmVySW5zdGFuY2UobWNwU2VydmVySW5zdGFuY2UpKSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLndhcm4oJ0RpZCBub3QgcGF0Y2ggTUNQIHNlcnZlci4gSW50ZXJmYWNlIGlzIGluY29tcGF0aWJsZS4nKTtcbiAgICByZXR1cm4gbWNwU2VydmVySW5zdGFuY2U7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gIG1jcFNlcnZlckluc3RhbmNlLmNvbm5lY3QgPSBuZXcgUHJveHkobWNwU2VydmVySW5zdGFuY2UuY29ubmVjdCwge1xuICAgIGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJnQXJyYXkpIHtcbiAgICAgIGNvbnN0IFt0cmFuc3BvcnQsIC4uLnJlc3RBcmdzXSA9IGFyZ0FycmF5IDtcblxuICAgICAgaWYgKCF0cmFuc3BvcnQub25jbG9zZSkge1xuICAgICAgICB0cmFuc3BvcnQub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodHJhbnNwb3J0LnNlc3Npb25JZCkge1xuICAgICAgICAgICAgaGFuZGxlVHJhbnNwb3J0T25DbG9zZSh0cmFuc3BvcnQuc2Vzc2lvbklkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICghdHJhbnNwb3J0Lm9ubWVzc2FnZSkge1xuICAgICAgICB0cmFuc3BvcnQub25tZXNzYWdlID0ganNvblJwY01lc3NhZ2UgPT4ge1xuICAgICAgICAgIGlmICh0cmFuc3BvcnQuc2Vzc2lvbklkICYmIGlzSnNvblJQQ01lc3NhZ2VXaXRoUmVxdWVzdElkKGpzb25ScGNNZXNzYWdlKSkge1xuICAgICAgICAgICAgaGFuZGxlVHJhbnNwb3J0T25NZXNzYWdlKHRyYW5zcG9ydC5zZXNzaW9uSWQsIGpzb25ScGNNZXNzYWdlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhdGNoZWRUcmFuc3BvcnQgPSBuZXcgUHJveHkodHJhbnNwb3J0LCB7XG4gICAgICAgIHNldCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSAnb25tZXNzYWdlJykge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBuZXcgUHJveHkodmFsdWUsIHtcbiAgICAgICAgICAgICAgYXBwbHkob25NZXNzYWdlVGFyZ2V0LCBvbk1lc3NhZ2VUaGlzQXJnLCBvbk1lc3NhZ2VBcmdBcnJheSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtqc29uUnBjTWVzc2FnZV0gPSBvbk1lc3NhZ2VBcmdBcnJheTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0LnNlc3Npb25JZCAmJiBpc0pzb25SUENNZXNzYWdlV2l0aFJlcXVlc3RJZChqc29uUnBjTWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZVRyYW5zcG9ydE9uTWVzc2FnZSh0cmFuc3BvcnQuc2Vzc2lvbklkLCBqc29uUnBjTWVzc2FnZS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KG9uTWVzc2FnZVRhcmdldCwgb25NZXNzYWdlVGhpc0FyZywgb25NZXNzYWdlQXJnQXJyYXkpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdvbmNsb3NlJykge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBuZXcgUHJveHkodmFsdWUsIHtcbiAgICAgICAgICAgICAgYXBwbHkob25DbG9zZVRhcmdldCwgb25DbG9zZVRoaXNBcmcsIG9uQ2xvc2VBcmdBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQuc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgICBoYW5kbGVUcmFuc3BvcnRPbkNsb3NlKHRyYW5zcG9ydC5zZXNzaW9uSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5hcHBseShvbkNsb3NlVGFyZ2V0LCBvbkNsb3NlVGhpc0FyZywgb25DbG9zZUFyZ0FycmF5KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5IF0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBbcGF0Y2hlZFRyYW5zcG9ydCwgLi4ucmVzdEFyZ3NdKTtcbiAgICB9LFxuICB9KTtcblxuICBtY3BTZXJ2ZXJJbnN0YW5jZS5yZXNvdXJjZSA9IG5ldyBQcm94eShtY3BTZXJ2ZXJJbnN0YW5jZS5yZXNvdXJjZSwge1xuICAgIGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJnQXJyYXkpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IGFyZ0FycmF5WzBdO1xuICAgICAgY29uc3QgcmVzb3VyY2VIYW5kbGVyID0gYXJnQXJyYXlbYXJnQXJyYXkubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzb3VyY2VOYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgcmVzb3VyY2VIYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJnQXJyYXkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3cmFwcGVkUmVzb3VyY2VIYW5kbGVyID0gbmV3IFByb3h5KHJlc291cmNlSGFuZGxlciwge1xuICAgICAgICBhcHBseShyZXNvdXJjZUhhbmRsZXJUYXJnZXQsIHJlc291cmNlSGFuZGxlclRoaXNBcmcsIHJlc291cmNlSGFuZGxlckFyZ0FycmF5KSB7XG4gICAgICAgICAgY29uc3QgZXh0cmFIYW5kbGVyRGF0YVdpdGhSZXF1ZXN0SWQgPSByZXNvdXJjZUhhbmRsZXJBcmdBcnJheS5maW5kKGlzRXh0cmFIYW5kbGVyRGF0YVdpdGhSZXF1ZXN0SWQpO1xuICAgICAgICAgIHJldHVybiBhc3NvY2lhdGVDb250ZXh0V2l0aFJlcXVlc3RTcGFuKGV4dHJhSGFuZGxlckRhdGFXaXRoUmVxdWVzdElkLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2Uuc3RhcnRTcGFuKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogYG1jcC1zZXJ2ZXIvcmVzb3VyY2U6JHtyZXNvdXJjZU5hbWV9YCxcbiAgICAgICAgICAgICAgICBmb3JjZVRyYW5zYWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF06ICdhdXRvLmZ1bmN0aW9uLm1jcC1zZXJ2ZXInLFxuICAgICAgICAgICAgICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06ICdhdXRvLmZ1bmN0aW9uLm1jcC1zZXJ2ZXInLFxuICAgICAgICAgICAgICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06ICdyb3V0ZScsXG4gICAgICAgICAgICAgICAgICAnbWNwX3NlcnZlci5yZXNvdXJjZSc6IHJlc291cmNlTmFtZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAoKSA9PiByZXNvdXJjZUhhbmRsZXJUYXJnZXQuYXBwbHkocmVzb3VyY2VIYW5kbGVyVGhpc0FyZywgcmVzb3VyY2VIYW5kbGVyQXJnQXJyYXkpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIFsuLi5hcmdBcnJheS5zbGljZSgwLCAtMSksIHdyYXBwZWRSZXNvdXJjZUhhbmRsZXJdKTtcbiAgICB9LFxuICB9KTtcblxuICBtY3BTZXJ2ZXJJbnN0YW5jZS50b29sID0gbmV3IFByb3h5KG1jcFNlcnZlckluc3RhbmNlLnRvb2wsIHtcbiAgICBhcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ0FycmF5KSB7XG4gICAgICBjb25zdCB0b29sTmFtZSA9IGFyZ0FycmF5WzBdO1xuICAgICAgY29uc3QgdG9vbEhhbmRsZXIgPSBhcmdBcnJheVthcmdBcnJheS5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKHR5cGVvZiB0b29sTmFtZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHRvb2xIYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJnQXJyYXkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3cmFwcGVkVG9vbEhhbmRsZXIgPSBuZXcgUHJveHkodG9vbEhhbmRsZXIsIHtcbiAgICAgICAgYXBwbHkodG9vbEhhbmRsZXJUYXJnZXQsIHRvb2xIYW5kbGVyVGhpc0FyZywgdG9vbEhhbmRsZXJBcmdBcnJheSkge1xuICAgICAgICAgIGNvbnN0IGV4dHJhSGFuZGxlckRhdGFXaXRoUmVxdWVzdElkID0gdG9vbEhhbmRsZXJBcmdBcnJheS5maW5kKGlzRXh0cmFIYW5kbGVyRGF0YVdpdGhSZXF1ZXN0SWQpO1xuICAgICAgICAgIHJldHVybiBhc3NvY2lhdGVDb250ZXh0V2l0aFJlcXVlc3RTcGFuKGV4dHJhSGFuZGxlckRhdGFXaXRoUmVxdWVzdElkLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2Uuc3RhcnRTcGFuKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogYG1jcC1zZXJ2ZXIvdG9vbDoke3Rvb2xOYW1lfWAsXG4gICAgICAgICAgICAgICAgZm9yY2VUcmFuc2FjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdOiAnYXV0by5mdW5jdGlvbi5tY3Atc2VydmVyJyxcbiAgICAgICAgICAgICAgICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnYXV0by5mdW5jdGlvbi5tY3Atc2VydmVyJyxcbiAgICAgICAgICAgICAgICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdOiAncm91dGUnLFxuICAgICAgICAgICAgICAgICAgJ21jcF9zZXJ2ZXIudG9vbCc6IHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICgpID0+IHRvb2xIYW5kbGVyVGFyZ2V0LmFwcGx5KHRvb2xIYW5kbGVyVGhpc0FyZywgdG9vbEhhbmRsZXJBcmdBcnJheSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgWy4uLmFyZ0FycmF5LnNsaWNlKDAsIC0xKSwgd3JhcHBlZFRvb2xIYW5kbGVyXSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgbWNwU2VydmVySW5zdGFuY2UucHJvbXB0ID0gbmV3IFByb3h5KG1jcFNlcnZlckluc3RhbmNlLnByb21wdCwge1xuICAgIGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJnQXJyYXkpIHtcbiAgICAgIGNvbnN0IHByb21wdE5hbWUgPSBhcmdBcnJheVswXTtcbiAgICAgIGNvbnN0IHByb21wdEhhbmRsZXIgPSBhcmdBcnJheVthcmdBcnJheS5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKHR5cGVvZiBwcm9tcHROYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvbXB0SGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ0FycmF5KTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd3JhcHBlZFByb21wdEhhbmRsZXIgPSBuZXcgUHJveHkocHJvbXB0SGFuZGxlciwge1xuICAgICAgICBhcHBseShwcm9tcHRIYW5kbGVyVGFyZ2V0LCBwcm9tcHRIYW5kbGVyVGhpc0FyZywgcHJvbXB0SGFuZGxlckFyZ0FycmF5KSB7XG4gICAgICAgICAgY29uc3QgZXh0cmFIYW5kbGVyRGF0YVdpdGhSZXF1ZXN0SWQgPSBwcm9tcHRIYW5kbGVyQXJnQXJyYXkuZmluZChpc0V4dHJhSGFuZGxlckRhdGFXaXRoUmVxdWVzdElkKTtcbiAgICAgICAgICByZXR1cm4gYXNzb2NpYXRlQ29udGV4dFdpdGhSZXF1ZXN0U3BhbihleHRyYUhhbmRsZXJEYXRhV2l0aFJlcXVlc3RJZCwgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNlLnN0YXJ0U3BhbihcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IGBtY3Atc2VydmVyL3Byb21wdDoke3Byb21wdE5hbWV9YCxcbiAgICAgICAgICAgICAgICBmb3JjZVRyYW5zYWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF06ICdhdXRvLmZ1bmN0aW9uLm1jcC1zZXJ2ZXInLFxuICAgICAgICAgICAgICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06ICdhdXRvLmZ1bmN0aW9uLm1jcC1zZXJ2ZXInLFxuICAgICAgICAgICAgICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06ICdyb3V0ZScsXG4gICAgICAgICAgICAgICAgICAnbWNwX3NlcnZlci5wcm9tcHQnOiBwcm9tcHROYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICgpID0+IHByb21wdEhhbmRsZXJUYXJnZXQuYXBwbHkocHJvbXB0SGFuZGxlclRoaXNBcmcsIHByb21wdEhhbmRsZXJBcmdBcnJheSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgWy4uLmFyZ0FycmF5LnNsaWNlKDAsIC0xKSwgd3JhcHBlZFByb21wdEhhbmRsZXJdKTtcbiAgICB9LFxuICB9KTtcblxuICB3cmFwcGVkTWNwU2VydmVySW5zdGFuY2VzLmFkZChtY3BTZXJ2ZXJJbnN0YW5jZSk7XG5cbiAgcmV0dXJuIG1jcFNlcnZlckluc3RhbmNlIDtcbn1cblxuZnVuY3Rpb24gaXNNY3BTZXJ2ZXJJbnN0YW5jZShtY3BTZXJ2ZXJJbnN0YW5jZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBtY3BTZXJ2ZXJJbnN0YW5jZSA9PT0gJ29iamVjdCcgJiZcbiAgICBtY3BTZXJ2ZXJJbnN0YW5jZSAhPT0gbnVsbCAmJlxuICAgICdyZXNvdXJjZScgaW4gbWNwU2VydmVySW5zdGFuY2UgJiZcbiAgICB0eXBlb2YgbWNwU2VydmVySW5zdGFuY2UucmVzb3VyY2UgPT09ICdmdW5jdGlvbicgJiZcbiAgICAndG9vbCcgaW4gbWNwU2VydmVySW5zdGFuY2UgJiZcbiAgICB0eXBlb2YgbWNwU2VydmVySW5zdGFuY2UudG9vbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICdwcm9tcHQnIGluIG1jcFNlcnZlckluc3RhbmNlICYmXG4gICAgdHlwZW9mIG1jcFNlcnZlckluc3RhbmNlLnByb21wdCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICdjb25uZWN0JyBpbiBtY3BTZXJ2ZXJJbnN0YW5jZSAmJlxuICAgIHR5cGVvZiBtY3BTZXJ2ZXJJbnN0YW5jZS5jb25uZWN0ID09PSAnZnVuY3Rpb24nXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzSnNvblJQQ01lc3NhZ2VXaXRoUmVxdWVzdElkKHRhcmdldCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmXG4gICAgdGFyZ2V0ICE9PSBudWxsICYmXG4gICAgJ2lkJyBpbiB0YXJnZXQgJiZcbiAgICAodHlwZW9mIHRhcmdldC5pZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHRhcmdldC5pZCA9PT0gJ3N0cmluZycpXG4gICk7XG59XG5cbi8vIE5vdGUgdGhhdCBub3QgYWxsIHZlcnNpb25zIG9mIHRoZSBNQ1AgbGlicmFyeSBoYXZlIGByZXF1ZXN0SWRgIGFzIGEgZmllbGQgb24gdGhlIGV4dHJhIGRhdGEuXG5mdW5jdGlvbiBpc0V4dHJhSGFuZGxlckRhdGFXaXRoUmVxdWVzdElkKHRhcmdldCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmXG4gICAgdGFyZ2V0ICE9PSBudWxsICYmXG4gICAgJ3Nlc3Npb25JZCcgaW4gdGFyZ2V0ICYmXG4gICAgdHlwZW9mIHRhcmdldC5zZXNzaW9uSWQgPT09ICdzdHJpbmcnICYmXG4gICAgJ3JlcXVlc3RJZCcgaW4gdGFyZ2V0ICYmXG4gICAgKHR5cGVvZiB0YXJnZXQucmVxdWVzdElkID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdGFyZ2V0LnJlcXVlc3RJZCA9PT0gJ3N0cmluZycpXG4gICk7XG59XG5cbmNvbnN0IHNlc3Npb25BbmRSZXF1ZXN0VG9SZXF1ZXN0UGFyZW50U3Bhbk1hcCA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gaGFuZGxlVHJhbnNwb3J0T25DbG9zZShzZXNzaW9uSWQpIHtcbiAgc2Vzc2lvbkFuZFJlcXVlc3RUb1JlcXVlc3RQYXJlbnRTcGFuTWFwLmRlbGV0ZShzZXNzaW9uSWQpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVUcmFuc3BvcnRPbk1lc3NhZ2Uoc2Vzc2lvbklkLCByZXF1ZXN0SWQpIHtcbiAgY29uc3QgYWN0aXZlU3BhbiA9IHNwYW5VdGlscy5nZXRBY3RpdmVTcGFuKCk7XG4gIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgY29uc3QgcmVxdWVzdElkVG9TcGFuTWFwID0gc2Vzc2lvbkFuZFJlcXVlc3RUb1JlcXVlc3RQYXJlbnRTcGFuTWFwLmdldChzZXNzaW9uSWQpID8/IG5ldyBNYXAoKTtcbiAgICByZXF1ZXN0SWRUb1NwYW5NYXAuc2V0KHJlcXVlc3RJZCwgYWN0aXZlU3Bhbik7XG4gICAgc2Vzc2lvbkFuZFJlcXVlc3RUb1JlcXVlc3RQYXJlbnRTcGFuTWFwLnNldChzZXNzaW9uSWQsIHJlcXVlc3RJZFRvU3Bhbk1hcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzb2NpYXRlQ29udGV4dFdpdGhSZXF1ZXN0U3BhbihcbiAgZXh0cmFIYW5kbGVyRGF0YSxcbiAgY2IsXG4pIHtcbiAgaWYgKGV4dHJhSGFuZGxlckRhdGEpIHtcbiAgICBjb25zdCB7IHNlc3Npb25JZCwgcmVxdWVzdElkIH0gPSBleHRyYUhhbmRsZXJEYXRhO1xuICAgIGNvbnN0IHJlcXVlc3RJZFNwYW5NYXAgPSBzZXNzaW9uQW5kUmVxdWVzdFRvUmVxdWVzdFBhcmVudFNwYW5NYXAuZ2V0KHNlc3Npb25JZCk7XG5cbiAgICBpZiAoIXJlcXVlc3RJZFNwYW5NYXApIHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH1cblxuICAgIGNvbnN0IHNwYW4gPSByZXF1ZXN0SWRTcGFuTWFwLmdldChyZXF1ZXN0SWQpO1xuICAgIGlmICghc3Bhbikge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHRoZSBzcGFuIGZyb20gdGhlIG1hcCBzbyBpdCBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICByZXF1ZXN0SWRTcGFuTWFwLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgIHJldHVybiB0cmFjZS53aXRoQWN0aXZlU3BhbihzcGFuLCAoKSA9PiB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjYigpO1xufVxuXG5leHBvcnRzLndyYXBNY3BTZXJ2ZXJXaXRoU2VudHJ5ID0gd3JhcE1jcFNlcnZlcldpdGhTZW50cnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tY3Atc2VydmVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/mcp-server.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/metadata.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst worldwide = __webpack_require__(/*! ./utils-hoist/worldwide.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/worldwide.js\");\n\n/** Keys are source filename/url, values are metadata objects. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst filenameMetadataMap = new Map();\n/** Set of stack strings that have already been parsed. */\nconst parsedStacks = new Set();\n\nfunction ensureMetadataStacksAreParsed(parser) {\n  if (!worldwide.GLOBAL_OBJ._sentryModuleMetadata) {\n    return;\n  }\n\n  for (const stack of Object.keys(worldwide.GLOBAL_OBJ._sentryModuleMetadata)) {\n    const metadata = worldwide.GLOBAL_OBJ._sentryModuleMetadata[stack];\n\n    if (parsedStacks.has(stack)) {\n      continue;\n    }\n\n    // Ensure this stack doesn't get parsed again\n    parsedStacks.add(stack);\n\n    const frames = parser(stack);\n\n    // Go through the frames starting from the top of the stack and find the first one with a filename\n    for (const frame of frames.reverse()) {\n      if (frame.filename) {\n        // Save the metadata for this filename\n        filenameMetadataMap.set(frame.filename, metadata);\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Retrieve metadata for a specific JavaScript file URL.\n *\n * Metadata is injected by the Sentry bundler plugins using the `_experiments.moduleMetadata` config option.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getMetadataForUrl(parser, filename) {\n  ensureMetadataStacksAreParsed(parser);\n  return filenameMetadataMap.get(filename);\n}\n\n/**\n * Adds metadata to stack frames.\n *\n * Metadata is injected by the Sentry bundler plugins using the `_experiments.moduleMetadata` config option.\n */\nfunction addMetadataToStackFrames(parser, event) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      if (!exception.stacktrace) {\n        return;\n      }\n\n      for (const frame of exception.stacktrace.frames || []) {\n        if (!frame.filename || frame.module_metadata) {\n          continue;\n        }\n\n        const metadata = getMetadataForUrl(parser, frame.filename);\n\n        if (metadata) {\n          frame.module_metadata = metadata;\n        }\n      }\n    });\n  } catch (_) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\n/**\n * Strips metadata from stack frames.\n */\nfunction stripMetadataFromStackFrames(event) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      if (!exception.stacktrace) {\n        return;\n      }\n\n      for (const frame of exception.stacktrace.frames || []) {\n        delete frame.module_metadata;\n      }\n    });\n  } catch (_) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\nexports.addMetadataToStackFrames = addMetadataToStackFrames;\nexports.getMetadataForUrl = getMetadataForUrl;\nexports.stripMetadataFromStackFrames = stripMetadataFromStackFrames;\n//# sourceMappingURL=metadata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvbWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsa0JBQWtCLG1CQUFPLENBQUMsb0lBQTRCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDLHlCQUF5QjtBQUN6QixvQ0FBb0M7QUFDcEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxtZXRhZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3Qgd29ybGR3aWRlID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC93b3JsZHdpZGUuanMnKTtcblxuLyoqIEtleXMgYXJlIHNvdXJjZSBmaWxlbmFtZS91cmwsIHZhbHVlcyBhcmUgbWV0YWRhdGEgb2JqZWN0cy4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBmaWxlbmFtZU1ldGFkYXRhTWFwID0gbmV3IE1hcCgpO1xuLyoqIFNldCBvZiBzdGFjayBzdHJpbmdzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gcGFyc2VkLiAqL1xuY29uc3QgcGFyc2VkU3RhY2tzID0gbmV3IFNldCgpO1xuXG5mdW5jdGlvbiBlbnN1cmVNZXRhZGF0YVN0YWNrc0FyZVBhcnNlZChwYXJzZXIpIHtcbiAgaWYgKCF3b3JsZHdpZGUuR0xPQkFMX09CSi5fc2VudHJ5TW9kdWxlTWV0YWRhdGEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGNvbnN0IHN0YWNrIG9mIE9iamVjdC5rZXlzKHdvcmxkd2lkZS5HTE9CQUxfT0JKLl9zZW50cnlNb2R1bGVNZXRhZGF0YSkpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHdvcmxkd2lkZS5HTE9CQUxfT0JKLl9zZW50cnlNb2R1bGVNZXRhZGF0YVtzdGFja107XG5cbiAgICBpZiAocGFyc2VkU3RhY2tzLmhhcyhzdGFjaykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGlzIHN0YWNrIGRvZXNuJ3QgZ2V0IHBhcnNlZCBhZ2FpblxuICAgIHBhcnNlZFN0YWNrcy5hZGQoc3RhY2spO1xuXG4gICAgY29uc3QgZnJhbWVzID0gcGFyc2VyKHN0YWNrKTtcblxuICAgIC8vIEdvIHRocm91Z2ggdGhlIGZyYW1lcyBzdGFydGluZyBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrIGFuZCBmaW5kIHRoZSBmaXJzdCBvbmUgd2l0aCBhIGZpbGVuYW1lXG4gICAgZm9yIChjb25zdCBmcmFtZSBvZiBmcmFtZXMucmV2ZXJzZSgpKSB7XG4gICAgICBpZiAoZnJhbWUuZmlsZW5hbWUpIHtcbiAgICAgICAgLy8gU2F2ZSB0aGUgbWV0YWRhdGEgZm9yIHRoaXMgZmlsZW5hbWVcbiAgICAgICAgZmlsZW5hbWVNZXRhZGF0YU1hcC5zZXQoZnJhbWUuZmlsZW5hbWUsIG1ldGFkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0cmlldmUgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgSmF2YVNjcmlwdCBmaWxlIFVSTC5cbiAqXG4gKiBNZXRhZGF0YSBpcyBpbmplY3RlZCBieSB0aGUgU2VudHJ5IGJ1bmRsZXIgcGx1Z2lucyB1c2luZyB0aGUgYF9leHBlcmltZW50cy5tb2R1bGVNZXRhZGF0YWAgY29uZmlnIG9wdGlvbi5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGdldE1ldGFkYXRhRm9yVXJsKHBhcnNlciwgZmlsZW5hbWUpIHtcbiAgZW5zdXJlTWV0YWRhdGFTdGFja3NBcmVQYXJzZWQocGFyc2VyKTtcbiAgcmV0dXJuIGZpbGVuYW1lTWV0YWRhdGFNYXAuZ2V0KGZpbGVuYW1lKTtcbn1cblxuLyoqXG4gKiBBZGRzIG1ldGFkYXRhIHRvIHN0YWNrIGZyYW1lcy5cbiAqXG4gKiBNZXRhZGF0YSBpcyBpbmplY3RlZCBieSB0aGUgU2VudHJ5IGJ1bmRsZXIgcGx1Z2lucyB1c2luZyB0aGUgYF9leHBlcmltZW50cy5tb2R1bGVNZXRhZGF0YWAgY29uZmlnIG9wdGlvbi5cbiAqL1xuZnVuY3Rpb24gYWRkTWV0YWRhdGFUb1N0YWNrRnJhbWVzKHBhcnNlciwgZXZlbnQpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXMuZm9yRWFjaChleGNlcHRpb24gPT4ge1xuICAgICAgaWYgKCFleGNlcHRpb24uc3RhY2t0cmFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZnJhbWUgb2YgZXhjZXB0aW9uLnN0YWNrdHJhY2UuZnJhbWVzIHx8IFtdKSB7XG4gICAgICAgIGlmICghZnJhbWUuZmlsZW5hbWUgfHwgZnJhbWUubW9kdWxlX21ldGFkYXRhKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGdldE1ldGFkYXRhRm9yVXJsKHBhcnNlciwgZnJhbWUuZmlsZW5hbWUpO1xuXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgIGZyYW1lLm1vZHVsZV9tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBUbyBzYXZlIGJ1bmRsZSBzaXplIHdlJ3JlIGp1c3QgdHJ5IGNhdGNoaW5nIGhlcmUgaW5zdGVhZCBvZiBjaGVja2luZyBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbGwgdGhlIGRpZmZlcmVudCBvYmplY3RzLlxuICB9XG59XG5cbi8qKlxuICogU3RyaXBzIG1ldGFkYXRhIGZyb20gc3RhY2sgZnJhbWVzLlxuICovXG5mdW5jdGlvbiBzdHJpcE1ldGFkYXRhRnJvbVN0YWNrRnJhbWVzKGV2ZW50KSB7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBldmVudC5leGNlcHRpb24udmFsdWVzLmZvckVhY2goZXhjZXB0aW9uID0+IHtcbiAgICAgIGlmICghZXhjZXB0aW9uLnN0YWNrdHJhY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZyYW1lIG9mIGV4Y2VwdGlvbi5zdGFja3RyYWNlLmZyYW1lcyB8fCBbXSkge1xuICAgICAgICBkZWxldGUgZnJhbWUubW9kdWxlX21ldGFkYXRhO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7XG4gICAgLy8gVG8gc2F2ZSBidW5kbGUgc2l6ZSB3ZSdyZSBqdXN0IHRyeSBjYXRjaGluZyBoZXJlIGluc3RlYWQgb2YgY2hlY2tpbmcgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYWxsIHRoZSBkaWZmZXJlbnQgb2JqZWN0cy5cbiAgfVxufVxuXG5leHBvcnRzLmFkZE1ldGFkYXRhVG9TdGFja0ZyYW1lcyA9IGFkZE1ldGFkYXRhVG9TdGFja0ZyYW1lcztcbmV4cG9ydHMuZ2V0TWV0YWRhdGFGb3JVcmwgPSBnZXRNZXRhZGF0YUZvclVybDtcbmV4cG9ydHMuc3RyaXBNZXRhZGF0YUZyb21TdGFja0ZyYW1lcyA9IHN0cmlwTWV0YWRhdGFGcm9tU3RhY2tGcmFtZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/metadata.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/profiling.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\n\nfunction isProfilingIntegrationWithProfiler(\n  integration,\n) {\n  return (\n    !!integration &&\n    typeof integration['_profiler'] !== 'undefined' &&\n    typeof integration['_profiler']['start'] === 'function' &&\n    typeof integration['_profiler']['stop'] === 'function'\n  );\n}\n/**\n * Starts the Sentry continuous profiler.\n * This mode is exclusive with the transaction profiler and will only work if the profilesSampleRate is set to a falsy value.\n * In continuous profiling mode, the profiler will keep reporting profile chunks to Sentry until it is stopped, which allows for continuous profiling of the application.\n */\nfunction startProfiler() {\n  const client = currentScopes.getClient();\n  if (!client) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('No Sentry client available, profiling is not started');\n    return;\n  }\n\n  const integration = client.getIntegrationByName('ProfilingIntegration');\n\n  if (!integration) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('ProfilingIntegration is not available');\n    return;\n  }\n\n  if (!isProfilingIntegrationWithProfiler(integration)) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('Profiler is not available on profiling integration.');\n    return;\n  }\n\n  integration._profiler.start();\n}\n\n/**\n * Stops the Sentry continuous profiler.\n * Calls to stop will stop the profiler and flush the currently collected profile data to Sentry.\n */\nfunction stopProfiler() {\n  const client = currentScopes.getClient();\n  if (!client) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('No Sentry client available, profiling is not started');\n    return;\n  }\n\n  const integration = client.getIntegrationByName('ProfilingIntegration');\n  if (!integration) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('ProfilingIntegration is not available');\n    return;\n  }\n\n  if (!isProfilingIntegrationWithProfiler(integration)) {\n    debugBuild.DEBUG_BUILD && logger.logger.warn('Profiler is not available on profiling integration.');\n    return;\n  }\n\n  integration._profiler.stop();\n}\n\nconst profiler = {\n  startProfiler,\n  stopProfiler,\n};\n\nexports.profiler = profiler;\n//# sourceMappingURL=profiling.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvcHJvZmlsaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLHNCQUFzQixtQkFBTyxDQUFDLG9IQUFvQjtBQUNsRCxtQkFBbUIsbUJBQU8sQ0FBQyxnSEFBa0I7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLDhIQUF5Qjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXHByb2ZpbGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgY3VycmVudFNjb3BlcyA9IHJlcXVpcmUoJy4vY3VycmVudFNjb3Blcy5qcycpO1xuY29uc3QgZGVidWdCdWlsZCA9IHJlcXVpcmUoJy4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5cbmZ1bmN0aW9uIGlzUHJvZmlsaW5nSW50ZWdyYXRpb25XaXRoUHJvZmlsZXIoXG4gIGludGVncmF0aW9uLFxuKSB7XG4gIHJldHVybiAoXG4gICAgISFpbnRlZ3JhdGlvbiAmJlxuICAgIHR5cGVvZiBpbnRlZ3JhdGlvblsnX3Byb2ZpbGVyJ10gIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGludGVncmF0aW9uWydfcHJvZmlsZXInXVsnc3RhcnQnXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBpbnRlZ3JhdGlvblsnX3Byb2ZpbGVyJ11bJ3N0b3AnXSA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufVxuLyoqXG4gKiBTdGFydHMgdGhlIFNlbnRyeSBjb250aW51b3VzIHByb2ZpbGVyLlxuICogVGhpcyBtb2RlIGlzIGV4Y2x1c2l2ZSB3aXRoIHRoZSB0cmFuc2FjdGlvbiBwcm9maWxlciBhbmQgd2lsbCBvbmx5IHdvcmsgaWYgdGhlIHByb2ZpbGVzU2FtcGxlUmF0ZSBpcyBzZXQgdG8gYSBmYWxzeSB2YWx1ZS5cbiAqIEluIGNvbnRpbnVvdXMgcHJvZmlsaW5nIG1vZGUsIHRoZSBwcm9maWxlciB3aWxsIGtlZXAgcmVwb3J0aW5nIHByb2ZpbGUgY2h1bmtzIHRvIFNlbnRyeSB1bnRpbCBpdCBpcyBzdG9wcGVkLCB3aGljaCBhbGxvd3MgZm9yIGNvbnRpbnVvdXMgcHJvZmlsaW5nIG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAqL1xuZnVuY3Rpb24gc3RhcnRQcm9maWxlcigpIHtcbiAgY29uc3QgY2xpZW50ID0gY3VycmVudFNjb3Blcy5nZXRDbGllbnQoKTtcbiAgaWYgKCFjbGllbnQpIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybignTm8gU2VudHJ5IGNsaWVudCBhdmFpbGFibGUsIHByb2ZpbGluZyBpcyBub3Qgc3RhcnRlZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGludGVncmF0aW9uID0gY2xpZW50LmdldEludGVncmF0aW9uQnlOYW1lKCdQcm9maWxpbmdJbnRlZ3JhdGlvbicpO1xuXG4gIGlmICghaW50ZWdyYXRpb24pIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybignUHJvZmlsaW5nSW50ZWdyYXRpb24gaXMgbm90IGF2YWlsYWJsZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghaXNQcm9maWxpbmdJbnRlZ3JhdGlvbldpdGhQcm9maWxlcihpbnRlZ3JhdGlvbikpIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybignUHJvZmlsZXIgaXMgbm90IGF2YWlsYWJsZSBvbiBwcm9maWxpbmcgaW50ZWdyYXRpb24uJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaW50ZWdyYXRpb24uX3Byb2ZpbGVyLnN0YXJ0KCk7XG59XG5cbi8qKlxuICogU3RvcHMgdGhlIFNlbnRyeSBjb250aW51b3VzIHByb2ZpbGVyLlxuICogQ2FsbHMgdG8gc3RvcCB3aWxsIHN0b3AgdGhlIHByb2ZpbGVyIGFuZCBmbHVzaCB0aGUgY3VycmVudGx5IGNvbGxlY3RlZCBwcm9maWxlIGRhdGEgdG8gU2VudHJ5LlxuICovXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXIoKSB7XG4gIGNvbnN0IGNsaWVudCA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG4gIGlmICghY2xpZW50KSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLndhcm4oJ05vIFNlbnRyeSBjbGllbnQgYXZhaWxhYmxlLCBwcm9maWxpbmcgaXMgbm90IHN0YXJ0ZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBpbnRlZ3JhdGlvbiA9IGNsaWVudC5nZXRJbnRlZ3JhdGlvbkJ5TmFtZSgnUHJvZmlsaW5nSW50ZWdyYXRpb24nKTtcbiAgaWYgKCFpbnRlZ3JhdGlvbikge1xuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdQcm9maWxpbmdJbnRlZ3JhdGlvbiBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFpc1Byb2ZpbGluZ0ludGVncmF0aW9uV2l0aFByb2ZpbGVyKGludGVncmF0aW9uKSkge1xuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKCdQcm9maWxlciBpcyBub3QgYXZhaWxhYmxlIG9uIHByb2ZpbGluZyBpbnRlZ3JhdGlvbi4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpbnRlZ3JhdGlvbi5fcHJvZmlsZXIuc3RvcCgpO1xufVxuXG5jb25zdCBwcm9maWxlciA9IHtcbiAgc3RhcnRQcm9maWxlcixcbiAgc3RvcFByb2ZpbGVyLFxufTtcblxuZXhwb3J0cy5wcm9maWxlciA9IHByb2ZpbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvZmlsaW5nLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/profiling.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/scope.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst session = __webpack_require__(/*! ./session.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/session.js\");\nconst merge = __webpack_require__(/*! ./utils/merge.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/merge.js\");\nconst spanOnScope = __webpack_require__(/*! ./utils/spanOnScope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanOnScope.js\");\nconst is = __webpack_require__(/*! ./utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst misc = __webpack_require__(/*! ./utils-hoist/misc.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js\");\nconst propagationContext = __webpack_require__(/*! ./utils-hoist/propagationContext.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/propagationContext.js\");\nconst string = __webpack_require__(/*! ./utils-hoist/string.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/string.js\");\nconst time = __webpack_require__(/*! ./utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\n\n/**\n * Default value for maximum number of breadcrumbs added to an event.\n */\nconst DEFAULT_MAX_BREADCRUMBS = 100;\n\n/**\n * A context to be used for capturing an event.\n * This can either be a Scope, or a partial ScopeContext,\n * or a callback that receives the current scope and returns a new scope to use.\n */\n\n/**\n * Holds additional event information.\n */\nclass Scope {\n  /** Flag if notifying is happening. */\n\n  /** Callback for client to receive scope changes. */\n\n  /** Callback list that will be called during event processing. */\n\n  /** Array of breadcrumbs. */\n\n  /** User */\n\n  /** Tags */\n\n  /** Extra */\n\n  /** Contexts */\n\n  /** Attachments */\n\n  /** Propagation Context for distributed tracing */\n\n  /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */\n\n  /** Fingerprint */\n\n  /** Severity */\n\n  /**\n   * Transaction Name\n   *\n   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.\n   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.\n   */\n\n  /** Session */\n\n  /** The client on this scope */\n\n  /** Contains the last event id of a captured event.  */\n\n  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.\n\n   constructor() {\n    this._notifyingListeners = false;\n    this._scopeListeners = [];\n    this._eventProcessors = [];\n    this._breadcrumbs = [];\n    this._attachments = [];\n    this._user = {};\n    this._tags = {};\n    this._extra = {};\n    this._contexts = {};\n    this._sdkProcessingMetadata = {};\n    this._propagationContext = {\n      traceId: propagationContext.generateTraceId(),\n      sampleRand: Math.random(),\n    };\n  }\n\n  /**\n   * Clone all data from this scope into a new scope.\n   */\n   clone() {\n    const newScope = new Scope();\n    newScope._breadcrumbs = [...this._breadcrumbs];\n    newScope._tags = { ...this._tags };\n    newScope._extra = { ...this._extra };\n    newScope._contexts = { ...this._contexts };\n    if (this._contexts.flags) {\n      // We need to copy the `values` array so insertions on a cloned scope\n      // won't affect the original array.\n      newScope._contexts.flags = {\n        values: [...this._contexts.flags.values],\n      };\n    }\n\n    newScope._user = this._user;\n    newScope._level = this._level;\n    newScope._session = this._session;\n    newScope._transactionName = this._transactionName;\n    newScope._fingerprint = this._fingerprint;\n    newScope._eventProcessors = [...this._eventProcessors];\n    newScope._attachments = [...this._attachments];\n    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };\n    newScope._propagationContext = { ...this._propagationContext };\n    newScope._client = this._client;\n    newScope._lastEventId = this._lastEventId;\n\n    spanOnScope._setSpanForScope(newScope, spanOnScope._getSpanForScope(this));\n\n    return newScope;\n  }\n\n  /**\n   * Update the client assigned to this scope.\n   * Note that not every scope will have a client assigned - isolation scopes & the global scope will generally not have a client,\n   * as well as manually created scopes.\n   */\n   setClient(client) {\n    this._client = client;\n  }\n\n  /**\n   * Set the ID of the last captured error event.\n   * This is generally only captured on the isolation scope.\n   */\n   setLastEventId(lastEventId) {\n    this._lastEventId = lastEventId;\n  }\n\n  /**\n   * Get the client assigned to this scope.\n   */\n   getClient() {\n    return this._client ;\n  }\n\n  /**\n   * Get the ID of the last captured error event.\n   * This is generally only available on the isolation scope.\n   */\n   lastEventId() {\n    return this._lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addScopeListener(callback) {\n    this._scopeListeners.push(callback);\n  }\n\n  /**\n   * Add an event processor that will be called before an event is sent.\n   */\n   addEventProcessor(callback) {\n    this._eventProcessors.push(callback);\n    return this;\n  }\n\n  /**\n   * Set the user for this scope.\n   * Set to `null` to unset the user.\n   */\n   setUser(user) {\n    // If null is passed we want to unset everything, but still define keys,\n    // so that later down in the pipeline any existing values are cleared.\n    this._user = user || {\n      email: undefined,\n      id: undefined,\n      ip_address: undefined,\n      username: undefined,\n    };\n\n    if (this._session) {\n      session.updateSession(this._session, { user });\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Get the user from this scope.\n   */\n   getUser() {\n    return this._user;\n  }\n\n  /**\n   * Set an object that will be merged into existing tags on the scope,\n   * and will be sent as tags data with the event.\n   */\n   setTags(tags) {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set a single tag that will be sent as tags data with the event.\n   */\n   setTag(key, value) {\n    this._tags = { ...this._tags, [key]: value };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set an object that will be merged into existing extra on the scope,\n   * and will be sent as extra data with the event.\n   */\n   setExtras(extras) {\n    this._extra = {\n      ...this._extra,\n      ...extras,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set a single key:value extra entry that will be sent as extra data with the event.\n   */\n   setExtra(key, extra) {\n    this._extra = { ...this._extra, [key]: extra };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the fingerprint on the scope to send with the events.\n   * @param {string[]} fingerprint Fingerprint to group events in Sentry.\n   */\n   setFingerprint(fingerprint) {\n    this._fingerprint = fingerprint;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the level on the scope for future events.\n   */\n   setLevel(level) {\n    this._level = level;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the transaction name on the scope so that the name of e.g. taken server route or\n   * the page location is attached to future events.\n   *\n   * IMPORTANT: Calling this function does NOT change the name of the currently active\n   * root span. If you want to change the name of the active root span, use\n   * `Sentry.updateSpanName(rootSpan, 'new name')` instead.\n   *\n   * By default, the SDK updates the scope's transaction name automatically on sensible\n   * occasions, such as a page navigation or when handling a new request on the server.\n   */\n   setTransactionName(name) {\n    this._transactionName = name;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets context data with the given name.\n   * Data passed as context will be normalized. You can also pass `null` to unset the context.\n   * Note that context data will not be merged - calling `setContext` will overwrite an existing context with the same key.\n   */\n   setContext(key, context) {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts[key] = context;\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set the session for the scope.\n   */\n   setSession(session) {\n    if (!session) {\n      delete this._session;\n    } else {\n      this._session = session;\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Get the session from the scope.\n   */\n   getSession() {\n    return this._session;\n  }\n\n  /**\n   * Updates the scope with provided data. Can work in three variations:\n   * - plain object containing updatable attributes\n   * - Scope instance that'll extract the attributes from\n   * - callback function that'll receive the current scope as an argument and allow for modifications\n   */\n   update(captureContext) {\n    if (!captureContext) {\n      return this;\n    }\n\n    const scopeToMerge = typeof captureContext === 'function' ? captureContext(this) : captureContext;\n\n    const scopeInstance =\n      scopeToMerge instanceof Scope\n        ? scopeToMerge.getScopeData()\n        : is.isPlainObject(scopeToMerge)\n          ? (captureContext )\n          : undefined;\n\n    const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};\n\n    this._tags = { ...this._tags, ...tags };\n    this._extra = { ...this._extra, ...extra };\n    this._contexts = { ...this._contexts, ...contexts };\n\n    if (user && Object.keys(user).length) {\n      this._user = user;\n    }\n\n    if (level) {\n      this._level = level;\n    }\n\n    if (fingerprint.length) {\n      this._fingerprint = fingerprint;\n    }\n\n    if (propagationContext) {\n      this._propagationContext = propagationContext;\n    }\n\n    return this;\n  }\n\n  /**\n   * Clears the current scope and resets its properties.\n   * Note: The client will not be cleared.\n   */\n   clear() {\n    // client is not cleared here on purpose!\n    this._breadcrumbs = [];\n    this._tags = {};\n    this._extra = {};\n    this._user = {};\n    this._contexts = {};\n    this._level = undefined;\n    this._transactionName = undefined;\n    this._fingerprint = undefined;\n    this._session = undefined;\n    spanOnScope._setSpanForScope(this, undefined);\n    this._attachments = [];\n    this.setPropagationContext({ traceId: propagationContext.generateTraceId(), sampleRand: Math.random() });\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Adds a breadcrumb to the scope.\n   * By default, the last 100 breadcrumbs are kept.\n   */\n   addBreadcrumb(breadcrumb, maxBreadcrumbs) {\n    const maxCrumbs = typeof maxBreadcrumbs === 'number' ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;\n\n    // No data has been changed, so don't notify scope listeners\n    if (maxCrumbs <= 0) {\n      return this;\n    }\n\n    const mergedBreadcrumb = {\n      timestamp: time.dateTimestampInSeconds(),\n      ...breadcrumb,\n      // Breadcrumb messages can theoretically be infinitely large and they're held in memory so we truncate them not to leak (too much) memory\n      message: breadcrumb.message ? string.truncate(breadcrumb.message, 2048) : breadcrumb.message,\n    };\n\n    this._breadcrumbs.push(mergedBreadcrumb);\n    if (this._breadcrumbs.length > maxCrumbs) {\n      this._breadcrumbs = this._breadcrumbs.slice(-maxCrumbs);\n      this._client?.recordDroppedEvent('buffer_overflow', 'log_item');\n    }\n\n    this._notifyScopeListeners();\n\n    return this;\n  }\n\n  /**\n   * Get the last breadcrumb of the scope.\n   */\n   getLastBreadcrumb() {\n    return this._breadcrumbs[this._breadcrumbs.length - 1];\n  }\n\n  /**\n   * Clear all breadcrumbs from the scope.\n   */\n   clearBreadcrumbs() {\n    this._breadcrumbs = [];\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Add an attachment to the scope.\n   */\n   addAttachment(attachment) {\n    this._attachments.push(attachment);\n    return this;\n  }\n\n  /**\n   * Clear all attachments from the scope.\n   */\n   clearAttachments() {\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * Get the data of this scope, which should be applied to an event during processing.\n   */\n   getScopeData() {\n    return {\n      breadcrumbs: this._breadcrumbs,\n      attachments: this._attachments,\n      contexts: this._contexts,\n      tags: this._tags,\n      extra: this._extra,\n      user: this._user,\n      level: this._level,\n      fingerprint: this._fingerprint || [],\n      eventProcessors: this._eventProcessors,\n      propagationContext: this._propagationContext,\n      sdkProcessingMetadata: this._sdkProcessingMetadata,\n      transactionName: this._transactionName,\n      span: spanOnScope._getSpanForScope(this),\n    };\n  }\n\n  /**\n   * Add data which will be accessible during event processing but won't get sent to Sentry.\n   */\n   setSDKProcessingMetadata(newData) {\n    this._sdkProcessingMetadata = merge.merge(this._sdkProcessingMetadata, newData, 2);\n    return this;\n  }\n\n  /**\n   * Add propagation context to the scope, used for distributed tracing\n   */\n   setPropagationContext(context) {\n    this._propagationContext = context;\n    return this;\n  }\n\n  /**\n   * Get propagation context from the scope, used for distributed tracing\n   */\n   getPropagationContext() {\n    return this._propagationContext;\n  }\n\n  /**\n   * Capture an exception for this scope.\n   *\n   * @returns {string} The id of the captured Sentry event.\n   */\n   captureException(exception, hint) {\n    const eventId = hint?.event_id || misc.uuid4();\n\n    if (!this._client) {\n      logger.logger.warn('No client configured on scope - will not capture exception!');\n      return eventId;\n    }\n\n    const syntheticException = new Error('Sentry syntheticException');\n\n    this._client.captureException(\n      exception,\n      {\n        originalException: exception,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * Capture a message for this scope.\n   *\n   * @returns {string} The id of the captured message.\n   */\n   captureMessage(message, level, hint) {\n    const eventId = hint?.event_id || misc.uuid4();\n\n    if (!this._client) {\n      logger.logger.warn('No client configured on scope - will not capture message!');\n      return eventId;\n    }\n\n    const syntheticException = new Error(message);\n\n    this._client.captureMessage(\n      message,\n      level,\n      {\n        originalException: message,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * Capture a Sentry event for this scope.\n   *\n   * @returns {string} The id of the captured event.\n   */\n   captureEvent(event, hint) {\n    const eventId = hint?.event_id || misc.uuid4();\n\n    if (!this._client) {\n      logger.logger.warn('No client configured on scope - will not capture event!');\n      return eventId;\n    }\n\n    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);\n\n    return eventId;\n  }\n\n  /**\n   * This will be called on every set call.\n   */\n   _notifyScopeListeners() {\n    // We need this check for this._notifyingListeners to be able to work on scope during updates\n    // If this check is not here we'll produce endless recursion when something is done with the scope\n    // during the callback.\n    if (!this._notifyingListeners) {\n      this._notifyingListeners = true;\n      this._scopeListeners.forEach(callback => {\n        callback(this);\n      });\n      this._notifyingListeners = false;\n    }\n  }\n}\n\nexports.Scope = Scope;\n//# sourceMappingURL=scope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvc2NvcGUuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQWM7QUFDdEMsY0FBYyxtQkFBTyxDQUFDLGdIQUFrQjtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyw0SEFBd0I7QUFDcEQsV0FBVyxtQkFBTyxDQUFDLHNIQUFxQjtBQUN4QyxlQUFlLG1CQUFPLENBQUMsOEhBQXlCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQywwSEFBdUI7QUFDNUMsMkJBQTJCLG1CQUFPLENBQUMsc0pBQXFDO0FBQ3hFLGVBQWUsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLDBIQUF1Qjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSwyRUFBMkU7O0FBRXZGLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBFQUEwRTs7QUFFM0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsNEJBQTRCOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcc2NvcGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IHNlc3Npb24gPSByZXF1aXJlKCcuL3Nlc3Npb24uanMnKTtcbmNvbnN0IG1lcmdlID0gcmVxdWlyZSgnLi91dGlscy9tZXJnZS5qcycpO1xuY29uc3Qgc3Bhbk9uU2NvcGUgPSByZXF1aXJlKCcuL3V0aWxzL3NwYW5PblNjb3BlLmpzJyk7XG5jb25zdCBpcyA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvaXMuanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCBtaXNjID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9taXNjLmpzJyk7XG5jb25zdCBwcm9wYWdhdGlvbkNvbnRleHQgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3Byb3BhZ2F0aW9uQ29udGV4dC5qcycpO1xuY29uc3Qgc3RyaW5nID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9zdHJpbmcuanMnKTtcbmNvbnN0IHRpbWUgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L3RpbWUuanMnKTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlIGZvciBtYXhpbXVtIG51bWJlciBvZiBicmVhZGNydW1icyBhZGRlZCB0byBhbiBldmVudC5cbiAqL1xuY29uc3QgREVGQVVMVF9NQVhfQlJFQURDUlVNQlMgPSAxMDA7XG5cbi8qKlxuICogQSBjb250ZXh0IHRvIGJlIHVzZWQgZm9yIGNhcHR1cmluZyBhbiBldmVudC5cbiAqIFRoaXMgY2FuIGVpdGhlciBiZSBhIFNjb3BlLCBvciBhIHBhcnRpYWwgU2NvcGVDb250ZXh0LFxuICogb3IgYSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBjdXJyZW50IHNjb3BlIGFuZCByZXR1cm5zIGEgbmV3IHNjb3BlIHRvIHVzZS5cbiAqL1xuXG4vKipcbiAqIEhvbGRzIGFkZGl0aW9uYWwgZXZlbnQgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIFNjb3BlIHtcbiAgLyoqIEZsYWcgaWYgbm90aWZ5aW5nIGlzIGhhcHBlbmluZy4gKi9cblxuICAvKiogQ2FsbGJhY2sgZm9yIGNsaWVudCB0byByZWNlaXZlIHNjb3BlIGNoYW5nZXMuICovXG5cbiAgLyoqIENhbGxiYWNrIGxpc3QgdGhhdCB3aWxsIGJlIGNhbGxlZCBkdXJpbmcgZXZlbnQgcHJvY2Vzc2luZy4gKi9cblxuICAvKiogQXJyYXkgb2YgYnJlYWRjcnVtYnMuICovXG5cbiAgLyoqIFVzZXIgKi9cblxuICAvKiogVGFncyAqL1xuXG4gIC8qKiBFeHRyYSAqL1xuXG4gIC8qKiBDb250ZXh0cyAqL1xuXG4gIC8qKiBBdHRhY2htZW50cyAqL1xuXG4gIC8qKiBQcm9wYWdhdGlvbiBDb250ZXh0IGZvciBkaXN0cmlidXRlZCB0cmFjaW5nICovXG5cbiAgLyoqXG4gICAqIEEgcGxhY2UgdG8gc3Rhc2ggZGF0YSB3aGljaCBpcyBuZWVkZWQgYXQgc29tZSBwb2ludCBpbiB0aGUgU0RLJ3MgZXZlbnQgcHJvY2Vzc2luZyBwaXBlbGluZSBidXQgd2hpY2ggc2hvdWxkbid0IGdldFxuICAgKiBzZW50IHRvIFNlbnRyeVxuICAgKi9cblxuICAvKiogRmluZ2VycHJpbnQgKi9cblxuICAvKiogU2V2ZXJpdHkgKi9cblxuICAvKipcbiAgICogVHJhbnNhY3Rpb24gTmFtZVxuICAgKlxuICAgKiBJTVBPUlRBTlQ6IFRoZSB0cmFuc2FjdGlvbiBuYW1lIG9uIHRoZSBzY29wZSBoYXMgbm90aGluZyB0byBkbyB3aXRoIHJvb3Qgc3BhbnMvdHJhbnNhY3Rpb24gb2JqZWN0cy5cbiAgICogSXQncyBwdXJwb3NlIGlzIHRvIGFzc2lnbiBhIHRyYW5zYWN0aW9uIHRvIHRoZSBzY29wZSB0aGF0J3MgYWRkZWQgdG8gbm9uLXRyYW5zYWN0aW9uIGV2ZW50cy5cbiAgICovXG5cbiAgLyoqIFNlc3Npb24gKi9cblxuICAvKiogVGhlIGNsaWVudCBvbiB0aGlzIHNjb3BlICovXG5cbiAgLyoqIENvbnRhaW5zIHRoZSBsYXN0IGV2ZW50IGlkIG9mIGEgY2FwdHVyZWQgZXZlbnQuICAqL1xuXG4gIC8vIE5PVEU6IEFueSBmaWVsZCB3aGljaCBnZXRzIGFkZGVkIGhlcmUgc2hvdWxkIGdldCBhZGRlZCBub3Qgb25seSB0byB0aGUgY29uc3RydWN0b3IgYnV0IGFsc28gdG8gdGhlIGBjbG9uZWAgbWV0aG9kLlxuXG4gICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9ub3RpZnlpbmdMaXN0ZW5lcnMgPSBmYWxzZTtcbiAgICB0aGlzLl9zY29wZUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX2V2ZW50UHJvY2Vzc29ycyA9IFtdO1xuICAgIHRoaXMuX2JyZWFkY3J1bWJzID0gW107XG4gICAgdGhpcy5fYXR0YWNobWVudHMgPSBbXTtcbiAgICB0aGlzLl91c2VyID0ge307XG4gICAgdGhpcy5fdGFncyA9IHt9O1xuICAgIHRoaXMuX2V4dHJhID0ge307XG4gICAgdGhpcy5fY29udGV4dHMgPSB7fTtcbiAgICB0aGlzLl9zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7fTtcbiAgICB0aGlzLl9wcm9wYWdhdGlvbkNvbnRleHQgPSB7XG4gICAgICB0cmFjZUlkOiBwcm9wYWdhdGlvbkNvbnRleHQuZ2VuZXJhdGVUcmFjZUlkKCksXG4gICAgICBzYW1wbGVSYW5kOiBNYXRoLnJhbmRvbSgpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmUgYWxsIGRhdGEgZnJvbSB0aGlzIHNjb3BlIGludG8gYSBuZXcgc2NvcGUuXG4gICAqL1xuICAgY2xvbmUoKSB7XG4gICAgY29uc3QgbmV3U2NvcGUgPSBuZXcgU2NvcGUoKTtcbiAgICBuZXdTY29wZS5fYnJlYWRjcnVtYnMgPSBbLi4udGhpcy5fYnJlYWRjcnVtYnNdO1xuICAgIG5ld1Njb3BlLl90YWdzID0geyAuLi50aGlzLl90YWdzIH07XG4gICAgbmV3U2NvcGUuX2V4dHJhID0geyAuLi50aGlzLl9leHRyYSB9O1xuICAgIG5ld1Njb3BlLl9jb250ZXh0cyA9IHsgLi4udGhpcy5fY29udGV4dHMgfTtcbiAgICBpZiAodGhpcy5fY29udGV4dHMuZmxhZ3MpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY29weSB0aGUgYHZhbHVlc2AgYXJyYXkgc28gaW5zZXJ0aW9ucyBvbiBhIGNsb25lZCBzY29wZVxuICAgICAgLy8gd29uJ3QgYWZmZWN0IHRoZSBvcmlnaW5hbCBhcnJheS5cbiAgICAgIG5ld1Njb3BlLl9jb250ZXh0cy5mbGFncyA9IHtcbiAgICAgICAgdmFsdWVzOiBbLi4udGhpcy5fY29udGV4dHMuZmxhZ3MudmFsdWVzXSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbmV3U2NvcGUuX3VzZXIgPSB0aGlzLl91c2VyO1xuICAgIG5ld1Njb3BlLl9sZXZlbCA9IHRoaXMuX2xldmVsO1xuICAgIG5ld1Njb3BlLl9zZXNzaW9uID0gdGhpcy5fc2Vzc2lvbjtcbiAgICBuZXdTY29wZS5fdHJhbnNhY3Rpb25OYW1lID0gdGhpcy5fdHJhbnNhY3Rpb25OYW1lO1xuICAgIG5ld1Njb3BlLl9maW5nZXJwcmludCA9IHRoaXMuX2ZpbmdlcnByaW50O1xuICAgIG5ld1Njb3BlLl9ldmVudFByb2Nlc3NvcnMgPSBbLi4udGhpcy5fZXZlbnRQcm9jZXNzb3JzXTtcbiAgICBuZXdTY29wZS5fYXR0YWNobWVudHMgPSBbLi4udGhpcy5fYXR0YWNobWVudHNdO1xuICAgIG5ld1Njb3BlLl9zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7IC4uLnRoaXMuX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSB9O1xuICAgIG5ld1Njb3BlLl9wcm9wYWdhdGlvbkNvbnRleHQgPSB7IC4uLnRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCB9O1xuICAgIG5ld1Njb3BlLl9jbGllbnQgPSB0aGlzLl9jbGllbnQ7XG4gICAgbmV3U2NvcGUuX2xhc3RFdmVudElkID0gdGhpcy5fbGFzdEV2ZW50SWQ7XG5cbiAgICBzcGFuT25TY29wZS5fc2V0U3BhbkZvclNjb3BlKG5ld1Njb3BlLCBzcGFuT25TY29wZS5fZ2V0U3BhbkZvclNjb3BlKHRoaXMpKTtcblxuICAgIHJldHVybiBuZXdTY29wZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNsaWVudCBhc3NpZ25lZCB0byB0aGlzIHNjb3BlLlxuICAgKiBOb3RlIHRoYXQgbm90IGV2ZXJ5IHNjb3BlIHdpbGwgaGF2ZSBhIGNsaWVudCBhc3NpZ25lZCAtIGlzb2xhdGlvbiBzY29wZXMgJiB0aGUgZ2xvYmFsIHNjb3BlIHdpbGwgZ2VuZXJhbGx5IG5vdCBoYXZlIGEgY2xpZW50LFxuICAgKiBhcyB3ZWxsIGFzIG1hbnVhbGx5IGNyZWF0ZWQgc2NvcGVzLlxuICAgKi9cbiAgIHNldENsaWVudChjbGllbnQpIHtcbiAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBJRCBvZiB0aGUgbGFzdCBjYXB0dXJlZCBlcnJvciBldmVudC5cbiAgICogVGhpcyBpcyBnZW5lcmFsbHkgb25seSBjYXB0dXJlZCBvbiB0aGUgaXNvbGF0aW9uIHNjb3BlLlxuICAgKi9cbiAgIHNldExhc3RFdmVudElkKGxhc3RFdmVudElkKSB7XG4gICAgdGhpcy5fbGFzdEV2ZW50SWQgPSBsYXN0RXZlbnRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNsaWVudCBhc3NpZ25lZCB0byB0aGlzIHNjb3BlLlxuICAgKi9cbiAgIGdldENsaWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50IDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIElEIG9mIHRoZSBsYXN0IGNhcHR1cmVkIGVycm9yIGV2ZW50LlxuICAgKiBUaGlzIGlzIGdlbmVyYWxseSBvbmx5IGF2YWlsYWJsZSBvbiB0aGUgaXNvbGF0aW9uIHNjb3BlLlxuICAgKi9cbiAgIGxhc3RFdmVudElkKCkge1xuICAgIHJldHVybiB0aGlzLl9sYXN0RXZlbnRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGFkZFNjb3BlTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9zY29wZUxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgcHJvY2Vzc29yIHRoYXQgd2lsbCBiZSBjYWxsZWQgYmVmb3JlIGFuIGV2ZW50IGlzIHNlbnQuXG4gICAqL1xuICAgYWRkRXZlbnRQcm9jZXNzb3IoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ldmVudFByb2Nlc3NvcnMucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB1c2VyIGZvciB0aGlzIHNjb3BlLlxuICAgKiBTZXQgdG8gYG51bGxgIHRvIHVuc2V0IHRoZSB1c2VyLlxuICAgKi9cbiAgIHNldFVzZXIodXNlcikge1xuICAgIC8vIElmIG51bGwgaXMgcGFzc2VkIHdlIHdhbnQgdG8gdW5zZXQgZXZlcnl0aGluZywgYnV0IHN0aWxsIGRlZmluZSBrZXlzLFxuICAgIC8vIHNvIHRoYXQgbGF0ZXIgZG93biBpbiB0aGUgcGlwZWxpbmUgYW55IGV4aXN0aW5nIHZhbHVlcyBhcmUgY2xlYXJlZC5cbiAgICB0aGlzLl91c2VyID0gdXNlciB8fCB7XG4gICAgICBlbWFpbDogdW5kZWZpbmVkLFxuICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgIGlwX2FkZHJlc3M6IHVuZGVmaW5lZCxcbiAgICAgIHVzZXJuYW1lOiB1bmRlZmluZWQsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9zZXNzaW9uKSB7XG4gICAgICBzZXNzaW9uLnVwZGF0ZVNlc3Npb24odGhpcy5fc2Vzc2lvbiwgeyB1c2VyIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1c2VyIGZyb20gdGhpcyBzY29wZS5cbiAgICovXG4gICBnZXRVc2VyKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhbiBvYmplY3QgdGhhdCB3aWxsIGJlIG1lcmdlZCBpbnRvIGV4aXN0aW5nIHRhZ3Mgb24gdGhlIHNjb3BlLFxuICAgKiBhbmQgd2lsbCBiZSBzZW50IGFzIHRhZ3MgZGF0YSB3aXRoIHRoZSBldmVudC5cbiAgICovXG4gICBzZXRUYWdzKHRhZ3MpIHtcbiAgICB0aGlzLl90YWdzID0ge1xuICAgICAgLi4udGhpcy5fdGFncyxcbiAgICAgIC4uLnRhZ3MsXG4gICAgfTtcbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIHNpbmdsZSB0YWcgdGhhdCB3aWxsIGJlIHNlbnQgYXMgdGFncyBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICAgKi9cbiAgIHNldFRhZyhrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fdGFncyA9IHsgLi4udGhpcy5fdGFncywgW2tleV06IHZhbHVlIH07XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYW4gb2JqZWN0IHRoYXQgd2lsbCBiZSBtZXJnZWQgaW50byBleGlzdGluZyBleHRyYSBvbiB0aGUgc2NvcGUsXG4gICAqIGFuZCB3aWxsIGJlIHNlbnQgYXMgZXh0cmEgZGF0YSB3aXRoIHRoZSBldmVudC5cbiAgICovXG4gICBzZXRFeHRyYXMoZXh0cmFzKSB7XG4gICAgdGhpcy5fZXh0cmEgPSB7XG4gICAgICAuLi50aGlzLl9leHRyYSxcbiAgICAgIC4uLmV4dHJhcyxcbiAgICB9O1xuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgc2luZ2xlIGtleTp2YWx1ZSBleHRyYSBlbnRyeSB0aGF0IHdpbGwgYmUgc2VudCBhcyBleHRyYSBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICAgKi9cbiAgIHNldEV4dHJhKGtleSwgZXh0cmEpIHtcbiAgICB0aGlzLl9leHRyYSA9IHsgLi4udGhpcy5fZXh0cmEsIFtrZXldOiBleHRyYSB9O1xuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmluZ2VycHJpbnQgb24gdGhlIHNjb3BlIHRvIHNlbmQgd2l0aCB0aGUgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaW5nZXJwcmludCBGaW5nZXJwcmludCB0byBncm91cCBldmVudHMgaW4gU2VudHJ5LlxuICAgKi9cbiAgIHNldEZpbmdlcnByaW50KGZpbmdlcnByaW50KSB7XG4gICAgdGhpcy5fZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludDtcbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxldmVsIG9uIHRoZSBzY29wZSBmb3IgZnV0dXJlIGV2ZW50cy5cbiAgICovXG4gICBzZXRMZXZlbChsZXZlbCkge1xuICAgIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0cmFuc2FjdGlvbiBuYW1lIG9uIHRoZSBzY29wZSBzbyB0aGF0IHRoZSBuYW1lIG9mIGUuZy4gdGFrZW4gc2VydmVyIHJvdXRlIG9yXG4gICAqIHRoZSBwYWdlIGxvY2F0aW9uIGlzIGF0dGFjaGVkIHRvIGZ1dHVyZSBldmVudHMuXG4gICAqXG4gICAqIElNUE9SVEFOVDogQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIGRvZXMgTk9UIGNoYW5nZSB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZVxuICAgKiByb290IHNwYW4uIElmIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgbmFtZSBvZiB0aGUgYWN0aXZlIHJvb3Qgc3BhbiwgdXNlXG4gICAqIGBTZW50cnkudXBkYXRlU3Bhbk5hbWUocm9vdFNwYW4sICduZXcgbmFtZScpYCBpbnN0ZWFkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgU0RLIHVwZGF0ZXMgdGhlIHNjb3BlJ3MgdHJhbnNhY3Rpb24gbmFtZSBhdXRvbWF0aWNhbGx5IG9uIHNlbnNpYmxlXG4gICAqIG9jY2FzaW9ucywgc3VjaCBhcyBhIHBhZ2UgbmF2aWdhdGlvbiBvciB3aGVuIGhhbmRsaW5nIGEgbmV3IHJlcXVlc3Qgb24gdGhlIHNlcnZlci5cbiAgICovXG4gICBzZXRUcmFuc2FjdGlvbk5hbWUobmFtZSkge1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uTmFtZSA9IG5hbWU7XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGNvbnRleHQgZGF0YSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgKiBEYXRhIHBhc3NlZCBhcyBjb250ZXh0IHdpbGwgYmUgbm9ybWFsaXplZC4gWW91IGNhbiBhbHNvIHBhc3MgYG51bGxgIHRvIHVuc2V0IHRoZSBjb250ZXh0LlxuICAgKiBOb3RlIHRoYXQgY29udGV4dCBkYXRhIHdpbGwgbm90IGJlIG1lcmdlZCAtIGNhbGxpbmcgYHNldENvbnRleHRgIHdpbGwgb3ZlcndyaXRlIGFuIGV4aXN0aW5nIGNvbnRleHQgd2l0aCB0aGUgc2FtZSBrZXkuXG4gICAqL1xuICAgc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZVxuICAgICAgZGVsZXRlIHRoaXMuX2NvbnRleHRzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnRleHRzW2tleV0gPSBjb250ZXh0O1xuICAgIH1cblxuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzZXNzaW9uIGZvciB0aGUgc2NvcGUuXG4gICAqL1xuICAgc2V0U2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc2Vzc2lvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgfVxuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZXNzaW9uIGZyb20gdGhlIHNjb3BlLlxuICAgKi9cbiAgIGdldFNlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb247XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2NvcGUgd2l0aCBwcm92aWRlZCBkYXRhLiBDYW4gd29yayBpbiB0aHJlZSB2YXJpYXRpb25zOlxuICAgKiAtIHBsYWluIG9iamVjdCBjb250YWluaW5nIHVwZGF0YWJsZSBhdHRyaWJ1dGVzXG4gICAqIC0gU2NvcGUgaW5zdGFuY2UgdGhhdCdsbCBleHRyYWN0IHRoZSBhdHRyaWJ1dGVzIGZyb21cbiAgICogLSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0J2xsIHJlY2VpdmUgdGhlIGN1cnJlbnQgc2NvcGUgYXMgYW4gYXJndW1lbnQgYW5kIGFsbG93IGZvciBtb2RpZmljYXRpb25zXG4gICAqL1xuICAgdXBkYXRlKGNhcHR1cmVDb250ZXh0KSB7XG4gICAgaWYgKCFjYXB0dXJlQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NvcGVUb01lcmdlID0gdHlwZW9mIGNhcHR1cmVDb250ZXh0ID09PSAnZnVuY3Rpb24nID8gY2FwdHVyZUNvbnRleHQodGhpcykgOiBjYXB0dXJlQ29udGV4dDtcblxuICAgIGNvbnN0IHNjb3BlSW5zdGFuY2UgPVxuICAgICAgc2NvcGVUb01lcmdlIGluc3RhbmNlb2YgU2NvcGVcbiAgICAgICAgPyBzY29wZVRvTWVyZ2UuZ2V0U2NvcGVEYXRhKClcbiAgICAgICAgOiBpcy5pc1BsYWluT2JqZWN0KHNjb3BlVG9NZXJnZSlcbiAgICAgICAgICA/IChjYXB0dXJlQ29udGV4dCApXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCB7IHRhZ3MsIGV4dHJhLCB1c2VyLCBjb250ZXh0cywgbGV2ZWwsIGZpbmdlcnByaW50ID0gW10sIHByb3BhZ2F0aW9uQ29udGV4dCB9ID0gc2NvcGVJbnN0YW5jZSB8fCB7fTtcblxuICAgIHRoaXMuX3RhZ3MgPSB7IC4uLnRoaXMuX3RhZ3MsIC4uLnRhZ3MgfTtcbiAgICB0aGlzLl9leHRyYSA9IHsgLi4udGhpcy5fZXh0cmEsIC4uLmV4dHJhIH07XG4gICAgdGhpcy5fY29udGV4dHMgPSB7IC4uLnRoaXMuX2NvbnRleHRzLCAuLi5jb250ZXh0cyB9O1xuXG4gICAgaWYgKHVzZXIgJiYgT2JqZWN0LmtleXModXNlcikubGVuZ3RoKSB7XG4gICAgICB0aGlzLl91c2VyID0gdXNlcjtcbiAgICB9XG5cbiAgICBpZiAobGV2ZWwpIHtcbiAgICAgIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gICAgfVxuXG4gICAgaWYgKGZpbmdlcnByaW50Lmxlbmd0aCkge1xuICAgICAgdGhpcy5fZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludDtcbiAgICB9XG5cbiAgICBpZiAocHJvcGFnYXRpb25Db250ZXh0KSB7XG4gICAgICB0aGlzLl9wcm9wYWdhdGlvbkNvbnRleHQgPSBwcm9wYWdhdGlvbkNvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBjdXJyZW50IHNjb3BlIGFuZCByZXNldHMgaXRzIHByb3BlcnRpZXMuXG4gICAqIE5vdGU6IFRoZSBjbGllbnQgd2lsbCBub3QgYmUgY2xlYXJlZC5cbiAgICovXG4gICBjbGVhcigpIHtcbiAgICAvLyBjbGllbnQgaXMgbm90IGNsZWFyZWQgaGVyZSBvbiBwdXJwb3NlIVxuICAgIHRoaXMuX2JyZWFkY3J1bWJzID0gW107XG4gICAgdGhpcy5fdGFncyA9IHt9O1xuICAgIHRoaXMuX2V4dHJhID0ge307XG4gICAgdGhpcy5fdXNlciA9IHt9O1xuICAgIHRoaXMuX2NvbnRleHRzID0ge307XG4gICAgdGhpcy5fbGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Nlc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgc3Bhbk9uU2NvcGUuX3NldFNwYW5Gb3JTY29wZSh0aGlzLCB1bmRlZmluZWQpO1xuICAgIHRoaXMuX2F0dGFjaG1lbnRzID0gW107XG4gICAgdGhpcy5zZXRQcm9wYWdhdGlvbkNvbnRleHQoeyB0cmFjZUlkOiBwcm9wYWdhdGlvbkNvbnRleHQuZ2VuZXJhdGVUcmFjZUlkKCksIHNhbXBsZVJhbmQ6IE1hdGgucmFuZG9tKCkgfSk7XG5cbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBicmVhZGNydW1iIHRvIHRoZSBzY29wZS5cbiAgICogQnkgZGVmYXVsdCwgdGhlIGxhc3QgMTAwIGJyZWFkY3J1bWJzIGFyZSBrZXB0LlxuICAgKi9cbiAgIGFkZEJyZWFkY3J1bWIoYnJlYWRjcnVtYiwgbWF4QnJlYWRjcnVtYnMpIHtcbiAgICBjb25zdCBtYXhDcnVtYnMgPSB0eXBlb2YgbWF4QnJlYWRjcnVtYnMgPT09ICdudW1iZXInID8gbWF4QnJlYWRjcnVtYnMgOiBERUZBVUxUX01BWF9CUkVBRENSVU1CUztcblxuICAgIC8vIE5vIGRhdGEgaGFzIGJlZW4gY2hhbmdlZCwgc28gZG9uJ3Qgbm90aWZ5IHNjb3BlIGxpc3RlbmVyc1xuICAgIGlmIChtYXhDcnVtYnMgPD0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgbWVyZ2VkQnJlYWRjcnVtYiA9IHtcbiAgICAgIHRpbWVzdGFtcDogdGltZS5kYXRlVGltZXN0YW1wSW5TZWNvbmRzKCksXG4gICAgICAuLi5icmVhZGNydW1iLFxuICAgICAgLy8gQnJlYWRjcnVtYiBtZXNzYWdlcyBjYW4gdGhlb3JldGljYWxseSBiZSBpbmZpbml0ZWx5IGxhcmdlIGFuZCB0aGV5J3JlIGhlbGQgaW4gbWVtb3J5IHNvIHdlIHRydW5jYXRlIHRoZW0gbm90IHRvIGxlYWsgKHRvbyBtdWNoKSBtZW1vcnlcbiAgICAgIG1lc3NhZ2U6IGJyZWFkY3J1bWIubWVzc2FnZSA/IHN0cmluZy50cnVuY2F0ZShicmVhZGNydW1iLm1lc3NhZ2UsIDIwNDgpIDogYnJlYWRjcnVtYi5tZXNzYWdlLFxuICAgIH07XG5cbiAgICB0aGlzLl9icmVhZGNydW1icy5wdXNoKG1lcmdlZEJyZWFkY3J1bWIpO1xuICAgIGlmICh0aGlzLl9icmVhZGNydW1icy5sZW5ndGggPiBtYXhDcnVtYnMpIHtcbiAgICAgIHRoaXMuX2JyZWFkY3J1bWJzID0gdGhpcy5fYnJlYWRjcnVtYnMuc2xpY2UoLW1heENydW1icyk7XG4gICAgICB0aGlzLl9jbGllbnQ/LnJlY29yZERyb3BwZWRFdmVudCgnYnVmZmVyX292ZXJmbG93JywgJ2xvZ19pdGVtJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCBicmVhZGNydW1iIG9mIHRoZSBzY29wZS5cbiAgICovXG4gICBnZXRMYXN0QnJlYWRjcnVtYigpIHtcbiAgICByZXR1cm4gdGhpcy5fYnJlYWRjcnVtYnNbdGhpcy5fYnJlYWRjcnVtYnMubGVuZ3RoIC0gMV07XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGJyZWFkY3J1bWJzIGZyb20gdGhlIHNjb3BlLlxuICAgKi9cbiAgIGNsZWFyQnJlYWRjcnVtYnMoKSB7XG4gICAgdGhpcy5fYnJlYWRjcnVtYnMgPSBbXTtcbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBhdHRhY2htZW50IHRvIHRoZSBzY29wZS5cbiAgICovXG4gICBhZGRBdHRhY2htZW50KGF0dGFjaG1lbnQpIHtcbiAgICB0aGlzLl9hdHRhY2htZW50cy5wdXNoKGF0dGFjaG1lbnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBhdHRhY2htZW50cyBmcm9tIHRoZSBzY29wZS5cbiAgICovXG4gICBjbGVhckF0dGFjaG1lbnRzKCkge1xuICAgIHRoaXMuX2F0dGFjaG1lbnRzID0gW107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXRhIG9mIHRoaXMgc2NvcGUsIHdoaWNoIHNob3VsZCBiZSBhcHBsaWVkIHRvIGFuIGV2ZW50IGR1cmluZyBwcm9jZXNzaW5nLlxuICAgKi9cbiAgIGdldFNjb3BlRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJlYWRjcnVtYnM6IHRoaXMuX2JyZWFkY3J1bWJzLFxuICAgICAgYXR0YWNobWVudHM6IHRoaXMuX2F0dGFjaG1lbnRzLFxuICAgICAgY29udGV4dHM6IHRoaXMuX2NvbnRleHRzLFxuICAgICAgdGFnczogdGhpcy5fdGFncyxcbiAgICAgIGV4dHJhOiB0aGlzLl9leHRyYSxcbiAgICAgIHVzZXI6IHRoaXMuX3VzZXIsXG4gICAgICBsZXZlbDogdGhpcy5fbGV2ZWwsXG4gICAgICBmaW5nZXJwcmludDogdGhpcy5fZmluZ2VycHJpbnQgfHwgW10sXG4gICAgICBldmVudFByb2Nlc3NvcnM6IHRoaXMuX2V2ZW50UHJvY2Vzc29ycyxcbiAgICAgIHByb3BhZ2F0aW9uQ29udGV4dDogdGhpcy5fcHJvcGFnYXRpb25Db250ZXh0LFxuICAgICAgc2RrUHJvY2Vzc2luZ01ldGFkYXRhOiB0aGlzLl9zZGtQcm9jZXNzaW5nTWV0YWRhdGEsXG4gICAgICB0cmFuc2FjdGlvbk5hbWU6IHRoaXMuX3RyYW5zYWN0aW9uTmFtZSxcbiAgICAgIHNwYW46IHNwYW5PblNjb3BlLl9nZXRTcGFuRm9yU2NvcGUodGhpcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZGF0YSB3aGljaCB3aWxsIGJlIGFjY2Vzc2libGUgZHVyaW5nIGV2ZW50IHByb2Nlc3NpbmcgYnV0IHdvbid0IGdldCBzZW50IHRvIFNlbnRyeS5cbiAgICovXG4gICBzZXRTREtQcm9jZXNzaW5nTWV0YWRhdGEobmV3RGF0YSkge1xuICAgIHRoaXMuX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IG1lcmdlLm1lcmdlKHRoaXMuX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSwgbmV3RGF0YSwgMik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHByb3BhZ2F0aW9uIGNvbnRleHQgdG8gdGhlIHNjb3BlLCB1c2VkIGZvciBkaXN0cmlidXRlZCB0cmFjaW5nXG4gICAqL1xuICAgc2V0UHJvcGFnYXRpb25Db250ZXh0KGNvbnRleHQpIHtcbiAgICB0aGlzLl9wcm9wYWdhdGlvbkNvbnRleHQgPSBjb250ZXh0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwcm9wYWdhdGlvbiBjb250ZXh0IGZyb20gdGhlIHNjb3BlLCB1c2VkIGZvciBkaXN0cmlidXRlZCB0cmFjaW5nXG4gICAqL1xuICAgZ2V0UHJvcGFnYXRpb25Db250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9wYWdhdGlvbkNvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FwdHVyZSBhbiBleGNlcHRpb24gZm9yIHRoaXMgc2NvcGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBpZCBvZiB0aGUgY2FwdHVyZWQgU2VudHJ5IGV2ZW50LlxuICAgKi9cbiAgIGNhcHR1cmVFeGNlcHRpb24oZXhjZXB0aW9uLCBoaW50KSB7XG4gICAgY29uc3QgZXZlbnRJZCA9IGhpbnQ/LmV2ZW50X2lkIHx8IG1pc2MudXVpZDQoKTtcblxuICAgIGlmICghdGhpcy5fY2xpZW50KSB7XG4gICAgICBsb2dnZXIubG9nZ2VyLndhcm4oJ05vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBleGNlcHRpb24hJyk7XG4gICAgICByZXR1cm4gZXZlbnRJZDtcbiAgICB9XG5cbiAgICBjb25zdCBzeW50aGV0aWNFeGNlcHRpb24gPSBuZXcgRXJyb3IoJ1NlbnRyeSBzeW50aGV0aWNFeGNlcHRpb24nKTtcblxuICAgIHRoaXMuX2NsaWVudC5jYXB0dXJlRXhjZXB0aW9uKFxuICAgICAgZXhjZXB0aW9uLFxuICAgICAge1xuICAgICAgICBvcmlnaW5hbEV4Y2VwdGlvbjogZXhjZXB0aW9uLFxuICAgICAgICBzeW50aGV0aWNFeGNlcHRpb24sXG4gICAgICAgIC4uLmhpbnQsXG4gICAgICAgIGV2ZW50X2lkOiBldmVudElkLFxuICAgICAgfSxcbiAgICAgIHRoaXMsXG4gICAgKTtcblxuICAgIHJldHVybiBldmVudElkO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmUgYSBtZXNzYWdlIGZvciB0aGlzIHNjb3BlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaWQgb2YgdGhlIGNhcHR1cmVkIG1lc3NhZ2UuXG4gICAqL1xuICAgY2FwdHVyZU1lc3NhZ2UobWVzc2FnZSwgbGV2ZWwsIGhpbnQpIHtcbiAgICBjb25zdCBldmVudElkID0gaGludD8uZXZlbnRfaWQgfHwgbWlzYy51dWlkNCgpO1xuXG4gICAgaWYgKCF0aGlzLl9jbGllbnQpIHtcbiAgICAgIGxvZ2dlci5sb2dnZXIud2FybignTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIG1lc3NhZ2UhJyk7XG4gICAgICByZXR1cm4gZXZlbnRJZDtcbiAgICB9XG5cbiAgICBjb25zdCBzeW50aGV0aWNFeGNlcHRpb24gPSBuZXcgRXJyb3IobWVzc2FnZSk7XG5cbiAgICB0aGlzLl9jbGllbnQuY2FwdHVyZU1lc3NhZ2UoXG4gICAgICBtZXNzYWdlLFxuICAgICAgbGV2ZWwsXG4gICAgICB7XG4gICAgICAgIG9yaWdpbmFsRXhjZXB0aW9uOiBtZXNzYWdlLFxuICAgICAgICBzeW50aGV0aWNFeGNlcHRpb24sXG4gICAgICAgIC4uLmhpbnQsXG4gICAgICAgIGV2ZW50X2lkOiBldmVudElkLFxuICAgICAgfSxcbiAgICAgIHRoaXMsXG4gICAgKTtcblxuICAgIHJldHVybiBldmVudElkO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmUgYSBTZW50cnkgZXZlbnQgZm9yIHRoaXMgc2NvcGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBpZCBvZiB0aGUgY2FwdHVyZWQgZXZlbnQuXG4gICAqL1xuICAgY2FwdHVyZUV2ZW50KGV2ZW50LCBoaW50KSB7XG4gICAgY29uc3QgZXZlbnRJZCA9IGhpbnQ/LmV2ZW50X2lkIHx8IG1pc2MudXVpZDQoKTtcblxuICAgIGlmICghdGhpcy5fY2xpZW50KSB7XG4gICAgICBsb2dnZXIubG9nZ2VyLndhcm4oJ05vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBldmVudCEnKTtcbiAgICAgIHJldHVybiBldmVudElkO1xuICAgIH1cblxuICAgIHRoaXMuX2NsaWVudC5jYXB0dXJlRXZlbnQoZXZlbnQsIHsgLi4uaGludCwgZXZlbnRfaWQ6IGV2ZW50SWQgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gZXZlbnRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgYmUgY2FsbGVkIG9uIGV2ZXJ5IHNldCBjYWxsLlxuICAgKi9cbiAgIF9ub3RpZnlTY29wZUxpc3RlbmVycygpIHtcbiAgICAvLyBXZSBuZWVkIHRoaXMgY2hlY2sgZm9yIHRoaXMuX25vdGlmeWluZ0xpc3RlbmVycyB0byBiZSBhYmxlIHRvIHdvcmsgb24gc2NvcGUgZHVyaW5nIHVwZGF0ZXNcbiAgICAvLyBJZiB0aGlzIGNoZWNrIGlzIG5vdCBoZXJlIHdlJ2xsIHByb2R1Y2UgZW5kbGVzcyByZWN1cnNpb24gd2hlbiBzb21ldGhpbmcgaXMgZG9uZSB3aXRoIHRoZSBzY29wZVxuICAgIC8vIGR1cmluZyB0aGUgY2FsbGJhY2suXG4gICAgaWYgKCF0aGlzLl9ub3RpZnlpbmdMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX25vdGlmeWluZ0xpc3RlbmVycyA9IHRydWU7XG4gICAgICB0aGlzLl9zY29wZUxpc3RlbmVycy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgY2FsbGJhY2sodGhpcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX25vdGlmeWluZ0xpc3RlbmVycyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLlNjb3BlID0gU2NvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/scope.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/sdk.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js");\nconst debugBuild = __webpack_require__(/*! ./debug-build.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js");\n\n/** A class object that can instantiate Client objects. */\n\n/**\n * Internal function to create a new SDK client instance. The client is\n * installed and then bound to the current scope.\n *\n * @param clientClass The client class to instantiate.\n * @param options Options to pass to the client.\n */\nfunction initAndBind(\n  clientClass,\n  options,\n) {\n  if (options.debug === true) {\n    if (debugBuild.DEBUG_BUILD) {\n      logger.logger.enable();\n    } else {\n      // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped\n      logger.consoleSandbox(() => {\n        // eslint-disable-next-line no-console\n        console.warn(\'[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.\');\n      });\n    }\n  }\n  const scope = currentScopes.getCurrentScope();\n  scope.update(options.initialScope);\n\n  const client = new clientClass(options);\n  setCurrentClient(client);\n  client.init();\n  return client;\n}\n\n/**\n * Make the given client the current client.\n */\nfunction setCurrentClient(client) {\n  currentScopes.getCurrentScope().setClient(client);\n}\n\nexports.initAndBind = initAndBind;\nexports.setCurrentClient = setCurrentClient;\n//# sourceMappingURL=sdk.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvc2RrLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLHNCQUFzQixtQkFBTyxDQUFDLG9IQUFvQjtBQUNsRCxtQkFBbUIsbUJBQU8sQ0FBQyxnSEFBa0I7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLDhIQUF5Qjs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcc2RrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcblxuLyoqIEEgY2xhc3Mgb2JqZWN0IHRoYXQgY2FuIGluc3RhbnRpYXRlIENsaWVudCBvYmplY3RzLiAqL1xuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBTREsgY2xpZW50IGluc3RhbmNlLiBUaGUgY2xpZW50IGlzXG4gKiBpbnN0YWxsZWQgYW5kIHRoZW4gYm91bmQgdG8gdGhlIGN1cnJlbnQgc2NvcGUuXG4gKlxuICogQHBhcmFtIGNsaWVudENsYXNzIFRoZSBjbGllbnQgY2xhc3MgdG8gaW5zdGFudGlhdGUuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIGNsaWVudC5cbiAqL1xuZnVuY3Rpb24gaW5pdEFuZEJpbmQoXG4gIGNsaWVudENsYXNzLFxuICBvcHRpb25zLFxuKSB7XG4gIGlmIChvcHRpb25zLmRlYnVnID09PSB0cnVlKSB7XG4gICAgaWYgKGRlYnVnQnVpbGQuREVCVUdfQlVJTEQpIHtcbiAgICAgIGxvZ2dlci5sb2dnZXIuZW5hYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVzZSBgY29uc29sZS53YXJuYCByYXRoZXIgdGhhbiBgbG9nZ2VyLndhcm5gIHNpbmNlIGJ5IG5vbi1kZWJ1ZyBidW5kbGVzIGhhdmUgYWxsIGBsb2dnZXIueGAgc3RhdGVtZW50cyBzdHJpcHBlZFxuICAgICAgbG9nZ2VyLmNvbnNvbGVTYW5kYm94KCgpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKCdbU2VudHJ5XSBDYW5ub3QgaW5pdGlhbGl6ZSBTREsgd2l0aCBgZGVidWdgIG9wdGlvbiB1c2luZyBhIG5vbi1kZWJ1ZyBidW5kbGUuJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldEN1cnJlbnRTY29wZSgpO1xuICBzY29wZS51cGRhdGUob3B0aW9ucy5pbml0aWFsU2NvcGUpO1xuXG4gIGNvbnN0IGNsaWVudCA9IG5ldyBjbGllbnRDbGFzcyhvcHRpb25zKTtcbiAgc2V0Q3VycmVudENsaWVudChjbGllbnQpO1xuICBjbGllbnQuaW5pdCgpO1xuICByZXR1cm4gY2xpZW50O1xufVxuXG4vKipcbiAqIE1ha2UgdGhlIGdpdmVuIGNsaWVudCB0aGUgY3VycmVudCBjbGllbnQuXG4gKi9cbmZ1bmN0aW9uIHNldEN1cnJlbnRDbGllbnQoY2xpZW50KSB7XG4gIGN1cnJlbnRTY29wZXMuZ2V0Q3VycmVudFNjb3BlKCkuc2V0Q2xpZW50KGNsaWVudCk7XG59XG5cbmV4cG9ydHMuaW5pdEFuZEJpbmQgPSBpbml0QW5kQmluZDtcbmV4cG9ydHMuc2V0Q3VycmVudENsaWVudCA9IHNldEN1cnJlbnRDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZGsuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/sdk.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/semanticAttributes.js":(__unused_webpack_module,exports)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\n/**\n * Use this attribute to represent the source of a span.\n * Should be one of: custom, url, route, view, component, task, unknown\n *\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = 'sentry.source';\n\n/**\n * Attributes that holds the sample rate that was locally applied to a span.\n * If this attribute is not defined, it means that the span inherited a sampling decision.\n *\n * NOTE: Is only defined on root spans.\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = 'sentry.sample_rate';\n\n/**\n * Attribute holding the sample rate of the previous trace.\n * This is used to sample consistently across subsequent traces in the browser SDK.\n *\n * Note: Only defined on root spans, if opted into consistent sampling\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE = 'sentry.previous_trace_sample_rate';\n\n/**\n * Use this attribute to represent the operation of a span.\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_OP = 'sentry.op';\n\n/**\n * Use this attribute to represent the origin of a span.\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = 'sentry.origin';\n\n/** The reason why an idle span finished. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON = 'sentry.idle_span_finish_reason';\n\n/** The unit of a measurement, which may be stored as a TimedEvent. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = 'sentry.measurement_unit';\n\n/** The value of a measurement, which may be stored as a TimedEvent. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = 'sentry.measurement_value';\n\n/**\n * A custom span name set by users guaranteed to be taken over any automatically\n * inferred name. This attribute is removed before the span is sent.\n *\n * @internal only meant for internal SDK usage\n * @hidden\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = 'sentry.custom_span_name';\n\n/**\n * The id of the profile that this span occurred in.\n */\nconst SEMANTIC_ATTRIBUTE_PROFILE_ID = 'sentry.profile_id';\n\nconst SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = 'sentry.exclusive_time';\n\nconst SEMANTIC_ATTRIBUTE_CACHE_HIT = 'cache.hit';\n\nconst SEMANTIC_ATTRIBUTE_CACHE_KEY = 'cache.key';\n\nconst SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = 'cache.item_size';\n\n/** TODO: Remove these once we update to latest semantic conventions */\nconst SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD = 'http.request.method';\nconst SEMANTIC_ATTRIBUTE_URL_FULL = 'url.full';\n\n/**\n * A span link attribute to mark the link as a special span link.\n *\n * Known values:\n * - `previous_trace`: The span links to the frontend root span of the previous trace.\n * - `next_trace`: The span links to the frontend root span of the next trace. (Not set by the SDK)\n *\n * Other values may be set as appropriate.\n * @see https://develop.sentry.dev/sdk/telemetry/traces/span-links/#link-types\n */\nconst SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE = 'sentry.link.type';\n\nexports.SEMANTIC_ATTRIBUTE_CACHE_HIT = SEMANTIC_ATTRIBUTE_CACHE_HIT;\nexports.SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE;\nexports.SEMANTIC_ATTRIBUTE_CACHE_KEY = SEMANTIC_ATTRIBUTE_CACHE_KEY;\nexports.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME;\nexports.SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD = SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD;\nexports.SEMANTIC_ATTRIBUTE_PROFILE_ID = SEMANTIC_ATTRIBUTE_PROFILE_ID;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON = SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_OP = SEMANTIC_ATTRIBUTE_SENTRY_OP;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE = SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = SEMANTIC_ATTRIBUTE_SENTRY_SOURCE;\nexports.SEMANTIC_ATTRIBUTE_URL_FULL = SEMANTIC_ATTRIBUTE_URL_FULL;\nexports.SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE = SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE;\n//# sourceMappingURL=semanticAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvc2VtYW50aWNBdHRyaWJ1dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQywwQ0FBMEM7QUFDMUMsb0NBQW9DO0FBQ3BDLHlDQUF5QztBQUN6Qyw4Q0FBOEM7QUFDOUMscUNBQXFDO0FBQ3JDLGtEQUFrRDtBQUNsRCx5REFBeUQ7QUFDekQsa0RBQWtEO0FBQ2xELG1EQUFtRDtBQUNuRCxvQ0FBb0M7QUFDcEMsd0NBQXdDO0FBQ3hDLDREQUE0RDtBQUM1RCw2Q0FBNkM7QUFDN0Msd0NBQXdDO0FBQ3hDLG1DQUFtQztBQUNuQyx5Q0FBeUM7QUFDekMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxzZW1hbnRpY0F0dHJpYnV0ZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbi8qKlxuICogVXNlIHRoaXMgYXR0cmlidXRlIHRvIHJlcHJlc2VudCB0aGUgc291cmNlIG9mIGEgc3Bhbi5cbiAqIFNob3VsZCBiZSBvbmUgb2Y6IGN1c3RvbSwgdXJsLCByb3V0ZSwgdmlldywgY29tcG9uZW50LCB0YXNrLCB1bmtub3duXG4gKlxuICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRSA9ICdzZW50cnkuc291cmNlJztcblxuLyoqXG4gKiBBdHRyaWJ1dGVzIHRoYXQgaG9sZHMgdGhlIHNhbXBsZSByYXRlIHRoYXQgd2FzIGxvY2FsbHkgYXBwbGllZCB0byBhIHNwYW4uXG4gKiBJZiB0aGlzIGF0dHJpYnV0ZSBpcyBub3QgZGVmaW5lZCwgaXQgbWVhbnMgdGhhdCB0aGUgc3BhbiBpbmhlcml0ZWQgYSBzYW1wbGluZyBkZWNpc2lvbi5cbiAqXG4gKiBOT1RFOiBJcyBvbmx5IGRlZmluZWQgb24gcm9vdCBzcGFucy5cbiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURSA9ICdzZW50cnkuc2FtcGxlX3JhdGUnO1xuXG4vKipcbiAqIEF0dHJpYnV0ZSBob2xkaW5nIHRoZSBzYW1wbGUgcmF0ZSBvZiB0aGUgcHJldmlvdXMgdHJhY2UuXG4gKiBUaGlzIGlzIHVzZWQgdG8gc2FtcGxlIGNvbnNpc3RlbnRseSBhY3Jvc3Mgc3Vic2VxdWVudCB0cmFjZXMgaW4gdGhlIGJyb3dzZXIgU0RLLlxuICpcbiAqIE5vdGU6IE9ubHkgZGVmaW5lZCBvbiByb290IHNwYW5zLCBpZiBvcHRlZCBpbnRvIGNvbnNpc3RlbnQgc2FtcGxpbmdcbiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QUkVWSU9VU19UUkFDRV9TQU1QTEVfUkFURSA9ICdzZW50cnkucHJldmlvdXNfdHJhY2Vfc2FtcGxlX3JhdGUnO1xuXG4vKipcbiAqIFVzZSB0aGlzIGF0dHJpYnV0ZSB0byByZXByZXNlbnQgdGhlIG9wZXJhdGlvbiBvZiBhIHNwYW4uXG4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1AgPSAnc2VudHJ5Lm9wJztcblxuLyoqXG4gKiBVc2UgdGhpcyBhdHRyaWJ1dGUgdG8gcmVwcmVzZW50IHRoZSBvcmlnaW4gb2YgYSBzcGFuLlxuICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTiA9ICdzZW50cnkub3JpZ2luJztcblxuLyoqIFRoZSByZWFzb24gd2h5IGFuIGlkbGUgc3BhbiBmaW5pc2hlZC4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfSURMRV9TUEFOX0ZJTklTSF9SRUFTT04gPSAnc2VudHJ5LmlkbGVfc3Bhbl9maW5pc2hfcmVhc29uJztcblxuLyoqIFRoZSB1bml0IG9mIGEgbWVhc3VyZW1lbnQsIHdoaWNoIG1heSBiZSBzdG9yZWQgYXMgYSBUaW1lZEV2ZW50LiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9NRUFTVVJFTUVOVF9VTklUID0gJ3NlbnRyeS5tZWFzdXJlbWVudF91bml0JztcblxuLyoqIFRoZSB2YWx1ZSBvZiBhIG1lYXN1cmVtZW50LCB3aGljaCBtYXkgYmUgc3RvcmVkIGFzIGEgVGltZWRFdmVudC4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfTUVBU1VSRU1FTlRfVkFMVUUgPSAnc2VudHJ5Lm1lYXN1cmVtZW50X3ZhbHVlJztcblxuLyoqXG4gKiBBIGN1c3RvbSBzcGFuIG5hbWUgc2V0IGJ5IHVzZXJzIGd1YXJhbnRlZWQgdG8gYmUgdGFrZW4gb3ZlciBhbnkgYXV0b21hdGljYWxseVxuICogaW5mZXJyZWQgbmFtZS4gVGhpcyBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCBiZWZvcmUgdGhlIHNwYW4gaXMgc2VudC5cbiAqXG4gKiBAaW50ZXJuYWwgb25seSBtZWFudCBmb3IgaW50ZXJuYWwgU0RLIHVzYWdlXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfQ1VTVE9NX1NQQU5fTkFNRSA9ICdzZW50cnkuY3VzdG9tX3NwYW5fbmFtZSc7XG5cbi8qKlxuICogVGhlIGlkIG9mIHRoZSBwcm9maWxlIHRoYXQgdGhpcyBzcGFuIG9jY3VycmVkIGluLlxuICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfUFJPRklMRV9JRCA9ICdzZW50cnkucHJvZmlsZV9pZCc7XG5cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9FWENMVVNJVkVfVElNRSA9ICdzZW50cnkuZXhjbHVzaXZlX3RpbWUnO1xuXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfSElUID0gJ2NhY2hlLmhpdCc7XG5cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9LRVkgPSAnY2FjaGUua2V5JztcblxuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX0NBQ0hFX0lURU1fU0laRSA9ICdjYWNoZS5pdGVtX3NpemUnO1xuXG4vKiogVE9ETzogUmVtb3ZlIHRoZXNlIG9uY2Ugd2UgdXBkYXRlIHRvIGxhdGVzdCBzZW1hbnRpYyBjb252ZW50aW9ucyAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX0hUVFBfUkVRVUVTVF9NRVRIT0QgPSAnaHR0cC5yZXF1ZXN0Lm1ldGhvZCc7XG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfVVJMX0ZVTEwgPSAndXJsLmZ1bGwnO1xuXG4vKipcbiAqIEEgc3BhbiBsaW5rIGF0dHJpYnV0ZSB0byBtYXJrIHRoZSBsaW5rIGFzIGEgc3BlY2lhbCBzcGFuIGxpbmsuXG4gKlxuICogS25vd24gdmFsdWVzOlxuICogLSBgcHJldmlvdXNfdHJhY2VgOiBUaGUgc3BhbiBsaW5rcyB0byB0aGUgZnJvbnRlbmQgcm9vdCBzcGFuIG9mIHRoZSBwcmV2aW91cyB0cmFjZS5cbiAqIC0gYG5leHRfdHJhY2VgOiBUaGUgc3BhbiBsaW5rcyB0byB0aGUgZnJvbnRlbmQgcm9vdCBzcGFuIG9mIHRoZSBuZXh0IHRyYWNlLiAoTm90IHNldCBieSB0aGUgU0RLKVxuICpcbiAqIE90aGVyIHZhbHVlcyBtYXkgYmUgc2V0IGFzIGFwcHJvcHJpYXRlLlxuICogQHNlZSBodHRwczovL2RldmVsb3Auc2VudHJ5LmRldi9zZGsvdGVsZW1ldHJ5L3RyYWNlcy9zcGFuLWxpbmtzLyNsaW5rLXR5cGVzXG4gKi9cbmNvbnN0IFNFTUFOVElDX0xJTktfQVRUUklCVVRFX0xJTktfVFlQRSA9ICdzZW50cnkubGluay50eXBlJztcblxuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfSElUID0gU0VNQU5USUNfQVRUUklCVVRFX0NBQ0hFX0hJVDtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX0NBQ0hFX0lURU1fU0laRSA9IFNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9JVEVNX1NJWkU7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9LRVkgPSBTRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfS0VZO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfRVhDTFVTSVZFX1RJTUUgPSBTRU1BTlRJQ19BVFRSSUJVVEVfRVhDTFVTSVZFX1RJTUU7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9IVFRQX1JFUVVFU1RfTUVUSE9EID0gU0VNQU5USUNfQVRUUklCVVRFX0hUVFBfUkVRVUVTVF9NRVRIT0Q7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9QUk9GSUxFX0lEID0gU0VNQU5USUNfQVRUUklCVVRFX1BST0ZJTEVfSUQ7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfQ1VTVE9NX1NQQU5fTkFNRSA9IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfQ1VTVE9NX1NQQU5fTkFNRTtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9JRExFX1NQQU5fRklOSVNIX1JFQVNPTiA9IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfSURMRV9TUEFOX0ZJTklTSF9SRUFTT047XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfTUVBU1VSRU1FTlRfVU5JVCA9IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfTUVBU1VSRU1FTlRfVU5JVDtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9NRUFTVVJFTUVOVF9WQUxVRSA9IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfTUVBU1VSRU1FTlRfVkFMVUU7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1AgPSBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTiA9IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1BSRVZJT1VTX1RSQUNFX1NBTVBMRV9SQVRFID0gU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QUkVWSU9VU19UUkFDRV9TQU1QTEVfUkFURTtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURSA9IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEU7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFID0gU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0U7XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9VUkxfRlVMTCA9IFNFTUFOVElDX0FUVFJJQlVURV9VUkxfRlVMTDtcbmV4cG9ydHMuU0VNQU5USUNfTElOS19BVFRSSUJVVEVfTElOS19UWVBFID0gU0VNQU5USUNfTElOS19BVFRSSUJVVEVfTElOS19UWVBFO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VtYW50aWNBdHRyaWJ1dGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/semanticAttributes.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/server-runtime-client.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst checkin = __webpack_require__(/*! ./checkin.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/checkin.js\");\nconst client = __webpack_require__(/*! ./client.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/client.js\");\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst exports$1 = __webpack_require__(/*! ./logs/exports.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/logs/exports.js\");\nconst errors = __webpack_require__(/*! ./tracing/errors.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/errors.js\");\nconst is = __webpack_require__(/*! ./utils-hoist/is.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/is.js\");\nconst logger = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst misc = __webpack_require__(/*! ./utils-hoist/misc.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js\");\n__webpack_require__(/*! ./utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst eventbuilder = __webpack_require__(/*! ./utils-hoist/eventbuilder.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/eventbuilder.js\");\nconst syncpromise = __webpack_require__(/*! ./utils-hoist/syncpromise.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/syncpromise.js\");\n\n// TODO: Make this configurable\nconst DEFAULT_LOG_FLUSH_INTERVAL = 5000;\n\n/**\n * The Sentry Server Runtime Client SDK.\n */\nclass ServerRuntimeClient\n\n extends client.Client {\n\n  /**\n   * Creates a new Edge SDK instance.\n   * @param options Configuration options for this SDK.\n   */\n   constructor(options) {\n    // Server clients always support tracing\n    errors.registerSpanErrorInstrumentation();\n\n    super(options);\n\n    this._logWeight = 0;\n\n    if (this._options._experiments?.enableLogs) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const client = this;\n\n      client.on('flushLogs', () => {\n        client._logWeight = 0;\n        clearTimeout(client._logFlushIdleTimeout);\n      });\n\n      client.on('afterCaptureLog', log => {\n        client._logWeight += estimateLogSizeInBytes(log);\n\n        // We flush the logs buffer if it exceeds 0.8 MB\n        // The log weight is a rough estimate, so we flush way before\n        // the payload gets too big.\n        if (client._logWeight >= 800000) {\n          exports$1._INTERNAL_flushLogsBuffer(client);\n        } else {\n          // start an idle timeout to flush the logs buffer if no logs are captured for a while\n          client._logFlushIdleTimeout = setTimeout(() => {\n            exports$1._INTERNAL_flushLogsBuffer(client);\n          }, DEFAULT_LOG_FLUSH_INTERVAL);\n        }\n      });\n\n      client.on('flush', () => {\n        exports$1._INTERNAL_flushLogsBuffer(client);\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromException(exception, hint) {\n    const event = eventbuilder.eventFromUnknownInput(this, this._options.stackParser, exception, hint);\n    event.level = 'error';\n\n    return syncpromise.resolvedSyncPromise(event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromMessage(\n    message,\n    level = 'info',\n    hint,\n  ) {\n    return syncpromise.resolvedSyncPromise(\n      eventbuilder.eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureException(exception, hint, scope) {\n    setCurrentRequestSessionErroredOrCrashed(hint);\n    return super.captureException(exception, hint, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureEvent(event, hint, scope) {\n    // If the event is of type Exception, then a request session should be captured\n    const isException = !event.type && event.exception?.values && event.exception.values.length > 0;\n    if (isException) {\n      setCurrentRequestSessionErroredOrCrashed(hint);\n    }\n\n    return super.captureEvent(event, hint, scope);\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   */\n   captureCheckIn(checkIn, monitorConfig, scope) {\n    const id = 'checkInId' in checkIn && checkIn.checkInId ? checkIn.checkInId : misc.uuid4();\n    if (!this._isEnabled()) {\n      debugBuild.DEBUG_BUILD && logger.logger.warn('SDK not enabled, will not capture check-in.');\n      return id;\n    }\n\n    const options = this.getOptions();\n    const { release, environment, tunnel } = options;\n\n    const serializedCheckIn = {\n      check_in_id: id,\n      monitor_slug: checkIn.monitorSlug,\n      status: checkIn.status,\n      release,\n      environment,\n    };\n\n    if ('duration' in checkIn) {\n      serializedCheckIn.duration = checkIn.duration;\n    }\n\n    if (monitorConfig) {\n      serializedCheckIn.monitor_config = {\n        schedule: monitorConfig.schedule,\n        checkin_margin: monitorConfig.checkinMargin,\n        max_runtime: monitorConfig.maxRuntime,\n        timezone: monitorConfig.timezone,\n        failure_issue_threshold: monitorConfig.failureIssueThreshold,\n        recovery_threshold: monitorConfig.recoveryThreshold,\n      };\n    }\n\n    const [dynamicSamplingContext, traceContext] = client._getTraceInfoFromScope(this, scope);\n    if (traceContext) {\n      serializedCheckIn.contexts = {\n        trace: traceContext,\n      };\n    }\n\n    const envelope = checkin.createCheckInEnvelope(\n      serializedCheckIn,\n      dynamicSamplingContext,\n      this.getSdkMetadata(),\n      tunnel,\n      this.getDsn(),\n    );\n\n    debugBuild.DEBUG_BUILD && logger.logger.info('Sending checkin:', checkIn.monitorSlug, checkIn.status);\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(envelope);\n\n    return id;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   _prepareEvent(\n    event,\n    hint,\n    currentScope,\n    isolationScope,\n  ) {\n    if (this._options.platform) {\n      event.platform = event.platform || this._options.platform;\n    }\n\n    if (this._options.runtime) {\n      event.contexts = {\n        ...event.contexts,\n        runtime: event.contexts?.runtime || this._options.runtime,\n      };\n    }\n\n    if (this._options.serverName) {\n      event.server_name = event.server_name || this._options.serverName;\n    }\n\n    return super._prepareEvent(event, hint, currentScope, isolationScope);\n  }\n}\n\nfunction setCurrentRequestSessionErroredOrCrashed(eventHint) {\n  const requestSession = currentScopes.getIsolationScope().getScopeData().sdkProcessingMetadata.requestSession;\n  if (requestSession) {\n    // We mutate instead of doing `setSdkProcessingMetadata` because the http integration stores away a particular\n    // isolationScope. If that isolation scope is forked, setting the processing metadata here will not mutate the\n    // original isolation scope that the http integration stored away.\n    const isHandledException = eventHint?.mechanism?.handled ?? true;\n    // A request session can go from \"errored\" -> \"crashed\" but not \"crashed\" -> \"errored\".\n    // Crashed (unhandled exception) is worse than errored (handled exception).\n    if (isHandledException && requestSession.status !== 'crashed') {\n      requestSession.status = 'errored';\n    } else if (!isHandledException) {\n      requestSession.status = 'crashed';\n    }\n  }\n}\n\n/**\n * Estimate the size of a log in bytes.\n *\n * @param log - The log to estimate the size of.\n * @returns The estimated size of the log in bytes.\n */\nfunction estimateLogSizeInBytes(log) {\n  let weight = 0;\n\n  // Estimate byte size of 2 bytes per character. This is a rough estimate JS strings are stored as UTF-16.\n  if (log.message) {\n    weight += log.message.length * 2;\n  }\n\n  if (log.attributes) {\n    Object.values(log.attributes).forEach(value => {\n      if (Array.isArray(value)) {\n        weight += value.length * estimatePrimitiveSizeInBytes(value[0]);\n      } else if (is.isPrimitive(value)) {\n        weight += estimatePrimitiveSizeInBytes(value);\n      } else {\n        // For objects values, we estimate the size of the object as 100 bytes\n        weight += 100;\n      }\n    });\n  }\n\n  return weight;\n}\n\nfunction estimatePrimitiveSizeInBytes(value) {\n  if (typeof value === 'string') {\n    return value.length * 2;\n  } else if (typeof value === 'number') {\n    return 8;\n  } else if (typeof value === 'boolean') {\n    return 4;\n  }\n\n  return 0;\n}\n\nexports.ServerRuntimeClient = ServerRuntimeClient;\n//# sourceMappingURL=server-runtime-client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvc2VydmVyLXJ1bnRpbWUtY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLGdCQUFnQixtQkFBTyxDQUFDLHdHQUFjO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyxzR0FBYTtBQUNwQyxzQkFBc0IsbUJBQU8sQ0FBQyxvSEFBb0I7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsZ0hBQWtCO0FBQzdDLGtCQUFrQixtQkFBTyxDQUFDLGtIQUFtQjtBQUM3QyxlQUFlLG1CQUFPLENBQUMsc0hBQXFCO0FBQzVDLFdBQVcsbUJBQU8sQ0FBQyxzSEFBcUI7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLDhIQUF5QjtBQUNoRCxhQUFhLG1CQUFPLENBQUMsMEhBQXVCO0FBQzVDLG1CQUFPLENBQUMsMEhBQXVCO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLDBJQUErQjtBQUM1RCxvQkFBb0IsbUJBQU8sQ0FBQyx3SUFBOEI7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksK0JBQStCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFxzZXJ2ZXItcnVudGltZS1jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGNoZWNraW4gPSByZXF1aXJlKCcuL2NoZWNraW4uanMnKTtcbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50LmpzJyk7XG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3QgZXhwb3J0cyQxID0gcmVxdWlyZSgnLi9sb2dzL2V4cG9ydHMuanMnKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vdHJhY2luZy9lcnJvcnMuanMnKTtcbmNvbnN0IGlzID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9pcy5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IG1pc2MgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L21pc2MuanMnKTtcbnJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvdGltZS5qcycpO1xuY29uc3QgZXZlbnRidWlsZGVyID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9ldmVudGJ1aWxkZXIuanMnKTtcbmNvbnN0IHN5bmNwcm9taXNlID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9zeW5jcHJvbWlzZS5qcycpO1xuXG4vLyBUT0RPOiBNYWtlIHRoaXMgY29uZmlndXJhYmxlXG5jb25zdCBERUZBVUxUX0xPR19GTFVTSF9JTlRFUlZBTCA9IDUwMDA7XG5cbi8qKlxuICogVGhlIFNlbnRyeSBTZXJ2ZXIgUnVudGltZSBDbGllbnQgU0RLLlxuICovXG5jbGFzcyBTZXJ2ZXJSdW50aW1lQ2xpZW50XG5cbiBleHRlbmRzIGNsaWVudC5DbGllbnQge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEVkZ2UgU0RLIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoaXMgU0RLLlxuICAgKi9cbiAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvLyBTZXJ2ZXIgY2xpZW50cyBhbHdheXMgc3VwcG9ydCB0cmFjaW5nXG4gICAgZXJyb3JzLnJlZ2lzdGVyU3BhbkVycm9ySW5zdHJ1bWVudGF0aW9uKCk7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuX2xvZ1dlaWdodCA9IDA7XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5fZXhwZXJpbWVudHM/LmVuYWJsZUxvZ3MpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgY29uc3QgY2xpZW50ID0gdGhpcztcblxuICAgICAgY2xpZW50Lm9uKCdmbHVzaExvZ3MnLCAoKSA9PiB7XG4gICAgICAgIGNsaWVudC5fbG9nV2VpZ2h0ID0gMDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGNsaWVudC5fbG9nRmx1c2hJZGxlVGltZW91dCk7XG4gICAgICB9KTtcblxuICAgICAgY2xpZW50Lm9uKCdhZnRlckNhcHR1cmVMb2cnLCBsb2cgPT4ge1xuICAgICAgICBjbGllbnQuX2xvZ1dlaWdodCArPSBlc3RpbWF0ZUxvZ1NpemVJbkJ5dGVzKGxvZyk7XG5cbiAgICAgICAgLy8gV2UgZmx1c2ggdGhlIGxvZ3MgYnVmZmVyIGlmIGl0IGV4Y2VlZHMgMC44IE1CXG4gICAgICAgIC8vIFRoZSBsb2cgd2VpZ2h0IGlzIGEgcm91Z2ggZXN0aW1hdGUsIHNvIHdlIGZsdXNoIHdheSBiZWZvcmVcbiAgICAgICAgLy8gdGhlIHBheWxvYWQgZ2V0cyB0b28gYmlnLlxuICAgICAgICBpZiAoY2xpZW50Ll9sb2dXZWlnaHQgPj0gODAwMDAwKSB7XG4gICAgICAgICAgZXhwb3J0cyQxLl9JTlRFUk5BTF9mbHVzaExvZ3NCdWZmZXIoY2xpZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzdGFydCBhbiBpZGxlIHRpbWVvdXQgdG8gZmx1c2ggdGhlIGxvZ3MgYnVmZmVyIGlmIG5vIGxvZ3MgYXJlIGNhcHR1cmVkIGZvciBhIHdoaWxlXG4gICAgICAgICAgY2xpZW50Ll9sb2dGbHVzaElkbGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBleHBvcnRzJDEuX0lOVEVSTkFMX2ZsdXNoTG9nc0J1ZmZlcihjbGllbnQpO1xuICAgICAgICAgIH0sIERFRkFVTFRfTE9HX0ZMVVNIX0lOVEVSVkFMKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNsaWVudC5vbignZmx1c2gnLCAoKSA9PiB7XG4gICAgICAgIGV4cG9ydHMkMS5fSU5URVJOQUxfZmx1c2hMb2dzQnVmZmVyKGNsaWVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBldmVudEZyb21FeGNlcHRpb24oZXhjZXB0aW9uLCBoaW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBldmVudGJ1aWxkZXIuZXZlbnRGcm9tVW5rbm93bklucHV0KHRoaXMsIHRoaXMuX29wdGlvbnMuc3RhY2tQYXJzZXIsIGV4Y2VwdGlvbiwgaGludCk7XG4gICAgZXZlbnQubGV2ZWwgPSAnZXJyb3InO1xuXG4gICAgcmV0dXJuIHN5bmNwcm9taXNlLnJlc29sdmVkU3luY1Byb21pc2UoZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgZXZlbnRGcm9tTWVzc2FnZShcbiAgICBtZXNzYWdlLFxuICAgIGxldmVsID0gJ2luZm8nLFxuICAgIGhpbnQsXG4gICkge1xuICAgIHJldHVybiBzeW5jcHJvbWlzZS5yZXNvbHZlZFN5bmNQcm9taXNlKFxuICAgICAgZXZlbnRidWlsZGVyLmV2ZW50RnJvbU1lc3NhZ2UodGhpcy5fb3B0aW9ucy5zdGFja1BhcnNlciwgbWVzc2FnZSwgbGV2ZWwsIGhpbnQsIHRoaXMuX29wdGlvbnMuYXR0YWNoU3RhY2t0cmFjZSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGNhcHR1cmVFeGNlcHRpb24oZXhjZXB0aW9uLCBoaW50LCBzY29wZSkge1xuICAgIHNldEN1cnJlbnRSZXF1ZXN0U2Vzc2lvbkVycm9yZWRPckNyYXNoZWQoaGludCk7XG4gICAgcmV0dXJuIHN1cGVyLmNhcHR1cmVFeGNlcHRpb24oZXhjZXB0aW9uLCBoaW50LCBzY29wZSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBjYXB0dXJlRXZlbnQoZXZlbnQsIGhpbnQsIHNjb3BlKSB7XG4gICAgLy8gSWYgdGhlIGV2ZW50IGlzIG9mIHR5cGUgRXhjZXB0aW9uLCB0aGVuIGEgcmVxdWVzdCBzZXNzaW9uIHNob3VsZCBiZSBjYXB0dXJlZFxuICAgIGNvbnN0IGlzRXhjZXB0aW9uID0gIWV2ZW50LnR5cGUgJiYgZXZlbnQuZXhjZXB0aW9uPy52YWx1ZXMgJiYgZXZlbnQuZXhjZXB0aW9uLnZhbHVlcy5sZW5ndGggPiAwO1xuICAgIGlmIChpc0V4Y2VwdGlvbikge1xuICAgICAgc2V0Q3VycmVudFJlcXVlc3RTZXNzaW9uRXJyb3JlZE9yQ3Jhc2hlZChoaW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuY2FwdHVyZUV2ZW50KGV2ZW50LCBoaW50LCBzY29wZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY3JvbiBtb25pdG9yIGNoZWNrIGluIGFuZCBzZW5kIGl0IHRvIFNlbnRyeS5cbiAgICpcbiAgICogQHBhcmFtIGNoZWNrSW4gQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgY2hlY2sgaW4uXG4gICAqIEBwYXJhbSB1cHNlcnRNb25pdG9yQ29uZmlnIEFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIG1vbml0b3IgY29uZmlnLiBVc2UgdGhpcyBpZiB5b3Ugd2FudFxuICAgKiB0byBjcmVhdGUgYSBtb25pdG9yIGF1dG9tYXRpY2FsbHkgd2hlbiBzZW5kaW5nIGEgY2hlY2sgaW4uXG4gICAqL1xuICAgY2FwdHVyZUNoZWNrSW4oY2hlY2tJbiwgbW9uaXRvckNvbmZpZywgc2NvcGUpIHtcbiAgICBjb25zdCBpZCA9ICdjaGVja0luSWQnIGluIGNoZWNrSW4gJiYgY2hlY2tJbi5jaGVja0luSWQgPyBjaGVja0luLmNoZWNrSW5JZCA6IG1pc2MudXVpZDQoKTtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCgpKSB7XG4gICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybignU0RLIG5vdCBlbmFibGVkLCB3aWxsIG5vdCBjYXB0dXJlIGNoZWNrLWluLicpO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICBjb25zdCB7IHJlbGVhc2UsIGVudmlyb25tZW50LCB0dW5uZWwgfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBzZXJpYWxpemVkQ2hlY2tJbiA9IHtcbiAgICAgIGNoZWNrX2luX2lkOiBpZCxcbiAgICAgIG1vbml0b3Jfc2x1ZzogY2hlY2tJbi5tb25pdG9yU2x1ZyxcbiAgICAgIHN0YXR1czogY2hlY2tJbi5zdGF0dXMsXG4gICAgICByZWxlYXNlLFxuICAgICAgZW52aXJvbm1lbnQsXG4gICAgfTtcblxuICAgIGlmICgnZHVyYXRpb24nIGluIGNoZWNrSW4pIHtcbiAgICAgIHNlcmlhbGl6ZWRDaGVja0luLmR1cmF0aW9uID0gY2hlY2tJbi5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICBpZiAobW9uaXRvckNvbmZpZykge1xuICAgICAgc2VyaWFsaXplZENoZWNrSW4ubW9uaXRvcl9jb25maWcgPSB7XG4gICAgICAgIHNjaGVkdWxlOiBtb25pdG9yQ29uZmlnLnNjaGVkdWxlLFxuICAgICAgICBjaGVja2luX21hcmdpbjogbW9uaXRvckNvbmZpZy5jaGVja2luTWFyZ2luLFxuICAgICAgICBtYXhfcnVudGltZTogbW9uaXRvckNvbmZpZy5tYXhSdW50aW1lLFxuICAgICAgICB0aW1lem9uZTogbW9uaXRvckNvbmZpZy50aW1lem9uZSxcbiAgICAgICAgZmFpbHVyZV9pc3N1ZV90aHJlc2hvbGQ6IG1vbml0b3JDb25maWcuZmFpbHVyZUlzc3VlVGhyZXNob2xkLFxuICAgICAgICByZWNvdmVyeV90aHJlc2hvbGQ6IG1vbml0b3JDb25maWcucmVjb3ZlcnlUaHJlc2hvbGQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IFtkeW5hbWljU2FtcGxpbmdDb250ZXh0LCB0cmFjZUNvbnRleHRdID0gY2xpZW50Ll9nZXRUcmFjZUluZm9Gcm9tU2NvcGUodGhpcywgc2NvcGUpO1xuICAgIGlmICh0cmFjZUNvbnRleHQpIHtcbiAgICAgIHNlcmlhbGl6ZWRDaGVja0luLmNvbnRleHRzID0ge1xuICAgICAgICB0cmFjZTogdHJhY2VDb250ZXh0LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBlbnZlbG9wZSA9IGNoZWNraW4uY3JlYXRlQ2hlY2tJbkVudmVsb3BlKFxuICAgICAgc2VyaWFsaXplZENoZWNrSW4sXG4gICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0LFxuICAgICAgdGhpcy5nZXRTZGtNZXRhZGF0YSgpLFxuICAgICAgdHVubmVsLFxuICAgICAgdGhpcy5nZXREc24oKSxcbiAgICApO1xuXG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLmluZm8oJ1NlbmRpbmcgY2hlY2tpbjonLCBjaGVja0luLm1vbml0b3JTbHVnLCBjaGVja0luLnN0YXR1cyk7XG5cbiAgICAvLyBzZW5kRW52ZWxvcGUgc2hvdWxkIG5vdCB0aHJvd1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICB0aGlzLnNlbmRFbnZlbG9wZShlbnZlbG9wZSk7XG5cbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBfcHJlcGFyZUV2ZW50KFxuICAgIGV2ZW50LFxuICAgIGhpbnQsXG4gICAgY3VycmVudFNjb3BlLFxuICAgIGlzb2xhdGlvblNjb3BlLFxuICApIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5wbGF0Zm9ybSkge1xuICAgICAgZXZlbnQucGxhdGZvcm0gPSBldmVudC5wbGF0Zm9ybSB8fCB0aGlzLl9vcHRpb25zLnBsYXRmb3JtO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnJ1bnRpbWUpIHtcbiAgICAgIGV2ZW50LmNvbnRleHRzID0ge1xuICAgICAgICAuLi5ldmVudC5jb250ZXh0cyxcbiAgICAgICAgcnVudGltZTogZXZlbnQuY29udGV4dHM/LnJ1bnRpbWUgfHwgdGhpcy5fb3B0aW9ucy5ydW50aW1lLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJOYW1lKSB7XG4gICAgICBldmVudC5zZXJ2ZXJfbmFtZSA9IGV2ZW50LnNlcnZlcl9uYW1lIHx8IHRoaXMuX29wdGlvbnMuc2VydmVyTmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuX3ByZXBhcmVFdmVudChldmVudCwgaGludCwgY3VycmVudFNjb3BlLCBpc29sYXRpb25TY29wZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudFJlcXVlc3RTZXNzaW9uRXJyb3JlZE9yQ3Jhc2hlZChldmVudEhpbnQpIHtcbiAgY29uc3QgcmVxdWVzdFNlc3Npb24gPSBjdXJyZW50U2NvcGVzLmdldElzb2xhdGlvblNjb3BlKCkuZ2V0U2NvcGVEYXRhKCkuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLnJlcXVlc3RTZXNzaW9uO1xuICBpZiAocmVxdWVzdFNlc3Npb24pIHtcbiAgICAvLyBXZSBtdXRhdGUgaW5zdGVhZCBvZiBkb2luZyBgc2V0U2RrUHJvY2Vzc2luZ01ldGFkYXRhYCBiZWNhdXNlIHRoZSBodHRwIGludGVncmF0aW9uIHN0b3JlcyBhd2F5IGEgcGFydGljdWxhclxuICAgIC8vIGlzb2xhdGlvblNjb3BlLiBJZiB0aGF0IGlzb2xhdGlvbiBzY29wZSBpcyBmb3JrZWQsIHNldHRpbmcgdGhlIHByb2Nlc3NpbmcgbWV0YWRhdGEgaGVyZSB3aWxsIG5vdCBtdXRhdGUgdGhlXG4gICAgLy8gb3JpZ2luYWwgaXNvbGF0aW9uIHNjb3BlIHRoYXQgdGhlIGh0dHAgaW50ZWdyYXRpb24gc3RvcmVkIGF3YXkuXG4gICAgY29uc3QgaXNIYW5kbGVkRXhjZXB0aW9uID0gZXZlbnRIaW50Py5tZWNoYW5pc20/LmhhbmRsZWQgPz8gdHJ1ZTtcbiAgICAvLyBBIHJlcXVlc3Qgc2Vzc2lvbiBjYW4gZ28gZnJvbSBcImVycm9yZWRcIiAtPiBcImNyYXNoZWRcIiBidXQgbm90IFwiY3Jhc2hlZFwiIC0+IFwiZXJyb3JlZFwiLlxuICAgIC8vIENyYXNoZWQgKHVuaGFuZGxlZCBleGNlcHRpb24pIGlzIHdvcnNlIHRoYW4gZXJyb3JlZCAoaGFuZGxlZCBleGNlcHRpb24pLlxuICAgIGlmIChpc0hhbmRsZWRFeGNlcHRpb24gJiYgcmVxdWVzdFNlc3Npb24uc3RhdHVzICE9PSAnY3Jhc2hlZCcpIHtcbiAgICAgIHJlcXVlc3RTZXNzaW9uLnN0YXR1cyA9ICdlcnJvcmVkJztcbiAgICB9IGVsc2UgaWYgKCFpc0hhbmRsZWRFeGNlcHRpb24pIHtcbiAgICAgIHJlcXVlc3RTZXNzaW9uLnN0YXR1cyA9ICdjcmFzaGVkJztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFc3RpbWF0ZSB0aGUgc2l6ZSBvZiBhIGxvZyBpbiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gbG9nIC0gVGhlIGxvZyB0byBlc3RpbWF0ZSB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIFRoZSBlc3RpbWF0ZWQgc2l6ZSBvZiB0aGUgbG9nIGluIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBlc3RpbWF0ZUxvZ1NpemVJbkJ5dGVzKGxvZykge1xuICBsZXQgd2VpZ2h0ID0gMDtcblxuICAvLyBFc3RpbWF0ZSBieXRlIHNpemUgb2YgMiBieXRlcyBwZXIgY2hhcmFjdGVyLiBUaGlzIGlzIGEgcm91Z2ggZXN0aW1hdGUgSlMgc3RyaW5ncyBhcmUgc3RvcmVkIGFzIFVURi0xNi5cbiAgaWYgKGxvZy5tZXNzYWdlKSB7XG4gICAgd2VpZ2h0ICs9IGxvZy5tZXNzYWdlLmxlbmd0aCAqIDI7XG4gIH1cblxuICBpZiAobG9nLmF0dHJpYnV0ZXMpIHtcbiAgICBPYmplY3QudmFsdWVzKGxvZy5hdHRyaWJ1dGVzKS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB3ZWlnaHQgKz0gdmFsdWUubGVuZ3RoICogZXN0aW1hdGVQcmltaXRpdmVTaXplSW5CeXRlcyh2YWx1ZVswXSk7XG4gICAgICB9IGVsc2UgaWYgKGlzLmlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgICB3ZWlnaHQgKz0gZXN0aW1hdGVQcmltaXRpdmVTaXplSW5CeXRlcyh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2JqZWN0cyB2YWx1ZXMsIHdlIGVzdGltYXRlIHRoZSBzaXplIG9mIHRoZSBvYmplY3QgYXMgMTAwIGJ5dGVzXG4gICAgICAgIHdlaWdodCArPSAxMDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gd2VpZ2h0O1xufVxuXG5mdW5jdGlvbiBlc3RpbWF0ZVByaW1pdGl2ZVNpemVJbkJ5dGVzKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCAqIDI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiA4O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIDQ7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZXhwb3J0cy5TZXJ2ZXJSdW50aW1lQ2xpZW50ID0gU2VydmVyUnVudGltZUNsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci1ydW50aW1lLWNsaWVudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/server-runtime-client.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/session.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst misc = __webpack_require__(/*! ./utils-hoist/misc.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/misc.js\");\nconst time = __webpack_require__(/*! ./utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\n\n/**\n * Creates a new `Session` object by setting certain default parameters. If optional @param context\n * is passed, the passed properties are applied to the session object.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns a new `Session` object\n */\nfunction makeSession(context) {\n  // Both timestamp and started are in seconds since the UNIX epoch.\n  const startingTime = time.timestampInSeconds();\n\n  const session = {\n    sid: misc.uuid4(),\n    init: true,\n    timestamp: startingTime,\n    started: startingTime,\n    duration: 0,\n    status: 'ok',\n    errors: 0,\n    ignoreDuration: false,\n    toJSON: () => sessionToJSON(session),\n  };\n\n  if (context) {\n    updateSession(session, context);\n  }\n\n  return session;\n}\n\n/**\n * Updates a session object with the properties passed in the context.\n *\n * Note that this function mutates the passed object and returns void.\n * (Had to do this instead of returning a new and updated session because closing and sending a session\n * makes an update to the session after it was passed to the sending logic.\n * @see Client.captureSession )\n *\n * @param session the `Session` to update\n * @param context the `SessionContext` holding the properties that should be updated in @param session\n */\n// eslint-disable-next-line complexity\nfunction updateSession(session, context = {}) {\n  if (context.user) {\n    if (!session.ipAddress && context.user.ip_address) {\n      session.ipAddress = context.user.ip_address;\n    }\n\n    if (!session.did && !context.did) {\n      session.did = context.user.id || context.user.email || context.user.username;\n    }\n  }\n\n  session.timestamp = context.timestamp || time.timestampInSeconds();\n\n  if (context.abnormal_mechanism) {\n    session.abnormal_mechanism = context.abnormal_mechanism;\n  }\n\n  if (context.ignoreDuration) {\n    session.ignoreDuration = context.ignoreDuration;\n  }\n  if (context.sid) {\n    // Good enough uuid validation. — Kamil\n    session.sid = context.sid.length === 32 ? context.sid : misc.uuid4();\n  }\n  if (context.init !== undefined) {\n    session.init = context.init;\n  }\n  if (!session.did && context.did) {\n    session.did = `${context.did}`;\n  }\n  if (typeof context.started === 'number') {\n    session.started = context.started;\n  }\n  if (session.ignoreDuration) {\n    session.duration = undefined;\n  } else if (typeof context.duration === 'number') {\n    session.duration = context.duration;\n  } else {\n    const duration = session.timestamp - session.started;\n    session.duration = duration >= 0 ? duration : 0;\n  }\n  if (context.release) {\n    session.release = context.release;\n  }\n  if (context.environment) {\n    session.environment = context.environment;\n  }\n  if (!session.ipAddress && context.ipAddress) {\n    session.ipAddress = context.ipAddress;\n  }\n  if (!session.userAgent && context.userAgent) {\n    session.userAgent = context.userAgent;\n  }\n  if (typeof context.errors === 'number') {\n    session.errors = context.errors;\n  }\n  if (context.status) {\n    session.status = context.status;\n  }\n}\n\n/**\n * Closes a session by setting its status and updating the session object with it.\n * Internally calls `updateSession` to update the passed session object.\n *\n * Note that this function mutates the passed session (@see updateSession for explanation).\n *\n * @param session the `Session` object to be closed\n * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,\n *               this function will keep the previously set status, unless it was `'ok'` in which case\n *               it is changed to `'exited'`.\n */\nfunction closeSession(session, status) {\n  let context = {};\n  if (status) {\n    context = { status };\n  } else if (session.status === 'ok') {\n    context = { status: 'exited' };\n  }\n\n  updateSession(session, context);\n}\n\n/**\n * Serializes a passed session object to a JSON object with a slightly different structure.\n * This is necessary because the Sentry backend requires a slightly different schema of a session\n * than the one the JS SDKs use internally.\n *\n * @param session the session to be converted\n *\n * @returns a JSON object of the passed session\n */\nfunction sessionToJSON(session) {\n  return {\n    sid: `${session.sid}`,\n    init: session.init,\n    // Make sure that sec is converted to ms for date constructor\n    started: new Date(session.started * 1000).toISOString(),\n    timestamp: new Date(session.timestamp * 1000).toISOString(),\n    status: session.status,\n    errors: session.errors,\n    did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,\n    duration: session.duration,\n    abnormal_mechanism: session.abnormal_mechanism,\n    attrs: {\n      release: session.release,\n      environment: session.environment,\n      ip_address: session.ipAddress,\n      user_agent: session.userAgent,\n    },\n  };\n}\n\nexports.closeSession = closeSession;\nexports.makeSession = makeSession;\nexports.updateSession = updateSession;\n//# sourceMappingURL=session.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvc2Vzc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxhQUFhLG1CQUFPLENBQUMsMEhBQXVCO0FBQzVDLGFBQWEsbUJBQU8sQ0FBQywwSEFBdUI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixJQUFJO0FBQ0osZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsWUFBWTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcc2Vzc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgbWlzYyA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvbWlzYy5qcycpO1xuY29uc3QgdGltZSA9IHJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvdGltZS5qcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYFNlc3Npb25gIG9iamVjdCBieSBzZXR0aW5nIGNlcnRhaW4gZGVmYXVsdCBwYXJhbWV0ZXJzLiBJZiBvcHRpb25hbCBAcGFyYW0gY29udGV4dFxuICogaXMgcGFzc2VkLCB0aGUgcGFzc2VkIHByb3BlcnRpZXMgYXJlIGFwcGxpZWQgdG8gdGhlIHNlc3Npb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBjb250ZXh0IChvcHRpb25hbCkgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHJldHVybmVkIHNlc3Npb24gb2JqZWN0XG4gKlxuICogQHJldHVybnMgYSBuZXcgYFNlc3Npb25gIG9iamVjdFxuICovXG5mdW5jdGlvbiBtYWtlU2Vzc2lvbihjb250ZXh0KSB7XG4gIC8vIEJvdGggdGltZXN0YW1wIGFuZCBzdGFydGVkIGFyZSBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoLlxuICBjb25zdCBzdGFydGluZ1RpbWUgPSB0aW1lLnRpbWVzdGFtcEluU2Vjb25kcygpO1xuXG4gIGNvbnN0IHNlc3Npb24gPSB7XG4gICAgc2lkOiBtaXNjLnV1aWQ0KCksXG4gICAgaW5pdDogdHJ1ZSxcbiAgICB0aW1lc3RhbXA6IHN0YXJ0aW5nVGltZSxcbiAgICBzdGFydGVkOiBzdGFydGluZ1RpbWUsXG4gICAgZHVyYXRpb246IDAsXG4gICAgc3RhdHVzOiAnb2snLFxuICAgIGVycm9yczogMCxcbiAgICBpZ25vcmVEdXJhdGlvbjogZmFsc2UsXG4gICAgdG9KU09OOiAoKSA9PiBzZXNzaW9uVG9KU09OKHNlc3Npb24pLFxuICB9O1xuXG4gIGlmIChjb250ZXh0KSB7XG4gICAgdXBkYXRlU2Vzc2lvbihzZXNzaW9uLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBzZXNzaW9uO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzZXNzaW9uIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIHBhc3NlZCBpbiB0aGUgY29udGV4dC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSBwYXNzZWQgb2JqZWN0IGFuZCByZXR1cm5zIHZvaWQuXG4gKiAoSGFkIHRvIGRvIHRoaXMgaW5zdGVhZCBvZiByZXR1cm5pbmcgYSBuZXcgYW5kIHVwZGF0ZWQgc2Vzc2lvbiBiZWNhdXNlIGNsb3NpbmcgYW5kIHNlbmRpbmcgYSBzZXNzaW9uXG4gKiBtYWtlcyBhbiB1cGRhdGUgdG8gdGhlIHNlc3Npb24gYWZ0ZXIgaXQgd2FzIHBhc3NlZCB0byB0aGUgc2VuZGluZyBsb2dpYy5cbiAqIEBzZWUgQ2xpZW50LmNhcHR1cmVTZXNzaW9uIClcbiAqXG4gKiBAcGFyYW0gc2Vzc2lvbiB0aGUgYFNlc3Npb25gIHRvIHVwZGF0ZVxuICogQHBhcmFtIGNvbnRleHQgdGhlIGBTZXNzaW9uQ29udGV4dGAgaG9sZGluZyB0aGUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSB1cGRhdGVkIGluIEBwYXJhbSBzZXNzaW9uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1cGRhdGVTZXNzaW9uKHNlc3Npb24sIGNvbnRleHQgPSB7fSkge1xuICBpZiAoY29udGV4dC51c2VyKSB7XG4gICAgaWYgKCFzZXNzaW9uLmlwQWRkcmVzcyAmJiBjb250ZXh0LnVzZXIuaXBfYWRkcmVzcykge1xuICAgICAgc2Vzc2lvbi5pcEFkZHJlc3MgPSBjb250ZXh0LnVzZXIuaXBfYWRkcmVzcztcbiAgICB9XG5cbiAgICBpZiAoIXNlc3Npb24uZGlkICYmICFjb250ZXh0LmRpZCkge1xuICAgICAgc2Vzc2lvbi5kaWQgPSBjb250ZXh0LnVzZXIuaWQgfHwgY29udGV4dC51c2VyLmVtYWlsIHx8IGNvbnRleHQudXNlci51c2VybmFtZTtcbiAgICB9XG4gIH1cblxuICBzZXNzaW9uLnRpbWVzdGFtcCA9IGNvbnRleHQudGltZXN0YW1wIHx8IHRpbWUudGltZXN0YW1wSW5TZWNvbmRzKCk7XG5cbiAgaWYgKGNvbnRleHQuYWJub3JtYWxfbWVjaGFuaXNtKSB7XG4gICAgc2Vzc2lvbi5hYm5vcm1hbF9tZWNoYW5pc20gPSBjb250ZXh0LmFibm9ybWFsX21lY2hhbmlzbTtcbiAgfVxuXG4gIGlmIChjb250ZXh0Lmlnbm9yZUR1cmF0aW9uKSB7XG4gICAgc2Vzc2lvbi5pZ25vcmVEdXJhdGlvbiA9IGNvbnRleHQuaWdub3JlRHVyYXRpb247XG4gIH1cbiAgaWYgKGNvbnRleHQuc2lkKSB7XG4gICAgLy8gR29vZCBlbm91Z2ggdXVpZCB2YWxpZGF0aW9uLiDigJQgS2FtaWxcbiAgICBzZXNzaW9uLnNpZCA9IGNvbnRleHQuc2lkLmxlbmd0aCA9PT0gMzIgPyBjb250ZXh0LnNpZCA6IG1pc2MudXVpZDQoKTtcbiAgfVxuICBpZiAoY29udGV4dC5pbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXNzaW9uLmluaXQgPSBjb250ZXh0LmluaXQ7XG4gIH1cbiAgaWYgKCFzZXNzaW9uLmRpZCAmJiBjb250ZXh0LmRpZCkge1xuICAgIHNlc3Npb24uZGlkID0gYCR7Y29udGV4dC5kaWR9YDtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRleHQuc3RhcnRlZCA9PT0gJ251bWJlcicpIHtcbiAgICBzZXNzaW9uLnN0YXJ0ZWQgPSBjb250ZXh0LnN0YXJ0ZWQ7XG4gIH1cbiAgaWYgKHNlc3Npb24uaWdub3JlRHVyYXRpb24pIHtcbiAgICBzZXNzaW9uLmR1cmF0aW9uID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0LmR1cmF0aW9uID09PSAnbnVtYmVyJykge1xuICAgIHNlc3Npb24uZHVyYXRpb24gPSBjb250ZXh0LmR1cmF0aW9uO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gc2Vzc2lvbi50aW1lc3RhbXAgLSBzZXNzaW9uLnN0YXJ0ZWQ7XG4gICAgc2Vzc2lvbi5kdXJhdGlvbiA9IGR1cmF0aW9uID49IDAgPyBkdXJhdGlvbiA6IDA7XG4gIH1cbiAgaWYgKGNvbnRleHQucmVsZWFzZSkge1xuICAgIHNlc3Npb24ucmVsZWFzZSA9IGNvbnRleHQucmVsZWFzZTtcbiAgfVxuICBpZiAoY29udGV4dC5lbnZpcm9ubWVudCkge1xuICAgIHNlc3Npb24uZW52aXJvbm1lbnQgPSBjb250ZXh0LmVudmlyb25tZW50O1xuICB9XG4gIGlmICghc2Vzc2lvbi5pcEFkZHJlc3MgJiYgY29udGV4dC5pcEFkZHJlc3MpIHtcbiAgICBzZXNzaW9uLmlwQWRkcmVzcyA9IGNvbnRleHQuaXBBZGRyZXNzO1xuICB9XG4gIGlmICghc2Vzc2lvbi51c2VyQWdlbnQgJiYgY29udGV4dC51c2VyQWdlbnQpIHtcbiAgICBzZXNzaW9uLnVzZXJBZ2VudCA9IGNvbnRleHQudXNlckFnZW50O1xuICB9XG4gIGlmICh0eXBlb2YgY29udGV4dC5lcnJvcnMgPT09ICdudW1iZXInKSB7XG4gICAgc2Vzc2lvbi5lcnJvcnMgPSBjb250ZXh0LmVycm9ycztcbiAgfVxuICBpZiAoY29udGV4dC5zdGF0dXMpIHtcbiAgICBzZXNzaW9uLnN0YXR1cyA9IGNvbnRleHQuc3RhdHVzO1xuICB9XG59XG5cbi8qKlxuICogQ2xvc2VzIGEgc2Vzc2lvbiBieSBzZXR0aW5nIGl0cyBzdGF0dXMgYW5kIHVwZGF0aW5nIHRoZSBzZXNzaW9uIG9iamVjdCB3aXRoIGl0LlxuICogSW50ZXJuYWxseSBjYWxscyBgdXBkYXRlU2Vzc2lvbmAgdG8gdXBkYXRlIHRoZSBwYXNzZWQgc2Vzc2lvbiBvYmplY3QuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGUgcGFzc2VkIHNlc3Npb24gKEBzZWUgdXBkYXRlU2Vzc2lvbiBmb3IgZXhwbGFuYXRpb24pLlxuICpcbiAqIEBwYXJhbSBzZXNzaW9uIHRoZSBgU2Vzc2lvbmAgb2JqZWN0IHRvIGJlIGNsb3NlZFxuICogQHBhcmFtIHN0YXR1cyB0aGUgYFNlc3Npb25TdGF0dXNgIHdpdGggd2hpY2ggdGhlIHNlc3Npb24gd2FzIGNsb3NlZC4gSWYgeW91IGRvbid0IHBhc3MgYSBzdGF0dXMsXG4gKiAgICAgICAgICAgICAgIHRoaXMgZnVuY3Rpb24gd2lsbCBrZWVwIHRoZSBwcmV2aW91c2x5IHNldCBzdGF0dXMsIHVubGVzcyBpdCB3YXMgYCdvaydgIGluIHdoaWNoIGNhc2VcbiAqICAgICAgICAgICAgICAgaXQgaXMgY2hhbmdlZCB0byBgJ2V4aXRlZCdgLlxuICovXG5mdW5jdGlvbiBjbG9zZVNlc3Npb24oc2Vzc2lvbiwgc3RhdHVzKSB7XG4gIGxldCBjb250ZXh0ID0ge307XG4gIGlmIChzdGF0dXMpIHtcbiAgICBjb250ZXh0ID0geyBzdGF0dXMgfTtcbiAgfSBlbHNlIGlmIChzZXNzaW9uLnN0YXR1cyA9PT0gJ29rJykge1xuICAgIGNvbnRleHQgPSB7IHN0YXR1czogJ2V4aXRlZCcgfTtcbiAgfVxuXG4gIHVwZGF0ZVNlc3Npb24oc2Vzc2lvbiwgY29udGV4dCk7XG59XG5cbi8qKlxuICogU2VyaWFsaXplcyBhIHBhc3NlZCBzZXNzaW9uIG9iamVjdCB0byBhIEpTT04gb2JqZWN0IHdpdGggYSBzbGlnaHRseSBkaWZmZXJlbnQgc3RydWN0dXJlLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgU2VudHJ5IGJhY2tlbmQgcmVxdWlyZXMgYSBzbGlnaHRseSBkaWZmZXJlbnQgc2NoZW1hIG9mIGEgc2Vzc2lvblxuICogdGhhbiB0aGUgb25lIHRoZSBKUyBTREtzIHVzZSBpbnRlcm5hbGx5LlxuICpcbiAqIEBwYXJhbSBzZXNzaW9uIHRoZSBzZXNzaW9uIHRvIGJlIGNvbnZlcnRlZFxuICpcbiAqIEByZXR1cm5zIGEgSlNPTiBvYmplY3Qgb2YgdGhlIHBhc3NlZCBzZXNzaW9uXG4gKi9cbmZ1bmN0aW9uIHNlc3Npb25Ub0pTT04oc2Vzc2lvbikge1xuICByZXR1cm4ge1xuICAgIHNpZDogYCR7c2Vzc2lvbi5zaWR9YCxcbiAgICBpbml0OiBzZXNzaW9uLmluaXQsXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgc2VjIGlzIGNvbnZlcnRlZCB0byBtcyBmb3IgZGF0ZSBjb25zdHJ1Y3RvclxuICAgIHN0YXJ0ZWQ6IG5ldyBEYXRlKHNlc3Npb24uc3RhcnRlZCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgdGltZXN0YW1wOiBuZXcgRGF0ZShzZXNzaW9uLnRpbWVzdGFtcCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgc3RhdHVzOiBzZXNzaW9uLnN0YXR1cyxcbiAgICBlcnJvcnM6IHNlc3Npb24uZXJyb3JzLFxuICAgIGRpZDogdHlwZW9mIHNlc3Npb24uZGlkID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc2Vzc2lvbi5kaWQgPT09ICdzdHJpbmcnID8gYCR7c2Vzc2lvbi5kaWR9YCA6IHVuZGVmaW5lZCxcbiAgICBkdXJhdGlvbjogc2Vzc2lvbi5kdXJhdGlvbixcbiAgICBhYm5vcm1hbF9tZWNoYW5pc206IHNlc3Npb24uYWJub3JtYWxfbWVjaGFuaXNtLFxuICAgIGF0dHJzOiB7XG4gICAgICByZWxlYXNlOiBzZXNzaW9uLnJlbGVhc2UsXG4gICAgICBlbnZpcm9ubWVudDogc2Vzc2lvbi5lbnZpcm9ubWVudCxcbiAgICAgIGlwX2FkZHJlc3M6IHNlc3Npb24uaXBBZGRyZXNzLFxuICAgICAgdXNlcl9hZ2VudDogc2Vzc2lvbi51c2VyQWdlbnQsXG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0cy5jbG9zZVNlc3Npb24gPSBjbG9zZVNlc3Npb247XG5leHBvcnRzLm1ha2VTZXNzaW9uID0gbWFrZVNlc3Npb247XG5leHBvcnRzLnVwZGF0ZVNlc3Npb24gPSB1cGRhdGVTZXNzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Vzc2lvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/session.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst constants = __webpack_require__(/*! ../constants.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/constants.js");\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/semanticAttributes.js");\nconst hasSpansEnabled = __webpack_require__(/*! ../utils/hasSpansEnabled.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/hasSpansEnabled.js");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanUtils.js");\nconst baggage = __webpack_require__(/*! ../utils-hoist/baggage.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/baggage.js");\nconst dsn = __webpack_require__(/*! ../utils-hoist/dsn.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/dsn.js");\nconst object = __webpack_require__(/*! ../utils-hoist/object.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/object.js");\nconst utils = __webpack_require__(/*! ./utils.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/utils.js");\n\n/**\n * If you change this value, also update the terser plugin config to\n * avoid minification of the object property!\n */\nconst FROZEN_DSC_FIELD = \'_frozenDsc\';\n\n/**\n * Freeze the given DSC on the given span.\n */\nfunction freezeDscOnSpan(span, dsc) {\n  const spanWithMaybeDsc = span ;\n  object.addNonEnumerableProperty(spanWithMaybeDsc, FROZEN_DSC_FIELD, dsc);\n}\n\n/**\n * Creates a dynamic sampling context from a client.\n *\n * Dispatches the `createDsc` lifecycle hook as a side effect.\n */\nfunction getDynamicSamplingContextFromClient(trace_id, client) {\n  const options = client.getOptions();\n\n  const { publicKey: public_key, host } = client.getDsn() || {};\n\n  let org_id;\n  if (options.orgId) {\n    org_id = String(options.orgId);\n  } else if (host) {\n    org_id = dsn.extractOrgIdFromDsnHost(host);\n  }\n\n  // Instead of conditionally adding non-undefined values, we add them and then remove them if needed\n  // otherwise, the order of baggage entries changes, which "breaks" a bunch of tests etc.\n  const dsc = {\n    environment: options.environment || constants.DEFAULT_ENVIRONMENT,\n    release: options.release,\n    public_key,\n    trace_id,\n    org_id,\n  };\n\n  client.emit(\'createDsc\', dsc);\n\n  return dsc;\n}\n\n/**\n * Get the dynamic sampling context for the currently active scopes.\n */\nfunction getDynamicSamplingContextFromScope(client, scope) {\n  const propagationContext = scope.getPropagationContext();\n  return propagationContext.dsc || getDynamicSamplingContextFromClient(propagationContext.traceId, client);\n}\n\n/**\n * Creates a dynamic sampling context from a span (and client and scope)\n *\n * @param span the span from which a few values like the root span name and sample rate are extracted.\n *\n * @returns a dynamic sampling context\n */\nfunction getDynamicSamplingContextFromSpan(span) {\n  const client = currentScopes.getClient();\n  if (!client) {\n    return {};\n  }\n\n  const rootSpan = spanUtils.getRootSpan(span);\n  const rootSpanJson = spanUtils.spanToJSON(rootSpan);\n  const rootSpanAttributes = rootSpanJson.data;\n  const traceState = rootSpan.spanContext().traceState;\n\n  // The span sample rate that was locally applied to the root span should also always be applied to the DSC, even if the DSC is frozen.\n  // This is so that the downstream traces/services can use parentSampleRate in their `tracesSampler` to make consistent sampling decisions across the entire trace.\n  const rootSpanSampleRate =\n    traceState?.get(\'sentry.sample_rate\') ??\n    rootSpanAttributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ??\n    rootSpanAttributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE];\n\n  function applyLocalSampleRateToDsc(dsc) {\n    if (typeof rootSpanSampleRate === \'number\' || typeof rootSpanSampleRate === \'string\') {\n      dsc.sample_rate = `${rootSpanSampleRate}`;\n    }\n    return dsc;\n  }\n\n  // For core implementation, we freeze the DSC onto the span as a non-enumerable property\n  const frozenDsc = (rootSpan )[FROZEN_DSC_FIELD];\n  if (frozenDsc) {\n    return applyLocalSampleRateToDsc(frozenDsc);\n  }\n\n  // For OpenTelemetry, we freeze the DSC on the trace state\n  const traceStateDsc = traceState?.get(\'sentry.dsc\');\n\n  // If the span has a DSC, we want it to take precedence\n  const dscOnTraceState = traceStateDsc && baggage.baggageHeaderToDynamicSamplingContext(traceStateDsc);\n\n  if (dscOnTraceState) {\n    return applyLocalSampleRateToDsc(dscOnTraceState);\n  }\n\n  // Else, we generate it from the span\n  const dsc = getDynamicSamplingContextFromClient(span.spanContext().traceId, client);\n\n  // We don\'t want to have a transaction name in the DSC if the source is "url" because URLs might contain PII\n  const source = rootSpanAttributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n  // after JSON conversion, txn.name becomes jsonSpan.description\n  const name = rootSpanJson.description;\n  if (source !== \'url\' && name) {\n    dsc.transaction = name;\n  }\n\n  // How can we even land here with hasSpansEnabled() returning false?\n  // Otel creates a Non-recording span in Tracing Without Performance mode when handling incoming requests\n  // So we end up with an active span that is not sampled (neither positively nor negatively)\n  if (hasSpansEnabled.hasSpansEnabled()) {\n    dsc.sampled = String(spanUtils.spanIsSampled(rootSpan));\n    dsc.sample_rand =\n      // In OTEL we store the sample rand on the trace state because we cannot access scopes for NonRecordingSpans\n      // The Sentry OTEL SpanSampler takes care of writing the sample rand on the root span\n      traceState?.get(\'sentry.sample_rand\') ??\n      // On all other platforms we can actually get the scopes from a root span (we use this as a fallback)\n      utils.getCapturedScopesOnSpan(rootSpan).scope?.getPropagationContext().sampleRand.toString();\n  }\n\n  applyLocalSampleRateToDsc(dsc);\n\n  client.emit(\'createDsc\', dsc, rootSpan);\n\n  return dsc;\n}\n\n/**\n * Convert a Span to a baggage header.\n */\nfunction spanToBaggageHeader(span) {\n  const dsc = getDynamicSamplingContextFromSpan(span);\n  return baggage.dynamicSamplingContextToSentryBaggageHeader(dsc);\n}\n\nexports.freezeDscOnSpan = freezeDscOnSpan;\nexports.getDynamicSamplingContextFromClient = getDynamicSamplingContextFromClient;\nexports.getDynamicSamplingContextFromScope = getDynamicSamplingContextFromScope;\nexports.getDynamicSamplingContextFromSpan = getDynamicSamplingContextFromSpan;\nexports.spanToBaggageHeader = spanToBaggageHeader;\n//# sourceMappingURL=dynamicSamplingContext.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhY2luZy9keW5hbWljU2FtcGxpbmdDb250ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLGtCQUFrQixtQkFBTyxDQUFDLDZHQUFpQjtBQUMzQyxzQkFBc0IsbUJBQU8sQ0FBQyxxSEFBcUI7QUFDbkQsMkJBQTJCLG1CQUFPLENBQUMsK0hBQTBCO0FBQzdELHdCQUF3QixtQkFBTyxDQUFDLHFJQUE2QjtBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyx5SEFBdUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsaUlBQTJCO0FBQ25ELFlBQVksbUJBQU8sQ0FBQyx5SEFBdUI7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLCtIQUEwQjtBQUNqRCxjQUFjLG1CQUFPLENBQUMsNEdBQVk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSw4QkFBOEI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsMkNBQTJDO0FBQzNDLDBDQUEwQztBQUMxQyx5Q0FBeUM7QUFDekMsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcdHJhY2luZ1xcZHluYW1pY1NhbXBsaW5nQ29udGV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzLmpzJyk7XG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi4vY3VycmVudFNjb3Blcy5qcycpO1xuY29uc3Qgc2VtYW50aWNBdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi4vc2VtYW50aWNBdHRyaWJ1dGVzLmpzJyk7XG5jb25zdCBoYXNTcGFuc0VuYWJsZWQgPSByZXF1aXJlKCcuLi91dGlscy9oYXNTcGFuc0VuYWJsZWQuanMnKTtcbmNvbnN0IHNwYW5VdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3NwYW5VdGlscy5qcycpO1xuY29uc3QgYmFnZ2FnZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2JhZ2dhZ2UuanMnKTtcbmNvbnN0IGRzbiA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2Rzbi5qcycpO1xuY29uc3Qgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvb2JqZWN0LmpzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcblxuLyoqXG4gKiBJZiB5b3UgY2hhbmdlIHRoaXMgdmFsdWUsIGFsc28gdXBkYXRlIHRoZSB0ZXJzZXIgcGx1Z2luIGNvbmZpZyB0b1xuICogYXZvaWQgbWluaWZpY2F0aW9uIG9mIHRoZSBvYmplY3QgcHJvcGVydHkhXG4gKi9cbmNvbnN0IEZST1pFTl9EU0NfRklFTEQgPSAnX2Zyb3plbkRzYyc7XG5cbi8qKlxuICogRnJlZXplIHRoZSBnaXZlbiBEU0Mgb24gdGhlIGdpdmVuIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGZyZWV6ZURzY09uU3BhbihzcGFuLCBkc2MpIHtcbiAgY29uc3Qgc3BhbldpdGhNYXliZURzYyA9IHNwYW4gO1xuICBvYmplY3QuYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KHNwYW5XaXRoTWF5YmVEc2MsIEZST1pFTl9EU0NfRklFTEQsIGRzYyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGR5bmFtaWMgc2FtcGxpbmcgY29udGV4dCBmcm9tIGEgY2xpZW50LlxuICpcbiAqIERpc3BhdGNoZXMgdGhlIGBjcmVhdGVEc2NgIGxpZmVjeWNsZSBob29rIGFzIGEgc2lkZSBlZmZlY3QuXG4gKi9cbmZ1bmN0aW9uIGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tQ2xpZW50KHRyYWNlX2lkLCBjbGllbnQpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGNsaWVudC5nZXRPcHRpb25zKCk7XG5cbiAgY29uc3QgeyBwdWJsaWNLZXk6IHB1YmxpY19rZXksIGhvc3QgfSA9IGNsaWVudC5nZXREc24oKSB8fCB7fTtcblxuICBsZXQgb3JnX2lkO1xuICBpZiAob3B0aW9ucy5vcmdJZCkge1xuICAgIG9yZ19pZCA9IFN0cmluZyhvcHRpb25zLm9yZ0lkKTtcbiAgfSBlbHNlIGlmIChob3N0KSB7XG4gICAgb3JnX2lkID0gZHNuLmV4dHJhY3RPcmdJZEZyb21Ec25Ib3N0KGhvc3QpO1xuICB9XG5cbiAgLy8gSW5zdGVhZCBvZiBjb25kaXRpb25hbGx5IGFkZGluZyBub24tdW5kZWZpbmVkIHZhbHVlcywgd2UgYWRkIHRoZW0gYW5kIHRoZW4gcmVtb3ZlIHRoZW0gaWYgbmVlZGVkXG4gIC8vIG90aGVyd2lzZSwgdGhlIG9yZGVyIG9mIGJhZ2dhZ2UgZW50cmllcyBjaGFuZ2VzLCB3aGljaCBcImJyZWFrc1wiIGEgYnVuY2ggb2YgdGVzdHMgZXRjLlxuICBjb25zdCBkc2MgPSB7XG4gICAgZW52aXJvbm1lbnQ6IG9wdGlvbnMuZW52aXJvbm1lbnQgfHwgY29uc3RhbnRzLkRFRkFVTFRfRU5WSVJPTk1FTlQsXG4gICAgcmVsZWFzZTogb3B0aW9ucy5yZWxlYXNlLFxuICAgIHB1YmxpY19rZXksXG4gICAgdHJhY2VfaWQsXG4gICAgb3JnX2lkLFxuICB9O1xuXG4gIGNsaWVudC5lbWl0KCdjcmVhdGVEc2MnLCBkc2MpO1xuXG4gIHJldHVybiBkc2M7XG59XG5cbi8qKlxuICogR2V0IHRoZSBkeW5hbWljIHNhbXBsaW5nIGNvbnRleHQgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNjb3Blcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TY29wZShjbGllbnQsIHNjb3BlKSB7XG4gIGNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IHNjb3BlLmdldFByb3BhZ2F0aW9uQ29udGV4dCgpO1xuICByZXR1cm4gcHJvcGFnYXRpb25Db250ZXh0LmRzYyB8fCBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbUNsaWVudChwcm9wYWdhdGlvbkNvbnRleHQudHJhY2VJZCwgY2xpZW50KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZHluYW1pYyBzYW1wbGluZyBjb250ZXh0IGZyb20gYSBzcGFuIChhbmQgY2xpZW50IGFuZCBzY29wZSlcbiAqXG4gKiBAcGFyYW0gc3BhbiB0aGUgc3BhbiBmcm9tIHdoaWNoIGEgZmV3IHZhbHVlcyBsaWtlIHRoZSByb290IHNwYW4gbmFtZSBhbmQgc2FtcGxlIHJhdGUgYXJlIGV4dHJhY3RlZC5cbiAqXG4gKiBAcmV0dXJucyBhIGR5bmFtaWMgc2FtcGxpbmcgY29udGV4dFxuICovXG5mdW5jdGlvbiBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3Bhbikge1xuICBjb25zdCBjbGllbnQgPSBjdXJyZW50U2NvcGVzLmdldENsaWVudCgpO1xuICBpZiAoIWNsaWVudCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IHJvb3RTcGFuID0gc3BhblV0aWxzLmdldFJvb3RTcGFuKHNwYW4pO1xuICBjb25zdCByb290U3Bhbkpzb24gPSBzcGFuVXRpbHMuc3BhblRvSlNPTihyb290U3Bhbik7XG4gIGNvbnN0IHJvb3RTcGFuQXR0cmlidXRlcyA9IHJvb3RTcGFuSnNvbi5kYXRhO1xuICBjb25zdCB0cmFjZVN0YXRlID0gcm9vdFNwYW4uc3BhbkNvbnRleHQoKS50cmFjZVN0YXRlO1xuXG4gIC8vIFRoZSBzcGFuIHNhbXBsZSByYXRlIHRoYXQgd2FzIGxvY2FsbHkgYXBwbGllZCB0byB0aGUgcm9vdCBzcGFuIHNob3VsZCBhbHNvIGFsd2F5cyBiZSBhcHBsaWVkIHRvIHRoZSBEU0MsIGV2ZW4gaWYgdGhlIERTQyBpcyBmcm96ZW4uXG4gIC8vIFRoaXMgaXMgc28gdGhhdCB0aGUgZG93bnN0cmVhbSB0cmFjZXMvc2VydmljZXMgY2FuIHVzZSBwYXJlbnRTYW1wbGVSYXRlIGluIHRoZWlyIGB0cmFjZXNTYW1wbGVyYCB0byBtYWtlIGNvbnNpc3RlbnQgc2FtcGxpbmcgZGVjaXNpb25zIGFjcm9zcyB0aGUgZW50aXJlIHRyYWNlLlxuICBjb25zdCByb290U3BhblNhbXBsZVJhdGUgPVxuICAgIHRyYWNlU3RhdGU/LmdldCgnc2VudHJ5LnNhbXBsZV9yYXRlJykgPz9cbiAgICByb290U3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEVdID8/XG4gICAgcm9vdFNwYW5BdHRyaWJ1dGVzW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1BSRVZJT1VTX1RSQUNFX1NBTVBMRV9SQVRFXTtcblxuICBmdW5jdGlvbiBhcHBseUxvY2FsU2FtcGxlUmF0ZVRvRHNjKGRzYykge1xuICAgIGlmICh0eXBlb2Ygcm9vdFNwYW5TYW1wbGVSYXRlID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygcm9vdFNwYW5TYW1wbGVSYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgZHNjLnNhbXBsZV9yYXRlID0gYCR7cm9vdFNwYW5TYW1wbGVSYXRlfWA7XG4gICAgfVxuICAgIHJldHVybiBkc2M7XG4gIH1cblxuICAvLyBGb3IgY29yZSBpbXBsZW1lbnRhdGlvbiwgd2UgZnJlZXplIHRoZSBEU0Mgb250byB0aGUgc3BhbiBhcyBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG4gIGNvbnN0IGZyb3plbkRzYyA9IChyb290U3BhbiApW0ZST1pFTl9EU0NfRklFTERdO1xuICBpZiAoZnJvemVuRHNjKSB7XG4gICAgcmV0dXJuIGFwcGx5TG9jYWxTYW1wbGVSYXRlVG9Ec2MoZnJvemVuRHNjKTtcbiAgfVxuXG4gIC8vIEZvciBPcGVuVGVsZW1ldHJ5LCB3ZSBmcmVlemUgdGhlIERTQyBvbiB0aGUgdHJhY2Ugc3RhdGVcbiAgY29uc3QgdHJhY2VTdGF0ZURzYyA9IHRyYWNlU3RhdGU/LmdldCgnc2VudHJ5LmRzYycpO1xuXG4gIC8vIElmIHRoZSBzcGFuIGhhcyBhIERTQywgd2Ugd2FudCBpdCB0byB0YWtlIHByZWNlZGVuY2VcbiAgY29uc3QgZHNjT25UcmFjZVN0YXRlID0gdHJhY2VTdGF0ZURzYyAmJiBiYWdnYWdlLmJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQodHJhY2VTdGF0ZURzYyk7XG5cbiAgaWYgKGRzY09uVHJhY2VTdGF0ZSkge1xuICAgIHJldHVybiBhcHBseUxvY2FsU2FtcGxlUmF0ZVRvRHNjKGRzY09uVHJhY2VTdGF0ZSk7XG4gIH1cblxuICAvLyBFbHNlLCB3ZSBnZW5lcmF0ZSBpdCBmcm9tIHRoZSBzcGFuXG4gIGNvbnN0IGRzYyA9IGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tQ2xpZW50KHNwYW4uc3BhbkNvbnRleHQoKS50cmFjZUlkLCBjbGllbnQpO1xuXG4gIC8vIFdlIGRvbid0IHdhbnQgdG8gaGF2ZSBhIHRyYW5zYWN0aW9uIG5hbWUgaW4gdGhlIERTQyBpZiB0aGUgc291cmNlIGlzIFwidXJsXCIgYmVjYXVzZSBVUkxzIG1pZ2h0IGNvbnRhaW4gUElJXG4gIGNvbnN0IHNvdXJjZSA9IHJvb3RTcGFuQXR0cmlidXRlc1tzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdO1xuXG4gIC8vIGFmdGVyIEpTT04gY29udmVyc2lvbiwgdHhuLm5hbWUgYmVjb21lcyBqc29uU3Bhbi5kZXNjcmlwdGlvblxuICBjb25zdCBuYW1lID0gcm9vdFNwYW5Kc29uLmRlc2NyaXB0aW9uO1xuICBpZiAoc291cmNlICE9PSAndXJsJyAmJiBuYW1lKSB7XG4gICAgZHNjLnRyYW5zYWN0aW9uID0gbmFtZTtcbiAgfVxuXG4gIC8vIEhvdyBjYW4gd2UgZXZlbiBsYW5kIGhlcmUgd2l0aCBoYXNTcGFuc0VuYWJsZWQoKSByZXR1cm5pbmcgZmFsc2U/XG4gIC8vIE90ZWwgY3JlYXRlcyBhIE5vbi1yZWNvcmRpbmcgc3BhbiBpbiBUcmFjaW5nIFdpdGhvdXQgUGVyZm9ybWFuY2UgbW9kZSB3aGVuIGhhbmRsaW5nIGluY29taW5nIHJlcXVlc3RzXG4gIC8vIFNvIHdlIGVuZCB1cCB3aXRoIGFuIGFjdGl2ZSBzcGFuIHRoYXQgaXMgbm90IHNhbXBsZWQgKG5laXRoZXIgcG9zaXRpdmVseSBub3IgbmVnYXRpdmVseSlcbiAgaWYgKGhhc1NwYW5zRW5hYmxlZC5oYXNTcGFuc0VuYWJsZWQoKSkge1xuICAgIGRzYy5zYW1wbGVkID0gU3RyaW5nKHNwYW5VdGlscy5zcGFuSXNTYW1wbGVkKHJvb3RTcGFuKSk7XG4gICAgZHNjLnNhbXBsZV9yYW5kID1cbiAgICAgIC8vIEluIE9URUwgd2Ugc3RvcmUgdGhlIHNhbXBsZSByYW5kIG9uIHRoZSB0cmFjZSBzdGF0ZSBiZWNhdXNlIHdlIGNhbm5vdCBhY2Nlc3Mgc2NvcGVzIGZvciBOb25SZWNvcmRpbmdTcGFuc1xuICAgICAgLy8gVGhlIFNlbnRyeSBPVEVMIFNwYW5TYW1wbGVyIHRha2VzIGNhcmUgb2Ygd3JpdGluZyB0aGUgc2FtcGxlIHJhbmQgb24gdGhlIHJvb3Qgc3BhblxuICAgICAgdHJhY2VTdGF0ZT8uZ2V0KCdzZW50cnkuc2FtcGxlX3JhbmQnKSA/P1xuICAgICAgLy8gT24gYWxsIG90aGVyIHBsYXRmb3JtcyB3ZSBjYW4gYWN0dWFsbHkgZ2V0IHRoZSBzY29wZXMgZnJvbSBhIHJvb3Qgc3BhbiAod2UgdXNlIHRoaXMgYXMgYSBmYWxsYmFjaylcbiAgICAgIHV0aWxzLmdldENhcHR1cmVkU2NvcGVzT25TcGFuKHJvb3RTcGFuKS5zY29wZT8uZ2V0UHJvcGFnYXRpb25Db250ZXh0KCkuc2FtcGxlUmFuZC50b1N0cmluZygpO1xuICB9XG5cbiAgYXBwbHlMb2NhbFNhbXBsZVJhdGVUb0RzYyhkc2MpO1xuXG4gIGNsaWVudC5lbWl0KCdjcmVhdGVEc2MnLCBkc2MsIHJvb3RTcGFuKTtcblxuICByZXR1cm4gZHNjO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBTcGFuIHRvIGEgYmFnZ2FnZSBoZWFkZXIuXG4gKi9cbmZ1bmN0aW9uIHNwYW5Ub0JhZ2dhZ2VIZWFkZXIoc3Bhbikge1xuICBjb25zdCBkc2MgPSBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3Bhbik7XG4gIHJldHVybiBiYWdnYWdlLmR5bmFtaWNTYW1wbGluZ0NvbnRleHRUb1NlbnRyeUJhZ2dhZ2VIZWFkZXIoZHNjKTtcbn1cblxuZXhwb3J0cy5mcmVlemVEc2NPblNwYW4gPSBmcmVlemVEc2NPblNwYW47XG5leHBvcnRzLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tQ2xpZW50ID0gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21DbGllbnQ7XG5leHBvcnRzLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU2NvcGUgPSBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNjb3BlO1xuZXhwb3J0cy5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4gPSBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW47XG5leHBvcnRzLnNwYW5Ub0JhZ2dhZ2VIZWFkZXIgPSBzcGFuVG9CYWdnYWdlSGVhZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHluYW1pY1NhbXBsaW5nQ29udGV4dC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/errors.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanUtils.js");\nconst globalError = __webpack_require__(/*! ../utils-hoist/instrument/globalError.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/globalError.js");\nconst globalUnhandledRejection = __webpack_require__(/*! ../utils-hoist/instrument/globalUnhandledRejection.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/instrument/globalUnhandledRejection.js");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js");\nconst spanstatus = __webpack_require__(/*! ./spanstatus.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js");\n\nlet errorsInstrumented = false;\n\n/**\n * Ensure that global errors automatically set the active span status.\n */\nfunction registerSpanErrorInstrumentation() {\n  if (errorsInstrumented) {\n    return;\n  }\n\n  errorsInstrumented = true;\n  globalError.addGlobalErrorInstrumentationHandler(errorCallback);\n  globalUnhandledRejection.addGlobalUnhandledRejectionInstrumentationHandler(errorCallback);\n}\n\n/**\n * If an error or unhandled promise occurs, we mark the active root span as failed\n */\nfunction errorCallback() {\n  const activeSpan = spanUtils.getActiveSpan();\n  const rootSpan = activeSpan && spanUtils.getRootSpan(activeSpan);\n  if (rootSpan) {\n    const message = \'internal_error\';\n    debugBuild.DEBUG_BUILD && logger.logger.log(`[Tracing] Root span: ${message} -> Global error occurred`);\n    rootSpan.setStatus({ code: spanstatus.SPAN_STATUS_ERROR, message });\n  }\n}\n\n// The function name will be lost when bundling but we need to be able to identify this listener later to maintain the\n// node.js default exit behaviour\nerrorCallback.tag = \'sentry_tracingErrorCallback\';\n\nexports.registerSpanErrorInstrumentation = registerSpanErrorInstrumentation;\n//# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhY2luZy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsbUJBQW1CLG1CQUFPLENBQUMsaUhBQW1CO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLHlIQUF1QjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQywrSkFBMEM7QUFDdEUsaUNBQWlDLG1CQUFPLENBQUMseUxBQXVEO0FBQ2hHLGVBQWUsbUJBQU8sQ0FBQywrSEFBMEI7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsc0hBQWlCOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFNBQVM7QUFDakYseUJBQXlCLDZDQUE2QztBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFx0cmFjaW5nXFxlcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGRlYnVnQnVpbGQgPSByZXF1aXJlKCcuLi9kZWJ1Zy1idWlsZC5qcycpO1xuY29uc3Qgc3BhblV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvc3BhblV0aWxzLmpzJyk7XG5jb25zdCBnbG9iYWxFcnJvciA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2luc3RydW1lbnQvZ2xvYmFsRXJyb3IuanMnKTtcbmNvbnN0IGdsb2JhbFVuaGFuZGxlZFJlamVjdGlvbiA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2luc3RydW1lbnQvZ2xvYmFsVW5oYW5kbGVkUmVqZWN0aW9uLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IHNwYW5zdGF0dXMgPSByZXF1aXJlKCcuL3NwYW5zdGF0dXMuanMnKTtcblxubGV0IGVycm9yc0luc3RydW1lbnRlZCA9IGZhbHNlO1xuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGdsb2JhbCBlcnJvcnMgYXV0b21hdGljYWxseSBzZXQgdGhlIGFjdGl2ZSBzcGFuIHN0YXR1cy5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJTcGFuRXJyb3JJbnN0cnVtZW50YXRpb24oKSB7XG4gIGlmIChlcnJvcnNJbnN0cnVtZW50ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlcnJvcnNJbnN0cnVtZW50ZWQgPSB0cnVlO1xuICBnbG9iYWxFcnJvci5hZGRHbG9iYWxFcnJvckluc3RydW1lbnRhdGlvbkhhbmRsZXIoZXJyb3JDYWxsYmFjayk7XG4gIGdsb2JhbFVuaGFuZGxlZFJlamVjdGlvbi5hZGRHbG9iYWxVbmhhbmRsZWRSZWplY3Rpb25JbnN0cnVtZW50YXRpb25IYW5kbGVyKGVycm9yQ2FsbGJhY2spO1xufVxuXG4vKipcbiAqIElmIGFuIGVycm9yIG9yIHVuaGFuZGxlZCBwcm9taXNlIG9jY3Vycywgd2UgbWFyayB0aGUgYWN0aXZlIHJvb3Qgc3BhbiBhcyBmYWlsZWRcbiAqL1xuZnVuY3Rpb24gZXJyb3JDYWxsYmFjaygpIHtcbiAgY29uc3QgYWN0aXZlU3BhbiA9IHNwYW5VdGlscy5nZXRBY3RpdmVTcGFuKCk7XG4gIGNvbnN0IHJvb3RTcGFuID0gYWN0aXZlU3BhbiAmJiBzcGFuVXRpbHMuZ2V0Um9vdFNwYW4oYWN0aXZlU3Bhbik7XG4gIGlmIChyb290U3Bhbikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAnaW50ZXJuYWxfZXJyb3InO1xuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci5sb2coYFtUcmFjaW5nXSBSb290IHNwYW46ICR7bWVzc2FnZX0gLT4gR2xvYmFsIGVycm9yIG9jY3VycmVkYCk7XG4gICAgcm9vdFNwYW4uc2V0U3RhdHVzKHsgY29kZTogc3BhbnN0YXR1cy5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZSB9KTtcbiAgfVxufVxuXG4vLyBUaGUgZnVuY3Rpb24gbmFtZSB3aWxsIGJlIGxvc3Qgd2hlbiBidW5kbGluZyBidXQgd2UgbmVlZCB0byBiZSBhYmxlIHRvIGlkZW50aWZ5IHRoaXMgbGlzdGVuZXIgbGF0ZXIgdG8gbWFpbnRhaW4gdGhlXG4vLyBub2RlLmpzIGRlZmF1bHQgZXhpdCBiZWhhdmlvdXJcbmVycm9yQ2FsbGJhY2sudGFnID0gJ3NlbnRyeV90cmFjaW5nRXJyb3JDYWxsYmFjayc7XG5cbmV4cG9ydHMucmVnaXN0ZXJTcGFuRXJyb3JJbnN0cnVtZW50YXRpb24gPSByZWdpc3RlclNwYW5FcnJvckluc3RydW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/errors.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/idleSpan.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\nconst hasSpansEnabled = __webpack_require__(/*! ../utils/hasSpansEnabled.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/hasSpansEnabled.js\");\nconst spanOnScope = __webpack_require__(/*! ../utils/spanOnScope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanOnScope.js\");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanUtils.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst time = __webpack_require__(/*! ../utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst dynamicSamplingContext = __webpack_require__(/*! ./dynamicSamplingContext.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js\");\nconst sentryNonRecordingSpan = __webpack_require__(/*! ./sentryNonRecordingSpan.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sentryNonRecordingSpan.js\");\nconst spanstatus = __webpack_require__(/*! ./spanstatus.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js\");\nconst trace = __webpack_require__(/*! ./trace.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/trace.js\");\n\nconst TRACING_DEFAULTS = {\n  idleTimeout: 1000,\n  finalTimeout: 30000,\n  childSpanTimeout: 15000,\n};\n\nconst FINISH_REASON_HEARTBEAT_FAILED = 'heartbeatFailed';\nconst FINISH_REASON_IDLE_TIMEOUT = 'idleTimeout';\nconst FINISH_REASON_FINAL_TIMEOUT = 'finalTimeout';\nconst FINISH_REASON_EXTERNAL_FINISH = 'externalFinish';\n\n/**\n * An idle span is a span that automatically finishes. It does this by tracking child spans as activities.\n * An idle span is always the active span.\n */\nfunction startIdleSpan(startSpanOptions, options = {}) {\n  // Activities store a list of active spans\n  const activities = new Map();\n\n  // We should not use heartbeat if we finished a span\n  let _finished = false;\n\n  // Timer that tracks idleTimeout\n  let _idleTimeoutID;\n\n  // The reason why the span was finished\n  let _finishReason = FINISH_REASON_EXTERNAL_FINISH;\n\n  let _autoFinishAllowed = !options.disableAutoFinish;\n\n  const _cleanupHooks = [];\n\n  const {\n    idleTimeout = TRACING_DEFAULTS.idleTimeout,\n    finalTimeout = TRACING_DEFAULTS.finalTimeout,\n    childSpanTimeout = TRACING_DEFAULTS.childSpanTimeout,\n    beforeSpanEnd,\n  } = options;\n\n  const client = currentScopes.getClient();\n\n  if (!client || !hasSpansEnabled.hasSpansEnabled()) {\n    const span = new sentryNonRecordingSpan.SentryNonRecordingSpan();\n\n    const dsc = {\n      sample_rate: '0',\n      sampled: 'false',\n      ...dynamicSamplingContext.getDynamicSamplingContextFromSpan(span),\n    } ;\n    dynamicSamplingContext.freezeDscOnSpan(span, dsc);\n\n    return span;\n  }\n\n  const scope = currentScopes.getCurrentScope();\n  const previousActiveSpan = spanUtils.getActiveSpan();\n  const span = _startIdleSpan(startSpanOptions);\n\n  // We patch span.end to ensure we can run some things before the span is ended\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  span.end = new Proxy(span.end, {\n    apply(target, thisArg, args) {\n      if (beforeSpanEnd) {\n        beforeSpanEnd(span);\n      }\n\n      // If the span is non-recording, nothing more to do here...\n      // This is the case if tracing is enabled but this specific span was not sampled\n      if (thisArg instanceof sentryNonRecordingSpan.SentryNonRecordingSpan) {\n        return;\n      }\n\n      // Just ensuring that this keeps working, even if we ever have more arguments here\n      const [definedEndTimestamp, ...rest] = args;\n      const timestamp = definedEndTimestamp || time.timestampInSeconds();\n      const spanEndTimestamp = spanUtils.spanTimeInputToSeconds(timestamp);\n\n      // Ensure we end with the last span timestamp, if possible\n      const spans = spanUtils.getSpanDescendants(span).filter(child => child !== span);\n\n      // If we have no spans, we just end, nothing else to do here\n      if (!spans.length) {\n        onIdleSpanEnded(spanEndTimestamp);\n        return Reflect.apply(target, thisArg, [spanEndTimestamp, ...rest]);\n      }\n\n      const childEndTimestamps = spans\n        .map(span => spanUtils.spanToJSON(span).timestamp)\n        .filter(timestamp => !!timestamp) ;\n      const latestSpanEndTimestamp = childEndTimestamps.length ? Math.max(...childEndTimestamps) : undefined;\n\n      // In reality this should always exist here, but type-wise it may be undefined...\n      const spanStartTimestamp = spanUtils.spanToJSON(span).start_timestamp;\n\n      // The final endTimestamp should:\n      // * Never be before the span start timestamp\n      // * Be the latestSpanEndTimestamp, if there is one, and it is smaller than the passed span end timestamp\n      // * Otherwise be the passed end timestamp\n      // Final timestamp can never be after finalTimeout\n      const endTimestamp = Math.min(\n        spanStartTimestamp ? spanStartTimestamp + finalTimeout / 1000 : Infinity,\n        Math.max(spanStartTimestamp || -Infinity, Math.min(spanEndTimestamp, latestSpanEndTimestamp || Infinity)),\n      );\n\n      onIdleSpanEnded(endTimestamp);\n      return Reflect.apply(target, thisArg, [endTimestamp, ...rest]);\n    },\n  });\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   */\n  function _cancelIdleTimeout() {\n    if (_idleTimeoutID) {\n      clearTimeout(_idleTimeoutID);\n      _idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  function _restartIdleTimeout(endTimestamp) {\n    _cancelIdleTimeout();\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && activities.size === 0 && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_IDLE_TIMEOUT;\n        span.end(endTimestamp);\n      }\n    }, idleTimeout);\n  }\n\n  /**\n   * Restarts child span timeout, if there is none running it will start one.\n   */\n  function _restartChildSpanTimeout(endTimestamp) {\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_HEARTBEAT_FAILED;\n        span.end(endTimestamp);\n      }\n    }, childSpanTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  function _pushActivity(spanId) {\n    _cancelIdleTimeout();\n    activities.set(spanId, true);\n\n    const endTimestamp = time.timestampInSeconds();\n    // We need to add the timeout here to have the real endtimestamp of the idle span\n    // Remember timestampInSeconds is in seconds, timeout is in ms\n    _restartChildSpanTimeout(endTimestamp + childSpanTimeout / 1000);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  function _popActivity(spanId) {\n    if (activities.has(spanId)) {\n      activities.delete(spanId);\n    }\n\n    if (activities.size === 0) {\n      const endTimestamp = time.timestampInSeconds();\n      // We need to add the timeout here to have the real endtimestamp of the idle span\n      // Remember timestampInSeconds is in seconds, timeout is in ms\n      _restartIdleTimeout(endTimestamp + idleTimeout / 1000);\n    }\n  }\n\n  function onIdleSpanEnded(endTimestamp) {\n    _finished = true;\n    activities.clear();\n\n    _cleanupHooks.forEach(cleanup => cleanup());\n\n    spanOnScope._setSpanForScope(scope, previousActiveSpan);\n\n    const spanJSON = spanUtils.spanToJSON(span);\n\n    const { start_timestamp: startTimestamp } = spanJSON;\n    // This should never happen, but to make TS happy...\n    if (!startTimestamp) {\n      return;\n    }\n\n    const attributes = spanJSON.data;\n    if (!attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON]) {\n      span.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, _finishReason);\n    }\n\n    logger.logger.log(`[Tracing] Idle span \"${spanJSON.op}\" finished`);\n\n    const childSpans = spanUtils.getSpanDescendants(span).filter(child => child !== span);\n\n    let discardedSpans = 0;\n    childSpans.forEach(childSpan => {\n      // We cancel all pending spans with status \"cancelled\" to indicate the idle span was finished early\n      if (childSpan.isRecording()) {\n        childSpan.setStatus({ code: spanstatus.SPAN_STATUS_ERROR, message: 'cancelled' });\n        childSpan.end(endTimestamp);\n        debugBuild.DEBUG_BUILD &&\n          logger.logger.log('[Tracing] Cancelling span since span ended early', JSON.stringify(childSpan, undefined, 2));\n      }\n\n      const childSpanJSON = spanUtils.spanToJSON(childSpan);\n      const { timestamp: childEndTimestamp = 0, start_timestamp: childStartTimestamp = 0 } = childSpanJSON;\n\n      const spanStartedBeforeIdleSpanEnd = childStartTimestamp <= endTimestamp;\n\n      // Add a delta with idle timeout so that we prevent false positives\n      const timeoutWithMarginOfError = (finalTimeout + idleTimeout) / 1000;\n      const spanEndedBeforeFinalTimeout = childEndTimestamp - childStartTimestamp <= timeoutWithMarginOfError;\n\n      if (debugBuild.DEBUG_BUILD) {\n        const stringifiedSpan = JSON.stringify(childSpan, undefined, 2);\n        if (!spanStartedBeforeIdleSpanEnd) {\n          logger.logger.log('[Tracing] Discarding span since it happened after idle span was finished', stringifiedSpan);\n        } else if (!spanEndedBeforeFinalTimeout) {\n          logger.logger.log('[Tracing] Discarding span since it finished after idle span final timeout', stringifiedSpan);\n        }\n      }\n\n      if (!spanEndedBeforeFinalTimeout || !spanStartedBeforeIdleSpanEnd) {\n        spanUtils.removeChildSpanFromSpan(span, childSpan);\n        discardedSpans++;\n      }\n    });\n\n    if (discardedSpans > 0) {\n      span.setAttribute('sentry.idle_span_discarded_spans', discardedSpans);\n    }\n  }\n\n  _cleanupHooks.push(\n    client.on('spanStart', startedSpan => {\n      // If we already finished the idle span,\n      // or if this is the idle span itself being started,\n      // or if the started span has already been closed,\n      // we don't care about it for activity\n      if (_finished || startedSpan === span || !!spanUtils.spanToJSON(startedSpan).timestamp) {\n        return;\n      }\n\n      const allSpans = spanUtils.getSpanDescendants(span);\n\n      // If the span that was just started is a child of the idle span, we should track it\n      if (allSpans.includes(startedSpan)) {\n        _pushActivity(startedSpan.spanContext().spanId);\n      }\n    }),\n  );\n\n  _cleanupHooks.push(\n    client.on('spanEnd', endedSpan => {\n      if (_finished) {\n        return;\n      }\n\n      _popActivity(endedSpan.spanContext().spanId);\n    }),\n  );\n\n  _cleanupHooks.push(\n    client.on('idleSpanEnableAutoFinish', spanToAllowAutoFinish => {\n      if (spanToAllowAutoFinish === span) {\n        _autoFinishAllowed = true;\n        _restartIdleTimeout();\n\n        if (activities.size) {\n          _restartChildSpanTimeout();\n        }\n      }\n    }),\n  );\n\n  // We only start the initial idle timeout if we are not delaying the auto finish\n  if (!options.disableAutoFinish) {\n    _restartIdleTimeout();\n  }\n\n  setTimeout(() => {\n    if (!_finished) {\n      span.setStatus({ code: spanstatus.SPAN_STATUS_ERROR, message: 'deadline_exceeded' });\n      _finishReason = FINISH_REASON_FINAL_TIMEOUT;\n      span.end();\n    }\n  }, finalTimeout);\n\n  return span;\n}\n\nfunction _startIdleSpan(options) {\n  const span = trace.startInactiveSpan(options);\n\n  spanOnScope._setSpanForScope(currentScopes.getCurrentScope(), span);\n\n  debugBuild.DEBUG_BUILD && logger.logger.log('[Tracing] Started span is an idle span');\n\n  return span;\n}\n\nexports.TRACING_DEFAULTS = TRACING_DEFAULTS;\nexports.startIdleSpan = startIdleSpan;\n//# sourceMappingURL=idleSpan.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhY2luZy9pZGxlU3Bhbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxzQkFBc0IsbUJBQU8sQ0FBQyxxSEFBcUI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsaUhBQW1CO0FBQzlDLDJCQUEyQixtQkFBTyxDQUFDLCtIQUEwQjtBQUM3RCx3QkFBd0IsbUJBQU8sQ0FBQyxxSUFBNkI7QUFDN0Qsb0JBQW9CLG1CQUFPLENBQUMsNkhBQXlCO0FBQ3JELGtCQUFrQixtQkFBTyxDQUFDLHlIQUF1QjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsK0hBQTBCO0FBQ2pELGFBQWEsbUJBQU8sQ0FBQywySEFBd0I7QUFDN0MsK0JBQStCLG1CQUFPLENBQUMsOElBQTZCO0FBQ3BFLCtCQUErQixtQkFBTyxDQUFDLDhJQUE2QjtBQUNwRSxtQkFBbUIsbUJBQU8sQ0FBQyxzSEFBaUI7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLDRHQUFZOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxZQUFZLGtDQUFrQztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsWUFBWTs7QUFFMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMERBQTBEO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyw2RUFBNkU7O0FBRTNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixrRUFBa0U7QUFDekY7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcdHJhY2luZ1xcaWRsZVNwYW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IHNlbWFudGljQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4uL3NlbWFudGljQXR0cmlidXRlcy5qcycpO1xuY29uc3QgaGFzU3BhbnNFbmFibGVkID0gcmVxdWlyZSgnLi4vdXRpbHMvaGFzU3BhbnNFbmFibGVkLmpzJyk7XG5jb25zdCBzcGFuT25TY29wZSA9IHJlcXVpcmUoJy4uL3V0aWxzL3NwYW5PblNjb3BlLmpzJyk7XG5jb25zdCBzcGFuVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9zcGFuVXRpbHMuanMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2xvZ2dlci5qcycpO1xuY29uc3QgdGltZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3RpbWUuanMnKTtcbmNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSByZXF1aXJlKCcuL2R5bmFtaWNTYW1wbGluZ0NvbnRleHQuanMnKTtcbmNvbnN0IHNlbnRyeU5vblJlY29yZGluZ1NwYW4gPSByZXF1aXJlKCcuL3NlbnRyeU5vblJlY29yZGluZ1NwYW4uanMnKTtcbmNvbnN0IHNwYW5zdGF0dXMgPSByZXF1aXJlKCcuL3NwYW5zdGF0dXMuanMnKTtcbmNvbnN0IHRyYWNlID0gcmVxdWlyZSgnLi90cmFjZS5qcycpO1xuXG5jb25zdCBUUkFDSU5HX0RFRkFVTFRTID0ge1xuICBpZGxlVGltZW91dDogMTAwMCxcbiAgZmluYWxUaW1lb3V0OiAzMDAwMCxcbiAgY2hpbGRTcGFuVGltZW91dDogMTUwMDAsXG59O1xuXG5jb25zdCBGSU5JU0hfUkVBU09OX0hFQVJUQkVBVF9GQUlMRUQgPSAnaGVhcnRiZWF0RmFpbGVkJztcbmNvbnN0IEZJTklTSF9SRUFTT05fSURMRV9USU1FT1VUID0gJ2lkbGVUaW1lb3V0JztcbmNvbnN0IEZJTklTSF9SRUFTT05fRklOQUxfVElNRU9VVCA9ICdmaW5hbFRpbWVvdXQnO1xuY29uc3QgRklOSVNIX1JFQVNPTl9FWFRFUk5BTF9GSU5JU0ggPSAnZXh0ZXJuYWxGaW5pc2gnO1xuXG4vKipcbiAqIEFuIGlkbGUgc3BhbiBpcyBhIHNwYW4gdGhhdCBhdXRvbWF0aWNhbGx5IGZpbmlzaGVzLiBJdCBkb2VzIHRoaXMgYnkgdHJhY2tpbmcgY2hpbGQgc3BhbnMgYXMgYWN0aXZpdGllcy5cbiAqIEFuIGlkbGUgc3BhbiBpcyBhbHdheXMgdGhlIGFjdGl2ZSBzcGFuLlxuICovXG5mdW5jdGlvbiBzdGFydElkbGVTcGFuKHN0YXJ0U3Bhbk9wdGlvbnMsIG9wdGlvbnMgPSB7fSkge1xuICAvLyBBY3Rpdml0aWVzIHN0b3JlIGEgbGlzdCBvZiBhY3RpdmUgc3BhbnNcbiAgY29uc3QgYWN0aXZpdGllcyA9IG5ldyBNYXAoKTtcblxuICAvLyBXZSBzaG91bGQgbm90IHVzZSBoZWFydGJlYXQgaWYgd2UgZmluaXNoZWQgYSBzcGFuXG4gIGxldCBfZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUaW1lciB0aGF0IHRyYWNrcyBpZGxlVGltZW91dFxuICBsZXQgX2lkbGVUaW1lb3V0SUQ7XG5cbiAgLy8gVGhlIHJlYXNvbiB3aHkgdGhlIHNwYW4gd2FzIGZpbmlzaGVkXG4gIGxldCBfZmluaXNoUmVhc29uID0gRklOSVNIX1JFQVNPTl9FWFRFUk5BTF9GSU5JU0g7XG5cbiAgbGV0IF9hdXRvRmluaXNoQWxsb3dlZCA9ICFvcHRpb25zLmRpc2FibGVBdXRvRmluaXNoO1xuXG4gIGNvbnN0IF9jbGVhbnVwSG9va3MgPSBbXTtcblxuICBjb25zdCB7XG4gICAgaWRsZVRpbWVvdXQgPSBUUkFDSU5HX0RFRkFVTFRTLmlkbGVUaW1lb3V0LFxuICAgIGZpbmFsVGltZW91dCA9IFRSQUNJTkdfREVGQVVMVFMuZmluYWxUaW1lb3V0LFxuICAgIGNoaWxkU3BhblRpbWVvdXQgPSBUUkFDSU5HX0RFRkFVTFRTLmNoaWxkU3BhblRpbWVvdXQsXG4gICAgYmVmb3JlU3BhbkVuZCxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgY2xpZW50ID0gY3VycmVudFNjb3Blcy5nZXRDbGllbnQoKTtcblxuICBpZiAoIWNsaWVudCB8fCAhaGFzU3BhbnNFbmFibGVkLmhhc1NwYW5zRW5hYmxlZCgpKSB7XG4gICAgY29uc3Qgc3BhbiA9IG5ldyBzZW50cnlOb25SZWNvcmRpbmdTcGFuLlNlbnRyeU5vblJlY29yZGluZ1NwYW4oKTtcblxuICAgIGNvbnN0IGRzYyA9IHtcbiAgICAgIHNhbXBsZV9yYXRlOiAnMCcsXG4gICAgICBzYW1wbGVkOiAnZmFsc2UnLFxuICAgICAgLi4uZHluYW1pY1NhbXBsaW5nQ29udGV4dC5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3BhbiksXG4gICAgfSA7XG4gICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dC5mcmVlemVEc2NPblNwYW4oc3BhbiwgZHNjKTtcblxuICAgIHJldHVybiBzcGFuO1xuICB9XG5cbiAgY29uc3Qgc2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldEN1cnJlbnRTY29wZSgpO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZVNwYW4gPSBzcGFuVXRpbHMuZ2V0QWN0aXZlU3BhbigpO1xuICBjb25zdCBzcGFuID0gX3N0YXJ0SWRsZVNwYW4oc3RhcnRTcGFuT3B0aW9ucyk7XG5cbiAgLy8gV2UgcGF0Y2ggc3Bhbi5lbmQgdG8gZW5zdXJlIHdlIGNhbiBydW4gc29tZSB0aGluZ3MgYmVmb3JlIHRoZSBzcGFuIGlzIGVuZGVkXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgc3Bhbi5lbmQgPSBuZXcgUHJveHkoc3Bhbi5lbmQsIHtcbiAgICBhcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgIGlmIChiZWZvcmVTcGFuRW5kKSB7XG4gICAgICAgIGJlZm9yZVNwYW5FbmQoc3Bhbik7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBzcGFuIGlzIG5vbi1yZWNvcmRpbmcsIG5vdGhpbmcgbW9yZSB0byBkbyBoZXJlLi4uXG4gICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIGlmIHRyYWNpbmcgaXMgZW5hYmxlZCBidXQgdGhpcyBzcGVjaWZpYyBzcGFuIHdhcyBub3Qgc2FtcGxlZFxuICAgICAgaWYgKHRoaXNBcmcgaW5zdGFuY2VvZiBzZW50cnlOb25SZWNvcmRpbmdTcGFuLlNlbnRyeU5vblJlY29yZGluZ1NwYW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBKdXN0IGVuc3VyaW5nIHRoYXQgdGhpcyBrZWVwcyB3b3JraW5nLCBldmVuIGlmIHdlIGV2ZXIgaGF2ZSBtb3JlIGFyZ3VtZW50cyBoZXJlXG4gICAgICBjb25zdCBbZGVmaW5lZEVuZFRpbWVzdGFtcCwgLi4ucmVzdF0gPSBhcmdzO1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gZGVmaW5lZEVuZFRpbWVzdGFtcCB8fCB0aW1lLnRpbWVzdGFtcEluU2Vjb25kcygpO1xuICAgICAgY29uc3Qgc3BhbkVuZFRpbWVzdGFtcCA9IHNwYW5VdGlscy5zcGFuVGltZUlucHV0VG9TZWNvbmRzKHRpbWVzdGFtcCk7XG5cbiAgICAgIC8vIEVuc3VyZSB3ZSBlbmQgd2l0aCB0aGUgbGFzdCBzcGFuIHRpbWVzdGFtcCwgaWYgcG9zc2libGVcbiAgICAgIGNvbnN0IHNwYW5zID0gc3BhblV0aWxzLmdldFNwYW5EZXNjZW5kYW50cyhzcGFuKS5maWx0ZXIoY2hpbGQgPT4gY2hpbGQgIT09IHNwYW4pO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIG5vIHNwYW5zLCB3ZSBqdXN0IGVuZCwgbm90aGluZyBlbHNlIHRvIGRvIGhlcmVcbiAgICAgIGlmICghc3BhbnMubGVuZ3RoKSB7XG4gICAgICAgIG9uSWRsZVNwYW5FbmRlZChzcGFuRW5kVGltZXN0YW1wKTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBbc3BhbkVuZFRpbWVzdGFtcCwgLi4ucmVzdF0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGlsZEVuZFRpbWVzdGFtcHMgPSBzcGFuc1xuICAgICAgICAubWFwKHNwYW4gPT4gc3BhblV0aWxzLnNwYW5Ub0pTT04oc3BhbikudGltZXN0YW1wKVxuICAgICAgICAuZmlsdGVyKHRpbWVzdGFtcCA9PiAhIXRpbWVzdGFtcCkgO1xuICAgICAgY29uc3QgbGF0ZXN0U3BhbkVuZFRpbWVzdGFtcCA9IGNoaWxkRW5kVGltZXN0YW1wcy5sZW5ndGggPyBNYXRoLm1heCguLi5jaGlsZEVuZFRpbWVzdGFtcHMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAvLyBJbiByZWFsaXR5IHRoaXMgc2hvdWxkIGFsd2F5cyBleGlzdCBoZXJlLCBidXQgdHlwZS13aXNlIGl0IG1heSBiZSB1bmRlZmluZWQuLi5cbiAgICAgIGNvbnN0IHNwYW5TdGFydFRpbWVzdGFtcCA9IHNwYW5VdGlscy5zcGFuVG9KU09OKHNwYW4pLnN0YXJ0X3RpbWVzdGFtcDtcblxuICAgICAgLy8gVGhlIGZpbmFsIGVuZFRpbWVzdGFtcCBzaG91bGQ6XG4gICAgICAvLyAqIE5ldmVyIGJlIGJlZm9yZSB0aGUgc3BhbiBzdGFydCB0aW1lc3RhbXBcbiAgICAgIC8vICogQmUgdGhlIGxhdGVzdFNwYW5FbmRUaW1lc3RhbXAsIGlmIHRoZXJlIGlzIG9uZSwgYW5kIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcGFzc2VkIHNwYW4gZW5kIHRpbWVzdGFtcFxuICAgICAgLy8gKiBPdGhlcndpc2UgYmUgdGhlIHBhc3NlZCBlbmQgdGltZXN0YW1wXG4gICAgICAvLyBGaW5hbCB0aW1lc3RhbXAgY2FuIG5ldmVyIGJlIGFmdGVyIGZpbmFsVGltZW91dFxuICAgICAgY29uc3QgZW5kVGltZXN0YW1wID0gTWF0aC5taW4oXG4gICAgICAgIHNwYW5TdGFydFRpbWVzdGFtcCA/IHNwYW5TdGFydFRpbWVzdGFtcCArIGZpbmFsVGltZW91dCAvIDEwMDAgOiBJbmZpbml0eSxcbiAgICAgICAgTWF0aC5tYXgoc3BhblN0YXJ0VGltZXN0YW1wIHx8IC1JbmZpbml0eSwgTWF0aC5taW4oc3BhbkVuZFRpbWVzdGFtcCwgbGF0ZXN0U3BhbkVuZFRpbWVzdGFtcCB8fCBJbmZpbml0eSkpLFxuICAgICAgKTtcblxuICAgICAgb25JZGxlU3BhbkVuZGVkKGVuZFRpbWVzdGFtcCk7XG4gICAgICByZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIFtlbmRUaW1lc3RhbXAsIC4uLnJlc3RdKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogQ2FuY2VscyB0aGUgZXhpc3RpbmcgaWRsZSB0aW1lb3V0LCBpZiB0aGVyZSBpcyBvbmUuXG4gICAqL1xuICBmdW5jdGlvbiBfY2FuY2VsSWRsZVRpbWVvdXQoKSB7XG4gICAgaWYgKF9pZGxlVGltZW91dElEKSB7XG4gICAgICBjbGVhclRpbWVvdXQoX2lkbGVUaW1lb3V0SUQpO1xuICAgICAgX2lkbGVUaW1lb3V0SUQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RhcnRzIGlkbGUgdGltZW91dCwgaWYgdGhlcmUgaXMgbm8gcnVubmluZyBpZGxlIHRpbWVvdXQgaXQgd2lsbCBzdGFydCBvbmUuXG4gICAqL1xuICBmdW5jdGlvbiBfcmVzdGFydElkbGVUaW1lb3V0KGVuZFRpbWVzdGFtcCkge1xuICAgIF9jYW5jZWxJZGxlVGltZW91dCgpO1xuICAgIF9pZGxlVGltZW91dElEID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIV9maW5pc2hlZCAmJiBhY3Rpdml0aWVzLnNpemUgPT09IDAgJiYgX2F1dG9GaW5pc2hBbGxvd2VkKSB7XG4gICAgICAgIF9maW5pc2hSZWFzb24gPSBGSU5JU0hfUkVBU09OX0lETEVfVElNRU9VVDtcbiAgICAgICAgc3Bhbi5lbmQoZW5kVGltZXN0YW1wKTtcbiAgICAgIH1cbiAgICB9LCBpZGxlVGltZW91dCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzdGFydHMgY2hpbGQgc3BhbiB0aW1lb3V0LCBpZiB0aGVyZSBpcyBub25lIHJ1bm5pbmcgaXQgd2lsbCBzdGFydCBvbmUuXG4gICAqL1xuICBmdW5jdGlvbiBfcmVzdGFydENoaWxkU3BhblRpbWVvdXQoZW5kVGltZXN0YW1wKSB7XG4gICAgX2lkbGVUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghX2ZpbmlzaGVkICYmIF9hdXRvRmluaXNoQWxsb3dlZCkge1xuICAgICAgICBfZmluaXNoUmVhc29uID0gRklOSVNIX1JFQVNPTl9IRUFSVEJFQVRfRkFJTEVEO1xuICAgICAgICBzcGFuLmVuZChlbmRUaW1lc3RhbXApO1xuICAgICAgfVxuICAgIH0sIGNoaWxkU3BhblRpbWVvdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRyYWNraW5nIGEgc3BlY2lmaWMgYWN0aXZpdHkuXG4gICAqIEBwYXJhbSBzcGFuSWQgVGhlIHNwYW4gaWQgdGhhdCByZXByZXNlbnRzIHRoZSBhY3Rpdml0eVxuICAgKi9cbiAgZnVuY3Rpb24gX3B1c2hBY3Rpdml0eShzcGFuSWQpIHtcbiAgICBfY2FuY2VsSWRsZVRpbWVvdXQoKTtcbiAgICBhY3Rpdml0aWVzLnNldChzcGFuSWQsIHRydWUpO1xuXG4gICAgY29uc3QgZW5kVGltZXN0YW1wID0gdGltZS50aW1lc3RhbXBJblNlY29uZHMoKTtcbiAgICAvLyBXZSBuZWVkIHRvIGFkZCB0aGUgdGltZW91dCBoZXJlIHRvIGhhdmUgdGhlIHJlYWwgZW5kdGltZXN0YW1wIG9mIHRoZSBpZGxlIHNwYW5cbiAgICAvLyBSZW1lbWJlciB0aW1lc3RhbXBJblNlY29uZHMgaXMgaW4gc2Vjb25kcywgdGltZW91dCBpcyBpbiBtc1xuICAgIF9yZXN0YXJ0Q2hpbGRTcGFuVGltZW91dChlbmRUaW1lc3RhbXAgKyBjaGlsZFNwYW5UaW1lb3V0IC8gMTAwMCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGFjdGl2aXR5IGZyb20gdXNhZ2VcbiAgICogQHBhcmFtIHNwYW5JZCBUaGUgc3BhbiBpZCB0aGF0IHJlcHJlc2VudHMgdGhlIGFjdGl2aXR5XG4gICAqL1xuICBmdW5jdGlvbiBfcG9wQWN0aXZpdHkoc3BhbklkKSB7XG4gICAgaWYgKGFjdGl2aXRpZXMuaGFzKHNwYW5JZCkpIHtcbiAgICAgIGFjdGl2aXRpZXMuZGVsZXRlKHNwYW5JZCk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2aXRpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgY29uc3QgZW5kVGltZXN0YW1wID0gdGltZS50aW1lc3RhbXBJblNlY29uZHMoKTtcbiAgICAgIC8vIFdlIG5lZWQgdG8gYWRkIHRoZSB0aW1lb3V0IGhlcmUgdG8gaGF2ZSB0aGUgcmVhbCBlbmR0aW1lc3RhbXAgb2YgdGhlIGlkbGUgc3BhblxuICAgICAgLy8gUmVtZW1iZXIgdGltZXN0YW1wSW5TZWNvbmRzIGlzIGluIHNlY29uZHMsIHRpbWVvdXQgaXMgaW4gbXNcbiAgICAgIF9yZXN0YXJ0SWRsZVRpbWVvdXQoZW5kVGltZXN0YW1wICsgaWRsZVRpbWVvdXQgLyAxMDAwKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbklkbGVTcGFuRW5kZWQoZW5kVGltZXN0YW1wKSB7XG4gICAgX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICBhY3Rpdml0aWVzLmNsZWFyKCk7XG5cbiAgICBfY2xlYW51cEhvb2tzLmZvckVhY2goY2xlYW51cCA9PiBjbGVhbnVwKCkpO1xuXG4gICAgc3Bhbk9uU2NvcGUuX3NldFNwYW5Gb3JTY29wZShzY29wZSwgcHJldmlvdXNBY3RpdmVTcGFuKTtcblxuICAgIGNvbnN0IHNwYW5KU09OID0gc3BhblV0aWxzLnNwYW5Ub0pTT04oc3Bhbik7XG5cbiAgICBjb25zdCB7IHN0YXJ0X3RpbWVzdGFtcDogc3RhcnRUaW1lc3RhbXAgfSA9IHNwYW5KU09OO1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IHRvIG1ha2UgVFMgaGFwcHkuLi5cbiAgICBpZiAoIXN0YXJ0VGltZXN0YW1wKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHNwYW5KU09OLmRhdGE7XG4gICAgaWYgKCFhdHRyaWJ1dGVzW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0lETEVfU1BBTl9GSU5JU0hfUkVBU09OXSkge1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfSURMRV9TUEFOX0ZJTklTSF9SRUFTT04sIF9maW5pc2hSZWFzb24pO1xuICAgIH1cblxuICAgIGxvZ2dlci5sb2dnZXIubG9nKGBbVHJhY2luZ10gSWRsZSBzcGFuIFwiJHtzcGFuSlNPTi5vcH1cIiBmaW5pc2hlZGApO1xuXG4gICAgY29uc3QgY2hpbGRTcGFucyA9IHNwYW5VdGlscy5nZXRTcGFuRGVzY2VuZGFudHMoc3BhbikuZmlsdGVyKGNoaWxkID0+IGNoaWxkICE9PSBzcGFuKTtcblxuICAgIGxldCBkaXNjYXJkZWRTcGFucyA9IDA7XG4gICAgY2hpbGRTcGFucy5mb3JFYWNoKGNoaWxkU3BhbiA9PiB7XG4gICAgICAvLyBXZSBjYW5jZWwgYWxsIHBlbmRpbmcgc3BhbnMgd2l0aCBzdGF0dXMgXCJjYW5jZWxsZWRcIiB0byBpbmRpY2F0ZSB0aGUgaWRsZSBzcGFuIHdhcyBmaW5pc2hlZCBlYXJseVxuICAgICAgaWYgKGNoaWxkU3Bhbi5pc1JlY29yZGluZygpKSB7XG4gICAgICAgIGNoaWxkU3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBzcGFuc3RhdHVzLlNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnY2FuY2VsbGVkJyB9KTtcbiAgICAgICAgY2hpbGRTcGFuLmVuZChlbmRUaW1lc3RhbXApO1xuICAgICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmXG4gICAgICAgICAgbG9nZ2VyLmxvZ2dlci5sb2coJ1tUcmFjaW5nXSBDYW5jZWxsaW5nIHNwYW4gc2luY2Ugc3BhbiBlbmRlZCBlYXJseScsIEpTT04uc3RyaW5naWZ5KGNoaWxkU3BhbiwgdW5kZWZpbmVkLCAyKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkU3BhbkpTT04gPSBzcGFuVXRpbHMuc3BhblRvSlNPTihjaGlsZFNwYW4pO1xuICAgICAgY29uc3QgeyB0aW1lc3RhbXA6IGNoaWxkRW5kVGltZXN0YW1wID0gMCwgc3RhcnRfdGltZXN0YW1wOiBjaGlsZFN0YXJ0VGltZXN0YW1wID0gMCB9ID0gY2hpbGRTcGFuSlNPTjtcblxuICAgICAgY29uc3Qgc3BhblN0YXJ0ZWRCZWZvcmVJZGxlU3BhbkVuZCA9IGNoaWxkU3RhcnRUaW1lc3RhbXAgPD0gZW5kVGltZXN0YW1wO1xuXG4gICAgICAvLyBBZGQgYSBkZWx0YSB3aXRoIGlkbGUgdGltZW91dCBzbyB0aGF0IHdlIHByZXZlbnQgZmFsc2UgcG9zaXRpdmVzXG4gICAgICBjb25zdCB0aW1lb3V0V2l0aE1hcmdpbk9mRXJyb3IgPSAoZmluYWxUaW1lb3V0ICsgaWRsZVRpbWVvdXQpIC8gMTAwMDtcbiAgICAgIGNvbnN0IHNwYW5FbmRlZEJlZm9yZUZpbmFsVGltZW91dCA9IGNoaWxkRW5kVGltZXN0YW1wIC0gY2hpbGRTdGFydFRpbWVzdGFtcCA8PSB0aW1lb3V0V2l0aE1hcmdpbk9mRXJyb3I7XG5cbiAgICAgIGlmIChkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkU3BhbiA9IEpTT04uc3RyaW5naWZ5KGNoaWxkU3BhbiwgdW5kZWZpbmVkLCAyKTtcbiAgICAgICAgaWYgKCFzcGFuU3RhcnRlZEJlZm9yZUlkbGVTcGFuRW5kKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZ2dlci5sb2coJ1tUcmFjaW5nXSBEaXNjYXJkaW5nIHNwYW4gc2luY2UgaXQgaGFwcGVuZWQgYWZ0ZXIgaWRsZSBzcGFuIHdhcyBmaW5pc2hlZCcsIHN0cmluZ2lmaWVkU3Bhbik7XG4gICAgICAgIH0gZWxzZSBpZiAoIXNwYW5FbmRlZEJlZm9yZUZpbmFsVGltZW91dCkge1xuICAgICAgICAgIGxvZ2dlci5sb2dnZXIubG9nKCdbVHJhY2luZ10gRGlzY2FyZGluZyBzcGFuIHNpbmNlIGl0IGZpbmlzaGVkIGFmdGVyIGlkbGUgc3BhbiBmaW5hbCB0aW1lb3V0Jywgc3RyaW5naWZpZWRTcGFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXNwYW5FbmRlZEJlZm9yZUZpbmFsVGltZW91dCB8fCAhc3BhblN0YXJ0ZWRCZWZvcmVJZGxlU3BhbkVuZCkge1xuICAgICAgICBzcGFuVXRpbHMucmVtb3ZlQ2hpbGRTcGFuRnJvbVNwYW4oc3BhbiwgY2hpbGRTcGFuKTtcbiAgICAgICAgZGlzY2FyZGVkU3BhbnMrKztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChkaXNjYXJkZWRTcGFucyA+IDApIHtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlKCdzZW50cnkuaWRsZV9zcGFuX2Rpc2NhcmRlZF9zcGFucycsIGRpc2NhcmRlZFNwYW5zKTtcbiAgICB9XG4gIH1cblxuICBfY2xlYW51cEhvb2tzLnB1c2goXG4gICAgY2xpZW50Lm9uKCdzcGFuU3RhcnQnLCBzdGFydGVkU3BhbiA9PiB7XG4gICAgICAvLyBJZiB3ZSBhbHJlYWR5IGZpbmlzaGVkIHRoZSBpZGxlIHNwYW4sXG4gICAgICAvLyBvciBpZiB0aGlzIGlzIHRoZSBpZGxlIHNwYW4gaXRzZWxmIGJlaW5nIHN0YXJ0ZWQsXG4gICAgICAvLyBvciBpZiB0aGUgc3RhcnRlZCBzcGFuIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLFxuICAgICAgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpdCBmb3IgYWN0aXZpdHlcbiAgICAgIGlmIChfZmluaXNoZWQgfHwgc3RhcnRlZFNwYW4gPT09IHNwYW4gfHwgISFzcGFuVXRpbHMuc3BhblRvSlNPTihzdGFydGVkU3BhbikudGltZXN0YW1wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWxsU3BhbnMgPSBzcGFuVXRpbHMuZ2V0U3BhbkRlc2NlbmRhbnRzKHNwYW4pO1xuXG4gICAgICAvLyBJZiB0aGUgc3BhbiB0aGF0IHdhcyBqdXN0IHN0YXJ0ZWQgaXMgYSBjaGlsZCBvZiB0aGUgaWRsZSBzcGFuLCB3ZSBzaG91bGQgdHJhY2sgaXRcbiAgICAgIGlmIChhbGxTcGFucy5pbmNsdWRlcyhzdGFydGVkU3BhbikpIHtcbiAgICAgICAgX3B1c2hBY3Rpdml0eShzdGFydGVkU3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZCk7XG4gICAgICB9XG4gICAgfSksXG4gICk7XG5cbiAgX2NsZWFudXBIb29rcy5wdXNoKFxuICAgIGNsaWVudC5vbignc3BhbkVuZCcsIGVuZGVkU3BhbiA9PiB7XG4gICAgICBpZiAoX2ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3BvcEFjdGl2aXR5KGVuZGVkU3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZCk7XG4gICAgfSksXG4gICk7XG5cbiAgX2NsZWFudXBIb29rcy5wdXNoKFxuICAgIGNsaWVudC5vbignaWRsZVNwYW5FbmFibGVBdXRvRmluaXNoJywgc3BhblRvQWxsb3dBdXRvRmluaXNoID0+IHtcbiAgICAgIGlmIChzcGFuVG9BbGxvd0F1dG9GaW5pc2ggPT09IHNwYW4pIHtcbiAgICAgICAgX2F1dG9GaW5pc2hBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgX3Jlc3RhcnRJZGxlVGltZW91dCgpO1xuXG4gICAgICAgIGlmIChhY3Rpdml0aWVzLnNpemUpIHtcbiAgICAgICAgICBfcmVzdGFydENoaWxkU3BhblRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICApO1xuXG4gIC8vIFdlIG9ubHkgc3RhcnQgdGhlIGluaXRpYWwgaWRsZSB0aW1lb3V0IGlmIHdlIGFyZSBub3QgZGVsYXlpbmcgdGhlIGF1dG8gZmluaXNoXG4gIGlmICghb3B0aW9ucy5kaXNhYmxlQXV0b0ZpbmlzaCkge1xuICAgIF9yZXN0YXJ0SWRsZVRpbWVvdXQoKTtcbiAgfVxuXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmICghX2ZpbmlzaGVkKSB7XG4gICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IHNwYW5zdGF0dXMuU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICdkZWFkbGluZV9leGNlZWRlZCcgfSk7XG4gICAgICBfZmluaXNoUmVhc29uID0gRklOSVNIX1JFQVNPTl9GSU5BTF9USU1FT1VUO1xuICAgICAgc3Bhbi5lbmQoKTtcbiAgICB9XG4gIH0sIGZpbmFsVGltZW91dCk7XG5cbiAgcmV0dXJuIHNwYW47XG59XG5cbmZ1bmN0aW9uIF9zdGFydElkbGVTcGFuKG9wdGlvbnMpIHtcbiAgY29uc3Qgc3BhbiA9IHRyYWNlLnN0YXJ0SW5hY3RpdmVTcGFuKG9wdGlvbnMpO1xuXG4gIHNwYW5PblNjb3BlLl9zZXRTcGFuRm9yU2NvcGUoY3VycmVudFNjb3Blcy5nZXRDdXJyZW50U2NvcGUoKSwgc3Bhbik7XG5cbiAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLmxvZygnW1RyYWNpbmddIFN0YXJ0ZWQgc3BhbiBpcyBhbiBpZGxlIHNwYW4nKTtcblxuICByZXR1cm4gc3Bhbjtcbn1cblxuZXhwb3J0cy5UUkFDSU5HX0RFRkFVTFRTID0gVFJBQ0lOR19ERUZBVUxUUztcbmV4cG9ydHMuc3RhcnRJZGxlU3BhbiA9IHN0YXJ0SWRsZVNwYW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZGxlU3Bhbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/idleSpan.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/logSpans.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanUtils.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\n\n/**\n * Print a log message for a started span.\n */\nfunction logSpanStart(span) {\n  if (!debugBuild.DEBUG_BUILD) return;\n\n  const { description = '< unknown name >', op = '< unknown op >', parent_span_id: parentSpanId } = spanUtils.spanToJSON(span);\n  const { spanId } = span.spanContext();\n\n  const sampled = spanUtils.spanIsSampled(span);\n  const rootSpan = spanUtils.getRootSpan(span);\n  const isRootSpan = rootSpan === span;\n\n  const header = `[Tracing] Starting ${sampled ? 'sampled' : 'unsampled'} ${isRootSpan ? 'root ' : ''}span`;\n\n  const infoParts = [`op: ${op}`, `name: ${description}`, `ID: ${spanId}`];\n\n  if (parentSpanId) {\n    infoParts.push(`parent ID: ${parentSpanId}`);\n  }\n\n  if (!isRootSpan) {\n    const { op, description } = spanUtils.spanToJSON(rootSpan);\n    infoParts.push(`root ID: ${rootSpan.spanContext().spanId}`);\n    if (op) {\n      infoParts.push(`root op: ${op}`);\n    }\n    if (description) {\n      infoParts.push(`root description: ${description}`);\n    }\n  }\n\n  logger.logger.log(`${header}\n  ${infoParts.join('\\n  ')}`);\n}\n\n/**\n * Print a log message for an ended span.\n */\nfunction logSpanEnd(span) {\n  if (!debugBuild.DEBUG_BUILD) return;\n\n  const { description = '< unknown name >', op = '< unknown op >' } = spanUtils.spanToJSON(span);\n  const { spanId } = span.spanContext();\n  const rootSpan = spanUtils.getRootSpan(span);\n  const isRootSpan = rootSpan === span;\n\n  const msg = `[Tracing] Finishing \"${op}\" ${isRootSpan ? 'root ' : ''}span \"${description}\" with ID ${spanId}`;\n  logger.logger.log(msg);\n}\n\nexports.logSpanEnd = logSpanEnd;\nexports.logSpanStart = logSpanStart;\n//# sourceMappingURL=logSpans.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhY2luZy9sb2dTcGFucy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxtQkFBbUIsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDOUMsa0JBQWtCLG1CQUFPLENBQUMseUhBQXVCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQywrSEFBMEI7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSx3RkFBd0Y7QUFDbEcsVUFBVSxTQUFTOztBQUVuQjtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLG1DQUFtQyxFQUFFLDBCQUEwQjs7QUFFdEcsNEJBQTRCLEdBQUcsWUFBWSxZQUFZLFVBQVUsT0FBTzs7QUFFeEU7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5Qzs7QUFFQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLCtCQUErQiw4QkFBOEI7QUFDN0Q7QUFDQSxpQ0FBaUMsR0FBRztBQUNwQztBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsSUFBSSx1QkFBdUI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLDBEQUEwRDtBQUNwRSxVQUFVLFNBQVM7QUFDbkI7QUFDQTs7QUFFQSxzQ0FBc0MsR0FBRyxJQUFJLDBCQUEwQixRQUFRLFlBQVksWUFBWSxPQUFPO0FBQzlHO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXHRyYWNpbmdcXGxvZ1NwYW5zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IHNwYW5VdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3NwYW5VdGlscy5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5cbi8qKlxuICogUHJpbnQgYSBsb2cgbWVzc2FnZSBmb3IgYSBzdGFydGVkIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGxvZ1NwYW5TdGFydChzcGFuKSB7XG4gIGlmICghZGVidWdCdWlsZC5ERUJVR19CVUlMRCkgcmV0dXJuO1xuXG4gIGNvbnN0IHsgZGVzY3JpcHRpb24gPSAnPCB1bmtub3duIG5hbWUgPicsIG9wID0gJzwgdW5rbm93biBvcCA+JywgcGFyZW50X3NwYW5faWQ6IHBhcmVudFNwYW5JZCB9ID0gc3BhblV0aWxzLnNwYW5Ub0pTT04oc3Bhbik7XG4gIGNvbnN0IHsgc3BhbklkIH0gPSBzcGFuLnNwYW5Db250ZXh0KCk7XG5cbiAgY29uc3Qgc2FtcGxlZCA9IHNwYW5VdGlscy5zcGFuSXNTYW1wbGVkKHNwYW4pO1xuICBjb25zdCByb290U3BhbiA9IHNwYW5VdGlscy5nZXRSb290U3BhbihzcGFuKTtcbiAgY29uc3QgaXNSb290U3BhbiA9IHJvb3RTcGFuID09PSBzcGFuO1xuXG4gIGNvbnN0IGhlYWRlciA9IGBbVHJhY2luZ10gU3RhcnRpbmcgJHtzYW1wbGVkID8gJ3NhbXBsZWQnIDogJ3Vuc2FtcGxlZCd9ICR7aXNSb290U3BhbiA/ICdyb290ICcgOiAnJ31zcGFuYDtcblxuICBjb25zdCBpbmZvUGFydHMgPSBbYG9wOiAke29wfWAsIGBuYW1lOiAke2Rlc2NyaXB0aW9ufWAsIGBJRDogJHtzcGFuSWR9YF07XG5cbiAgaWYgKHBhcmVudFNwYW5JZCkge1xuICAgIGluZm9QYXJ0cy5wdXNoKGBwYXJlbnQgSUQ6ICR7cGFyZW50U3BhbklkfWApO1xuICB9XG5cbiAgaWYgKCFpc1Jvb3RTcGFuKSB7XG4gICAgY29uc3QgeyBvcCwgZGVzY3JpcHRpb24gfSA9IHNwYW5VdGlscy5zcGFuVG9KU09OKHJvb3RTcGFuKTtcbiAgICBpbmZvUGFydHMucHVzaChgcm9vdCBJRDogJHtyb290U3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZH1gKTtcbiAgICBpZiAob3ApIHtcbiAgICAgIGluZm9QYXJ0cy5wdXNoKGByb290IG9wOiAke29wfWApO1xuICAgIH1cbiAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgIGluZm9QYXJ0cy5wdXNoKGByb290IGRlc2NyaXB0aW9uOiAke2Rlc2NyaXB0aW9ufWApO1xuICAgIH1cbiAgfVxuXG4gIGxvZ2dlci5sb2dnZXIubG9nKGAke2hlYWRlcn1cbiAgJHtpbmZvUGFydHMuam9pbignXFxuICAnKX1gKTtcbn1cblxuLyoqXG4gKiBQcmludCBhIGxvZyBtZXNzYWdlIGZvciBhbiBlbmRlZCBzcGFuLlxuICovXG5mdW5jdGlvbiBsb2dTcGFuRW5kKHNwYW4pIHtcbiAgaWYgKCFkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEKSByZXR1cm47XG5cbiAgY29uc3QgeyBkZXNjcmlwdGlvbiA9ICc8IHVua25vd24gbmFtZSA+Jywgb3AgPSAnPCB1bmtub3duIG9wID4nIH0gPSBzcGFuVXRpbHMuc3BhblRvSlNPTihzcGFuKTtcbiAgY29uc3QgeyBzcGFuSWQgfSA9IHNwYW4uc3BhbkNvbnRleHQoKTtcbiAgY29uc3Qgcm9vdFNwYW4gPSBzcGFuVXRpbHMuZ2V0Um9vdFNwYW4oc3Bhbik7XG4gIGNvbnN0IGlzUm9vdFNwYW4gPSByb290U3BhbiA9PT0gc3BhbjtcblxuICBjb25zdCBtc2cgPSBgW1RyYWNpbmddIEZpbmlzaGluZyBcIiR7b3B9XCIgJHtpc1Jvb3RTcGFuID8gJ3Jvb3QgJyA6ICcnfXNwYW4gXCIke2Rlc2NyaXB0aW9ufVwiIHdpdGggSUQgJHtzcGFuSWR9YDtcbiAgbG9nZ2VyLmxvZ2dlci5sb2cobXNnKTtcbn1cblxuZXhwb3J0cy5sb2dTcGFuRW5kID0gbG9nU3BhbkVuZDtcbmV4cG9ydHMubG9nU3BhblN0YXJ0ID0gbG9nU3BhblN0YXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nU3BhbnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/logSpans.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/measurement.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/semanticAttributes.js");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanUtils.js");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js");\n\n/**\n * Adds a measurement to the active transaction on the current global scope. You can optionally pass in a different span\n * as the 4th parameter.\n */\nfunction setMeasurement(name, value, unit, activeSpan = spanUtils.getActiveSpan()) {\n  const rootSpan = activeSpan && spanUtils.getRootSpan(activeSpan);\n\n  if (rootSpan) {\n    debugBuild.DEBUG_BUILD && logger.logger.log(`[Measurement] Setting measurement on root span: ${name} = ${value} ${unit}`);\n    rootSpan.addEvent(name, {\n      [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: value,\n      [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: unit ,\n    });\n  }\n}\n\n/**\n * Convert timed events to measurements.\n */\nfunction timedEventsToMeasurements(events) {\n  if (!events || events.length === 0) {\n    return undefined;\n  }\n\n  const measurements = {};\n  events.forEach(event => {\n    const attributes = event.attributes || {};\n    const unit = attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT] ;\n    const value = attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE] ;\n\n    if (typeof unit === \'string\' && typeof value === \'number\') {\n      measurements[event.name] = { value, unit };\n    }\n  });\n\n  return measurements;\n}\n\nexports.setMeasurement = setMeasurement;\nexports.timedEventsToMeasurements = timedEventsToMeasurements;\n//# sourceMappingURL=measurement.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhY2luZy9tZWFzdXJlbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxtQkFBbUIsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDOUMsMkJBQTJCLG1CQUFPLENBQUMsK0hBQTBCO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLHlIQUF1QjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsK0hBQTBCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtR0FBbUcsTUFBTSxJQUFJLE9BQU8sRUFBRSxLQUFLO0FBQzNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLGlDQUFpQztBQUNqQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXHRyYWNpbmdcXG1lYXN1cmVtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IHNlbWFudGljQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4uL3NlbWFudGljQXR0cmlidXRlcy5qcycpO1xuY29uc3Qgc3BhblV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvc3BhblV0aWxzLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcblxuLyoqXG4gKiBBZGRzIGEgbWVhc3VyZW1lbnQgdG8gdGhlIGFjdGl2ZSB0cmFuc2FjdGlvbiBvbiB0aGUgY3VycmVudCBnbG9iYWwgc2NvcGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGluIGEgZGlmZmVyZW50IHNwYW5cbiAqIGFzIHRoZSA0dGggcGFyYW1ldGVyLlxuICovXG5mdW5jdGlvbiBzZXRNZWFzdXJlbWVudChuYW1lLCB2YWx1ZSwgdW5pdCwgYWN0aXZlU3BhbiA9IHNwYW5VdGlscy5nZXRBY3RpdmVTcGFuKCkpIHtcbiAgY29uc3Qgcm9vdFNwYW4gPSBhY3RpdmVTcGFuICYmIHNwYW5VdGlscy5nZXRSb290U3BhbihhY3RpdmVTcGFuKTtcblxuICBpZiAocm9vdFNwYW4pIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIubG9nKGBbTWVhc3VyZW1lbnRdIFNldHRpbmcgbWVhc3VyZW1lbnQgb24gcm9vdCBzcGFuOiAke25hbWV9ID0gJHt2YWx1ZX0gJHt1bml0fWApO1xuICAgIHJvb3RTcGFuLmFkZEV2ZW50KG5hbWUsIHtcbiAgICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9NRUFTVVJFTUVOVF9WQUxVRV06IHZhbHVlLFxuICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX01FQVNVUkVNRU5UX1VOSVRdOiB1bml0ICxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGltZWQgZXZlbnRzIHRvIG1lYXN1cmVtZW50cy5cbiAqL1xuZnVuY3Rpb24gdGltZWRFdmVudHNUb01lYXN1cmVtZW50cyhldmVudHMpIHtcbiAgaWYgKCFldmVudHMgfHwgZXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBtZWFzdXJlbWVudHMgPSB7fTtcbiAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4ge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBldmVudC5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGNvbnN0IHVuaXQgPSBhdHRyaWJ1dGVzW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX01FQVNVUkVNRU5UX1VOSVRdIDtcbiAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfTUVBU1VSRU1FTlRfVkFMVUVdIDtcblxuICAgIGlmICh0eXBlb2YgdW5pdCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgbWVhc3VyZW1lbnRzW2V2ZW50Lm5hbWVdID0geyB2YWx1ZSwgdW5pdCB9O1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG1lYXN1cmVtZW50cztcbn1cblxuZXhwb3J0cy5zZXRNZWFzdXJlbWVudCA9IHNldE1lYXN1cmVtZW50O1xuZXhwb3J0cy50aW1lZEV2ZW50c1RvTWVhc3VyZW1lbnRzID0gdGltZWRFdmVudHNUb01lYXN1cmVtZW50cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lYXN1cmVtZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/measurement.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sampling.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst hasSpansEnabled = __webpack_require__(/*! ../utils/hasSpansEnabled.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/hasSpansEnabled.js\");\nconst parseSampleRate = __webpack_require__(/*! ../utils/parseSampleRate.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/parseSampleRate.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\n\n/**\n * Makes a sampling decision for the given options.\n *\n * Called every time a root span is created. Only root spans which emerge with a `sampled` value of `true` will be\n * sent to Sentry.\n */\nfunction sampleSpan(\n  options,\n  samplingContext,\n  sampleRand,\n) {\n  // nothing to do if span recording is not enabled\n  if (!hasSpansEnabled.hasSpansEnabled(options)) {\n    return [false];\n  }\n\n  let localSampleRateWasApplied = undefined;\n\n  // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should\n  // work; prefer the hook if so\n  let sampleRate;\n  if (typeof options.tracesSampler === 'function') {\n    sampleRate = options.tracesSampler({\n      ...samplingContext,\n      inheritOrSampleWith: fallbackSampleRate => {\n        // If we have an incoming parent sample rate, we'll just use that one.\n        // The sampling decision will be inherited because of the sample_rand that was generated when the trace reached the incoming boundaries of the SDK.\n        if (typeof samplingContext.parentSampleRate === 'number') {\n          return samplingContext.parentSampleRate;\n        }\n\n        // Fallback if parent sample rate is not on the incoming trace (e.g. if there is no baggage)\n        // This is to provide backwards compatibility if there are incoming traces from older SDKs that don't send a parent sample rate or a sample rand. In these cases we just want to force either a sampling decision on the downstream traces via the sample rate.\n        if (typeof samplingContext.parentSampled === 'boolean') {\n          return Number(samplingContext.parentSampled);\n        }\n\n        return fallbackSampleRate;\n      },\n    });\n    localSampleRateWasApplied = true;\n  } else if (samplingContext.parentSampled !== undefined) {\n    sampleRate = samplingContext.parentSampled;\n  } else if (typeof options.tracesSampleRate !== 'undefined') {\n    sampleRate = options.tracesSampleRate;\n    localSampleRateWasApplied = true;\n  }\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get.\n  // (The only valid values are booleans or numbers between 0 and 1.)\n  const parsedSampleRate = parseSampleRate.parseSampleRate(sampleRate);\n\n  if (parsedSampleRate === undefined) {\n    debugBuild.DEBUG_BUILD &&\n      logger.logger.warn(\n        `[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          sampleRate,\n        )} of type ${JSON.stringify(typeof sampleRate)}.`,\n      );\n    return [false];\n  }\n\n  // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped\n  if (!parsedSampleRate) {\n    debugBuild.DEBUG_BUILD &&\n      logger.logger.log(\n        `[Tracing] Discarding transaction because ${\n          typeof options.tracesSampler === 'function'\n            ? 'tracesSampler returned 0 or false'\n            : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'\n        }`,\n      );\n    return [false, parsedSampleRate, localSampleRateWasApplied];\n  }\n\n  // We always compare the sample rand for the current execution context against the chosen sample rate.\n  // Read more: https://develop.sentry.dev/sdk/telemetry/traces/#propagated-random-value\n  const shouldSample = sampleRand < parsedSampleRate;\n\n  // if we're not going to keep it, we're done\n  if (!shouldSample) {\n    debugBuild.DEBUG_BUILD &&\n      logger.logger.log(\n        `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(\n          sampleRate,\n        )})`,\n      );\n  }\n\n  return [shouldSample, parsedSampleRate, localSampleRateWasApplied];\n}\n\nexports.sampleSpan = sampleSpan;\n//# sourceMappingURL=sampling.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhY2luZy9zYW1wbGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxtQkFBbUIsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDOUMsd0JBQXdCLG1CQUFPLENBQUMscUlBQTZCO0FBQzdELHdCQUF3QixtQkFBTyxDQUFDLHFJQUE2QjtBQUM3RCxlQUFlLG1CQUFPLENBQUMsK0hBQTBCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5SUFBeUk7QUFDekk7QUFDQSxXQUFXLFVBQVUsa0NBQWtDO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXHRyYWNpbmdcXHNhbXBsaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IGhhc1NwYW5zRW5hYmxlZCA9IHJlcXVpcmUoJy4uL3V0aWxzL2hhc1NwYW5zRW5hYmxlZC5qcycpO1xuY29uc3QgcGFyc2VTYW1wbGVSYXRlID0gcmVxdWlyZSgnLi4vdXRpbHMvcGFyc2VTYW1wbGVSYXRlLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcblxuLyoqXG4gKiBNYWtlcyBhIHNhbXBsaW5nIGRlY2lzaW9uIGZvciB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAqXG4gKiBDYWxsZWQgZXZlcnkgdGltZSBhIHJvb3Qgc3BhbiBpcyBjcmVhdGVkLiBPbmx5IHJvb3Qgc3BhbnMgd2hpY2ggZW1lcmdlIHdpdGggYSBgc2FtcGxlZGAgdmFsdWUgb2YgYHRydWVgIHdpbGwgYmVcbiAqIHNlbnQgdG8gU2VudHJ5LlxuICovXG5mdW5jdGlvbiBzYW1wbGVTcGFuKFxuICBvcHRpb25zLFxuICBzYW1wbGluZ0NvbnRleHQsXG4gIHNhbXBsZVJhbmQsXG4pIHtcbiAgLy8gbm90aGluZyB0byBkbyBpZiBzcGFuIHJlY29yZGluZyBpcyBub3QgZW5hYmxlZFxuICBpZiAoIWhhc1NwYW5zRW5hYmxlZC5oYXNTcGFuc0VuYWJsZWQob3B0aW9ucykpIHtcbiAgICByZXR1cm4gW2ZhbHNlXTtcbiAgfVxuXG4gIGxldCBsb2NhbFNhbXBsZVJhdGVXYXNBcHBsaWVkID0gdW5kZWZpbmVkO1xuXG4gIC8vIHdlIHdvdWxkIGhhdmUgYmFpbGVkIGFscmVhZHkgaWYgbmVpdGhlciBgdHJhY2VzU2FtcGxlcmAgbm9yIGB0cmFjZXNTYW1wbGVSYXRlYCB3ZXJlIGRlZmluZWQsIHNvIG9uZSBvZiB0aGVzZSBzaG91bGRcbiAgLy8gd29yazsgcHJlZmVyIHRoZSBob29rIGlmIHNvXG4gIGxldCBzYW1wbGVSYXRlO1xuICBpZiAodHlwZW9mIG9wdGlvbnMudHJhY2VzU2FtcGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNhbXBsZVJhdGUgPSBvcHRpb25zLnRyYWNlc1NhbXBsZXIoe1xuICAgICAgLi4uc2FtcGxpbmdDb250ZXh0LFxuICAgICAgaW5oZXJpdE9yU2FtcGxlV2l0aDogZmFsbGJhY2tTYW1wbGVSYXRlID0+IHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBpbmNvbWluZyBwYXJlbnQgc2FtcGxlIHJhdGUsIHdlJ2xsIGp1c3QgdXNlIHRoYXQgb25lLlxuICAgICAgICAvLyBUaGUgc2FtcGxpbmcgZGVjaXNpb24gd2lsbCBiZSBpbmhlcml0ZWQgYmVjYXVzZSBvZiB0aGUgc2FtcGxlX3JhbmQgdGhhdCB3YXMgZ2VuZXJhdGVkIHdoZW4gdGhlIHRyYWNlIHJlYWNoZWQgdGhlIGluY29taW5nIGJvdW5kYXJpZXMgb2YgdGhlIFNESy5cbiAgICAgICAgaWYgKHR5cGVvZiBzYW1wbGluZ0NvbnRleHQucGFyZW50U2FtcGxlUmF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gc2FtcGxpbmdDb250ZXh0LnBhcmVudFNhbXBsZVJhdGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGYWxsYmFjayBpZiBwYXJlbnQgc2FtcGxlIHJhdGUgaXMgbm90IG9uIHRoZSBpbmNvbWluZyB0cmFjZSAoZS5nLiBpZiB0aGVyZSBpcyBubyBiYWdnYWdlKVxuICAgICAgICAvLyBUaGlzIGlzIHRvIHByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgaWYgdGhlcmUgYXJlIGluY29taW5nIHRyYWNlcyBmcm9tIG9sZGVyIFNES3MgdGhhdCBkb24ndCBzZW5kIGEgcGFyZW50IHNhbXBsZSByYXRlIG9yIGEgc2FtcGxlIHJhbmQuIEluIHRoZXNlIGNhc2VzIHdlIGp1c3Qgd2FudCB0byBmb3JjZSBlaXRoZXIgYSBzYW1wbGluZyBkZWNpc2lvbiBvbiB0aGUgZG93bnN0cmVhbSB0cmFjZXMgdmlhIHRoZSBzYW1wbGUgcmF0ZS5cbiAgICAgICAgaWYgKHR5cGVvZiBzYW1wbGluZ0NvbnRleHQucGFyZW50U2FtcGxlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgcmV0dXJuIE51bWJlcihzYW1wbGluZ0NvbnRleHQucGFyZW50U2FtcGxlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsbGJhY2tTYW1wbGVSYXRlO1xuICAgICAgfSxcbiAgICB9KTtcbiAgICBsb2NhbFNhbXBsZVJhdGVXYXNBcHBsaWVkID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzYW1wbGluZ0NvbnRleHQucGFyZW50U2FtcGxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2FtcGxlUmF0ZSA9IHNhbXBsaW5nQ29udGV4dC5wYXJlbnRTYW1wbGVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnRyYWNlc1NhbXBsZVJhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2FtcGxlUmF0ZSA9IG9wdGlvbnMudHJhY2VzU2FtcGxlUmF0ZTtcbiAgICBsb2NhbFNhbXBsZVJhdGVXYXNBcHBsaWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFNpbmNlIHRoaXMgaXMgY29taW5nIGZyb20gdGhlIHVzZXIgKG9yIGZyb20gYSBmdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlciksIHdobyBrbm93cyB3aGF0IHdlIG1pZ2h0IGdldC5cbiAgLy8gKFRoZSBvbmx5IHZhbGlkIHZhbHVlcyBhcmUgYm9vbGVhbnMgb3IgbnVtYmVycyBiZXR3ZWVuIDAgYW5kIDEuKVxuICBjb25zdCBwYXJzZWRTYW1wbGVSYXRlID0gcGFyc2VTYW1wbGVSYXRlLnBhcnNlU2FtcGxlUmF0ZShzYW1wbGVSYXRlKTtcblxuICBpZiAocGFyc2VkU2FtcGxlUmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJlxuICAgICAgbG9nZ2VyLmxvZ2dlci53YXJuKFxuICAgICAgICBgW1RyYWNpbmddIERpc2NhcmRpbmcgcm9vdCBzcGFuIGJlY2F1c2Ugb2YgaW52YWxpZCBzYW1wbGUgcmF0ZS4gU2FtcGxlIHJhdGUgbXVzdCBiZSBhIGJvb2xlYW4gb3IgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLiBHb3QgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzYW1wbGVSYXRlLFxuICAgICAgICApfSBvZiB0eXBlICR7SlNPTi5zdHJpbmdpZnkodHlwZW9mIHNhbXBsZVJhdGUpfS5gLFxuICAgICAgKTtcbiAgICByZXR1cm4gW2ZhbHNlXTtcbiAgfVxuXG4gIC8vIGlmIHRoZSBmdW5jdGlvbiByZXR1cm5lZCAwIChvciBmYWxzZSksIG9yIGlmIGB0cmFjZXNTYW1wbGVSYXRlYCBpcyAwLCBpdCdzIGEgc2lnbiB0aGUgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGRyb3BwZWRcbiAgaWYgKCFwYXJzZWRTYW1wbGVSYXRlKSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJlxuICAgICAgbG9nZ2VyLmxvZ2dlci5sb2coXG4gICAgICAgIGBbVHJhY2luZ10gRGlzY2FyZGluZyB0cmFuc2FjdGlvbiBiZWNhdXNlICR7XG4gICAgICAgICAgdHlwZW9mIG9wdGlvbnMudHJhY2VzU2FtcGxlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyAndHJhY2VzU2FtcGxlciByZXR1cm5lZCAwIG9yIGZhbHNlJ1xuICAgICAgICAgICAgOiAnYSBuZWdhdGl2ZSBzYW1wbGluZyBkZWNpc2lvbiB3YXMgaW5oZXJpdGVkIG9yIHRyYWNlc1NhbXBsZVJhdGUgaXMgc2V0IHRvIDAnXG4gICAgICAgIH1gLFxuICAgICAgKTtcbiAgICByZXR1cm4gW2ZhbHNlLCBwYXJzZWRTYW1wbGVSYXRlLCBsb2NhbFNhbXBsZVJhdGVXYXNBcHBsaWVkXTtcbiAgfVxuXG4gIC8vIFdlIGFsd2F5cyBjb21wYXJlIHRoZSBzYW1wbGUgcmFuZCBmb3IgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQgYWdhaW5zdCB0aGUgY2hvc2VuIHNhbXBsZSByYXRlLlxuICAvLyBSZWFkIG1vcmU6IGh0dHBzOi8vZGV2ZWxvcC5zZW50cnkuZGV2L3Nkay90ZWxlbWV0cnkvdHJhY2VzLyNwcm9wYWdhdGVkLXJhbmRvbS12YWx1ZVxuICBjb25zdCBzaG91bGRTYW1wbGUgPSBzYW1wbGVSYW5kIDwgcGFyc2VkU2FtcGxlUmF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgZ29pbmcgdG8ga2VlcCBpdCwgd2UncmUgZG9uZVxuICBpZiAoIXNob3VsZFNhbXBsZSkge1xuICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiZcbiAgICAgIGxvZ2dlci5sb2dnZXIubG9nKFxuICAgICAgICBgW1RyYWNpbmddIERpc2NhcmRpbmcgdHJhbnNhY3Rpb24gYmVjYXVzZSBpdCdzIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmFuZG9tIHNhbXBsZSAoc2FtcGxpbmcgcmF0ZSA9ICR7TnVtYmVyKFxuICAgICAgICAgIHNhbXBsZVJhdGUsXG4gICAgICAgICl9KWAsXG4gICAgICApO1xuICB9XG5cbiAgcmV0dXJuIFtzaG91bGRTYW1wbGUsIHBhcnNlZFNhbXBsZVJhdGUsIGxvY2FsU2FtcGxlUmF0ZVdhc0FwcGxpZWRdO1xufVxuXG5leHBvcnRzLnNhbXBsZVNwYW4gPSBzYW1wbGVTcGFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FtcGxpbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sampling.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sentryNonRecordingSpan.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanUtils.js");\nconst propagationContext = __webpack_require__(/*! ../utils-hoist/propagationContext.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/propagationContext.js");\n\n/**\n * A Sentry Span that is non-recording, meaning it will not be sent to Sentry.\n */\nclass SentryNonRecordingSpan  {\n\n   constructor(spanContext = {}) {\n    this._traceId = spanContext.traceId || propagationContext.generateTraceId();\n    this._spanId = spanContext.spanId || propagationContext.generateSpanId();\n  }\n\n  /** @inheritdoc */\n   spanContext() {\n    return {\n      spanId: this._spanId,\n      traceId: this._traceId,\n      traceFlags: spanUtils.TRACE_FLAG_NONE,\n    };\n  }\n\n  /** @inheritdoc */\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n   end(_timestamp) {}\n\n  /** @inheritdoc */\n   setAttribute(_key, _value) {\n    return this;\n  }\n\n  /** @inheritdoc */\n   setAttributes(_values) {\n    return this;\n  }\n\n  /** @inheritdoc */\n   setStatus(_status) {\n    return this;\n  }\n\n  /** @inheritdoc */\n   updateName(_name) {\n    return this;\n  }\n\n  /** @inheritdoc */\n   isRecording() {\n    return false;\n  }\n\n  /** @inheritdoc */\n   addEvent(\n    _name,\n    _attributesOrStartTime,\n    _startTime,\n  ) {\n    return this;\n  }\n\n  /** @inheritDoc */\n   addLink(_link) {\n    return this;\n  }\n\n  /** @inheritDoc */\n   addLinks(_links) {\n    return this;\n  }\n\n  /**\n   * This should generally not be used,\n   * but we need it for being compliant with the OTEL Span interface.\n   *\n   * @hidden\n   * @internal\n   */\n   recordException(_exception, _time) {\n    // noop\n  }\n}\n\nexports.SentryNonRecordingSpan = SentryNonRecordingSpan;\n//# sourceMappingURL=sentryNonRecordingSpan.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhY2luZy9zZW50cnlOb25SZWNvcmRpbmdTcGFuLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLGtCQUFrQixtQkFBTyxDQUFDLHlIQUF1QjtBQUNqRCwyQkFBMkIsbUJBQU8sQ0FBQyx1SkFBc0M7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXHRyYWNpbmdcXHNlbnRyeU5vblJlY29yZGluZ1NwYW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IHNwYW5VdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3NwYW5VdGlscy5qcycpO1xuY29uc3QgcHJvcGFnYXRpb25Db250ZXh0ID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvcHJvcGFnYXRpb25Db250ZXh0LmpzJyk7XG5cbi8qKlxuICogQSBTZW50cnkgU3BhbiB0aGF0IGlzIG5vbi1yZWNvcmRpbmcsIG1lYW5pbmcgaXQgd2lsbCBub3QgYmUgc2VudCB0byBTZW50cnkuXG4gKi9cbmNsYXNzIFNlbnRyeU5vblJlY29yZGluZ1NwYW4gIHtcblxuICAgY29uc3RydWN0b3Ioc3BhbkNvbnRleHQgPSB7fSkge1xuICAgIHRoaXMuX3RyYWNlSWQgPSBzcGFuQ29udGV4dC50cmFjZUlkIHx8IHByb3BhZ2F0aW9uQ29udGV4dC5nZW5lcmF0ZVRyYWNlSWQoKTtcbiAgICB0aGlzLl9zcGFuSWQgPSBzcGFuQ29udGV4dC5zcGFuSWQgfHwgcHJvcGFnYXRpb25Db250ZXh0LmdlbmVyYXRlU3BhbklkKCk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIHNwYW5Db250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBzcGFuSWQ6IHRoaXMuX3NwYW5JZCxcbiAgICAgIHRyYWNlSWQ6IHRoaXMuX3RyYWNlSWQsXG4gICAgICB0cmFjZUZsYWdzOiBzcGFuVXRpbHMuVFJBQ0VfRkxBR19OT05FLFxuICAgIH07XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgZW5kKF90aW1lc3RhbXApIHt9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBzZXRBdHRyaWJ1dGUoX2tleSwgX3ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIHNldEF0dHJpYnV0ZXMoX3ZhbHVlcykge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBzZXRTdGF0dXMoX3N0YXR1cykge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICB1cGRhdGVOYW1lKF9uYW1lKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGlzUmVjb3JkaW5nKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgYWRkRXZlbnQoXG4gICAgX25hbWUsXG4gICAgX2F0dHJpYnV0ZXNPclN0YXJ0VGltZSxcbiAgICBfc3RhcnRUaW1lLFxuICApIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgYWRkTGluayhfbGluaykge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gICBhZGRMaW5rcyhfbGlua3MpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQsXG4gICAqIGJ1dCB3ZSBuZWVkIGl0IGZvciBiZWluZyBjb21wbGlhbnQgd2l0aCB0aGUgT1RFTCBTcGFuIGludGVyZmFjZS5cbiAgICpcbiAgICogQGhpZGRlblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICByZWNvcmRFeGNlcHRpb24oX2V4Y2VwdGlvbiwgX3RpbWUpIHtcbiAgICAvLyBub29wXG4gIH1cbn1cblxuZXhwb3J0cy5TZW50cnlOb25SZWNvcmRpbmdTcGFuID0gU2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbnRyeU5vblJlY29yZGluZ1NwYW4uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sentryNonRecordingSpan.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sentrySpan.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst envelope = __webpack_require__(/*! ../envelope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/envelope.js\");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanUtils.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst propagationContext = __webpack_require__(/*! ../utils-hoist/propagationContext.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/propagationContext.js\");\nconst time = __webpack_require__(/*! ../utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\nconst dynamicSamplingContext = __webpack_require__(/*! ./dynamicSamplingContext.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js\");\nconst logSpans = __webpack_require__(/*! ./logSpans.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/logSpans.js\");\nconst measurement = __webpack_require__(/*! ./measurement.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/measurement.js\");\nconst utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/utils.js\");\n\nconst MAX_SPAN_COUNT = 1000;\n\n/**\n * Span contains all data about a span\n */\nclass SentrySpan  {\n\n  /** Epoch timestamp in seconds when the span started. */\n\n  /** Epoch timestamp in seconds when the span ended. */\n\n  /** Internal keeper of the status */\n\n  /** The timed events added to this span. */\n\n  /** if true, treat span as a standalone span (not part of a transaction) */\n\n  /**\n   * You should never call the constructor manually, always use `Sentry.startSpan()`\n   * or other span methods.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n   constructor(spanContext = {}) {\n    this._traceId = spanContext.traceId || propagationContext.generateTraceId();\n    this._spanId = spanContext.spanId || propagationContext.generateSpanId();\n    this._startTime = spanContext.startTimestamp || time.timestampInSeconds();\n    this._links = spanContext.links;\n\n    this._attributes = {};\n    this.setAttributes({\n      [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'manual',\n      [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: spanContext.op,\n      ...spanContext.attributes,\n    });\n\n    this._name = spanContext.name;\n\n    if (spanContext.parentSpanId) {\n      this._parentSpanId = spanContext.parentSpanId;\n    }\n    // We want to include booleans as well here\n    if ('sampled' in spanContext) {\n      this._sampled = spanContext.sampled;\n    }\n    if (spanContext.endTimestamp) {\n      this._endTime = spanContext.endTimestamp;\n    }\n\n    this._events = [];\n\n    this._isStandaloneSpan = spanContext.isStandalone;\n\n    // If the span is already ended, ensure we finalize the span immediately\n    if (this._endTime) {\n      this._onSpanEnded();\n    }\n  }\n\n  /** @inheritDoc */\n   addLink(link) {\n    if (this._links) {\n      this._links.push(link);\n    } else {\n      this._links = [link];\n    }\n    return this;\n  }\n\n  /** @inheritDoc */\n   addLinks(links) {\n    if (this._links) {\n      this._links.push(...links);\n    } else {\n      this._links = links;\n    }\n    return this;\n  }\n\n  /**\n   * This should generally not be used,\n   * but it is needed for being compliant with the OTEL Span interface.\n   *\n   * @hidden\n   * @internal\n   */\n   recordException(_exception, _time) {\n    // noop\n  }\n\n  /** @inheritdoc */\n   spanContext() {\n    const { _spanId: spanId, _traceId: traceId, _sampled: sampled } = this;\n    return {\n      spanId,\n      traceId,\n      traceFlags: sampled ? spanUtils.TRACE_FLAG_SAMPLED : spanUtils.TRACE_FLAG_NONE,\n    };\n  }\n\n  /** @inheritdoc */\n   setAttribute(key, value) {\n    if (value === undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._attributes[key];\n    } else {\n      this._attributes[key] = value;\n    }\n\n    return this;\n  }\n\n  /** @inheritdoc */\n   setAttributes(attributes) {\n    Object.keys(attributes).forEach(key => this.setAttribute(key, attributes[key]));\n    return this;\n  }\n\n  /**\n   * This should generally not be used,\n   * but we need it for browser tracing where we want to adjust the start time afterwards.\n   * USE THIS WITH CAUTION!\n   *\n   * @hidden\n   * @internal\n   */\n   updateStartTime(timeInput) {\n    this._startTime = spanUtils.spanTimeInputToSeconds(timeInput);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setStatus(value) {\n    this._status = value;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   updateName(name) {\n    this._name = name;\n    this.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'custom');\n    return this;\n  }\n\n  /** @inheritdoc */\n   end(endTimestamp) {\n    // If already ended, skip\n    if (this._endTime) {\n      return;\n    }\n\n    this._endTime = spanUtils.spanTimeInputToSeconds(endTimestamp);\n    logSpans.logSpanEnd(this);\n\n    this._onSpanEnded();\n  }\n\n  /**\n   * Get JSON representation of this span.\n   *\n   * @hidden\n   * @internal This method is purely for internal purposes and should not be used outside\n   * of SDK code. If you need to get a JSON representation of a span,\n   * use `spanToJSON(span)` instead.\n   */\n   getSpanJSON() {\n    return {\n      data: this._attributes,\n      description: this._name,\n      op: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP],\n      parent_span_id: this._parentSpanId,\n      span_id: this._spanId,\n      start_timestamp: this._startTime,\n      status: spanUtils.getStatusMessage(this._status),\n      timestamp: this._endTime,\n      trace_id: this._traceId,\n      origin: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ,\n      profile_id: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_PROFILE_ID] ,\n      exclusive_time: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME] ,\n      measurements: measurement.timedEventsToMeasurements(this._events),\n      is_segment: (this._isStandaloneSpan && spanUtils.getRootSpan(this) === this) || undefined,\n      segment_id: this._isStandaloneSpan ? spanUtils.getRootSpan(this).spanContext().spanId : undefined,\n      links: spanUtils.convertSpanLinksForEnvelope(this._links),\n    };\n  }\n\n  /** @inheritdoc */\n   isRecording() {\n    return !this._endTime && !!this._sampled;\n  }\n\n  /**\n   * @inheritdoc\n   */\n   addEvent(\n    name,\n    attributesOrStartTime,\n    startTime,\n  ) {\n    debugBuild.DEBUG_BUILD && logger.logger.log('[Tracing] Adding an event to span:', name);\n\n    const time$1 = isSpanTimeInput(attributesOrStartTime) ? attributesOrStartTime : startTime || time.timestampInSeconds();\n    const attributes = isSpanTimeInput(attributesOrStartTime) ? {} : attributesOrStartTime || {};\n\n    const event = {\n      name,\n      time: spanUtils.spanTimeInputToSeconds(time$1),\n      attributes,\n    };\n\n    this._events.push(event);\n\n    return this;\n  }\n\n  /**\n   * This method should generally not be used,\n   * but for now we need a way to publicly check if the `_isStandaloneSpan` flag is set.\n   * USE THIS WITH CAUTION!\n   * @internal\n   * @hidden\n   * @experimental\n   */\n   isStandaloneSpan() {\n    return !!this._isStandaloneSpan;\n  }\n\n  /** Emit `spanEnd` when the span is ended. */\n   _onSpanEnded() {\n    const client = currentScopes.getClient();\n    if (client) {\n      client.emit('spanEnd', this);\n    }\n\n    // A segment span is basically the root span of a local span tree.\n    // So for now, this is either what we previously refer to as the root span,\n    // or a standalone span.\n    const isSegmentSpan = this._isStandaloneSpan || this === spanUtils.getRootSpan(this);\n\n    if (!isSegmentSpan) {\n      return;\n    }\n\n    // if this is a standalone span, we send it immediately\n    if (this._isStandaloneSpan) {\n      if (this._sampled) {\n        sendSpanEnvelope(envelope.createSpanEnvelope([this], client));\n      } else {\n        debugBuild.DEBUG_BUILD &&\n          logger.logger.log('[Tracing] Discarding standalone span because its trace was not chosen to be sampled.');\n        if (client) {\n          client.recordDroppedEvent('sample_rate', 'span');\n        }\n      }\n      return;\n    }\n\n    const transactionEvent = this._convertSpanToTransaction();\n    if (transactionEvent) {\n      const scope = utils.getCapturedScopesOnSpan(this).scope || currentScopes.getCurrentScope();\n      scope.captureEvent(transactionEvent);\n    }\n  }\n\n  /**\n   * Finish the transaction & prepare the event to send to Sentry.\n   */\n   _convertSpanToTransaction() {\n    // We can only convert finished spans\n    if (!isFullFinishedSpan(spanUtils.spanToJSON(this))) {\n      return undefined;\n    }\n\n    if (!this._name) {\n      debugBuild.DEBUG_BUILD && logger.logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this._name = '<unlabeled transaction>';\n    }\n\n    const { scope: capturedSpanScope, isolationScope: capturedSpanIsolationScope } = utils.getCapturedScopesOnSpan(this);\n\n    const normalizedRequest = capturedSpanScope?.getScopeData().sdkProcessingMetadata?.normalizedRequest;\n\n    if (this._sampled !== true) {\n      return undefined;\n    }\n\n    // The transaction span itself as well as any potential standalone spans should be filtered out\n    const finishedSpans = spanUtils.getSpanDescendants(this).filter(span => span !== this && !isStandaloneSpan(span));\n\n    const spans = finishedSpans.map(span => spanUtils.spanToJSON(span)).filter(isFullFinishedSpan);\n\n    const source = this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ;\n\n    // remove internal root span attributes we don't need to send.\n    /* eslint-disable @typescript-eslint/no-dynamic-delete */\n    delete this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n    spans.forEach(span => {\n      delete span.data[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n    });\n    // eslint-enabled-next-line @typescript-eslint/no-dynamic-delete\n\n    const transaction = {\n      contexts: {\n        trace: spanUtils.spanToTransactionTraceContext(this),\n      },\n      spans:\n        // spans.sort() mutates the array, but `spans` is already a copy so we can safely do this here\n        // we do not use spans anymore after this point\n        spans.length > MAX_SPAN_COUNT\n          ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n          : spans,\n      start_timestamp: this._startTime,\n      timestamp: this._endTime,\n      transaction: this._name,\n      type: 'transaction',\n      sdkProcessingMetadata: {\n        capturedSpanScope,\n        capturedSpanIsolationScope,\n        dynamicSamplingContext: dynamicSamplingContext.getDynamicSamplingContextFromSpan(this),\n      },\n      request: normalizedRequest,\n      ...(source && {\n        transaction_info: {\n          source,\n        },\n      }),\n    };\n\n    const measurements = measurement.timedEventsToMeasurements(this._events);\n    const hasMeasurements = measurements && Object.keys(measurements).length;\n\n    if (hasMeasurements) {\n      debugBuild.DEBUG_BUILD &&\n        logger.logger.log(\n          '[Measurements] Adding measurements to transaction event',\n          JSON.stringify(measurements, undefined, 2),\n        );\n      transaction.measurements = measurements;\n    }\n\n    return transaction;\n  }\n}\n\nfunction isSpanTimeInput(value) {\n  return (value && typeof value === 'number') || value instanceof Date || Array.isArray(value);\n}\n\n// We want to filter out any incomplete SpanJSON objects\nfunction isFullFinishedSpan(input) {\n  return !!input.start_timestamp && !!input.timestamp && !!input.span_id && !!input.trace_id;\n}\n\n/** `SentrySpan`s can be sent as a standalone span rather than belonging to a transaction */\nfunction isStandaloneSpan(span) {\n  return span instanceof SentrySpan && span.isStandaloneSpan();\n}\n\n/**\n * Sends a `SpanEnvelope`.\n *\n * Note: If the envelope's spans are dropped, e.g. via `beforeSendSpan`,\n * the envelope will not be sent either.\n */\nfunction sendSpanEnvelope(envelope) {\n  const client = currentScopes.getClient();\n  if (!client) {\n    return;\n  }\n\n  const spanItems = envelope[1];\n  if (!spanItems || spanItems.length === 0) {\n    client.recordDroppedEvent('before_send', 'span');\n    return;\n  }\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope);\n}\n\nexports.SentrySpan = SentrySpan;\n//# sourceMappingURL=sentrySpan.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhY2luZy9zZW50cnlTcGFuLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLHNCQUFzQixtQkFBTyxDQUFDLHFIQUFxQjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsMkdBQWdCO0FBQ3pDLDJCQUEyQixtQkFBTyxDQUFDLCtIQUEwQjtBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyx5SEFBdUI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLCtIQUEwQjtBQUNqRCwyQkFBMkIsbUJBQU8sQ0FBQyx1SkFBc0M7QUFDekUsYUFBYSxtQkFBTyxDQUFDLDJIQUF3QjtBQUM3QywrQkFBK0IsbUJBQU8sQ0FBQyw4SUFBNkI7QUFDcEUsaUJBQWlCLG1CQUFPLENBQUMsa0hBQWU7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsd0hBQWtCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyw0R0FBWTs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUVBQW1FOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSx1RUFBdUU7O0FBRW5GOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFx0cmFjaW5nXFxzZW50cnlTcGFuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBjdXJyZW50U2NvcGVzID0gcmVxdWlyZSgnLi4vY3VycmVudFNjb3Blcy5qcycpO1xuY29uc3QgZGVidWdCdWlsZCA9IHJlcXVpcmUoJy4uL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBlbnZlbG9wZSA9IHJlcXVpcmUoJy4uL2VudmVsb3BlLmpzJyk7XG5jb25zdCBzZW1hbnRpY0F0dHJpYnV0ZXMgPSByZXF1aXJlKCcuLi9zZW1hbnRpY0F0dHJpYnV0ZXMuanMnKTtcbmNvbnN0IHNwYW5VdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3NwYW5VdGlscy5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCBwcm9wYWdhdGlvbkNvbnRleHQgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9wcm9wYWdhdGlvbkNvbnRleHQuanMnKTtcbmNvbnN0IHRpbWUgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC90aW1lLmpzJyk7XG5jb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gcmVxdWlyZSgnLi9keW5hbWljU2FtcGxpbmdDb250ZXh0LmpzJyk7XG5jb25zdCBsb2dTcGFucyA9IHJlcXVpcmUoJy4vbG9nU3BhbnMuanMnKTtcbmNvbnN0IG1lYXN1cmVtZW50ID0gcmVxdWlyZSgnLi9tZWFzdXJlbWVudC5qcycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG5cbmNvbnN0IE1BWF9TUEFOX0NPVU5UID0gMTAwMDtcblxuLyoqXG4gKiBTcGFuIGNvbnRhaW5zIGFsbCBkYXRhIGFib3V0IGEgc3BhblxuICovXG5jbGFzcyBTZW50cnlTcGFuICB7XG5cbiAgLyoqIEVwb2NoIHRpbWVzdGFtcCBpbiBzZWNvbmRzIHdoZW4gdGhlIHNwYW4gc3RhcnRlZC4gKi9cblxuICAvKiogRXBvY2ggdGltZXN0YW1wIGluIHNlY29uZHMgd2hlbiB0aGUgc3BhbiBlbmRlZC4gKi9cblxuICAvKiogSW50ZXJuYWwga2VlcGVyIG9mIHRoZSBzdGF0dXMgKi9cblxuICAvKiogVGhlIHRpbWVkIGV2ZW50cyBhZGRlZCB0byB0aGlzIHNwYW4uICovXG5cbiAgLyoqIGlmIHRydWUsIHRyZWF0IHNwYW4gYXMgYSBzdGFuZGFsb25lIHNwYW4gKG5vdCBwYXJ0IG9mIGEgdHJhbnNhY3Rpb24pICovXG5cbiAgLyoqXG4gICAqIFlvdSBzaG91bGQgbmV2ZXIgY2FsbCB0aGUgY29uc3RydWN0b3IgbWFudWFsbHksIGFsd2F5cyB1c2UgYFNlbnRyeS5zdGFydFNwYW4oKWBcbiAgICogb3Igb3RoZXIgc3BhbiBtZXRob2RzLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgKiBAaGlkZGVuXG4gICAqL1xuICAgY29uc3RydWN0b3Ioc3BhbkNvbnRleHQgPSB7fSkge1xuICAgIHRoaXMuX3RyYWNlSWQgPSBzcGFuQ29udGV4dC50cmFjZUlkIHx8IHByb3BhZ2F0aW9uQ29udGV4dC5nZW5lcmF0ZVRyYWNlSWQoKTtcbiAgICB0aGlzLl9zcGFuSWQgPSBzcGFuQ29udGV4dC5zcGFuSWQgfHwgcHJvcGFnYXRpb25Db250ZXh0LmdlbmVyYXRlU3BhbklkKCk7XG4gICAgdGhpcy5fc3RhcnRUaW1lID0gc3BhbkNvbnRleHQuc3RhcnRUaW1lc3RhbXAgfHwgdGltZS50aW1lc3RhbXBJblNlY29uZHMoKTtcbiAgICB0aGlzLl9saW5rcyA9IHNwYW5Db250ZXh0LmxpbmtzO1xuXG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXTogJ21hbnVhbCcsXG4gICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdOiBzcGFuQ29udGV4dC5vcCxcbiAgICAgIC4uLnNwYW5Db250ZXh0LmF0dHJpYnV0ZXMsXG4gICAgfSk7XG5cbiAgICB0aGlzLl9uYW1lID0gc3BhbkNvbnRleHQubmFtZTtcblxuICAgIGlmIChzcGFuQ29udGV4dC5wYXJlbnRTcGFuSWQpIHtcbiAgICAgIHRoaXMuX3BhcmVudFNwYW5JZCA9IHNwYW5Db250ZXh0LnBhcmVudFNwYW5JZDtcbiAgICB9XG4gICAgLy8gV2Ugd2FudCB0byBpbmNsdWRlIGJvb2xlYW5zIGFzIHdlbGwgaGVyZVxuICAgIGlmICgnc2FtcGxlZCcgaW4gc3BhbkNvbnRleHQpIHtcbiAgICAgIHRoaXMuX3NhbXBsZWQgPSBzcGFuQ29udGV4dC5zYW1wbGVkO1xuICAgIH1cbiAgICBpZiAoc3BhbkNvbnRleHQuZW5kVGltZXN0YW1wKSB7XG4gICAgICB0aGlzLl9lbmRUaW1lID0gc3BhbkNvbnRleHQuZW5kVGltZXN0YW1wO1xuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuXG4gICAgdGhpcy5faXNTdGFuZGFsb25lU3BhbiA9IHNwYW5Db250ZXh0LmlzU3RhbmRhbG9uZTtcblxuICAgIC8vIElmIHRoZSBzcGFuIGlzIGFscmVhZHkgZW5kZWQsIGVuc3VyZSB3ZSBmaW5hbGl6ZSB0aGUgc3BhbiBpbW1lZGlhdGVseVxuICAgIGlmICh0aGlzLl9lbmRUaW1lKSB7XG4gICAgICB0aGlzLl9vblNwYW5FbmRlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgYWRkTGluayhsaW5rKSB7XG4gICAgaWYgKHRoaXMuX2xpbmtzKSB7XG4gICAgICB0aGlzLl9saW5rcy5wdXNoKGxpbmspO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9saW5rcyA9IFtsaW5rXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgIGFkZExpbmtzKGxpbmtzKSB7XG4gICAgaWYgKHRoaXMuX2xpbmtzKSB7XG4gICAgICB0aGlzLl9saW5rcy5wdXNoKC4uLmxpbmtzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGlua3MgPSBsaW5rcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSB1c2VkLFxuICAgKiBidXQgaXQgaXMgbmVlZGVkIGZvciBiZWluZyBjb21wbGlhbnQgd2l0aCB0aGUgT1RFTCBTcGFuIGludGVyZmFjZS5cbiAgICpcbiAgICogQGhpZGRlblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICByZWNvcmRFeGNlcHRpb24oX2V4Y2VwdGlvbiwgX3RpbWUpIHtcbiAgICAvLyBub29wXG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIHNwYW5Db250ZXh0KCkge1xuICAgIGNvbnN0IHsgX3NwYW5JZDogc3BhbklkLCBfdHJhY2VJZDogdHJhY2VJZCwgX3NhbXBsZWQ6IHNhbXBsZWQgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNwYW5JZCxcbiAgICAgIHRyYWNlSWQsXG4gICAgICB0cmFjZUZsYWdzOiBzYW1wbGVkID8gc3BhblV0aWxzLlRSQUNFX0ZMQUdfU0FNUExFRCA6IHNwYW5VdGlscy5UUkFDRV9GTEFHX05PTkUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZVxuICAgICAgZGVsZXRlIHRoaXMuX2F0dHJpYnV0ZXNba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIHNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goa2V5ID0+IHRoaXMuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSB1c2VkLFxuICAgKiBidXQgd2UgbmVlZCBpdCBmb3IgYnJvd3NlciB0cmFjaW5nIHdoZXJlIHdlIHdhbnQgdG8gYWRqdXN0IHRoZSBzdGFydCB0aW1lIGFmdGVyd2FyZHMuXG4gICAqIFVTRSBUSElTIFdJVEggQ0FVVElPTiFcbiAgICpcbiAgICogQGhpZGRlblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICB1cGRhdGVTdGFydFRpbWUodGltZUlucHV0KSB7XG4gICAgdGhpcy5fc3RhcnRUaW1lID0gc3BhblV0aWxzLnNwYW5UaW1lSW5wdXRUb1NlY29uZHModGltZUlucHV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIHNldFN0YXR1cyh2YWx1ZSkge1xuICAgIHRoaXMuX3N0YXR1cyA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgdXBkYXRlTmFtZShuYW1lKSB7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFLCAnY3VzdG9tJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGVuZChlbmRUaW1lc3RhbXApIHtcbiAgICAvLyBJZiBhbHJlYWR5IGVuZGVkLCBza2lwXG4gICAgaWYgKHRoaXMuX2VuZFRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9lbmRUaW1lID0gc3BhblV0aWxzLnNwYW5UaW1lSW5wdXRUb1NlY29uZHMoZW5kVGltZXN0YW1wKTtcbiAgICBsb2dTcGFucy5sb2dTcGFuRW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fb25TcGFuRW5kZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNwYW4uXG4gICAqXG4gICAqIEBoaWRkZW5cbiAgICogQGludGVybmFsIFRoaXMgbWV0aG9kIGlzIHB1cmVseSBmb3IgaW50ZXJuYWwgcHVycG9zZXMgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBvdXRzaWRlXG4gICAqIG9mIFNESyBjb2RlLiBJZiB5b3UgbmVlZCB0byBnZXQgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc3BhbixcbiAgICogdXNlIGBzcGFuVG9KU09OKHNwYW4pYCBpbnN0ZWFkLlxuICAgKi9cbiAgIGdldFNwYW5KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiB0aGlzLl9hdHRyaWJ1dGVzLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuX25hbWUsXG4gICAgICBvcDogdGhpcy5fYXR0cmlidXRlc1tzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF0sXG4gICAgICBwYXJlbnRfc3Bhbl9pZDogdGhpcy5fcGFyZW50U3BhbklkLFxuICAgICAgc3Bhbl9pZDogdGhpcy5fc3BhbklkLFxuICAgICAgc3RhcnRfdGltZXN0YW1wOiB0aGlzLl9zdGFydFRpbWUsXG4gICAgICBzdGF0dXM6IHNwYW5VdGlscy5nZXRTdGF0dXNNZXNzYWdlKHRoaXMuX3N0YXR1cyksXG4gICAgICB0aW1lc3RhbXA6IHRoaXMuX2VuZFRpbWUsXG4gICAgICB0cmFjZV9pZDogdGhpcy5fdHJhY2VJZCxcbiAgICAgIG9yaWdpbjogdGhpcy5fYXR0cmlidXRlc1tzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dICxcbiAgICAgIHByb2ZpbGVfaWQ6IHRoaXMuX2F0dHJpYnV0ZXNbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9QUk9GSUxFX0lEXSAsXG4gICAgICBleGNsdXNpdmVfdGltZTogdGhpcy5fYXR0cmlidXRlc1tzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX0VYQ0xVU0lWRV9USU1FXSAsXG4gICAgICBtZWFzdXJlbWVudHM6IG1lYXN1cmVtZW50LnRpbWVkRXZlbnRzVG9NZWFzdXJlbWVudHModGhpcy5fZXZlbnRzKSxcbiAgICAgIGlzX3NlZ21lbnQ6ICh0aGlzLl9pc1N0YW5kYWxvbmVTcGFuICYmIHNwYW5VdGlscy5nZXRSb290U3Bhbih0aGlzKSA9PT0gdGhpcykgfHwgdW5kZWZpbmVkLFxuICAgICAgc2VnbWVudF9pZDogdGhpcy5faXNTdGFuZGFsb25lU3BhbiA/IHNwYW5VdGlscy5nZXRSb290U3Bhbih0aGlzKS5zcGFuQ29udGV4dCgpLnNwYW5JZCA6IHVuZGVmaW5lZCxcbiAgICAgIGxpbmtzOiBzcGFuVXRpbHMuY29udmVydFNwYW5MaW5rc0ZvckVudmVsb3BlKHRoaXMuX2xpbmtzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBpc1JlY29yZGluZygpIHtcbiAgICByZXR1cm4gIXRoaXMuX2VuZFRpbWUgJiYgISF0aGlzLl9zYW1wbGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jXG4gICAqL1xuICAgYWRkRXZlbnQoXG4gICAgbmFtZSxcbiAgICBhdHRyaWJ1dGVzT3JTdGFydFRpbWUsXG4gICAgc3RhcnRUaW1lLFxuICApIHtcbiAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIubG9nKCdbVHJhY2luZ10gQWRkaW5nIGFuIGV2ZW50IHRvIHNwYW46JywgbmFtZSk7XG5cbiAgICBjb25zdCB0aW1lJDEgPSBpc1NwYW5UaW1lSW5wdXQoYXR0cmlidXRlc09yU3RhcnRUaW1lKSA/IGF0dHJpYnV0ZXNPclN0YXJ0VGltZSA6IHN0YXJ0VGltZSB8fCB0aW1lLnRpbWVzdGFtcEluU2Vjb25kcygpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBpc1NwYW5UaW1lSW5wdXQoYXR0cmlidXRlc09yU3RhcnRUaW1lKSA/IHt9IDogYXR0cmlidXRlc09yU3RhcnRUaW1lIHx8IHt9O1xuXG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICBuYW1lLFxuICAgICAgdGltZTogc3BhblV0aWxzLnNwYW5UaW1lSW5wdXRUb1NlY29uZHModGltZSQxKSxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgfTtcblxuICAgIHRoaXMuX2V2ZW50cy5wdXNoKGV2ZW50KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQsXG4gICAqIGJ1dCBmb3Igbm93IHdlIG5lZWQgYSB3YXkgdG8gcHVibGljbHkgY2hlY2sgaWYgdGhlIGBfaXNTdGFuZGFsb25lU3BhbmAgZmxhZyBpcyBzZXQuXG4gICAqIFVTRSBUSElTIFdJVEggQ0FVVElPTiFcbiAgICogQGludGVybmFsXG4gICAqIEBoaWRkZW5cbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgIGlzU3RhbmRhbG9uZVNwYW4oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faXNTdGFuZGFsb25lU3BhbjtcbiAgfVxuXG4gIC8qKiBFbWl0IGBzcGFuRW5kYCB3aGVuIHRoZSBzcGFuIGlzIGVuZGVkLiAqL1xuICAgX29uU3BhbkVuZGVkKCkge1xuICAgIGNvbnN0IGNsaWVudCA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG4gICAgaWYgKGNsaWVudCkge1xuICAgICAgY2xpZW50LmVtaXQoJ3NwYW5FbmQnLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBBIHNlZ21lbnQgc3BhbiBpcyBiYXNpY2FsbHkgdGhlIHJvb3Qgc3BhbiBvZiBhIGxvY2FsIHNwYW4gdHJlZS5cbiAgICAvLyBTbyBmb3Igbm93LCB0aGlzIGlzIGVpdGhlciB3aGF0IHdlIHByZXZpb3VzbHkgcmVmZXIgdG8gYXMgdGhlIHJvb3Qgc3BhbixcbiAgICAvLyBvciBhIHN0YW5kYWxvbmUgc3Bhbi5cbiAgICBjb25zdCBpc1NlZ21lbnRTcGFuID0gdGhpcy5faXNTdGFuZGFsb25lU3BhbiB8fCB0aGlzID09PSBzcGFuVXRpbHMuZ2V0Um9vdFNwYW4odGhpcyk7XG5cbiAgICBpZiAoIWlzU2VnbWVudFNwYW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgc3RhbmRhbG9uZSBzcGFuLCB3ZSBzZW5kIGl0IGltbWVkaWF0ZWx5XG4gICAgaWYgKHRoaXMuX2lzU3RhbmRhbG9uZVNwYW4pIHtcbiAgICAgIGlmICh0aGlzLl9zYW1wbGVkKSB7XG4gICAgICAgIHNlbmRTcGFuRW52ZWxvcGUoZW52ZWxvcGUuY3JlYXRlU3BhbkVudmVsb3BlKFt0aGlzXSwgY2xpZW50KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmXG4gICAgICAgICAgbG9nZ2VyLmxvZ2dlci5sb2coJ1tUcmFjaW5nXSBEaXNjYXJkaW5nIHN0YW5kYWxvbmUgc3BhbiBiZWNhdXNlIGl0cyB0cmFjZSB3YXMgbm90IGNob3NlbiB0byBiZSBzYW1wbGVkLicpO1xuICAgICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgICAgY2xpZW50LnJlY29yZERyb3BwZWRFdmVudCgnc2FtcGxlX3JhdGUnLCAnc3BhbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNhY3Rpb25FdmVudCA9IHRoaXMuX2NvbnZlcnRTcGFuVG9UcmFuc2FjdGlvbigpO1xuICAgIGlmICh0cmFuc2FjdGlvbkV2ZW50KSB7XG4gICAgICBjb25zdCBzY29wZSA9IHV0aWxzLmdldENhcHR1cmVkU2NvcGVzT25TcGFuKHRoaXMpLnNjb3BlIHx8IGN1cnJlbnRTY29wZXMuZ2V0Q3VycmVudFNjb3BlKCk7XG4gICAgICBzY29wZS5jYXB0dXJlRXZlbnQodHJhbnNhY3Rpb25FdmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmlzaCB0aGUgdHJhbnNhY3Rpb24gJiBwcmVwYXJlIHRoZSBldmVudCB0byBzZW5kIHRvIFNlbnRyeS5cbiAgICovXG4gICBfY29udmVydFNwYW5Ub1RyYW5zYWN0aW9uKCkge1xuICAgIC8vIFdlIGNhbiBvbmx5IGNvbnZlcnQgZmluaXNoZWQgc3BhbnNcbiAgICBpZiAoIWlzRnVsbEZpbmlzaGVkU3BhbihzcGFuVXRpbHMuc3BhblRvSlNPTih0aGlzKSkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9uYW1lKSB7XG4gICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIud2FybignVHJhbnNhY3Rpb24gaGFzIG5vIG5hbWUsIGZhbGxpbmcgYmFjayB0byBgPHVubGFiZWxlZCB0cmFuc2FjdGlvbj5gLicpO1xuICAgICAgdGhpcy5fbmFtZSA9ICc8dW5sYWJlbGVkIHRyYW5zYWN0aW9uPic7XG4gICAgfVxuXG4gICAgY29uc3QgeyBzY29wZTogY2FwdHVyZWRTcGFuU2NvcGUsIGlzb2xhdGlvblNjb3BlOiBjYXB0dXJlZFNwYW5Jc29sYXRpb25TY29wZSB9ID0gdXRpbHMuZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4odGhpcyk7XG5cbiAgICBjb25zdCBub3JtYWxpemVkUmVxdWVzdCA9IGNhcHR1cmVkU3BhblNjb3BlPy5nZXRTY29wZURhdGEoKS5zZGtQcm9jZXNzaW5nTWV0YWRhdGE/Lm5vcm1hbGl6ZWRSZXF1ZXN0O1xuXG4gICAgaWYgKHRoaXMuX3NhbXBsZWQgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gVGhlIHRyYW5zYWN0aW9uIHNwYW4gaXRzZWxmIGFzIHdlbGwgYXMgYW55IHBvdGVudGlhbCBzdGFuZGFsb25lIHNwYW5zIHNob3VsZCBiZSBmaWx0ZXJlZCBvdXRcbiAgICBjb25zdCBmaW5pc2hlZFNwYW5zID0gc3BhblV0aWxzLmdldFNwYW5EZXNjZW5kYW50cyh0aGlzKS5maWx0ZXIoc3BhbiA9PiBzcGFuICE9PSB0aGlzICYmICFpc1N0YW5kYWxvbmVTcGFuKHNwYW4pKTtcblxuICAgIGNvbnN0IHNwYW5zID0gZmluaXNoZWRTcGFucy5tYXAoc3BhbiA9PiBzcGFuVXRpbHMuc3BhblRvSlNPTihzcGFuKSkuZmlsdGVyKGlzRnVsbEZpbmlzaGVkU3Bhbik7XG5cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLl9hdHRyaWJ1dGVzW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV0gO1xuXG4gICAgLy8gcmVtb3ZlIGludGVybmFsIHJvb3Qgc3BhbiBhdHRyaWJ1dGVzIHdlIGRvbid0IG5lZWQgdG8gc2VuZC5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGUgKi9cbiAgICBkZWxldGUgdGhpcy5fYXR0cmlidXRlc1tzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FXTtcbiAgICBzcGFucy5mb3JFYWNoKHNwYW4gPT4ge1xuICAgICAgZGVsZXRlIHNwYW4uZGF0YVtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FXTtcbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZW5hYmxlZC1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgIGNvbnRleHRzOiB7XG4gICAgICAgIHRyYWNlOiBzcGFuVXRpbHMuc3BhblRvVHJhbnNhY3Rpb25UcmFjZUNvbnRleHQodGhpcyksXG4gICAgICB9LFxuICAgICAgc3BhbnM6XG4gICAgICAgIC8vIHNwYW5zLnNvcnQoKSBtdXRhdGVzIHRoZSBhcnJheSwgYnV0IGBzcGFuc2AgaXMgYWxyZWFkeSBhIGNvcHkgc28gd2UgY2FuIHNhZmVseSBkbyB0aGlzIGhlcmVcbiAgICAgICAgLy8gd2UgZG8gbm90IHVzZSBzcGFucyBhbnltb3JlIGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgc3BhbnMubGVuZ3RoID4gTUFYX1NQQU5fQ09VTlRcbiAgICAgICAgICA/IHNwYW5zLnNvcnQoKGEsIGIpID0+IGEuc3RhcnRfdGltZXN0YW1wIC0gYi5zdGFydF90aW1lc3RhbXApLnNsaWNlKDAsIE1BWF9TUEFOX0NPVU5UKVxuICAgICAgICAgIDogc3BhbnMsXG4gICAgICBzdGFydF90aW1lc3RhbXA6IHRoaXMuX3N0YXJ0VGltZSxcbiAgICAgIHRpbWVzdGFtcDogdGhpcy5fZW5kVGltZSxcbiAgICAgIHRyYW5zYWN0aW9uOiB0aGlzLl9uYW1lLFxuICAgICAgdHlwZTogJ3RyYW5zYWN0aW9uJyxcbiAgICAgIHNka1Byb2Nlc3NpbmdNZXRhZGF0YToge1xuICAgICAgICBjYXB0dXJlZFNwYW5TY29wZSxcbiAgICAgICAgY2FwdHVyZWRTcGFuSXNvbGF0aW9uU2NvcGUsXG4gICAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQ6IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHRoaXMpLFxuICAgICAgfSxcbiAgICAgIHJlcXVlc3Q6IG5vcm1hbGl6ZWRSZXF1ZXN0LFxuICAgICAgLi4uKHNvdXJjZSAmJiB7XG4gICAgICAgIHRyYW5zYWN0aW9uX2luZm86IHtcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICB9O1xuXG4gICAgY29uc3QgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnQudGltZWRFdmVudHNUb01lYXN1cmVtZW50cyh0aGlzLl9ldmVudHMpO1xuICAgIGNvbnN0IGhhc01lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyAmJiBPYmplY3Qua2V5cyhtZWFzdXJlbWVudHMpLmxlbmd0aDtcblxuICAgIGlmIChoYXNNZWFzdXJlbWVudHMpIHtcbiAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiZcbiAgICAgICAgbG9nZ2VyLmxvZ2dlci5sb2coXG4gICAgICAgICAgJ1tNZWFzdXJlbWVudHNdIEFkZGluZyBtZWFzdXJlbWVudHMgdG8gdHJhbnNhY3Rpb24gZXZlbnQnLFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG1lYXN1cmVtZW50cywgdW5kZWZpbmVkLCAyKSxcbiAgICAgICAgKTtcbiAgICAgIHRyYW5zYWN0aW9uLm1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTcGFuVGltZUlucHV0KHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuXG4vLyBXZSB3YW50IHRvIGZpbHRlciBvdXQgYW55IGluY29tcGxldGUgU3BhbkpTT04gb2JqZWN0c1xuZnVuY3Rpb24gaXNGdWxsRmluaXNoZWRTcGFuKGlucHV0KSB7XG4gIHJldHVybiAhIWlucHV0LnN0YXJ0X3RpbWVzdGFtcCAmJiAhIWlucHV0LnRpbWVzdGFtcCAmJiAhIWlucHV0LnNwYW5faWQgJiYgISFpbnB1dC50cmFjZV9pZDtcbn1cblxuLyoqIGBTZW50cnlTcGFuYHMgY2FuIGJlIHNlbnQgYXMgYSBzdGFuZGFsb25lIHNwYW4gcmF0aGVyIHRoYW4gYmVsb25naW5nIHRvIGEgdHJhbnNhY3Rpb24gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhbG9uZVNwYW4oc3Bhbikge1xuICByZXR1cm4gc3BhbiBpbnN0YW5jZW9mIFNlbnRyeVNwYW4gJiYgc3Bhbi5pc1N0YW5kYWxvbmVTcGFuKCk7XG59XG5cbi8qKlxuICogU2VuZHMgYSBgU3BhbkVudmVsb3BlYC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgZW52ZWxvcGUncyBzcGFucyBhcmUgZHJvcHBlZCwgZS5nLiB2aWEgYGJlZm9yZVNlbmRTcGFuYCxcbiAqIHRoZSBlbnZlbG9wZSB3aWxsIG5vdCBiZSBzZW50IGVpdGhlci5cbiAqL1xuZnVuY3Rpb24gc2VuZFNwYW5FbnZlbG9wZShlbnZlbG9wZSkge1xuICBjb25zdCBjbGllbnQgPSBjdXJyZW50U2NvcGVzLmdldENsaWVudCgpO1xuICBpZiAoIWNsaWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHNwYW5JdGVtcyA9IGVudmVsb3BlWzFdO1xuICBpZiAoIXNwYW5JdGVtcyB8fCBzcGFuSXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgY2xpZW50LnJlY29yZERyb3BwZWRFdmVudCgnYmVmb3JlX3NlbmQnLCAnc3BhbicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNlbmRFbnZlbG9wZSBzaG91bGQgbm90IHRocm93XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgY2xpZW50LnNlbmRFbnZlbG9wZShlbnZlbG9wZSk7XG59XG5cbmV4cG9ydHMuU2VudHJ5U3BhbiA9IFNlbnRyeVNwYW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW50cnlTcGFuLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sentrySpan.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js":(__unused_webpack_module,exports)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst SPAN_STATUS_UNSET = 0;\nconst SPAN_STATUS_OK = 1;\nconst SPAN_STATUS_ERROR = 2;\n\n/**\n * Converts a HTTP status code into a sentry status with a message.\n *\n * @param httpStatus The HTTP response status code.\n * @returns The span status or unknown_error.\n */\n// https://develop.sentry.dev/sdk/event-payloads/span/\nfunction getSpanStatusFromHttpCode(httpStatus) {\n  if (httpStatus < 400 && httpStatus >= 100) {\n    return { code: SPAN_STATUS_OK };\n  }\n\n  if (httpStatus >= 400 && httpStatus < 500) {\n    switch (httpStatus) {\n      case 401:\n        return { code: SPAN_STATUS_ERROR, message: 'unauthenticated' };\n      case 403:\n        return { code: SPAN_STATUS_ERROR, message: 'permission_denied' };\n      case 404:\n        return { code: SPAN_STATUS_ERROR, message: 'not_found' };\n      case 409:\n        return { code: SPAN_STATUS_ERROR, message: 'already_exists' };\n      case 413:\n        return { code: SPAN_STATUS_ERROR, message: 'failed_precondition' };\n      case 429:\n        return { code: SPAN_STATUS_ERROR, message: 'resource_exhausted' };\n      case 499:\n        return { code: SPAN_STATUS_ERROR, message: 'cancelled' };\n      default:\n        return { code: SPAN_STATUS_ERROR, message: 'invalid_argument' };\n    }\n  }\n\n  if (httpStatus >= 500 && httpStatus < 600) {\n    switch (httpStatus) {\n      case 501:\n        return { code: SPAN_STATUS_ERROR, message: 'unimplemented' };\n      case 503:\n        return { code: SPAN_STATUS_ERROR, message: 'unavailable' };\n      case 504:\n        return { code: SPAN_STATUS_ERROR, message: 'deadline_exceeded' };\n      default:\n        return { code: SPAN_STATUS_ERROR, message: 'internal_error' };\n    }\n  }\n\n  return { code: SPAN_STATUS_ERROR, message: 'unknown_error' };\n}\n\n/**\n * Sets the Http status attributes on the current span based on the http code.\n * Additionally, the span's status is updated, depending on the http code.\n */\nfunction setHttpStatus(span, httpStatus) {\n  span.setAttribute('http.response.status_code', httpStatus);\n\n  const spanStatus = getSpanStatusFromHttpCode(httpStatus);\n  if (spanStatus.message !== 'unknown_error') {\n    span.setStatus(spanStatus);\n  }\n}\n\nexports.SPAN_STATUS_ERROR = SPAN_STATUS_ERROR;\nexports.SPAN_STATUS_OK = SPAN_STATUS_OK;\nexports.SPAN_STATUS_UNSET = SPAN_STATUS_UNSET;\nexports.getSpanStatusFromHttpCode = getSpanStatusFromHttpCode;\nexports.setHttpStatus = setHttpStatus;\n//# sourceMappingURL=spanstatus.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhY2luZy9zcGFuc3RhdHVzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIseUJBQXlCO0FBQ3pCLGlDQUFpQztBQUNqQyxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnlcXG5leHRqc1xcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxjb3JlXFxidWlsZFxcY2pzXFx0cmFjaW5nXFxzcGFuc3RhdHVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBTUEFOX1NUQVRVU19VTlNFVCA9IDA7XG5jb25zdCBTUEFOX1NUQVRVU19PSyA9IDE7XG5jb25zdCBTUEFOX1NUQVRVU19FUlJPUiA9IDI7XG5cbi8qKlxuICogQ29udmVydHMgYSBIVFRQIHN0YXR1cyBjb2RlIGludG8gYSBzZW50cnkgc3RhdHVzIHdpdGggYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBodHRwU3RhdHVzIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuICogQHJldHVybnMgVGhlIHNwYW4gc3RhdHVzIG9yIHVua25vd25fZXJyb3IuXG4gKi9cbi8vIGh0dHBzOi8vZGV2ZWxvcC5zZW50cnkuZGV2L3Nkay9ldmVudC1wYXlsb2Fkcy9zcGFuL1xuZnVuY3Rpb24gZ2V0U3BhblN0YXR1c0Zyb21IdHRwQ29kZShodHRwU3RhdHVzKSB7XG4gIGlmIChodHRwU3RhdHVzIDwgNDAwICYmIGh0dHBTdGF0dXMgPj0gMTAwKSB7XG4gICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfT0sgfTtcbiAgfVxuXG4gIGlmIChodHRwU3RhdHVzID49IDQwMCAmJiBodHRwU3RhdHVzIDwgNTAwKSB7XG4gICAgc3dpdGNoIChodHRwU3RhdHVzKSB7XG4gICAgICBjYXNlIDQwMTpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICd1bmF1dGhlbnRpY2F0ZWQnIH07XG4gICAgICBjYXNlIDQwMzpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICdwZXJtaXNzaW9uX2RlbmllZCcgfTtcbiAgICAgIGNhc2UgNDA0OlxuICAgICAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ25vdF9mb3VuZCcgfTtcbiAgICAgIGNhc2UgNDA5OlxuICAgICAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ2FscmVhZHlfZXhpc3RzJyB9O1xuICAgICAgY2FzZSA0MTM6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnZmFpbGVkX3ByZWNvbmRpdGlvbicgfTtcbiAgICAgIGNhc2UgNDI5OlxuICAgICAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ3Jlc291cmNlX2V4aGF1c3RlZCcgfTtcbiAgICAgIGNhc2UgNDk5OlxuICAgICAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ2NhbmNlbGxlZCcgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnaW52YWxpZF9hcmd1bWVudCcgfTtcbiAgICB9XG4gIH1cblxuICBpZiAoaHR0cFN0YXR1cyA+PSA1MDAgJiYgaHR0cFN0YXR1cyA8IDYwMCkge1xuICAgIHN3aXRjaCAoaHR0cFN0YXR1cykge1xuICAgICAgY2FzZSA1MDE6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAndW5pbXBsZW1lbnRlZCcgfTtcbiAgICAgIGNhc2UgNTAzOlxuICAgICAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ3VuYXZhaWxhYmxlJyB9O1xuICAgICAgY2FzZSA1MDQ6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnZGVhZGxpbmVfZXhjZWVkZWQnIH07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ2ludGVybmFsX2Vycm9yJyB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAndW5rbm93bl9lcnJvcicgfTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBIdHRwIHN0YXR1cyBhdHRyaWJ1dGVzIG9uIHRoZSBjdXJyZW50IHNwYW4gYmFzZWQgb24gdGhlIGh0dHAgY29kZS5cbiAqIEFkZGl0aW9uYWxseSwgdGhlIHNwYW4ncyBzdGF0dXMgaXMgdXBkYXRlZCwgZGVwZW5kaW5nIG9uIHRoZSBodHRwIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHNldEh0dHBTdGF0dXMoc3BhbiwgaHR0cFN0YXR1cykge1xuICBzcGFuLnNldEF0dHJpYnV0ZSgnaHR0cC5yZXNwb25zZS5zdGF0dXNfY29kZScsIGh0dHBTdGF0dXMpO1xuXG4gIGNvbnN0IHNwYW5TdGF0dXMgPSBnZXRTcGFuU3RhdHVzRnJvbUh0dHBDb2RlKGh0dHBTdGF0dXMpO1xuICBpZiAoc3BhblN0YXR1cy5tZXNzYWdlICE9PSAndW5rbm93bl9lcnJvcicpIHtcbiAgICBzcGFuLnNldFN0YXR1cyhzcGFuU3RhdHVzKTtcbiAgfVxufVxuXG5leHBvcnRzLlNQQU5fU1RBVFVTX0VSUk9SID0gU1BBTl9TVEFUVVNfRVJST1I7XG5leHBvcnRzLlNQQU5fU1RBVFVTX09LID0gU1BBTl9TVEFUVVNfT0s7XG5leHBvcnRzLlNQQU5fU1RBVFVTX1VOU0VUID0gU1BBTl9TVEFUVVNfVU5TRVQ7XG5leHBvcnRzLmdldFNwYW5TdGF0dXNGcm9tSHR0cENvZGUgPSBnZXRTcGFuU3RhdHVzRnJvbUh0dHBDb2RlO1xuZXhwb3J0cy5zZXRIdHRwU3RhdHVzID0gc2V0SHR0cFN0YXR1cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwYW5zdGF0dXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/trace.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n\nconst index = __webpack_require__(/*! ../asyncContext/index.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/asyncContext/index.js");\nconst carrier = __webpack_require__(/*! ../carrier.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/carrier.js");\nconst currentScopes = __webpack_require__(/*! ../currentScopes.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js");\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js");\nconst semanticAttributes = __webpack_require__(/*! ../semanticAttributes.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/semanticAttributes.js");\nconst handleCallbackErrors = __webpack_require__(/*! ../utils/handleCallbackErrors.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/handleCallbackErrors.js");\nconst hasSpansEnabled = __webpack_require__(/*! ../utils/hasSpansEnabled.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/hasSpansEnabled.js");\nconst parseSampleRate = __webpack_require__(/*! ../utils/parseSampleRate.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/parseSampleRate.js");\nconst spanOnScope = __webpack_require__(/*! ../utils/spanOnScope.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanOnScope.js");\nconst spanUtils = __webpack_require__(/*! ../utils/spanUtils.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils/spanUtils.js");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js");\nconst propagationContext = __webpack_require__(/*! ../utils-hoist/propagationContext.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/propagationContext.js");\nconst tracing = __webpack_require__(/*! ../utils-hoist/tracing.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/tracing.js");\nconst dynamicSamplingContext = __webpack_require__(/*! ./dynamicSamplingContext.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/dynamicSamplingContext.js");\nconst logSpans = __webpack_require__(/*! ./logSpans.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/logSpans.js");\nconst sampling = __webpack_require__(/*! ./sampling.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sampling.js");\nconst sentryNonRecordingSpan = __webpack_require__(/*! ./sentryNonRecordingSpan.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sentryNonRecordingSpan.js");\nconst sentrySpan = __webpack_require__(/*! ./sentrySpan.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/sentrySpan.js");\nconst spanstatus = __webpack_require__(/*! ./spanstatus.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/spanstatus.js");\nconst utils = __webpack_require__(/*! ./utils.js */ "(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/utils.js");\n\n/* eslint-disable max-lines */\n\n\nconst SUPPRESS_TRACING_KEY = \'__SENTRY_SUPPRESS_TRACING__\';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You\'ll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpan(options, callback) {\n  const acs = getAcs();\n  if (acs.startSpan) {\n    return acs.startSpan(options, callback);\n  }\n\n  const spanArguments = parseSentrySpanArguments(options);\n  const { forceTransaction, parentSpan: customParentSpan, scope: customScope } = options;\n\n  // We still need to fork a potentially passed scope, as we set the active span on it\n  // and we need to ensure that it is cleaned up properly once the span ends.\n  const customForkedScope = customScope?.clone();\n\n  return currentScopes.withScope(customForkedScope, () => {\n    // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n    const wrapper = getActiveSpanWrapper(customParentSpan);\n\n    return wrapper(() => {\n      const scope = currentScopes.getCurrentScope();\n      const parentSpan = getParentSpan(scope);\n\n      const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan\n        ? new sentryNonRecordingSpan.SentryNonRecordingSpan()\n        : createChildOrRootSpan({\n            parentSpan,\n            spanArguments,\n            forceTransaction,\n            scope,\n          });\n\n      spanOnScope._setSpanForScope(scope, activeSpan);\n\n      return handleCallbackErrors.handleCallbackErrors(\n        () => callback(activeSpan),\n        () => {\n          // Only update the span status if it hasn\'t been changed yet, and the span is not yet finished\n          const { status } = spanUtils.spanToJSON(activeSpan);\n          if (activeSpan.isRecording() && (!status || status === \'ok\')) {\n            activeSpan.setStatus({ code: spanstatus.SPAN_STATUS_ERROR, message: \'internal_error\' });\n          }\n        },\n        () => {\n          activeSpan.end();\n        },\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a transaction/span, but does not finish the span\n * after the function is done automatically. Use `span.end()` to end the span.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You\'ll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpanManual(options, callback) {\n  const acs = getAcs();\n  if (acs.startSpanManual) {\n    return acs.startSpanManual(options, callback);\n  }\n\n  const spanArguments = parseSentrySpanArguments(options);\n  const { forceTransaction, parentSpan: customParentSpan, scope: customScope } = options;\n\n  const customForkedScope = customScope?.clone();\n\n  return currentScopes.withScope(customForkedScope, () => {\n    // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n    const wrapper = getActiveSpanWrapper(customParentSpan);\n\n    return wrapper(() => {\n      const scope = currentScopes.getCurrentScope();\n      const parentSpan = getParentSpan(scope);\n\n      const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan\n        ? new sentryNonRecordingSpan.SentryNonRecordingSpan()\n        : createChildOrRootSpan({\n            parentSpan,\n            spanArguments,\n            forceTransaction,\n            scope,\n          });\n\n      spanOnScope._setSpanForScope(scope, activeSpan);\n\n      return handleCallbackErrors.handleCallbackErrors(\n        // We pass the `finish` function to the callback, so the user can finish the span manually\n        // this is mainly here for historic purposes because previously, we instructed users to call\n        // `finish` instead of `span.end()` to also clean up the scope. Nowadays, calling `span.end()`\n        // or `finish` has the same effect and we simply leave it here to avoid breaking user code.\n        () => callback(activeSpan, () => activeSpan.end()),\n        () => {\n          // Only update the span status if it hasn\'t been changed yet, and the span is not yet finished\n          const { status } = spanUtils.spanToJSON(activeSpan);\n          if (activeSpan.isRecording() && (!status || status === \'ok\')) {\n            activeSpan.setStatus({ code: spanstatus.SPAN_STATUS_ERROR, message: \'internal_error\' });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startInactiveSpan(options) {\n  const acs = getAcs();\n  if (acs.startInactiveSpan) {\n    return acs.startInactiveSpan(options);\n  }\n\n  const spanArguments = parseSentrySpanArguments(options);\n  const { forceTransaction, parentSpan: customParentSpan } = options;\n\n  // If `options.scope` is defined, we use this as as a wrapper,\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = options.scope\n    ? (callback) => currentScopes.withScope(options.scope, callback)\n    : customParentSpan !== undefined\n      ? (callback) => withActiveSpan(customParentSpan, callback)\n      : (callback) => callback();\n\n  return wrapper(() => {\n    const scope = currentScopes.getCurrentScope();\n    const parentSpan = getParentSpan(scope);\n\n    const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n\n    if (shouldSkipSpan) {\n      return new sentryNonRecordingSpan.SentryNonRecordingSpan();\n    }\n\n    return createChildOrRootSpan({\n      parentSpan,\n      spanArguments,\n      forceTransaction,\n      scope,\n    });\n  });\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name="sentry-trace">`\n * and `<meta name="baggage">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n */\nconst continueTrace = (\n  options\n\n,\n  callback,\n) => {\n  const carrier$1 = carrier.getMainCarrier();\n  const acs = index.getAsyncContextStrategy(carrier$1);\n  if (acs.continueTrace) {\n    return acs.continueTrace(options, callback);\n  }\n\n  const { sentryTrace, baggage } = options;\n\n  return currentScopes.withScope(scope => {\n    const propagationContext = tracing.propagationContextFromHeaders(sentryTrace, baggage);\n    scope.setPropagationContext(propagationContext);\n    return callback();\n  });\n};\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will not be attached to a parent span.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nfunction withActiveSpan(span, callback) {\n  const acs = getAcs();\n  if (acs.withActiveSpan) {\n    return acs.withActiveSpan(span, callback);\n  }\n\n  return currentScopes.withScope(scope => {\n    spanOnScope._setSpanForScope(scope, span || undefined);\n    return callback(scope);\n  });\n}\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nfunction suppressTracing(callback) {\n  const acs = getAcs();\n\n  if (acs.suppressTracing) {\n    return acs.suppressTracing(callback);\n  }\n\n  return currentScopes.withScope(scope => {\n    // Note: We do not wait for the callback to finish before we reset the metadata\n    // the reason for this is that otherwise, in the browser this can lead to very weird behavior\n    // as there is only a single top scope, if the callback takes longer to finish,\n    // other, unrelated spans may also be suppressed, which we do not want\n    // so instead, we only suppress tracing synchronoysly in the browser\n    scope.setSDKProcessingMetadata({ [SUPPRESS_TRACING_KEY]: true });\n    const res = callback();\n    scope.setSDKProcessingMetadata({ [SUPPRESS_TRACING_KEY]: undefined });\n    return res;\n  });\n}\n\n/**\n * Starts a new trace for the duration of the provided callback. Spans started within the\n * callback will be part of the new trace instead of a potentially previously started trace.\n *\n * Important: Only use this function if you want to override the default trace lifetime and\n * propagation mechanism of the SDK for the duration and scope of the provided callback.\n * The newly created trace will also be the root of a new distributed trace, for example if\n * you make http requests within the callback.\n * This function might be useful if the operation you want to instrument should not be part\n * of a potentially ongoing trace.\n *\n * Default behavior:\n * - Server-side: A new trace is started for each incoming request.\n * - Browser: A new trace is started for each page our route. Navigating to a new route\n *            or page will automatically create a new trace.\n */\nfunction startNewTrace(callback) {\n  return currentScopes.withScope(scope => {\n    scope.setPropagationContext({\n      traceId: propagationContext.generateTraceId(),\n      sampleRand: Math.random(),\n    });\n    debugBuild.DEBUG_BUILD && logger.logger.info(`Starting a new trace with id ${scope.getPropagationContext().traceId}`);\n    return withActiveSpan(null, callback);\n  });\n}\n\nfunction createChildOrRootSpan({\n  parentSpan,\n  spanArguments,\n  forceTransaction,\n  scope,\n}\n\n) {\n  if (!hasSpansEnabled.hasSpansEnabled()) {\n    const span = new sentryNonRecordingSpan.SentryNonRecordingSpan();\n\n    // If this is a root span, we ensure to freeze a DSC\n    // So we can have at least partial data here\n    if (forceTransaction || !parentSpan) {\n      const dsc = {\n        sampled: \'false\',\n        sample_rate: \'0\',\n        transaction: spanArguments.name,\n        ...dynamicSamplingContext.getDynamicSamplingContextFromSpan(span),\n      } ;\n      dynamicSamplingContext.freezeDscOnSpan(span, dsc);\n    }\n\n    return span;\n  }\n\n  const isolationScope = currentScopes.getIsolationScope();\n\n  let span;\n  if (parentSpan && !forceTransaction) {\n    span = _startChildSpan(parentSpan, scope, spanArguments);\n    spanUtils.addChildSpanToSpan(parentSpan, span);\n  } else if (parentSpan) {\n    // If we forced a transaction but have a parent span, make sure to continue from the parent span, not the scope\n    const dsc = dynamicSamplingContext.getDynamicSamplingContextFromSpan(parentSpan);\n    const { traceId, spanId: parentSpanId } = parentSpan.spanContext();\n    const parentSampled = spanUtils.spanIsSampled(parentSpan);\n\n    span = _startRootSpan(\n      {\n        traceId,\n        parentSpanId,\n        ...spanArguments,\n      },\n      scope,\n      parentSampled,\n    );\n\n    dynamicSamplingContext.freezeDscOnSpan(span, dsc);\n  } else {\n    const {\n      traceId,\n      dsc,\n      parentSpanId,\n      sampled: parentSampled,\n    } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext(),\n    };\n\n    span = _startRootSpan(\n      {\n        traceId,\n        parentSpanId,\n        ...spanArguments,\n      },\n      scope,\n      parentSampled,\n    );\n\n    if (dsc) {\n      dynamicSamplingContext.freezeDscOnSpan(span, dsc);\n    }\n  }\n\n  logSpans.logSpanStart(span);\n\n  utils.setCapturedScopesOnSpan(span, scope, isolationScope);\n\n  return span;\n}\n\n/**\n * This converts StartSpanOptions to SentrySpanArguments.\n * For the most part (for now) we accept the same options,\n * but some of them need to be transformed.\n */\nfunction parseSentrySpanArguments(options) {\n  const exp = options.experimental || {};\n  const initialCtx = {\n    isStandalone: exp.standalone,\n    ...options,\n  };\n\n  if (options.startTime) {\n    const ctx = { ...initialCtx };\n    ctx.startTimestamp = spanUtils.spanTimeInputToSeconds(options.startTime);\n    delete ctx.startTime;\n    return ctx;\n  }\n\n  return initialCtx;\n}\n\nfunction getAcs() {\n  const carrier$1 = carrier.getMainCarrier();\n  return index.getAsyncContextStrategy(carrier$1);\n}\n\nfunction _startRootSpan(spanArguments, scope, parentSampled) {\n  const client = currentScopes.getClient();\n  const options = client?.getOptions() || {};\n\n  const { name = \'\' } = spanArguments;\n\n  const mutableSpanSamplingData = { spanAttributes: { ...spanArguments.attributes }, spanName: name, parentSampled };\n\n  // we don\'t care about the decision for the moment; this is just a placeholder\n  client?.emit(\'beforeSampling\', mutableSpanSamplingData, { decision: false });\n\n  // If hook consumers override the parentSampled flag, we will use that value instead of the actual one\n  const finalParentSampled = mutableSpanSamplingData.parentSampled ?? parentSampled;\n  const finalAttributes = mutableSpanSamplingData.spanAttributes;\n\n  const currentPropagationContext = scope.getPropagationContext();\n  const [sampled, sampleRate, localSampleRateWasApplied] = scope.getScopeData().sdkProcessingMetadata[\n    SUPPRESS_TRACING_KEY\n  ]\n    ? [false]\n    : sampling.sampleSpan(\n        options,\n        {\n          name,\n          parentSampled: finalParentSampled,\n          attributes: finalAttributes,\n          parentSampleRate: parseSampleRate.parseSampleRate(currentPropagationContext.dsc?.sample_rate),\n        },\n        currentPropagationContext.sampleRand,\n      );\n\n  const rootSpan = new sentrySpan.SentrySpan({\n    ...spanArguments,\n    attributes: {\n      [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: \'custom\',\n      [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]:\n        sampleRate !== undefined && localSampleRateWasApplied ? sampleRate : undefined,\n      ...finalAttributes,\n    },\n    sampled,\n  });\n\n  if (!sampled && client) {\n    debugBuild.DEBUG_BUILD && logger.logger.log(\'[Tracing] Discarding root span because its trace was not chosen to be sampled.\');\n    client.recordDroppedEvent(\'sample_rate\', \'transaction\');\n  }\n\n  if (client) {\n    client.emit(\'spanStart\', rootSpan);\n  }\n\n  return rootSpan;\n}\n\n/**\n * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.\n * This inherits the sampling decision from the parent span.\n */\nfunction _startChildSpan(parentSpan, scope, spanArguments) {\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? false : spanUtils.spanIsSampled(parentSpan);\n\n  const childSpan = sampled\n    ? new sentrySpan.SentrySpan({\n        ...spanArguments,\n        parentSpanId: spanId,\n        traceId,\n        sampled,\n      })\n    : new sentryNonRecordingSpan.SentryNonRecordingSpan({ traceId });\n\n  spanUtils.addChildSpanToSpan(parentSpan, childSpan);\n\n  const client = currentScopes.getClient();\n  if (client) {\n    client.emit(\'spanStart\', childSpan);\n    // If it has an endTimestamp, it\'s already ended\n    if (spanArguments.endTimestamp) {\n      client.emit(\'spanEnd\', childSpan);\n    }\n  }\n\n  return childSpan;\n}\n\nfunction getParentSpan(scope) {\n  const span = spanOnScope._getSpanForScope(scope) ;\n\n  if (!span) {\n    return undefined;\n  }\n\n  const client = currentScopes.getClient();\n  const options = client ? client.getOptions() : {};\n  if (options.parentSpanIsAlwaysRootSpan) {\n    return spanUtils.getRootSpan(span) ;\n  }\n\n  return span;\n}\n\nfunction getActiveSpanWrapper(parentSpan) {\n  return parentSpan !== undefined\n    ? (callback) => {\n        return withActiveSpan(parentSpan, callback);\n      }\n    : (callback) => callback();\n}\n\nexports.continueTrace = continueTrace;\nexports.startInactiveSpan = startInactiveSpan;\nexports.startNewTrace = startNewTrace;\nexports.startSpan = startSpan;\nexports.startSpanManual = startSpanManual;\nexports.suppressTracing = suppressTracing;\nexports.withActiveSpan = withActiveSpan;\n//# sourceMappingURL=trace.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhY2luZy90cmFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxjQUFjLG1CQUFPLENBQUMsK0hBQTBCO0FBQ2hELGdCQUFnQixtQkFBTyxDQUFDLHlHQUFlO0FBQ3ZDLHNCQUFzQixtQkFBTyxDQUFDLHFIQUFxQjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyxpSEFBbUI7QUFDOUMsMkJBQTJCLG1CQUFPLENBQUMsK0hBQTBCO0FBQzdELDZCQUE2QixtQkFBTyxDQUFDLCtJQUFrQztBQUN2RSx3QkFBd0IsbUJBQU8sQ0FBQyxxSUFBNkI7QUFDN0Qsd0JBQXdCLG1CQUFPLENBQUMscUlBQTZCO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLDZIQUF5QjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyx5SEFBdUI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLCtIQUEwQjtBQUNqRCwyQkFBMkIsbUJBQU8sQ0FBQyx1SkFBc0M7QUFDekUsZ0JBQWdCLG1CQUFPLENBQUMsaUlBQTJCO0FBQ25ELCtCQUErQixtQkFBTyxDQUFDLDhJQUE2QjtBQUNwRSxpQkFBaUIsbUJBQU8sQ0FBQyxrSEFBZTtBQUN4QyxpQkFBaUIsbUJBQU8sQ0FBQyxrSEFBZTtBQUN4QywrQkFBK0IsbUJBQU8sQ0FBQyw4SUFBNkI7QUFDcEUsbUJBQW1CLG1CQUFPLENBQUMsc0hBQWlCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLHNIQUFpQjtBQUM1QyxjQUFjLG1CQUFPLENBQUMsNEdBQVk7O0FBRWxDOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHdCQUF3QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLHFFQUFxRTs7QUFFL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBLG1DQUFtQywrREFBK0Q7QUFDbEc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxxRUFBcUU7O0FBRS9FOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0EsbUNBQW1DLCtEQUErRDtBQUNsRztBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsaURBQWlEOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSx1QkFBdUI7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDhCQUE4QjtBQUNuRTtBQUNBLHFDQUFxQyxtQ0FBbUM7QUFDeEU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlGQUFpRixzQ0FBc0M7QUFDdkg7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFlBQVk7O0FBRXRCLG9DQUFvQyxrQkFBa0IsNkJBQTZCOztBQUVuRixzREFBc0Q7QUFDdEQsNERBQTRELGlCQUFpQjs7QUFFN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDBEQUEwRCxTQUFTOztBQUVuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXHRyYWNpbmdcXHRyYWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBpbmRleCA9IHJlcXVpcmUoJy4uL2FzeW5jQ29udGV4dC9pbmRleC5qcycpO1xuY29uc3QgY2FycmllciA9IHJlcXVpcmUoJy4uL2NhcnJpZXIuanMnKTtcbmNvbnN0IGN1cnJlbnRTY29wZXMgPSByZXF1aXJlKCcuLi9jdXJyZW50U2NvcGVzLmpzJyk7XG5jb25zdCBkZWJ1Z0J1aWxkID0gcmVxdWlyZSgnLi4vZGVidWctYnVpbGQuanMnKTtcbmNvbnN0IHNlbWFudGljQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4uL3NlbWFudGljQXR0cmlidXRlcy5qcycpO1xuY29uc3QgaGFuZGxlQ2FsbGJhY2tFcnJvcnMgPSByZXF1aXJlKCcuLi91dGlscy9oYW5kbGVDYWxsYmFja0Vycm9ycy5qcycpO1xuY29uc3QgaGFzU3BhbnNFbmFibGVkID0gcmVxdWlyZSgnLi4vdXRpbHMvaGFzU3BhbnNFbmFibGVkLmpzJyk7XG5jb25zdCBwYXJzZVNhbXBsZVJhdGUgPSByZXF1aXJlKCcuLi91dGlscy9wYXJzZVNhbXBsZVJhdGUuanMnKTtcbmNvbnN0IHNwYW5PblNjb3BlID0gcmVxdWlyZSgnLi4vdXRpbHMvc3Bhbk9uU2NvcGUuanMnKTtcbmNvbnN0IHNwYW5VdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3NwYW5VdGlscy5qcycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJyk7XG5jb25zdCBwcm9wYWdhdGlvbkNvbnRleHQgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9wcm9wYWdhdGlvbkNvbnRleHQuanMnKTtcbmNvbnN0IHRyYWNpbmcgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC90cmFjaW5nLmpzJyk7XG5jb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gcmVxdWlyZSgnLi9keW5hbWljU2FtcGxpbmdDb250ZXh0LmpzJyk7XG5jb25zdCBsb2dTcGFucyA9IHJlcXVpcmUoJy4vbG9nU3BhbnMuanMnKTtcbmNvbnN0IHNhbXBsaW5nID0gcmVxdWlyZSgnLi9zYW1wbGluZy5qcycpO1xuY29uc3Qgc2VudHJ5Tm9uUmVjb3JkaW5nU3BhbiA9IHJlcXVpcmUoJy4vc2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbi5qcycpO1xuY29uc3Qgc2VudHJ5U3BhbiA9IHJlcXVpcmUoJy4vc2VudHJ5U3Bhbi5qcycpO1xuY29uc3Qgc3BhbnN0YXR1cyA9IHJlcXVpcmUoJy4vc3BhbnN0YXR1cy5qcycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1saW5lcyAqL1xuXG5cbmNvbnN0IFNVUFBSRVNTX1RSQUNJTkdfS0VZID0gJ19fU0VOVFJZX1NVUFBSRVNTX1RSQUNJTkdfXyc7XG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiB3aXRoIGEgdHJhbnNhY3Rpb24vc3BhbiBhbmQgZmluaXNoZXMgdGhlIHNwYW4gYWZ0ZXIgdGhlIGZ1bmN0aW9uIGlzIGRvbmUuXG4gKiBUaGUgY3JlYXRlZCBzcGFuIGlzIHRoZSBhY3RpdmUgc3BhbiBhbmQgd2lsbCBiZSB1c2VkIGFzIHBhcmVudCBieSBvdGhlciBzcGFucyBjcmVhdGVkIGluc2lkZSB0aGUgZnVuY3Rpb25cbiAqIGFuZCBjYW4gYmUgYWNjZXNzZWQgdmlhIGBTZW50cnkuZ2V0QWN0aXZlU3BhbigpYCwgYXMgbG9uZyBhcyB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2hpbGUgdGhlIHNjb3BlIGlzIGFjdGl2ZS5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBzcGFuIHRoYXQgaXMgbm90IHNldCBhcyBhY3RpdmUsIHVzZSB7QGxpbmsgc3RhcnRJbmFjdGl2ZVNwYW59LlxuICpcbiAqIFlvdSdsbCBhbHdheXMgZ2V0IGEgc3BhbiBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLFxuICogaXQgbWF5IGp1c3QgYmUgYSBub24tcmVjb3JkaW5nIHNwYW4gaWYgdGhlIHNwYW4gaXMgbm90IHNhbXBsZWQgb3IgaWYgdHJhY2luZyBpcyBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRTcGFuKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFjcyA9IGdldEFjcygpO1xuICBpZiAoYWNzLnN0YXJ0U3Bhbikge1xuICAgIHJldHVybiBhY3Muc3RhcnRTcGFuKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGNvbnN0IHNwYW5Bcmd1bWVudHMgPSBwYXJzZVNlbnRyeVNwYW5Bcmd1bWVudHMob3B0aW9ucyk7XG4gIGNvbnN0IHsgZm9yY2VUcmFuc2FjdGlvbiwgcGFyZW50U3BhbjogY3VzdG9tUGFyZW50U3Bhbiwgc2NvcGU6IGN1c3RvbVNjb3BlIH0gPSBvcHRpb25zO1xuXG4gIC8vIFdlIHN0aWxsIG5lZWQgdG8gZm9yayBhIHBvdGVudGlhbGx5IHBhc3NlZCBzY29wZSwgYXMgd2Ugc2V0IHRoZSBhY3RpdmUgc3BhbiBvbiBpdFxuICAvLyBhbmQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCBpdCBpcyBjbGVhbmVkIHVwIHByb3Blcmx5IG9uY2UgdGhlIHNwYW4gZW5kcy5cbiAgY29uc3QgY3VzdG9tRm9ya2VkU2NvcGUgPSBjdXN0b21TY29wZT8uY2xvbmUoKTtcblxuICByZXR1cm4gY3VycmVudFNjb3Blcy53aXRoU2NvcGUoY3VzdG9tRm9ya2VkU2NvcGUsICgpID0+IHtcbiAgICAvLyBJZiBgb3B0aW9ucy5wYXJlbnRTcGFuYCBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIHdyYXAgdGhlIGNhbGxiYWNrIGluIGB3aXRoQWN0aXZlU3BhbmBcbiAgICBjb25zdCB3cmFwcGVyID0gZ2V0QWN0aXZlU3BhbldyYXBwZXIoY3VzdG9tUGFyZW50U3Bhbik7XG5cbiAgICByZXR1cm4gd3JhcHBlcigoKSA9PiB7XG4gICAgICBjb25zdCBzY29wZSA9IGN1cnJlbnRTY29wZXMuZ2V0Q3VycmVudFNjb3BlKCk7XG4gICAgICBjb25zdCBwYXJlbnRTcGFuID0gZ2V0UGFyZW50U3BhbihzY29wZSk7XG5cbiAgICAgIGNvbnN0IHNob3VsZFNraXBTcGFuID0gb3B0aW9ucy5vbmx5SWZQYXJlbnQgJiYgIXBhcmVudFNwYW47XG4gICAgICBjb25zdCBhY3RpdmVTcGFuID0gc2hvdWxkU2tpcFNwYW5cbiAgICAgICAgPyBuZXcgc2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbi5TZW50cnlOb25SZWNvcmRpbmdTcGFuKClcbiAgICAgICAgOiBjcmVhdGVDaGlsZE9yUm9vdFNwYW4oe1xuICAgICAgICAgICAgcGFyZW50U3BhbixcbiAgICAgICAgICAgIHNwYW5Bcmd1bWVudHMsXG4gICAgICAgICAgICBmb3JjZVRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgfSk7XG5cbiAgICAgIHNwYW5PblNjb3BlLl9zZXRTcGFuRm9yU2NvcGUoc2NvcGUsIGFjdGl2ZVNwYW4pO1xuXG4gICAgICByZXR1cm4gaGFuZGxlQ2FsbGJhY2tFcnJvcnMuaGFuZGxlQ2FsbGJhY2tFcnJvcnMoXG4gICAgICAgICgpID0+IGNhbGxiYWNrKGFjdGl2ZVNwYW4pLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgLy8gT25seSB1cGRhdGUgdGhlIHNwYW4gc3RhdHVzIGlmIGl0IGhhc24ndCBiZWVuIGNoYW5nZWQgeWV0LCBhbmQgdGhlIHNwYW4gaXMgbm90IHlldCBmaW5pc2hlZFxuICAgICAgICAgIGNvbnN0IHsgc3RhdHVzIH0gPSBzcGFuVXRpbHMuc3BhblRvSlNPTihhY3RpdmVTcGFuKTtcbiAgICAgICAgICBpZiAoYWN0aXZlU3Bhbi5pc1JlY29yZGluZygpICYmICghc3RhdHVzIHx8IHN0YXR1cyA9PT0gJ29rJykpIHtcbiAgICAgICAgICAgIGFjdGl2ZVNwYW4uc2V0U3RhdHVzKHsgY29kZTogc3BhbnN0YXR1cy5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ2ludGVybmFsX2Vycm9yJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBhY3RpdmVTcGFuLmVuZCgpO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBgU2VudHJ5LnN0YXJ0U3BhbmAuIFdyYXBzIGEgZnVuY3Rpb24gd2l0aCBhIHRyYW5zYWN0aW9uL3NwYW4sIGJ1dCBkb2VzIG5vdCBmaW5pc2ggdGhlIHNwYW5cbiAqIGFmdGVyIHRoZSBmdW5jdGlvbiBpcyBkb25lIGF1dG9tYXRpY2FsbHkuIFVzZSBgc3Bhbi5lbmQoKWAgdG8gZW5kIHRoZSBzcGFuLlxuICpcbiAqIFRoZSBjcmVhdGVkIHNwYW4gaXMgdGhlIGFjdGl2ZSBzcGFuIGFuZCB3aWxsIGJlIHVzZWQgYXMgcGFyZW50IGJ5IG90aGVyIHNwYW5zIGNyZWF0ZWQgaW5zaWRlIHRoZSBmdW5jdGlvblxuICogYW5kIGNhbiBiZSBhY2Nlc3NlZCB2aWEgYFNlbnRyeS5nZXRBY3RpdmVTcGFuKClgLCBhcyBsb25nIGFzIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aGlsZSB0aGUgc2NvcGUgaXMgYWN0aXZlLlxuICpcbiAqIFlvdSdsbCBhbHdheXMgZ2V0IGEgc3BhbiBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLFxuICogaXQgbWF5IGp1c3QgYmUgYSBub24tcmVjb3JkaW5nIHNwYW4gaWYgdGhlIHNwYW4gaXMgbm90IHNhbXBsZWQgb3IgaWYgdHJhY2luZyBpcyBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRTcGFuTWFudWFsKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFjcyA9IGdldEFjcygpO1xuICBpZiAoYWNzLnN0YXJ0U3Bhbk1hbnVhbCkge1xuICAgIHJldHVybiBhY3Muc3RhcnRTcGFuTWFudWFsKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGNvbnN0IHNwYW5Bcmd1bWVudHMgPSBwYXJzZVNlbnRyeVNwYW5Bcmd1bWVudHMob3B0aW9ucyk7XG4gIGNvbnN0IHsgZm9yY2VUcmFuc2FjdGlvbiwgcGFyZW50U3BhbjogY3VzdG9tUGFyZW50U3Bhbiwgc2NvcGU6IGN1c3RvbVNjb3BlIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IGN1c3RvbUZvcmtlZFNjb3BlID0gY3VzdG9tU2NvcGU/LmNsb25lKCk7XG5cbiAgcmV0dXJuIGN1cnJlbnRTY29wZXMud2l0aFNjb3BlKGN1c3RvbUZvcmtlZFNjb3BlLCAoKSA9PiB7XG4gICAgLy8gSWYgYG9wdGlvbnMucGFyZW50U3BhbmAgaXMgZGVmaW5lZCwgd2Ugd2FudCB0byB3cmFwIHRoZSBjYWxsYmFjayBpbiBgd2l0aEFjdGl2ZVNwYW5gXG4gICAgY29uc3Qgd3JhcHBlciA9IGdldEFjdGl2ZVNwYW5XcmFwcGVyKGN1c3RvbVBhcmVudFNwYW4pO1xuXG4gICAgcmV0dXJuIHdyYXBwZXIoKCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldEN1cnJlbnRTY29wZSgpO1xuICAgICAgY29uc3QgcGFyZW50U3BhbiA9IGdldFBhcmVudFNwYW4oc2NvcGUpO1xuXG4gICAgICBjb25zdCBzaG91bGRTa2lwU3BhbiA9IG9wdGlvbnMub25seUlmUGFyZW50ICYmICFwYXJlbnRTcGFuO1xuICAgICAgY29uc3QgYWN0aXZlU3BhbiA9IHNob3VsZFNraXBTcGFuXG4gICAgICAgID8gbmV3IHNlbnRyeU5vblJlY29yZGluZ1NwYW4uU2VudHJ5Tm9uUmVjb3JkaW5nU3BhbigpXG4gICAgICAgIDogY3JlYXRlQ2hpbGRPclJvb3RTcGFuKHtcbiAgICAgICAgICAgIHBhcmVudFNwYW4sXG4gICAgICAgICAgICBzcGFuQXJndW1lbnRzLFxuICAgICAgICAgICAgZm9yY2VUcmFuc2FjdGlvbixcbiAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgIH0pO1xuXG4gICAgICBzcGFuT25TY29wZS5fc2V0U3BhbkZvclNjb3BlKHNjb3BlLCBhY3RpdmVTcGFuKTtcblxuICAgICAgcmV0dXJuIGhhbmRsZUNhbGxiYWNrRXJyb3JzLmhhbmRsZUNhbGxiYWNrRXJyb3JzKFxuICAgICAgICAvLyBXZSBwYXNzIHRoZSBgZmluaXNoYCBmdW5jdGlvbiB0byB0aGUgY2FsbGJhY2ssIHNvIHRoZSB1c2VyIGNhbiBmaW5pc2ggdGhlIHNwYW4gbWFudWFsbHlcbiAgICAgICAgLy8gdGhpcyBpcyBtYWlubHkgaGVyZSBmb3IgaGlzdG9yaWMgcHVycG9zZXMgYmVjYXVzZSBwcmV2aW91c2x5LCB3ZSBpbnN0cnVjdGVkIHVzZXJzIHRvIGNhbGxcbiAgICAgICAgLy8gYGZpbmlzaGAgaW5zdGVhZCBvZiBgc3Bhbi5lbmQoKWAgdG8gYWxzbyBjbGVhbiB1cCB0aGUgc2NvcGUuIE5vd2FkYXlzLCBjYWxsaW5nIGBzcGFuLmVuZCgpYFxuICAgICAgICAvLyBvciBgZmluaXNoYCBoYXMgdGhlIHNhbWUgZWZmZWN0IGFuZCB3ZSBzaW1wbHkgbGVhdmUgaXQgaGVyZSB0byBhdm9pZCBicmVha2luZyB1c2VyIGNvZGUuXG4gICAgICAgICgpID0+IGNhbGxiYWNrKGFjdGl2ZVNwYW4sICgpID0+IGFjdGl2ZVNwYW4uZW5kKCkpLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgLy8gT25seSB1cGRhdGUgdGhlIHNwYW4gc3RhdHVzIGlmIGl0IGhhc24ndCBiZWVuIGNoYW5nZWQgeWV0LCBhbmQgdGhlIHNwYW4gaXMgbm90IHlldCBmaW5pc2hlZFxuICAgICAgICAgIGNvbnN0IHsgc3RhdHVzIH0gPSBzcGFuVXRpbHMuc3BhblRvSlNPTihhY3RpdmVTcGFuKTtcbiAgICAgICAgICBpZiAoYWN0aXZlU3Bhbi5pc1JlY29yZGluZygpICYmICghc3RhdHVzIHx8IHN0YXR1cyA9PT0gJ29rJykpIHtcbiAgICAgICAgICAgIGFjdGl2ZVNwYW4uc2V0U3RhdHVzKHsgY29kZTogc3BhbnN0YXR1cy5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ2ludGVybmFsX2Vycm9yJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3Bhbi4gVGhpcyBzcGFuIGlzIG5vdCBzZXQgYXMgYWN0aXZlLCBzbyB3aWxsIG5vdCBnZXQgYXV0b21hdGljIGluc3RydW1lbnRhdGlvbiBzcGFuc1xuICogYXMgY2hpbGRyZW4gb3IgYmUgYWJsZSB0byBiZSBhY2Nlc3NlZCB2aWEgYFNlbnRyeS5nZXRBY3RpdmVTcGFuKClgLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIHNwYW4gdGhhdCBpcyBzZXQgYXMgYWN0aXZlLCB1c2Uge0BsaW5rIHN0YXJ0U3Bhbn0uXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFsd2F5cyByZXR1cm4gYSBzcGFuLFxuICogaXQgbWF5IGp1c3QgYmUgYSBub24tcmVjb3JkaW5nIHNwYW4gaWYgdGhlIHNwYW4gaXMgbm90IHNhbXBsZWQgb3IgaWYgdHJhY2luZyBpcyBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRJbmFjdGl2ZVNwYW4ob3B0aW9ucykge1xuICBjb25zdCBhY3MgPSBnZXRBY3MoKTtcbiAgaWYgKGFjcy5zdGFydEluYWN0aXZlU3Bhbikge1xuICAgIHJldHVybiBhY3Muc3RhcnRJbmFjdGl2ZVNwYW4ob3B0aW9ucyk7XG4gIH1cblxuICBjb25zdCBzcGFuQXJndW1lbnRzID0gcGFyc2VTZW50cnlTcGFuQXJndW1lbnRzKG9wdGlvbnMpO1xuICBjb25zdCB7IGZvcmNlVHJhbnNhY3Rpb24sIHBhcmVudFNwYW46IGN1c3RvbVBhcmVudFNwYW4gfSA9IG9wdGlvbnM7XG5cbiAgLy8gSWYgYG9wdGlvbnMuc2NvcGVgIGlzIGRlZmluZWQsIHdlIHVzZSB0aGlzIGFzIGFzIGEgd3JhcHBlcixcbiAgLy8gSWYgYG9wdGlvbnMucGFyZW50U3BhbmAgaXMgZGVmaW5lZCwgd2Ugd2FudCB0byB3cmFwIHRoZSBjYWxsYmFjayBpbiBgd2l0aEFjdGl2ZVNwYW5gXG4gIGNvbnN0IHdyYXBwZXIgPSBvcHRpb25zLnNjb3BlXG4gICAgPyAoY2FsbGJhY2spID0+IGN1cnJlbnRTY29wZXMud2l0aFNjb3BlKG9wdGlvbnMuc2NvcGUsIGNhbGxiYWNrKVxuICAgIDogY3VzdG9tUGFyZW50U3BhbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IChjYWxsYmFjaykgPT4gd2l0aEFjdGl2ZVNwYW4oY3VzdG9tUGFyZW50U3BhbiwgY2FsbGJhY2spXG4gICAgICA6IChjYWxsYmFjaykgPT4gY2FsbGJhY2soKTtcblxuICByZXR1cm4gd3JhcHBlcigoKSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldEN1cnJlbnRTY29wZSgpO1xuICAgIGNvbnN0IHBhcmVudFNwYW4gPSBnZXRQYXJlbnRTcGFuKHNjb3BlKTtcblxuICAgIGNvbnN0IHNob3VsZFNraXBTcGFuID0gb3B0aW9ucy5vbmx5SWZQYXJlbnQgJiYgIXBhcmVudFNwYW47XG5cbiAgICBpZiAoc2hvdWxkU2tpcFNwYW4pIHtcbiAgICAgIHJldHVybiBuZXcgc2VudHJ5Tm9uUmVjb3JkaW5nU3Bhbi5TZW50cnlOb25SZWNvcmRpbmdTcGFuKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoaWxkT3JSb290U3Bhbih7XG4gICAgICBwYXJlbnRTcGFuLFxuICAgICAgc3BhbkFyZ3VtZW50cyxcbiAgICAgIGZvcmNlVHJhbnNhY3Rpb24sXG4gICAgICBzY29wZSxcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udGludWUgYSB0cmFjZSBmcm9tIGBzZW50cnktdHJhY2VgIGFuZCBgYmFnZ2FnZWAgdmFsdWVzLlxuICogVGhlc2UgdmFsdWVzIGNhbiBiZSBvYnRhaW5lZCBmcm9tIGluY29taW5nIHJlcXVlc3QgaGVhZGVycywgb3IgaW4gdGhlIGJyb3dzZXIgZnJvbSBgPG1ldGEgbmFtZT1cInNlbnRyeS10cmFjZVwiPmBcbiAqIGFuZCBgPG1ldGEgbmFtZT1cImJhZ2dhZ2VcIj5gIEhUTUwgdGFncy5cbiAqXG4gKiBTcGFucyBzdGFydGVkIHdpdGggYHN0YXJ0U3BhbmAsIGBzdGFydFNwYW5NYW51YWxgIGFuZCBgc3RhcnRJbmFjdGl2ZVNwYW5gLCB3aXRoaW4gdGhlIGNhbGxiYWNrIHdpbGwgYXV0b21hdGljYWxseVxuICogYmUgYXR0YWNoZWQgdG8gdGhlIGluY29taW5nIHRyYWNlLlxuICovXG5jb25zdCBjb250aW51ZVRyYWNlID0gKFxuICBvcHRpb25zXG5cbixcbiAgY2FsbGJhY2ssXG4pID0+IHtcbiAgY29uc3QgY2FycmllciQxID0gY2Fycmllci5nZXRNYWluQ2FycmllcigpO1xuICBjb25zdCBhY3MgPSBpbmRleC5nZXRBc3luY0NvbnRleHRTdHJhdGVneShjYXJyaWVyJDEpO1xuICBpZiAoYWNzLmNvbnRpbnVlVHJhY2UpIHtcbiAgICByZXR1cm4gYWNzLmNvbnRpbnVlVHJhY2Uob3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG5cbiAgY29uc3QgeyBzZW50cnlUcmFjZSwgYmFnZ2FnZSB9ID0gb3B0aW9ucztcblxuICByZXR1cm4gY3VycmVudFNjb3Blcy53aXRoU2NvcGUoc2NvcGUgPT4ge1xuICAgIGNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IHRyYWNpbmcucHJvcGFnYXRpb25Db250ZXh0RnJvbUhlYWRlcnMoc2VudHJ5VHJhY2UsIGJhZ2dhZ2UpO1xuICAgIHNjb3BlLnNldFByb3BhZ2F0aW9uQ29udGV4dChwcm9wYWdhdGlvbkNvbnRleHQpO1xuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRm9ya3MgdGhlIGN1cnJlbnQgc2NvcGUgYW5kIHNldHMgdGhlIHByb3ZpZGVkIHNwYW4gYXMgYWN0aXZlIHNwYW4gaW4gdGhlIGNvbnRleHQgb2YgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLiBDYW4gYmVcbiAqIHBhc3NlZCBgbnVsbGAgdG8gc3RhcnQgYW4gZW50aXJlbHkgbmV3IHNwYW4gdHJlZS5cbiAqXG4gKiBAcGFyYW0gc3BhbiBTcGFucyBzdGFydGVkIGluIHRoZSBjb250ZXh0IG9mIHRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGNoaWxkcmVuIG9mIHRoaXMgc3Bhbi4gSWYgYG51bGxgIGlzIHBhc3NlZCxcbiAqIHNwYW5zIHN0YXJ0ZWQgd2l0aGluIHRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBhdHRhY2hlZCB0byBhIHBhcmVudCBzcGFuLlxuICogQHBhcmFtIGNhbGxiYWNrIEV4ZWN1dGlvbiBjb250ZXh0IGluIHdoaWNoIHRoZSBwcm92aWRlZCBzcGFuIHdpbGwgYmUgYWN0aXZlLiBJcyBwYXNzZWQgdGhlIG5ld2x5IGZvcmtlZCBzY29wZS5cbiAqIEByZXR1cm5zIHRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gd2l0aEFjdGl2ZVNwYW4oc3BhbiwgY2FsbGJhY2spIHtcbiAgY29uc3QgYWNzID0gZ2V0QWNzKCk7XG4gIGlmIChhY3Mud2l0aEFjdGl2ZVNwYW4pIHtcbiAgICByZXR1cm4gYWNzLndpdGhBY3RpdmVTcGFuKHNwYW4sIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBjdXJyZW50U2NvcGVzLndpdGhTY29wZShzY29wZSA9PiB7XG4gICAgc3Bhbk9uU2NvcGUuX3NldFNwYW5Gb3JTY29wZShzY29wZSwgc3BhbiB8fCB1bmRlZmluZWQpO1xuICAgIHJldHVybiBjYWxsYmFjayhzY29wZSk7XG4gIH0pO1xufVxuXG4vKiogU3VwcHJlc3MgdHJhY2luZyBpbiB0aGUgZ2l2ZW4gY2FsbGJhY2ssIGVuc3VyaW5nIG5vIHNwYW5zIGFyZSBnZW5lcmF0ZWQgaW5zaWRlIG9mIGl0LiAqL1xuZnVuY3Rpb24gc3VwcHJlc3NUcmFjaW5nKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFjcyA9IGdldEFjcygpO1xuXG4gIGlmIChhY3Muc3VwcHJlc3NUcmFjaW5nKSB7XG4gICAgcmV0dXJuIGFjcy5zdXBwcmVzc1RyYWNpbmcoY2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRTY29wZXMud2l0aFNjb3BlKHNjb3BlID0+IHtcbiAgICAvLyBOb3RlOiBXZSBkbyBub3Qgd2FpdCBmb3IgdGhlIGNhbGxiYWNrIHRvIGZpbmlzaCBiZWZvcmUgd2UgcmVzZXQgdGhlIG1ldGFkYXRhXG4gICAgLy8gdGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IG90aGVyd2lzZSwgaW4gdGhlIGJyb3dzZXIgdGhpcyBjYW4gbGVhZCB0byB2ZXJ5IHdlaXJkIGJlaGF2aW9yXG4gICAgLy8gYXMgdGhlcmUgaXMgb25seSBhIHNpbmdsZSB0b3Agc2NvcGUsIGlmIHRoZSBjYWxsYmFjayB0YWtlcyBsb25nZXIgdG8gZmluaXNoLFxuICAgIC8vIG90aGVyLCB1bnJlbGF0ZWQgc3BhbnMgbWF5IGFsc28gYmUgc3VwcHJlc3NlZCwgd2hpY2ggd2UgZG8gbm90IHdhbnRcbiAgICAvLyBzbyBpbnN0ZWFkLCB3ZSBvbmx5IHN1cHByZXNzIHRyYWNpbmcgc3luY2hyb25veXNseSBpbiB0aGUgYnJvd3NlclxuICAgIHNjb3BlLnNldFNES1Byb2Nlc3NpbmdNZXRhZGF0YSh7IFtTVVBQUkVTU19UUkFDSU5HX0tFWV06IHRydWUgfSk7XG4gICAgY29uc3QgcmVzID0gY2FsbGJhY2soKTtcbiAgICBzY29wZS5zZXRTREtQcm9jZXNzaW5nTWV0YWRhdGEoeyBbU1VQUFJFU1NfVFJBQ0lOR19LRVldOiB1bmRlZmluZWQgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSk7XG59XG5cbi8qKlxuICogU3RhcnRzIGEgbmV3IHRyYWNlIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLiBTcGFucyBzdGFydGVkIHdpdGhpbiB0aGVcbiAqIGNhbGxiYWNrIHdpbGwgYmUgcGFydCBvZiB0aGUgbmV3IHRyYWNlIGluc3RlYWQgb2YgYSBwb3RlbnRpYWxseSBwcmV2aW91c2x5IHN0YXJ0ZWQgdHJhY2UuXG4gKlxuICogSW1wb3J0YW50OiBPbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHRyYWNlIGxpZmV0aW1lIGFuZFxuICogcHJvcGFnYXRpb24gbWVjaGFuaXNtIG9mIHRoZSBTREsgZm9yIHRoZSBkdXJhdGlvbiBhbmQgc2NvcGUgb2YgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLlxuICogVGhlIG5ld2x5IGNyZWF0ZWQgdHJhY2Ugd2lsbCBhbHNvIGJlIHRoZSByb290IG9mIGEgbmV3IGRpc3RyaWJ1dGVkIHRyYWNlLCBmb3IgZXhhbXBsZSBpZlxuICogeW91IG1ha2UgaHR0cCByZXF1ZXN0cyB3aXRoaW4gdGhlIGNhbGxiYWNrLlxuICogVGhpcyBmdW5jdGlvbiBtaWdodCBiZSB1c2VmdWwgaWYgdGhlIG9wZXJhdGlvbiB5b3Ugd2FudCB0byBpbnN0cnVtZW50IHNob3VsZCBub3QgYmUgcGFydFxuICogb2YgYSBwb3RlbnRpYWxseSBvbmdvaW5nIHRyYWNlLlxuICpcbiAqIERlZmF1bHQgYmVoYXZpb3I6XG4gKiAtIFNlcnZlci1zaWRlOiBBIG5ldyB0cmFjZSBpcyBzdGFydGVkIGZvciBlYWNoIGluY29taW5nIHJlcXVlc3QuXG4gKiAtIEJyb3dzZXI6IEEgbmV3IHRyYWNlIGlzIHN0YXJ0ZWQgZm9yIGVhY2ggcGFnZSBvdXIgcm91dGUuIE5hdmlnYXRpbmcgdG8gYSBuZXcgcm91dGVcbiAqICAgICAgICAgICAgb3IgcGFnZSB3aWxsIGF1dG9tYXRpY2FsbHkgY3JlYXRlIGEgbmV3IHRyYWNlLlxuICovXG5mdW5jdGlvbiBzdGFydE5ld1RyYWNlKGNhbGxiYWNrKSB7XG4gIHJldHVybiBjdXJyZW50U2NvcGVzLndpdGhTY29wZShzY29wZSA9PiB7XG4gICAgc2NvcGUuc2V0UHJvcGFnYXRpb25Db250ZXh0KHtcbiAgICAgIHRyYWNlSWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5nZW5lcmF0ZVRyYWNlSWQoKSxcbiAgICAgIHNhbXBsZVJhbmQ6IE1hdGgucmFuZG9tKCksXG4gICAgfSk7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLmluZm8oYFN0YXJ0aW5nIGEgbmV3IHRyYWNlIHdpdGggaWQgJHtzY29wZS5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKS50cmFjZUlkfWApO1xuICAgIHJldHVybiB3aXRoQWN0aXZlU3BhbihudWxsLCBjYWxsYmFjayk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDaGlsZE9yUm9vdFNwYW4oe1xuICBwYXJlbnRTcGFuLFxuICBzcGFuQXJndW1lbnRzLFxuICBmb3JjZVRyYW5zYWN0aW9uLFxuICBzY29wZSxcbn1cblxuKSB7XG4gIGlmICghaGFzU3BhbnNFbmFibGVkLmhhc1NwYW5zRW5hYmxlZCgpKSB7XG4gICAgY29uc3Qgc3BhbiA9IG5ldyBzZW50cnlOb25SZWNvcmRpbmdTcGFuLlNlbnRyeU5vblJlY29yZGluZ1NwYW4oKTtcblxuICAgIC8vIElmIHRoaXMgaXMgYSByb290IHNwYW4sIHdlIGVuc3VyZSB0byBmcmVlemUgYSBEU0NcbiAgICAvLyBTbyB3ZSBjYW4gaGF2ZSBhdCBsZWFzdCBwYXJ0aWFsIGRhdGEgaGVyZVxuICAgIGlmIChmb3JjZVRyYW5zYWN0aW9uIHx8ICFwYXJlbnRTcGFuKSB7XG4gICAgICBjb25zdCBkc2MgPSB7XG4gICAgICAgIHNhbXBsZWQ6ICdmYWxzZScsXG4gICAgICAgIHNhbXBsZV9yYXRlOiAnMCcsXG4gICAgICAgIHRyYW5zYWN0aW9uOiBzcGFuQXJndW1lbnRzLm5hbWUsXG4gICAgICAgIC4uLmR5bmFtaWNTYW1wbGluZ0NvbnRleHQuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHNwYW4pLFxuICAgICAgfSA7XG4gICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0LmZyZWV6ZURzY09uU3BhbihzcGFuLCBkc2MpO1xuICAgIH1cblxuICAgIHJldHVybiBzcGFuO1xuICB9XG5cbiAgY29uc3QgaXNvbGF0aW9uU2NvcGUgPSBjdXJyZW50U2NvcGVzLmdldElzb2xhdGlvblNjb3BlKCk7XG5cbiAgbGV0IHNwYW47XG4gIGlmIChwYXJlbnRTcGFuICYmICFmb3JjZVRyYW5zYWN0aW9uKSB7XG4gICAgc3BhbiA9IF9zdGFydENoaWxkU3BhbihwYXJlbnRTcGFuLCBzY29wZSwgc3BhbkFyZ3VtZW50cyk7XG4gICAgc3BhblV0aWxzLmFkZENoaWxkU3BhblRvU3BhbihwYXJlbnRTcGFuLCBzcGFuKTtcbiAgfSBlbHNlIGlmIChwYXJlbnRTcGFuKSB7XG4gICAgLy8gSWYgd2UgZm9yY2VkIGEgdHJhbnNhY3Rpb24gYnV0IGhhdmUgYSBwYXJlbnQgc3BhbiwgbWFrZSBzdXJlIHRvIGNvbnRpbnVlIGZyb20gdGhlIHBhcmVudCBzcGFuLCBub3QgdGhlIHNjb3BlXG4gICAgY29uc3QgZHNjID0gZHluYW1pY1NhbXBsaW5nQ29udGV4dC5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4ocGFyZW50U3Bhbik7XG4gICAgY29uc3QgeyB0cmFjZUlkLCBzcGFuSWQ6IHBhcmVudFNwYW5JZCB9ID0gcGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpO1xuICAgIGNvbnN0IHBhcmVudFNhbXBsZWQgPSBzcGFuVXRpbHMuc3BhbklzU2FtcGxlZChwYXJlbnRTcGFuKTtcblxuICAgIHNwYW4gPSBfc3RhcnRSb290U3BhbihcbiAgICAgIHtcbiAgICAgICAgdHJhY2VJZCxcbiAgICAgICAgcGFyZW50U3BhbklkLFxuICAgICAgICAuLi5zcGFuQXJndW1lbnRzLFxuICAgICAgfSxcbiAgICAgIHNjb3BlLFxuICAgICAgcGFyZW50U2FtcGxlZCxcbiAgICApO1xuXG4gICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dC5mcmVlemVEc2NPblNwYW4oc3BhbiwgZHNjKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFjZUlkLFxuICAgICAgZHNjLFxuICAgICAgcGFyZW50U3BhbklkLFxuICAgICAgc2FtcGxlZDogcGFyZW50U2FtcGxlZCxcbiAgICB9ID0ge1xuICAgICAgLi4uaXNvbGF0aW9uU2NvcGUuZ2V0UHJvcGFnYXRpb25Db250ZXh0KCksXG4gICAgICAuLi5zY29wZS5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKSxcbiAgICB9O1xuXG4gICAgc3BhbiA9IF9zdGFydFJvb3RTcGFuKFxuICAgICAge1xuICAgICAgICB0cmFjZUlkLFxuICAgICAgICBwYXJlbnRTcGFuSWQsXG4gICAgICAgIC4uLnNwYW5Bcmd1bWVudHMsXG4gICAgICB9LFxuICAgICAgc2NvcGUsXG4gICAgICBwYXJlbnRTYW1wbGVkLFxuICAgICk7XG5cbiAgICBpZiAoZHNjKSB7XG4gICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0LmZyZWV6ZURzY09uU3BhbihzcGFuLCBkc2MpO1xuICAgIH1cbiAgfVxuXG4gIGxvZ1NwYW5zLmxvZ1NwYW5TdGFydChzcGFuKTtcblxuICB1dGlscy5zZXRDYXB0dXJlZFNjb3Blc09uU3BhbihzcGFuLCBzY29wZSwgaXNvbGF0aW9uU2NvcGUpO1xuXG4gIHJldHVybiBzcGFuO1xufVxuXG4vKipcbiAqIFRoaXMgY29udmVydHMgU3RhcnRTcGFuT3B0aW9ucyB0byBTZW50cnlTcGFuQXJndW1lbnRzLlxuICogRm9yIHRoZSBtb3N0IHBhcnQgKGZvciBub3cpIHdlIGFjY2VwdCB0aGUgc2FtZSBvcHRpb25zLFxuICogYnV0IHNvbWUgb2YgdGhlbSBuZWVkIHRvIGJlIHRyYW5zZm9ybWVkLlxuICovXG5mdW5jdGlvbiBwYXJzZVNlbnRyeVNwYW5Bcmd1bWVudHMob3B0aW9ucykge1xuICBjb25zdCBleHAgPSBvcHRpb25zLmV4cGVyaW1lbnRhbCB8fCB7fTtcbiAgY29uc3QgaW5pdGlhbEN0eCA9IHtcbiAgICBpc1N0YW5kYWxvbmU6IGV4cC5zdGFuZGFsb25lLFxuICAgIC4uLm9wdGlvbnMsXG4gIH07XG5cbiAgaWYgKG9wdGlvbnMuc3RhcnRUaW1lKSB7XG4gICAgY29uc3QgY3R4ID0geyAuLi5pbml0aWFsQ3R4IH07XG4gICAgY3R4LnN0YXJ0VGltZXN0YW1wID0gc3BhblV0aWxzLnNwYW5UaW1lSW5wdXRUb1NlY29uZHMob3B0aW9ucy5zdGFydFRpbWUpO1xuICAgIGRlbGV0ZSBjdHguc3RhcnRUaW1lO1xuICAgIHJldHVybiBjdHg7XG4gIH1cblxuICByZXR1cm4gaW5pdGlhbEN0eDtcbn1cblxuZnVuY3Rpb24gZ2V0QWNzKCkge1xuICBjb25zdCBjYXJyaWVyJDEgPSBjYXJyaWVyLmdldE1haW5DYXJyaWVyKCk7XG4gIHJldHVybiBpbmRleC5nZXRBc3luY0NvbnRleHRTdHJhdGVneShjYXJyaWVyJDEpO1xufVxuXG5mdW5jdGlvbiBfc3RhcnRSb290U3BhbihzcGFuQXJndW1lbnRzLCBzY29wZSwgcGFyZW50U2FtcGxlZCkge1xuICBjb25zdCBjbGllbnQgPSBjdXJyZW50U2NvcGVzLmdldENsaWVudCgpO1xuICBjb25zdCBvcHRpb25zID0gY2xpZW50Py5nZXRPcHRpb25zKCkgfHwge307XG5cbiAgY29uc3QgeyBuYW1lID0gJycgfSA9IHNwYW5Bcmd1bWVudHM7XG5cbiAgY29uc3QgbXV0YWJsZVNwYW5TYW1wbGluZ0RhdGEgPSB7IHNwYW5BdHRyaWJ1dGVzOiB7IC4uLnNwYW5Bcmd1bWVudHMuYXR0cmlidXRlcyB9LCBzcGFuTmFtZTogbmFtZSwgcGFyZW50U2FtcGxlZCB9O1xuXG4gIC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGRlY2lzaW9uIGZvciB0aGUgbW9tZW50OyB0aGlzIGlzIGp1c3QgYSBwbGFjZWhvbGRlclxuICBjbGllbnQ/LmVtaXQoJ2JlZm9yZVNhbXBsaW5nJywgbXV0YWJsZVNwYW5TYW1wbGluZ0RhdGEsIHsgZGVjaXNpb246IGZhbHNlIH0pO1xuXG4gIC8vIElmIGhvb2sgY29uc3VtZXJzIG92ZXJyaWRlIHRoZSBwYXJlbnRTYW1wbGVkIGZsYWcsIHdlIHdpbGwgdXNlIHRoYXQgdmFsdWUgaW5zdGVhZCBvZiB0aGUgYWN0dWFsIG9uZVxuICBjb25zdCBmaW5hbFBhcmVudFNhbXBsZWQgPSBtdXRhYmxlU3BhblNhbXBsaW5nRGF0YS5wYXJlbnRTYW1wbGVkID8/IHBhcmVudFNhbXBsZWQ7XG4gIGNvbnN0IGZpbmFsQXR0cmlidXRlcyA9IG11dGFibGVTcGFuU2FtcGxpbmdEYXRhLnNwYW5BdHRyaWJ1dGVzO1xuXG4gIGNvbnN0IGN1cnJlbnRQcm9wYWdhdGlvbkNvbnRleHQgPSBzY29wZS5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKTtcbiAgY29uc3QgW3NhbXBsZWQsIHNhbXBsZVJhdGUsIGxvY2FsU2FtcGxlUmF0ZVdhc0FwcGxpZWRdID0gc2NvcGUuZ2V0U2NvcGVEYXRhKCkuc2RrUHJvY2Vzc2luZ01ldGFkYXRhW1xuICAgIFNVUFBSRVNTX1RSQUNJTkdfS0VZXG4gIF1cbiAgICA/IFtmYWxzZV1cbiAgICA6IHNhbXBsaW5nLnNhbXBsZVNwYW4oXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHBhcmVudFNhbXBsZWQ6IGZpbmFsUGFyZW50U2FtcGxlZCxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBmaW5hbEF0dHJpYnV0ZXMsXG4gICAgICAgICAgcGFyZW50U2FtcGxlUmF0ZTogcGFyc2VTYW1wbGVSYXRlLnBhcnNlU2FtcGxlUmF0ZShjdXJyZW50UHJvcGFnYXRpb25Db250ZXh0LmRzYz8uc2FtcGxlX3JhdGUpLFxuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50UHJvcGFnYXRpb25Db250ZXh0LnNhbXBsZVJhbmQsXG4gICAgICApO1xuXG4gIGNvbnN0IHJvb3RTcGFuID0gbmV3IHNlbnRyeVNwYW4uU2VudHJ5U3Bhbih7XG4gICAgLi4uc3BhbkFyZ3VtZW50cyxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXTogJ2N1c3RvbScsXG4gICAgICBbc2VtYW50aWNBdHRyaWJ1dGVzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEVdOlxuICAgICAgICBzYW1wbGVSYXRlICE9PSB1bmRlZmluZWQgJiYgbG9jYWxTYW1wbGVSYXRlV2FzQXBwbGllZCA/IHNhbXBsZVJhdGUgOiB1bmRlZmluZWQsXG4gICAgICAuLi5maW5hbEF0dHJpYnV0ZXMsXG4gICAgfSxcbiAgICBzYW1wbGVkLFxuICB9KTtcblxuICBpZiAoIXNhbXBsZWQgJiYgY2xpZW50KSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLmxvZygnW1RyYWNpbmddIERpc2NhcmRpbmcgcm9vdCBzcGFuIGJlY2F1c2UgaXRzIHRyYWNlIHdhcyBub3QgY2hvc2VuIHRvIGJlIHNhbXBsZWQuJyk7XG4gICAgY2xpZW50LnJlY29yZERyb3BwZWRFdmVudCgnc2FtcGxlX3JhdGUnLCAndHJhbnNhY3Rpb24nKTtcbiAgfVxuXG4gIGlmIChjbGllbnQpIHtcbiAgICBjbGllbnQuZW1pdCgnc3BhblN0YXJ0Jywgcm9vdFNwYW4pO1xuICB9XG5cbiAgcmV0dXJuIHJvb3RTcGFuO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYFNwYW5gIHdoaWxlIHNldHRpbmcgdGhlIGN1cnJlbnQgYFNwYW4uaWRgIGFzIGBwYXJlbnRTcGFuSWRgLlxuICogVGhpcyBpbmhlcml0cyB0aGUgc2FtcGxpbmcgZGVjaXNpb24gZnJvbSB0aGUgcGFyZW50IHNwYW4uXG4gKi9cbmZ1bmN0aW9uIF9zdGFydENoaWxkU3BhbihwYXJlbnRTcGFuLCBzY29wZSwgc3BhbkFyZ3VtZW50cykge1xuICBjb25zdCB7IHNwYW5JZCwgdHJhY2VJZCB9ID0gcGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpO1xuICBjb25zdCBzYW1wbGVkID0gc2NvcGUuZ2V0U2NvcGVEYXRhKCkuc2RrUHJvY2Vzc2luZ01ldGFkYXRhW1NVUFBSRVNTX1RSQUNJTkdfS0VZXSA/IGZhbHNlIDogc3BhblV0aWxzLnNwYW5Jc1NhbXBsZWQocGFyZW50U3Bhbik7XG5cbiAgY29uc3QgY2hpbGRTcGFuID0gc2FtcGxlZFxuICAgID8gbmV3IHNlbnRyeVNwYW4uU2VudHJ5U3Bhbih7XG4gICAgICAgIC4uLnNwYW5Bcmd1bWVudHMsXG4gICAgICAgIHBhcmVudFNwYW5JZDogc3BhbklkLFxuICAgICAgICB0cmFjZUlkLFxuICAgICAgICBzYW1wbGVkLFxuICAgICAgfSlcbiAgICA6IG5ldyBzZW50cnlOb25SZWNvcmRpbmdTcGFuLlNlbnRyeU5vblJlY29yZGluZ1NwYW4oeyB0cmFjZUlkIH0pO1xuXG4gIHNwYW5VdGlscy5hZGRDaGlsZFNwYW5Ub1NwYW4ocGFyZW50U3BhbiwgY2hpbGRTcGFuKTtcblxuICBjb25zdCBjbGllbnQgPSBjdXJyZW50U2NvcGVzLmdldENsaWVudCgpO1xuICBpZiAoY2xpZW50KSB7XG4gICAgY2xpZW50LmVtaXQoJ3NwYW5TdGFydCcsIGNoaWxkU3Bhbik7XG4gICAgLy8gSWYgaXQgaGFzIGFuIGVuZFRpbWVzdGFtcCwgaXQncyBhbHJlYWR5IGVuZGVkXG4gICAgaWYgKHNwYW5Bcmd1bWVudHMuZW5kVGltZXN0YW1wKSB7XG4gICAgICBjbGllbnQuZW1pdCgnc3BhbkVuZCcsIGNoaWxkU3Bhbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkU3Bhbjtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50U3BhbihzY29wZSkge1xuICBjb25zdCBzcGFuID0gc3Bhbk9uU2NvcGUuX2dldFNwYW5Gb3JTY29wZShzY29wZSkgO1xuXG4gIGlmICghc3Bhbikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBjbGllbnQgPSBjdXJyZW50U2NvcGVzLmdldENsaWVudCgpO1xuICBjb25zdCBvcHRpb25zID0gY2xpZW50ID8gY2xpZW50LmdldE9wdGlvbnMoKSA6IHt9O1xuICBpZiAob3B0aW9ucy5wYXJlbnRTcGFuSXNBbHdheXNSb290U3Bhbikge1xuICAgIHJldHVybiBzcGFuVXRpbHMuZ2V0Um9vdFNwYW4oc3BhbikgO1xuICB9XG5cbiAgcmV0dXJuIHNwYW47XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZVNwYW5XcmFwcGVyKHBhcmVudFNwYW4pIHtcbiAgcmV0dXJuIHBhcmVudFNwYW4gIT09IHVuZGVmaW5lZFxuICAgID8gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHJldHVybiB3aXRoQWN0aXZlU3BhbihwYXJlbnRTcGFuLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgOiAoY2FsbGJhY2spID0+IGNhbGxiYWNrKCk7XG59XG5cbmV4cG9ydHMuY29udGludWVUcmFjZSA9IGNvbnRpbnVlVHJhY2U7XG5leHBvcnRzLnN0YXJ0SW5hY3RpdmVTcGFuID0gc3RhcnRJbmFjdGl2ZVNwYW47XG5leHBvcnRzLnN0YXJ0TmV3VHJhY2UgPSBzdGFydE5ld1RyYWNlO1xuZXhwb3J0cy5zdGFydFNwYW4gPSBzdGFydFNwYW47XG5leHBvcnRzLnN0YXJ0U3Bhbk1hbnVhbCA9IHN0YXJ0U3Bhbk1hbnVhbDtcbmV4cG9ydHMuc3VwcHJlc3NUcmFjaW5nID0gc3VwcHJlc3NUcmFjaW5nO1xuZXhwb3J0cy53aXRoQWN0aXZlU3BhbiA9IHdpdGhBY3RpdmVTcGFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/trace.js\n')},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/utils.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst object = __webpack_require__(/*! ../utils-hoist/object.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/object.js\");\n\nconst SCOPE_ON_START_SPAN_FIELD = '_sentryScope';\nconst ISOLATION_SCOPE_ON_START_SPAN_FIELD = '_sentryIsolationScope';\n\n/** Store the scope & isolation scope for a span, which can the be used when it is finished. */\nfunction setCapturedScopesOnSpan(span, scope, isolationScope) {\n  if (span) {\n    object.addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);\n    object.addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);\n  }\n}\n\n/**\n * Grabs the scope and isolation scope off a span that were active when the span was started.\n */\nfunction getCapturedScopesOnSpan(span) {\n  return {\n    scope: (span )[SCOPE_ON_START_SPAN_FIELD],\n    isolationScope: (span )[ISOLATION_SCOPE_ON_START_SPAN_FIELD],\n  };\n}\n\nexports.getCapturedScopesOnSpan = getCapturedScopesOnSpan;\nexports.setCapturedScopesOnSpan = setCapturedScopesOnSpan;\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhY2luZy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxlQUFlLG1CQUFPLENBQUMsK0hBQTBCOztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcdHJhY2luZ1xcdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L29iamVjdC5qcycpO1xuXG5jb25zdCBTQ09QRV9PTl9TVEFSVF9TUEFOX0ZJRUxEID0gJ19zZW50cnlTY29wZSc7XG5jb25zdCBJU09MQVRJT05fU0NPUEVfT05fU1RBUlRfU1BBTl9GSUVMRCA9ICdfc2VudHJ5SXNvbGF0aW9uU2NvcGUnO1xuXG4vKiogU3RvcmUgdGhlIHNjb3BlICYgaXNvbGF0aW9uIHNjb3BlIGZvciBhIHNwYW4sIHdoaWNoIGNhbiB0aGUgYmUgdXNlZCB3aGVuIGl0IGlzIGZpbmlzaGVkLiAqL1xuZnVuY3Rpb24gc2V0Q2FwdHVyZWRTY29wZXNPblNwYW4oc3Bhbiwgc2NvcGUsIGlzb2xhdGlvblNjb3BlKSB7XG4gIGlmIChzcGFuKSB7XG4gICAgb2JqZWN0LmFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eShzcGFuLCBJU09MQVRJT05fU0NPUEVfT05fU1RBUlRfU1BBTl9GSUVMRCwgaXNvbGF0aW9uU2NvcGUpO1xuICAgIG9iamVjdC5hZGROb25FbnVtZXJhYmxlUHJvcGVydHkoc3BhbiwgU0NPUEVfT05fU1RBUlRfU1BBTl9GSUVMRCwgc2NvcGUpO1xuICB9XG59XG5cbi8qKlxuICogR3JhYnMgdGhlIHNjb3BlIGFuZCBpc29sYXRpb24gc2NvcGUgb2ZmIGEgc3BhbiB0aGF0IHdlcmUgYWN0aXZlIHdoZW4gdGhlIHNwYW4gd2FzIHN0YXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGdldENhcHR1cmVkU2NvcGVzT25TcGFuKHNwYW4pIHtcbiAgcmV0dXJuIHtcbiAgICBzY29wZTogKHNwYW4gKVtTQ09QRV9PTl9TVEFSVF9TUEFOX0ZJRUxEXSxcbiAgICBpc29sYXRpb25TY29wZTogKHNwYW4gKVtJU09MQVRJT05fU0NPUEVfT05fU1RBUlRfU1BBTl9GSUVMRF0sXG4gIH07XG59XG5cbmV4cG9ydHMuZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4gPSBnZXRDYXB0dXJlZFNjb3Blc09uU3BhbjtcbmV4cG9ydHMuc2V0Q2FwdHVyZWRTY29wZXNPblNwYW4gPSBzZXRDYXB0dXJlZFNjb3Blc09uU3Bhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/utils.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/transports/base.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst envelope = __webpack_require__(/*! ../utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst promisebuffer = __webpack_require__(/*! ../utils-hoist/promisebuffer.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/promisebuffer.js\");\nconst ratelimit = __webpack_require__(/*! ../utils-hoist/ratelimit.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/ratelimit.js\");\nconst syncpromise = __webpack_require__(/*! ../utils-hoist/syncpromise.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/syncpromise.js\");\n\nconst DEFAULT_TRANSPORT_BUFFER_SIZE = 64;\n\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\nfunction createTransport(\n  options,\n  makeRequest,\n  buffer = promisebuffer.makePromiseBuffer(\n    options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE,\n  ),\n) {\n  let rateLimits = {};\n  const flush = (timeout) => buffer.drain(timeout);\n\n  function send(envelope$1) {\n    const filteredEnvelopeItems = [];\n\n    // Drop rate limited items from envelope\n    envelope.forEachEnvelopeItem(envelope$1, (item, type) => {\n      const dataCategory = envelope.envelopeItemTypeToDataCategory(type);\n      if (ratelimit.isRateLimited(rateLimits, dataCategory)) {\n        options.recordDroppedEvent('ratelimit_backoff', dataCategory);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    });\n\n    // Skip sending if envelope is empty after filtering out rate limited events\n    if (filteredEnvelopeItems.length === 0) {\n      return syncpromise.resolvedSyncPromise({});\n    }\n\n    const filteredEnvelope = envelope.createEnvelope(envelope$1[0], filteredEnvelopeItems );\n\n    // Creates client report for each item in an envelope\n    const recordEnvelopeLoss = (reason) => {\n      envelope.forEachEnvelopeItem(filteredEnvelope, (item, type) => {\n        options.recordDroppedEvent(reason, envelope.envelopeItemTypeToDataCategory(type));\n      });\n    };\n\n    const requestTask = () =>\n      makeRequest({ body: envelope.serializeEnvelope(filteredEnvelope) }).then(\n        response => {\n          // We don't want to throw on NOK responses, but we want to at least log them\n          if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n            debugBuild.DEBUG_BUILD && logger.logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);\n          }\n\n          rateLimits = ratelimit.updateRateLimits(rateLimits, response);\n          return response;\n        },\n        error => {\n          recordEnvelopeLoss('network_error');\n          debugBuild.DEBUG_BUILD && logger.logger.error('Encountered error running transport request:', error);\n          throw error;\n        },\n      );\n\n    return buffer.add(requestTask).then(\n      result => result,\n      error => {\n        if (error === promisebuffer.SENTRY_BUFFER_FULL_ERROR) {\n          debugBuild.DEBUG_BUILD && logger.logger.error('Skipped sending event because buffer is full.');\n          recordEnvelopeLoss('queue_overflow');\n          return syncpromise.resolvedSyncPromise({});\n        } else {\n          throw error;\n        }\n      },\n    );\n  }\n\n  return {\n    send,\n    flush,\n  };\n}\n\nexports.DEFAULT_TRANSPORT_BUFFER_SIZE = DEFAULT_TRANSPORT_BUFFER_SIZE;\nexports.createTransport = createTransport;\n//# sourceMappingURL=base.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhbnNwb3J0cy9iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLG1CQUFtQixtQkFBTyxDQUFDLGlIQUFtQjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyxtSUFBNEI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLCtIQUEwQjtBQUNqRCxzQkFBc0IsbUJBQU8sQ0FBQyw2SUFBaUM7QUFDL0Qsa0JBQWtCLG1CQUFPLENBQUMscUlBQTZCO0FBQ3ZELG9CQUFvQixtQkFBTyxDQUFDLHlJQUErQjs7QUFFM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYscUJBQXFCO0FBQ25IOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckMsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcdHJhbnNwb3J0c1xcYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgZGVidWdCdWlsZCA9IHJlcXVpcmUoJy4uL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBlbnZlbG9wZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2VudmVsb3BlLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IHByb21pc2VidWZmZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9wcm9taXNlYnVmZmVyLmpzJyk7XG5jb25zdCByYXRlbGltaXQgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9yYXRlbGltaXQuanMnKTtcbmNvbnN0IHN5bmNwcm9taXNlID0gcmVxdWlyZSgnLi4vdXRpbHMtaG9pc3Qvc3luY3Byb21pc2UuanMnKTtcblxuY29uc3QgREVGQVVMVF9UUkFOU1BPUlRfQlVGRkVSX1NJWkUgPSA2NDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgU2VudHJ5IGBUcmFuc3BvcnRgXG4gKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBtYWtlUmVxdWVzdFxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFuc3BvcnQoXG4gIG9wdGlvbnMsXG4gIG1ha2VSZXF1ZXN0LFxuICBidWZmZXIgPSBwcm9taXNlYnVmZmVyLm1ha2VQcm9taXNlQnVmZmVyKFxuICAgIG9wdGlvbnMuYnVmZmVyU2l6ZSB8fCBERUZBVUxUX1RSQU5TUE9SVF9CVUZGRVJfU0laRSxcbiAgKSxcbikge1xuICBsZXQgcmF0ZUxpbWl0cyA9IHt9O1xuICBjb25zdCBmbHVzaCA9ICh0aW1lb3V0KSA9PiBidWZmZXIuZHJhaW4odGltZW91dCk7XG5cbiAgZnVuY3Rpb24gc2VuZChlbnZlbG9wZSQxKSB7XG4gICAgY29uc3QgZmlsdGVyZWRFbnZlbG9wZUl0ZW1zID0gW107XG5cbiAgICAvLyBEcm9wIHJhdGUgbGltaXRlZCBpdGVtcyBmcm9tIGVudmVsb3BlXG4gICAgZW52ZWxvcGUuZm9yRWFjaEVudmVsb3BlSXRlbShlbnZlbG9wZSQxLCAoaXRlbSwgdHlwZSkgPT4ge1xuICAgICAgY29uc3QgZGF0YUNhdGVnb3J5ID0gZW52ZWxvcGUuZW52ZWxvcGVJdGVtVHlwZVRvRGF0YUNhdGVnb3J5KHR5cGUpO1xuICAgICAgaWYgKHJhdGVsaW1pdC5pc1JhdGVMaW1pdGVkKHJhdGVMaW1pdHMsIGRhdGFDYXRlZ29yeSkpIHtcbiAgICAgICAgb3B0aW9ucy5yZWNvcmREcm9wcGVkRXZlbnQoJ3JhdGVsaW1pdF9iYWNrb2ZmJywgZGF0YUNhdGVnb3J5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbHRlcmVkRW52ZWxvcGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2tpcCBzZW5kaW5nIGlmIGVudmVsb3BlIGlzIGVtcHR5IGFmdGVyIGZpbHRlcmluZyBvdXQgcmF0ZSBsaW1pdGVkIGV2ZW50c1xuICAgIGlmIChmaWx0ZXJlZEVudmVsb3BlSXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gc3luY3Byb21pc2UucmVzb2x2ZWRTeW5jUHJvbWlzZSh7fSk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyZWRFbnZlbG9wZSA9IGVudmVsb3BlLmNyZWF0ZUVudmVsb3BlKGVudmVsb3BlJDFbMF0sIGZpbHRlcmVkRW52ZWxvcGVJdGVtcyApO1xuXG4gICAgLy8gQ3JlYXRlcyBjbGllbnQgcmVwb3J0IGZvciBlYWNoIGl0ZW0gaW4gYW4gZW52ZWxvcGVcbiAgICBjb25zdCByZWNvcmRFbnZlbG9wZUxvc3MgPSAocmVhc29uKSA9PiB7XG4gICAgICBlbnZlbG9wZS5mb3JFYWNoRW52ZWxvcGVJdGVtKGZpbHRlcmVkRW52ZWxvcGUsIChpdGVtLCB0eXBlKSA9PiB7XG4gICAgICAgIG9wdGlvbnMucmVjb3JkRHJvcHBlZEV2ZW50KHJlYXNvbiwgZW52ZWxvcGUuZW52ZWxvcGVJdGVtVHlwZVRvRGF0YUNhdGVnb3J5KHR5cGUpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCByZXF1ZXN0VGFzayA9ICgpID0+XG4gICAgICBtYWtlUmVxdWVzdCh7IGJvZHk6IGVudmVsb3BlLnNlcmlhbGl6ZUVudmVsb3BlKGZpbHRlcmVkRW52ZWxvcGUpIH0pLnRoZW4oXG4gICAgICAgIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHRocm93IG9uIE5PSyByZXNwb25zZXMsIGJ1dCB3ZSB3YW50IHRvIGF0IGxlYXN0IGxvZyB0aGVtXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IHVuZGVmaW5lZCAmJiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXNDb2RlID49IDMwMCkpIHtcbiAgICAgICAgICAgIGRlYnVnQnVpbGQuREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZ2dlci53YXJuKGBTZW50cnkgcmVzcG9uZGVkIHdpdGggc3RhdHVzIGNvZGUgJHtyZXNwb25zZS5zdGF0dXNDb2RlfSB0byBzZW50IGV2ZW50LmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJhdGVMaW1pdHMgPSByYXRlbGltaXQudXBkYXRlUmF0ZUxpbWl0cyhyYXRlTGltaXRzLCByZXNwb25zZSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgcmVjb3JkRW52ZWxvcGVMb3NzKCduZXR3b3JrX2Vycm9yJyk7XG4gICAgICAgICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLmVycm9yKCdFbmNvdW50ZXJlZCBlcnJvciBydW5uaW5nIHRyYW5zcG9ydCByZXF1ZXN0OicsIGVycm9yKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSxcbiAgICAgICk7XG5cbiAgICByZXR1cm4gYnVmZmVyLmFkZChyZXF1ZXN0VGFzaykudGhlbihcbiAgICAgIHJlc3VsdCA9PiByZXN1bHQsXG4gICAgICBlcnJvciA9PiB7XG4gICAgICAgIGlmIChlcnJvciA9PT0gcHJvbWlzZWJ1ZmZlci5TRU5UUllfQlVGRkVSX0ZVTExfRVJST1IpIHtcbiAgICAgICAgICBkZWJ1Z0J1aWxkLkRFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2dnZXIuZXJyb3IoJ1NraXBwZWQgc2VuZGluZyBldmVudCBiZWNhdXNlIGJ1ZmZlciBpcyBmdWxsLicpO1xuICAgICAgICAgIHJlY29yZEVudmVsb3BlTG9zcygncXVldWVfb3ZlcmZsb3cnKTtcbiAgICAgICAgICByZXR1cm4gc3luY3Byb21pc2UucmVzb2x2ZWRTeW5jUHJvbWlzZSh7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2VuZCxcbiAgICBmbHVzaCxcbiAgfTtcbn1cblxuZXhwb3J0cy5ERUZBVUxUX1RSQU5TUE9SVF9CVUZGRVJfU0laRSA9IERFRkFVTFRfVFJBTlNQT1JUX0JVRkZFUl9TSVpFO1xuZXhwb3J0cy5jcmVhdGVUcmFuc3BvcnQgPSBjcmVhdGVUcmFuc3BvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/transports/base.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/transports/multiplexed.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst api = __webpack_require__(/*! ../api.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/api.js\");\nconst dsn = __webpack_require__(/*! ../utils-hoist/dsn.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/dsn.js\");\nconst envelope = __webpack_require__(/*! ../utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\n\n/**\n * Gets an event from an envelope.\n *\n * This is only exported for use in the tests\n */\nfunction eventFromEnvelope(env, types) {\n  let event;\n\n  envelope.forEachEnvelopeItem(env, (item, type) => {\n    if (types.includes(type)) {\n      event = Array.isArray(item) ? (item )[1] : undefined;\n    }\n    // bail out if we found an event\n    return !!event;\n  });\n\n  return event;\n}\n\n/**\n * Creates a transport that overrides the release on all events.\n */\nfunction makeOverrideReleaseTransport(\n  createTransport,\n  release,\n) {\n  return options => {\n    const transport = createTransport(options);\n\n    return {\n      ...transport,\n      send: async (envelope) => {\n        const event = eventFromEnvelope(envelope, ['event', 'transaction', 'profile', 'replay_event']);\n\n        if (event) {\n          event.release = release;\n        }\n        return transport.send(envelope);\n      },\n    };\n  };\n}\n\n/** Overrides the DSN in the envelope header  */\nfunction overrideDsn(envelope$1, dsn) {\n  return envelope.createEnvelope(\n    dsn\n      ? {\n          ...envelope$1[0],\n          dsn,\n        }\n      : envelope$1[0],\n    envelope$1[1],\n  );\n}\n\n/**\n * Creates a transport that can send events to different DSNs depending on the envelope contents.\n */\nfunction makeMultiplexedTransport(\n  createTransport,\n  matcher,\n) {\n  return options => {\n    const fallbackTransport = createTransport(options);\n    const otherTransports = new Map();\n\n    function getTransport(dsn$1, release) {\n      // We create a transport for every unique dsn/release combination as there may be code from multiple releases in\n      // use at the same time\n      const key = release ? `${dsn$1}:${release}` : dsn$1;\n\n      let transport = otherTransports.get(key);\n\n      if (!transport) {\n        const validatedDsn = dsn.dsnFromString(dsn$1);\n        if (!validatedDsn) {\n          return undefined;\n        }\n        const url = api.getEnvelopeEndpointWithUrlEncodedAuth(validatedDsn, options.tunnel);\n\n        transport = release\n          ? makeOverrideReleaseTransport(createTransport, release)({ ...options, url })\n          : createTransport({ ...options, url });\n\n        otherTransports.set(key, transport);\n      }\n\n      return [dsn$1, transport];\n    }\n\n    async function send(envelope) {\n      function getEvent(types) {\n        const eventTypes = types?.length ? types : ['event'];\n        return eventFromEnvelope(envelope, eventTypes);\n      }\n\n      const transports = matcher({ envelope, getEvent })\n        .map(result => {\n          if (typeof result === 'string') {\n            return getTransport(result, undefined);\n          } else {\n            return getTransport(result.dsn, result.release);\n          }\n        })\n        .filter((t) => !!t);\n\n      // If we have no transports to send to, use the fallback transport\n      // Don't override the DSN in the header for the fallback transport. '' is falsy\n      const transportsWithFallback = transports.length ? transports : [['', fallbackTransport]];\n\n      const results = (await Promise.all(\n        transportsWithFallback.map(([dsn, transport]) => transport.send(overrideDsn(envelope, dsn))),\n      )) ;\n\n      return results[0];\n    }\n\n    async function flush(timeout) {\n      const allTransports = [...otherTransports.values(), fallbackTransport];\n      const results = await Promise.all(allTransports.map(transport => transport.flush(timeout)));\n      return results.every(r => r);\n    }\n\n    return {\n      send,\n      flush,\n    };\n  };\n}\n\nexports.eventFromEnvelope = eventFromEnvelope;\nexports.makeMultiplexedTransport = makeMultiplexedTransport;\n//# sourceMappingURL=multiplexed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhbnNwb3J0cy9tdWx0aXBsZXhlZC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxZQUFZLG1CQUFPLENBQUMsaUdBQVc7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLHlIQUF1QjtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyxtSUFBNEI7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTSxHQUFHLFFBQVE7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRSxpQkFBaUI7QUFDdEYsOEJBQThCLGlCQUFpQjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLG9CQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFwxXFxEb3dubG9hZHNcXHRhYm9yQWNhZGVteVVwZGF0ZWRcXHRhYm9yLWFjYWRlbXlcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcbmV4dGpzXFxub2RlX21vZHVsZXNcXEBzZW50cnlcXGNvcmVcXGJ1aWxkXFxjanNcXHRyYW5zcG9ydHNcXG11bHRpcGxleGVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBhcGkgPSByZXF1aXJlKCcuLi9hcGkuanMnKTtcbmNvbnN0IGRzbiA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2Rzbi5qcycpO1xuY29uc3QgZW52ZWxvcGUgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9lbnZlbG9wZS5qcycpO1xuXG4vKipcbiAqIEdldHMgYW4gZXZlbnQgZnJvbSBhbiBlbnZlbG9wZS5cbiAqXG4gKiBUaGlzIGlzIG9ubHkgZXhwb3J0ZWQgZm9yIHVzZSBpbiB0aGUgdGVzdHNcbiAqL1xuZnVuY3Rpb24gZXZlbnRGcm9tRW52ZWxvcGUoZW52LCB0eXBlcykge1xuICBsZXQgZXZlbnQ7XG5cbiAgZW52ZWxvcGUuZm9yRWFjaEVudmVsb3BlSXRlbShlbnYsIChpdGVtLCB0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICBldmVudCA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyAoaXRlbSApWzFdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBiYWlsIG91dCBpZiB3ZSBmb3VuZCBhbiBldmVudFxuICAgIHJldHVybiAhIWV2ZW50O1xuICB9KTtcblxuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRyYW5zcG9ydCB0aGF0IG92ZXJyaWRlcyB0aGUgcmVsZWFzZSBvbiBhbGwgZXZlbnRzLlxuICovXG5mdW5jdGlvbiBtYWtlT3ZlcnJpZGVSZWxlYXNlVHJhbnNwb3J0KFxuICBjcmVhdGVUcmFuc3BvcnQsXG4gIHJlbGVhc2UsXG4pIHtcbiAgcmV0dXJuIG9wdGlvbnMgPT4ge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IGNyZWF0ZVRyYW5zcG9ydChvcHRpb25zKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi50cmFuc3BvcnQsXG4gICAgICBzZW5kOiBhc3luYyAoZW52ZWxvcGUpID0+IHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudEZyb21FbnZlbG9wZShlbnZlbG9wZSwgWydldmVudCcsICd0cmFuc2FjdGlvbicsICdwcm9maWxlJywgJ3JlcGxheV9ldmVudCddKTtcblxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICBldmVudC5yZWxlYXNlID0gcmVsZWFzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNwb3J0LnNlbmQoZW52ZWxvcGUpO1xuICAgICAgfSxcbiAgICB9O1xuICB9O1xufVxuXG4vKiogT3ZlcnJpZGVzIHRoZSBEU04gaW4gdGhlIGVudmVsb3BlIGhlYWRlciAgKi9cbmZ1bmN0aW9uIG92ZXJyaWRlRHNuKGVudmVsb3BlJDEsIGRzbikge1xuICByZXR1cm4gZW52ZWxvcGUuY3JlYXRlRW52ZWxvcGUoXG4gICAgZHNuXG4gICAgICA/IHtcbiAgICAgICAgICAuLi5lbnZlbG9wZSQxWzBdLFxuICAgICAgICAgIGRzbixcbiAgICAgICAgfVxuICAgICAgOiBlbnZlbG9wZSQxWzBdLFxuICAgIGVudmVsb3BlJDFbMV0sXG4gICk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRyYW5zcG9ydCB0aGF0IGNhbiBzZW5kIGV2ZW50cyB0byBkaWZmZXJlbnQgRFNOcyBkZXBlbmRpbmcgb24gdGhlIGVudmVsb3BlIGNvbnRlbnRzLlxuICovXG5mdW5jdGlvbiBtYWtlTXVsdGlwbGV4ZWRUcmFuc3BvcnQoXG4gIGNyZWF0ZVRyYW5zcG9ydCxcbiAgbWF0Y2hlcixcbikge1xuICByZXR1cm4gb3B0aW9ucyA9PiB7XG4gICAgY29uc3QgZmFsbGJhY2tUcmFuc3BvcnQgPSBjcmVhdGVUcmFuc3BvcnQob3B0aW9ucyk7XG4gICAgY29uc3Qgb3RoZXJUcmFuc3BvcnRzID0gbmV3IE1hcCgpO1xuXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNwb3J0KGRzbiQxLCByZWxlYXNlKSB7XG4gICAgICAvLyBXZSBjcmVhdGUgYSB0cmFuc3BvcnQgZm9yIGV2ZXJ5IHVuaXF1ZSBkc24vcmVsZWFzZSBjb21iaW5hdGlvbiBhcyB0aGVyZSBtYXkgYmUgY29kZSBmcm9tIG11bHRpcGxlIHJlbGVhc2VzIGluXG4gICAgICAvLyB1c2UgYXQgdGhlIHNhbWUgdGltZVxuICAgICAgY29uc3Qga2V5ID0gcmVsZWFzZSA/IGAke2RzbiQxfToke3JlbGVhc2V9YCA6IGRzbiQxO1xuXG4gICAgICBsZXQgdHJhbnNwb3J0ID0gb3RoZXJUcmFuc3BvcnRzLmdldChrZXkpO1xuXG4gICAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWREc24gPSBkc24uZHNuRnJvbVN0cmluZyhkc24kMSk7XG4gICAgICAgIGlmICghdmFsaWRhdGVkRHNuKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBhcGkuZ2V0RW52ZWxvcGVFbmRwb2ludFdpdGhVcmxFbmNvZGVkQXV0aCh2YWxpZGF0ZWREc24sIG9wdGlvbnMudHVubmVsKTtcblxuICAgICAgICB0cmFuc3BvcnQgPSByZWxlYXNlXG4gICAgICAgICAgPyBtYWtlT3ZlcnJpZGVSZWxlYXNlVHJhbnNwb3J0KGNyZWF0ZVRyYW5zcG9ydCwgcmVsZWFzZSkoeyAuLi5vcHRpb25zLCB1cmwgfSlcbiAgICAgICAgICA6IGNyZWF0ZVRyYW5zcG9ydCh7IC4uLm9wdGlvbnMsIHVybCB9KTtcblxuICAgICAgICBvdGhlclRyYW5zcG9ydHMuc2V0KGtleSwgdHJhbnNwb3J0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtkc24kMSwgdHJhbnNwb3J0XTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBzZW5kKGVudmVsb3BlKSB7XG4gICAgICBmdW5jdGlvbiBnZXRFdmVudCh0eXBlcykge1xuICAgICAgICBjb25zdCBldmVudFR5cGVzID0gdHlwZXM/Lmxlbmd0aCA/IHR5cGVzIDogWydldmVudCddO1xuICAgICAgICByZXR1cm4gZXZlbnRGcm9tRW52ZWxvcGUoZW52ZWxvcGUsIGV2ZW50VHlwZXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0cmFuc3BvcnRzID0gbWF0Y2hlcih7IGVudmVsb3BlLCBnZXRFdmVudCB9KVxuICAgICAgICAubWFwKHJlc3VsdCA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VHJhbnNwb3J0KHJlc3VsdCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRyYW5zcG9ydChyZXN1bHQuZHNuLCByZXN1bHQucmVsZWFzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKCh0KSA9PiAhIXQpO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIG5vIHRyYW5zcG9ydHMgdG8gc2VuZCB0bywgdXNlIHRoZSBmYWxsYmFjayB0cmFuc3BvcnRcbiAgICAgIC8vIERvbid0IG92ZXJyaWRlIHRoZSBEU04gaW4gdGhlIGhlYWRlciBmb3IgdGhlIGZhbGxiYWNrIHRyYW5zcG9ydC4gJycgaXMgZmFsc3lcbiAgICAgIGNvbnN0IHRyYW5zcG9ydHNXaXRoRmFsbGJhY2sgPSB0cmFuc3BvcnRzLmxlbmd0aCA/IHRyYW5zcG9ydHMgOiBbWycnLCBmYWxsYmFja1RyYW5zcG9ydF1dO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gKGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICB0cmFuc3BvcnRzV2l0aEZhbGxiYWNrLm1hcCgoW2RzbiwgdHJhbnNwb3J0XSkgPT4gdHJhbnNwb3J0LnNlbmQob3ZlcnJpZGVEc24oZW52ZWxvcGUsIGRzbikpKSxcbiAgICAgICkpIDtcblxuICAgICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZmx1c2godGltZW91dCkge1xuICAgICAgY29uc3QgYWxsVHJhbnNwb3J0cyA9IFsuLi5vdGhlclRyYW5zcG9ydHMudmFsdWVzKCksIGZhbGxiYWNrVHJhbnNwb3J0XTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChhbGxUcmFuc3BvcnRzLm1hcCh0cmFuc3BvcnQgPT4gdHJhbnNwb3J0LmZsdXNoKHRpbWVvdXQpKSk7XG4gICAgICByZXR1cm4gcmVzdWx0cy5ldmVyeShyID0+IHIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzZW5kLFxuICAgICAgZmx1c2gsXG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0cy5ldmVudEZyb21FbnZlbG9wZSA9IGV2ZW50RnJvbUVudmVsb3BlO1xuZXhwb3J0cy5tYWtlTXVsdGlwbGV4ZWRUcmFuc3BvcnQgPSBtYWtlTXVsdGlwbGV4ZWRUcmFuc3BvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBsZXhlZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/transports/multiplexed.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/transports/offline.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst debugBuild = __webpack_require__(/*! ../debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\nconst envelope = __webpack_require__(/*! ../utils-hoist/envelope.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/envelope.js\");\nconst logger = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst ratelimit = __webpack_require__(/*! ../utils-hoist/ratelimit.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/ratelimit.js\");\n\nconst MIN_DELAY = 100; // 100 ms\nconst START_DELAY = 5000; // 5 seconds\nconst MAX_DELAY = 3.6e6; // 1 hour\n\n/**\n * Wraps a transport and stores and retries events when they fail to send.\n *\n * @param createTransport The transport to wrap.\n */\nfunction makeOfflineTransport(\n  createTransport,\n) {\n  function log(...args) {\n    debugBuild.DEBUG_BUILD && logger.logger.info('[Offline]:', ...args);\n  }\n\n  return options => {\n    const transport = createTransport(options);\n\n    if (!options.createStore) {\n      throw new Error('No `createStore` function was provided');\n    }\n\n    const store = options.createStore(options);\n\n    let retryDelay = START_DELAY;\n    let flushTimer;\n\n    function shouldQueue(env, error, retryDelay) {\n      // We want to drop client reports because they can be generated when we retry sending events while offline.\n      if (envelope.envelopeContainsItemType(env, ['client_report'])) {\n        return false;\n      }\n\n      if (options.shouldStore) {\n        return options.shouldStore(env, error, retryDelay);\n      }\n\n      return true;\n    }\n\n    function flushIn(delay) {\n      if (flushTimer) {\n        clearTimeout(flushTimer );\n      }\n\n      flushTimer = setTimeout(async () => {\n        flushTimer = undefined;\n\n        const found = await store.shift();\n        if (found) {\n          log('Attempting to send previously queued event');\n\n          // We should to update the sent_at timestamp to the current time.\n          found[0].sent_at = new Date().toISOString();\n\n          void send(found, true).catch(e => {\n            log('Failed to retry sending', e);\n          });\n        }\n      }, delay) ;\n\n      // We need to unref the timer in node.js, otherwise the node process never exit.\n      if (typeof flushTimer !== 'number' && flushTimer.unref) {\n        flushTimer.unref();\n      }\n    }\n\n    function flushWithBackOff() {\n      if (flushTimer) {\n        return;\n      }\n\n      flushIn(retryDelay);\n\n      retryDelay = Math.min(retryDelay * 2, MAX_DELAY);\n    }\n\n    async function send(envelope$1, isRetry = false) {\n      // We queue all replay envelopes to avoid multiple replay envelopes being sent at the same time. If one fails, we\n      // need to retry them in order.\n      if (!isRetry && envelope.envelopeContainsItemType(envelope$1, ['replay_event', 'replay_recording'])) {\n        await store.push(envelope$1);\n        flushIn(MIN_DELAY);\n        return {};\n      }\n\n      try {\n        if (options.shouldSend && (await options.shouldSend(envelope$1)) === false) {\n          throw new Error('Envelope not sent because `shouldSend` callback returned false');\n        }\n\n        const result = await transport.send(envelope$1);\n\n        let delay = MIN_DELAY;\n\n        if (result) {\n          // If there's a retry-after header, use that as the next delay.\n          if (result.headers?.['retry-after']) {\n            delay = ratelimit.parseRetryAfterHeader(result.headers['retry-after']);\n          } else if (result.headers?.['x-sentry-rate-limits']) {\n            delay = 60000; // 60 seconds\n          } // If we have a server error, return now so we don't flush the queue.\n          else if ((result.statusCode || 0) >= 400) {\n            return result;\n          }\n        }\n\n        flushIn(delay);\n        retryDelay = START_DELAY;\n        return result;\n      } catch (e) {\n        if (await shouldQueue(envelope$1, e , retryDelay)) {\n          // If this envelope was a retry, we want to add it to the front of the queue so it's retried again first.\n          if (isRetry) {\n            await store.unshift(envelope$1);\n          } else {\n            await store.push(envelope$1);\n          }\n          flushWithBackOff();\n          log('Error sending. Event queued.', e );\n          return {};\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    if (options.flushAtStartup) {\n      flushWithBackOff();\n    }\n\n    return {\n      send,\n      flush: timeout => {\n        // If there's no timeout, we should attempt to flush the offline queue.\n        if (timeout === undefined) {\n          retryDelay = START_DELAY;\n          flushIn(MIN_DELAY);\n        }\n\n        return transport.flush(timeout);\n      },\n    };\n  };\n}\n\nexports.MIN_DELAY = MIN_DELAY;\nexports.START_DELAY = START_DELAY;\nexports.makeOfflineTransport = makeOfflineTransport;\n//# sourceMappingURL=offline.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJhbnNwb3J0cy9vZmZsaW5lLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLG1CQUFtQixtQkFBTyxDQUFDLGlIQUFtQjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyxtSUFBNEI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLCtIQUEwQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxxSUFBNkI7O0FBRXZELHVCQUF1QjtBQUN2QiwwQkFBMEI7QUFDMUIseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDJCQUEyQjtBQUMzQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQixtQkFBbUI7QUFDbkIsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcdHJhbnNwb3J0c1xcb2ZmbGluZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgZGVidWdCdWlsZCA9IHJlcXVpcmUoJy4uL2RlYnVnLWJ1aWxkLmpzJyk7XG5jb25zdCBlbnZlbG9wZSA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L2VudmVsb3BlLmpzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IHJhdGVsaW1pdCA9IHJlcXVpcmUoJy4uL3V0aWxzLWhvaXN0L3JhdGVsaW1pdC5qcycpO1xuXG5jb25zdCBNSU5fREVMQVkgPSAxMDA7IC8vIDEwMCBtc1xuY29uc3QgU1RBUlRfREVMQVkgPSA1MDAwOyAvLyA1IHNlY29uZHNcbmNvbnN0IE1BWF9ERUxBWSA9IDMuNmU2OyAvLyAxIGhvdXJcblxuLyoqXG4gKiBXcmFwcyBhIHRyYW5zcG9ydCBhbmQgc3RvcmVzIGFuZCByZXRyaWVzIGV2ZW50cyB3aGVuIHRoZXkgZmFpbCB0byBzZW5kLlxuICpcbiAqIEBwYXJhbSBjcmVhdGVUcmFuc3BvcnQgVGhlIHRyYW5zcG9ydCB0byB3cmFwLlxuICovXG5mdW5jdGlvbiBtYWtlT2ZmbGluZVRyYW5zcG9ydChcbiAgY3JlYXRlVHJhbnNwb3J0LFxuKSB7XG4gIGZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG4gICAgZGVidWdCdWlsZC5ERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nZ2VyLmluZm8oJ1tPZmZsaW5lXTonLCAuLi5hcmdzKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zID0+IHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSBjcmVhdGVUcmFuc3BvcnQob3B0aW9ucyk7XG5cbiAgICBpZiAoIW9wdGlvbnMuY3JlYXRlU3RvcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYGNyZWF0ZVN0b3JlYCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZSA9IG9wdGlvbnMuY3JlYXRlU3RvcmUob3B0aW9ucyk7XG5cbiAgICBsZXQgcmV0cnlEZWxheSA9IFNUQVJUX0RFTEFZO1xuICAgIGxldCBmbHVzaFRpbWVyO1xuXG4gICAgZnVuY3Rpb24gc2hvdWxkUXVldWUoZW52LCBlcnJvciwgcmV0cnlEZWxheSkge1xuICAgICAgLy8gV2Ugd2FudCB0byBkcm9wIGNsaWVudCByZXBvcnRzIGJlY2F1c2UgdGhleSBjYW4gYmUgZ2VuZXJhdGVkIHdoZW4gd2UgcmV0cnkgc2VuZGluZyBldmVudHMgd2hpbGUgb2ZmbGluZS5cbiAgICAgIGlmIChlbnZlbG9wZS5lbnZlbG9wZUNvbnRhaW5zSXRlbVR5cGUoZW52LCBbJ2NsaWVudF9yZXBvcnQnXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5zaG91bGRTdG9yZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5zaG91bGRTdG9yZShlbnYsIGVycm9yLCByZXRyeURlbGF5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmx1c2hJbihkZWxheSkge1xuICAgICAgaWYgKGZsdXNoVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGZsdXNoVGltZXIgKTtcbiAgICAgIH1cblxuICAgICAgZmx1c2hUaW1lciA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBmbHVzaFRpbWVyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGNvbnN0IGZvdW5kID0gYXdhaXQgc3RvcmUuc2hpZnQoKTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgbG9nKCdBdHRlbXB0aW5nIHRvIHNlbmQgcHJldmlvdXNseSBxdWV1ZWQgZXZlbnQnKTtcblxuICAgICAgICAgIC8vIFdlIHNob3VsZCB0byB1cGRhdGUgdGhlIHNlbnRfYXQgdGltZXN0YW1wIHRvIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgICAgICAgZm91bmRbMF0uc2VudF9hdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcblxuICAgICAgICAgIHZvaWQgc2VuZChmb3VuZCwgdHJ1ZSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBsb2coJ0ZhaWxlZCB0byByZXRyeSBzZW5kaW5nJywgZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGRlbGF5KSA7XG5cbiAgICAgIC8vIFdlIG5lZWQgdG8gdW5yZWYgdGhlIHRpbWVyIGluIG5vZGUuanMsIG90aGVyd2lzZSB0aGUgbm9kZSBwcm9jZXNzIG5ldmVyIGV4aXQuXG4gICAgICBpZiAodHlwZW9mIGZsdXNoVGltZXIgIT09ICdudW1iZXInICYmIGZsdXNoVGltZXIudW5yZWYpIHtcbiAgICAgICAgZmx1c2hUaW1lci51bnJlZigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsdXNoV2l0aEJhY2tPZmYoKSB7XG4gICAgICBpZiAoZmx1c2hUaW1lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZsdXNoSW4ocmV0cnlEZWxheSk7XG5cbiAgICAgIHJldHJ5RGVsYXkgPSBNYXRoLm1pbihyZXRyeURlbGF5ICogMiwgTUFYX0RFTEFZKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBzZW5kKGVudmVsb3BlJDEsIGlzUmV0cnkgPSBmYWxzZSkge1xuICAgICAgLy8gV2UgcXVldWUgYWxsIHJlcGxheSBlbnZlbG9wZXMgdG8gYXZvaWQgbXVsdGlwbGUgcmVwbGF5IGVudmVsb3BlcyBiZWluZyBzZW50IGF0IHRoZSBzYW1lIHRpbWUuIElmIG9uZSBmYWlscywgd2VcbiAgICAgIC8vIG5lZWQgdG8gcmV0cnkgdGhlbSBpbiBvcmRlci5cbiAgICAgIGlmICghaXNSZXRyeSAmJiBlbnZlbG9wZS5lbnZlbG9wZUNvbnRhaW5zSXRlbVR5cGUoZW52ZWxvcGUkMSwgWydyZXBsYXlfZXZlbnQnLCAncmVwbGF5X3JlY29yZGluZyddKSkge1xuICAgICAgICBhd2FpdCBzdG9yZS5wdXNoKGVudmVsb3BlJDEpO1xuICAgICAgICBmbHVzaEluKE1JTl9ERUxBWSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkU2VuZCAmJiAoYXdhaXQgb3B0aW9ucy5zaG91bGRTZW5kKGVudmVsb3BlJDEpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudmVsb3BlIG5vdCBzZW50IGJlY2F1c2UgYHNob3VsZFNlbmRgIGNhbGxiYWNrIHJldHVybmVkIGZhbHNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0cmFuc3BvcnQuc2VuZChlbnZlbG9wZSQxKTtcblxuICAgICAgICBsZXQgZGVsYXkgPSBNSU5fREVMQVk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSByZXRyeS1hZnRlciBoZWFkZXIsIHVzZSB0aGF0IGFzIHRoZSBuZXh0IGRlbGF5LlxuICAgICAgICAgIGlmIChyZXN1bHQuaGVhZGVycz8uWydyZXRyeS1hZnRlciddKSB7XG4gICAgICAgICAgICBkZWxheSA9IHJhdGVsaW1pdC5wYXJzZVJldHJ5QWZ0ZXJIZWFkZXIocmVzdWx0LmhlYWRlcnNbJ3JldHJ5LWFmdGVyJ10pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmhlYWRlcnM/LlsneC1zZW50cnktcmF0ZS1saW1pdHMnXSkge1xuICAgICAgICAgICAgZGVsYXkgPSA2MDAwMDsgLy8gNjAgc2Vjb25kc1xuICAgICAgICAgIH0gLy8gSWYgd2UgaGF2ZSBhIHNlcnZlciBlcnJvciwgcmV0dXJuIG5vdyBzbyB3ZSBkb24ndCBmbHVzaCB0aGUgcXVldWUuXG4gICAgICAgICAgZWxzZSBpZiAoKHJlc3VsdC5zdGF0dXNDb2RlIHx8IDApID49IDQwMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbHVzaEluKGRlbGF5KTtcbiAgICAgICAgcmV0cnlEZWxheSA9IFNUQVJUX0RFTEFZO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoYXdhaXQgc2hvdWxkUXVldWUoZW52ZWxvcGUkMSwgZSAsIHJldHJ5RGVsYXkpKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBlbnZlbG9wZSB3YXMgYSByZXRyeSwgd2Ugd2FudCB0byBhZGQgaXQgdG8gdGhlIGZyb250IG9mIHRoZSBxdWV1ZSBzbyBpdCdzIHJldHJpZWQgYWdhaW4gZmlyc3QuXG4gICAgICAgICAgaWYgKGlzUmV0cnkpIHtcbiAgICAgICAgICAgIGF3YWl0IHN0b3JlLnVuc2hpZnQoZW52ZWxvcGUkMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHN0b3JlLnB1c2goZW52ZWxvcGUkMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoV2l0aEJhY2tPZmYoKTtcbiAgICAgICAgICBsb2coJ0Vycm9yIHNlbmRpbmcuIEV2ZW50IHF1ZXVlZC4nLCBlICk7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5mbHVzaEF0U3RhcnR1cCkge1xuICAgICAgZmx1c2hXaXRoQmFja09mZigpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzZW5kLFxuICAgICAgZmx1c2g6IHRpbWVvdXQgPT4ge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHRpbWVvdXQsIHdlIHNob3VsZCBhdHRlbXB0IHRvIGZsdXNoIHRoZSBvZmZsaW5lIHF1ZXVlLlxuICAgICAgICBpZiAodGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0cnlEZWxheSA9IFNUQVJUX0RFTEFZO1xuICAgICAgICAgIGZsdXNoSW4oTUlOX0RFTEFZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQuZmx1c2godGltZW91dCk7XG4gICAgICB9LFxuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydHMuTUlOX0RFTEFZID0gTUlOX0RFTEFZO1xuZXhwb3J0cy5TVEFSVF9ERUxBWSA9IFNUQVJUX0RFTEFZO1xuZXhwb3J0cy5tYWtlT2ZmbGluZVRyYW5zcG9ydCA9IG1ha2VPZmZsaW5lVHJhbnNwb3J0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2ZmbGluZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/transports/offline.js\n")},"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/trpc.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst currentScopes = __webpack_require__(/*! ./currentScopes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/currentScopes.js\");\nconst exports$1 = __webpack_require__(/*! ./exports.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/exports.js\");\nconst semanticAttributes = __webpack_require__(/*! ./semanticAttributes.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/semanticAttributes.js\");\n__webpack_require__(/*! ./tracing/errors.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/errors.js\");\nconst object = __webpack_require__(/*! ./utils-hoist/object.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/object.js\");\n__webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/debug-build.js\");\n__webpack_require__(/*! ./utils-hoist/time.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/time.js\");\n__webpack_require__(/*! ./utils-hoist/logger.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/logger.js\");\nconst trace = __webpack_require__(/*! ./tracing/trace.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/tracing/trace.js\");\nconst normalize = __webpack_require__(/*! ./utils-hoist/normalize.js */ \"(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/utils-hoist/normalize.js\");\n\nconst trpcCaptureContext = { mechanism: { handled: false, data: { function: 'trpcMiddleware' } } };\n\nfunction captureIfError(nextResult) {\n  // TODO: Set span status based on what TRPCError was encountered\n  if (\n    typeof nextResult === 'object' &&\n    nextResult !== null &&\n    'ok' in nextResult &&\n    !nextResult.ok &&\n    'error' in nextResult\n  ) {\n    exports$1.captureException(nextResult.error, trpcCaptureContext);\n  }\n}\n\n/**\n * Sentry tRPC middleware that captures errors and creates spans for tRPC procedures.\n */\nfunction trpcMiddleware(options = {}) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return async function (opts) {\n    const { path, type, next, rawInput, getRawInput } = opts;\n\n    const client = currentScopes.getClient();\n    const clientOptions = client?.getOptions();\n\n    const trpcContext = {\n      procedure_path: path,\n      procedure_type: type,\n    };\n\n    object.addNonEnumerableProperty(\n      trpcContext,\n      '__sentry_override_normalization_depth__',\n      1 + // 1 for context.input + the normal normalization depth\n        (clientOptions?.normalizeDepth ?? 5), // 5 is a sane depth\n    );\n\n    if (options.attachRpcInput !== undefined ? options.attachRpcInput : clientOptions?.sendDefaultPii) {\n      if (rawInput !== undefined) {\n        trpcContext.input = normalize.normalize(rawInput);\n      }\n\n      if (getRawInput !== undefined && typeof getRawInput === 'function') {\n        try {\n          const rawRes = await getRawInput();\n\n          trpcContext.input = normalize.normalize(rawRes);\n        } catch (err) {\n          // noop\n        }\n      }\n    }\n\n    return currentScopes.withIsolationScope(scope => {\n      scope.setContext('trpc', trpcContext);\n      return trace.startSpanManual(\n        {\n          name: `trpc/${path}`,\n          op: 'rpc.server',\n          attributes: {\n            [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n            [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.rpc.trpc',\n          },\n          forceTransaction: !!options.forceTransaction,\n        },\n        async span => {\n          try {\n            const nextResult = await next();\n            captureIfError(nextResult);\n            span.end();\n            return nextResult;\n          } catch (e) {\n            exports$1.captureException(e, trpcCaptureContext);\n            span.end();\n            throw e;\n          }\n        },\n      ) ;\n    });\n  };\n}\n\nexports.trpcMiddleware = trpcMiddleware;\n//# sourceMappingURL=trpc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9uZXh0anMvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9janMvdHJwYy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSxzQkFBc0IsbUJBQU8sQ0FBQyxvSEFBb0I7QUFDbEQsa0JBQWtCLG1CQUFPLENBQUMsd0dBQWM7QUFDeEMsMkJBQTJCLG1CQUFPLENBQUMsOEhBQXlCO0FBQzVELG1CQUFPLENBQUMsc0hBQXFCO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDaEQsbUJBQU8sQ0FBQyxnSEFBa0I7QUFDMUIsbUJBQU8sQ0FBQywwSEFBdUI7QUFDL0IsbUJBQU8sQ0FBQyw4SEFBeUI7QUFDakMsY0FBYyxtQkFBTyxDQUFDLG9IQUFvQjtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyxvSUFBNEI7O0FBRXRELDZCQUE2QixhQUFhLHdCQUF3Qjs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxZQUFZLDBDQUEwQzs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXERvd25sb2Fkc1xcdGFib3JBY2FkZW15VXBkYXRlZFxcdGFib3ItYWNhZGVteVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxuZXh0anNcXG5vZGVfbW9kdWxlc1xcQHNlbnRyeVxcY29yZVxcYnVpbGRcXGNqc1xcdHJwYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3QgY3VycmVudFNjb3BlcyA9IHJlcXVpcmUoJy4vY3VycmVudFNjb3Blcy5qcycpO1xuY29uc3QgZXhwb3J0cyQxID0gcmVxdWlyZSgnLi9leHBvcnRzLmpzJyk7XG5jb25zdCBzZW1hbnRpY0F0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL3NlbWFudGljQXR0cmlidXRlcy5qcycpO1xucmVxdWlyZSgnLi90cmFjaW5nL2Vycm9ycy5qcycpO1xuY29uc3Qgb2JqZWN0ID0gcmVxdWlyZSgnLi91dGlscy1ob2lzdC9vYmplY3QuanMnKTtcbnJlcXVpcmUoJy4vZGVidWctYnVpbGQuanMnKTtcbnJlcXVpcmUoJy4vdXRpbHMtaG9pc3QvdGltZS5qcycpO1xucmVxdWlyZSgnLi91dGlscy1ob2lzdC9sb2dnZXIuanMnKTtcbmNvbnN0IHRyYWNlID0gcmVxdWlyZSgnLi90cmFjaW5nL3RyYWNlLmpzJyk7XG5jb25zdCBub3JtYWxpemUgPSByZXF1aXJlKCcuL3V0aWxzLWhvaXN0L25vcm1hbGl6ZS5qcycpO1xuXG5jb25zdCB0cnBjQ2FwdHVyZUNvbnRleHQgPSB7IG1lY2hhbmlzbTogeyBoYW5kbGVkOiBmYWxzZSwgZGF0YTogeyBmdW5jdGlvbjogJ3RycGNNaWRkbGV3YXJlJyB9IH0gfTtcblxuZnVuY3Rpb24gY2FwdHVyZUlmRXJyb3IobmV4dFJlc3VsdCkge1xuICAvLyBUT0RPOiBTZXQgc3BhbiBzdGF0dXMgYmFzZWQgb24gd2hhdCBUUlBDRXJyb3Igd2FzIGVuY291bnRlcmVkXG4gIGlmIChcbiAgICB0eXBlb2YgbmV4dFJlc3VsdCA9PT0gJ29iamVjdCcgJiZcbiAgICBuZXh0UmVzdWx0ICE9PSBudWxsICYmXG4gICAgJ29rJyBpbiBuZXh0UmVzdWx0ICYmXG4gICAgIW5leHRSZXN1bHQub2sgJiZcbiAgICAnZXJyb3InIGluIG5leHRSZXN1bHRcbiAgKSB7XG4gICAgZXhwb3J0cyQxLmNhcHR1cmVFeGNlcHRpb24obmV4dFJlc3VsdC5lcnJvciwgdHJwY0NhcHR1cmVDb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNlbnRyeSB0UlBDIG1pZGRsZXdhcmUgdGhhdCBjYXB0dXJlcyBlcnJvcnMgYW5kIGNyZWF0ZXMgc3BhbnMgZm9yIHRSUEMgcHJvY2VkdXJlcy5cbiAqL1xuZnVuY3Rpb24gdHJwY01pZGRsZXdhcmUob3B0aW9ucyA9IHt9KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBjb25zdCB7IHBhdGgsIHR5cGUsIG5leHQsIHJhd0lucHV0LCBnZXRSYXdJbnB1dCB9ID0gb3B0cztcblxuICAgIGNvbnN0IGNsaWVudCA9IGN1cnJlbnRTY29wZXMuZ2V0Q2xpZW50KCk7XG4gICAgY29uc3QgY2xpZW50T3B0aW9ucyA9IGNsaWVudD8uZ2V0T3B0aW9ucygpO1xuXG4gICAgY29uc3QgdHJwY0NvbnRleHQgPSB7XG4gICAgICBwcm9jZWR1cmVfcGF0aDogcGF0aCxcbiAgICAgIHByb2NlZHVyZV90eXBlOiB0eXBlLFxuICAgIH07XG5cbiAgICBvYmplY3QuYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KFxuICAgICAgdHJwY0NvbnRleHQsXG4gICAgICAnX19zZW50cnlfb3ZlcnJpZGVfbm9ybWFsaXphdGlvbl9kZXB0aF9fJyxcbiAgICAgIDEgKyAvLyAxIGZvciBjb250ZXh0LmlucHV0ICsgdGhlIG5vcm1hbCBub3JtYWxpemF0aW9uIGRlcHRoXG4gICAgICAgIChjbGllbnRPcHRpb25zPy5ub3JtYWxpemVEZXB0aCA/PyA1KSwgLy8gNSBpcyBhIHNhbmUgZGVwdGhcbiAgICApO1xuXG4gICAgaWYgKG9wdGlvbnMuYXR0YWNoUnBjSW5wdXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXR0YWNoUnBjSW5wdXQgOiBjbGllbnRPcHRpb25zPy5zZW5kRGVmYXVsdFBpaSkge1xuICAgICAgaWYgKHJhd0lucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHJwY0NvbnRleHQuaW5wdXQgPSBub3JtYWxpemUubm9ybWFsaXplKHJhd0lucHV0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldFJhd0lucHV0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGdldFJhd0lucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmF3UmVzID0gYXdhaXQgZ2V0UmF3SW5wdXQoKTtcblxuICAgICAgICAgIHRycGNDb250ZXh0LmlucHV0ID0gbm9ybWFsaXplLm5vcm1hbGl6ZShyYXdSZXMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudFNjb3Blcy53aXRoSXNvbGF0aW9uU2NvcGUoc2NvcGUgPT4ge1xuICAgICAgc2NvcGUuc2V0Q29udGV4dCgndHJwYycsIHRycGNDb250ZXh0KTtcbiAgICAgIHJldHVybiB0cmFjZS5zdGFydFNwYW5NYW51YWwoXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBgdHJwYy8ke3BhdGh9YCxcbiAgICAgICAgICBvcDogJ3JwYy5zZXJ2ZXInLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFtzZW1hbnRpY0F0dHJpYnV0ZXMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdOiAncm91dGUnLFxuICAgICAgICAgICAgW3NlbWFudGljQXR0cmlidXRlcy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06ICdhdXRvLnJwYy50cnBjJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvcmNlVHJhbnNhY3Rpb246ICEhb3B0aW9ucy5mb3JjZVRyYW5zYWN0aW9uLFxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBzcGFuID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFJlc3VsdCA9IGF3YWl0IG5leHQoKTtcbiAgICAgICAgICAgIGNhcHR1cmVJZkVycm9yKG5leHRSZXN1bHQpO1xuICAgICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0UmVzdWx0O1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGV4cG9ydHMkMS5jYXB0dXJlRXhjZXB0aW9uKGUsIHRycGNDYXB0dXJlQ29udGV4dCk7XG4gICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApIDtcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0cy50cnBjTWlkZGxld2FyZSA9IHRycGNNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJwYy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/nextjs/node_modules/@sentry/core/build/cjs/trpc.js\n")}};