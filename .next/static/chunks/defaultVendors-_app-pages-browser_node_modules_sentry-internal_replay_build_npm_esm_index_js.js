"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([["defaultVendors-_app-pages-browser_node_modules_sentry-internal_replay_build_npm_esm_index_js"],{"(app-pages-browser)/./node_modules/@sentry-internal/replay/build/npm/esm/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval(__webpack_require__.ts('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getReplay: () => (/* binding */ getReplay),\n/* harmony export */   replayIntegration: () => (/* binding */ replayIntegration)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils-hoist/normalize.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils-hoist/object.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils-hoist/browser.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils-hoist/time.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/breadcrumbs.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils-hoist/logger.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils-hoist/severity.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/exports.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils-hoist/misc.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/currentScopes.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils/spanUtils.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils/isSentryRequestUrl.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils-hoist/string.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils-hoist/envelope.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils/prepareEvent.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils-hoist/syncpromise.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils-hoist/ratelimit.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/semanticAttributes.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils-hoist/isBrowser.js");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @sentry/core */ "(app-pages-browser)/./node_modules/@sentry-internal/replay/node_modules/@sentry/core/build/esm/utils/parseSampleRate.js");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sentry-internal/browser-utils */ "(app-pages-browser)/./node_modules/@sentry-internal/browser-utils/build/esm/getNativeImplementation.js");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sentry-internal/browser-utils */ "(app-pages-browser)/./node_modules/@sentry-internal/browser-utils/build/esm/metrics/instrument.js");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @sentry-internal/browser-utils */ "(app-pages-browser)/./node_modules/@sentry-internal/browser-utils/build/esm/networkUtils.js");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @sentry-internal/browser-utils */ "(app-pages-browser)/./node_modules/@sentry-internal/browser-utils/build/esm/instrument/xhr.js");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @sentry-internal/browser-utils */ "(app-pages-browser)/./node_modules/@sentry-internal/browser-utils/build/esm/instrument/dom.js");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @sentry-internal/browser-utils */ "(app-pages-browser)/./node_modules/@sentry-internal/browser-utils/build/esm/instrument/history.js");\n\n\n\n// exporting a separate copy of `WINDOW` rather than exporting the one from `@sentry/browser`\n// prevents the browser package from being bundled in the CDN bundle, and avoids a\n// circular dependency between the browser and replay packages should `@sentry/browser` import\n// from `@sentry/replay` in the future\nconst WINDOW = _sentry_core__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ ;\n\nconst REPLAY_SESSION_KEY = \'sentryReplaySession\';\nconst REPLAY_EVENT_NAME = \'replay_event\';\nconst UNABLE_TO_SEND_REPLAY = \'Unable to send Replay\';\n\n// The idle limit for a session after which recording is paused.\nconst SESSION_IDLE_PAUSE_DURATION = 300000; // 5 minutes in ms\n\n// The idle limit for a session after which the session expires.\nconst SESSION_IDLE_EXPIRE_DURATION = 900000; // 15 minutes in ms\n\n/** Default flush delays */\nconst DEFAULT_FLUSH_MIN_DELAY = 5000;\n// XXX: Temp fix for our debounce logic where `maxWait` would never occur if it\n// was the same as `wait`\nconst DEFAULT_FLUSH_MAX_DELAY = 5500;\n\n/* How long to wait for error checkouts */\nconst BUFFER_CHECKOUT_TIME = 60000;\n\nconst RETRY_BASE_INTERVAL = 5000;\nconst RETRY_MAX_COUNT = 3;\n\n/* The max (uncompressed) size in bytes of a network body. Any body larger than this will be truncated. */\nconst NETWORK_BODY_MAX_SIZE = 150000;\n\n/* The max size of a single console arg that is captured. Any arg larger than this will be truncated. */\nconst CONSOLE_ARG_MAX_SIZE = 5000;\n\n/* Min. time to wait before we consider something a slow click. */\nconst SLOW_CLICK_THRESHOLD = 3000;\n/* For scroll actions after a click, we only look for a very short time period to detect programmatic scrolling. */\nconst SLOW_CLICK_SCROLL_TIMEOUT = 300;\n\n/** When encountering a total segment size exceeding this size, stop the replay (as we cannot properly ingest it). */\nconst REPLAY_MAX_EVENT_BUFFER_SIZE = 20000000; // ~20MB\n\n/** Replays must be min. 5s long before we send them. */\nconst MIN_REPLAY_DURATION = 4999;\n/* The max. allowed value that the minReplayDuration can be set to. */\nconst MIN_REPLAY_DURATION_LIMIT = 15000;\n\n/** The max. length of a replay. */\nconst MAX_REPLAY_DURATION = 3600000; // 60 minutes in ms;\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);\nvar NodeType$2 = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2["Document"] = 0] = "Document";\n  NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";\n  NodeType2[NodeType2["Element"] = 2] = "Element";\n  NodeType2[NodeType2["Text"] = 3] = "Text";\n  NodeType2[NodeType2["CDATA"] = 4] = "CDATA";\n  NodeType2[NodeType2["Comment"] = 5] = "Comment";\n  return NodeType2;\n})(NodeType$2 || {});\nfunction isElement$1(n2) {\n  return n2.nodeType === n2.ELEMENT_NODE;\n}\nfunction isShadowRoot(n2) {\n  const host = n2?.host;\n  return Boolean(host?.shadowRoot === n2);\n}\nfunction isNativeShadowDom(shadowRoot) {\n  return Object.prototype.toString.call(shadowRoot) === "[object ShadowRoot]";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n  if (cssText.includes(" background-clip: text;") && !cssText.includes(" -webkit-background-clip: text;")) {\n    cssText = cssText.replace(\n      /\\sbackground-clip:\\s*text;/g,\n      " -webkit-background-clip: text; background-clip: text;"\n    );\n  }\n  return cssText;\n}\nfunction escapeImportStatement(rule) {\n  const { cssText } = rule;\n  if (cssText.split(\'"\').length < 3) return cssText;\n  const statement = ["@import", `url(${JSON.stringify(rule.href)})`];\n  if (rule.layerName === "") {\n    statement.push(`layer`);\n  } else if (rule.layerName) {\n    statement.push(`layer(${rule.layerName})`);\n  }\n  if (rule.supportsText) {\n    statement.push(`supports(${rule.supportsText})`);\n  }\n  if (rule.media.length) {\n    statement.push(rule.media.mediaText);\n  }\n  return statement.join(" ") + ";";\n}\nfunction stringifyStylesheet(s2) {\n  try {\n    const rules2 = s2.rules || s2.cssRules;\n    return rules2 ? fixBrowserCompatibilityIssuesInCSS(\n      Array.from(rules2, stringifyRule).join("")\n    ) : null;\n  } catch (error) {\n    return null;\n  }\n}\nfunction fixAllCssProperty(rule) {\n  let styles = "";\n  for (let i2 = 0; i2 < rule.style.length; i2++) {\n    const styleDeclaration = rule.style;\n    const attribute = styleDeclaration[i2];\n    const isImportant = styleDeclaration.getPropertyPriority(attribute);\n    styles += `${attribute}:${styleDeclaration.getPropertyValue(attribute)}${isImportant ? ` !important` : ""};`;\n  }\n  return `${rule.selectorText} { ${styles} }`;\n}\nfunction stringifyRule(rule) {\n  let importStringified;\n  if (isCSSImportRule(rule)) {\n    try {\n      importStringified = // for same-origin stylesheets,\n      // we can access the imported stylesheet rules directly\n      stringifyStylesheet(rule.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement\n      escapeImportStatement(rule);\n    } catch (error) {\n    }\n  } else if (isCSSStyleRule(rule)) {\n    let cssText = rule.cssText;\n    const needsSafariColonFix = rule.selectorText.includes(":");\n    const needsAllFix = typeof rule.style["all"] === "string" && rule.style["all"];\n    if (needsAllFix) {\n      cssText = fixAllCssProperty(rule);\n    }\n    if (needsSafariColonFix) {\n      cssText = fixSafariColons(cssText);\n    }\n    if (needsSafariColonFix || needsAllFix) {\n      return cssText;\n    }\n  }\n  return importStringified || rule.cssText;\n}\nfunction fixSafariColons(cssStringified) {\n  const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n  return cssStringified.replace(regex, "$1\\\\$2");\n}\nfunction isCSSImportRule(rule) {\n  return "styleSheet" in rule;\n}\nfunction isCSSStyleRule(rule) {\n  return "selectorText" in rule;\n}\nclass Mirror {\n  constructor() {\n    __publicField$1(this, "idNodeMap", /* @__PURE__ */ new Map());\n    __publicField$1(this, "nodeMetaMap", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn\'t remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach(\n        (childNode) => this.removeNodeFromMap(childNode)\n      );\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n}\nfunction createMirror$2() {\n  return new Mirror();\n}\nfunction shouldMaskInput({\n  maskInputOptions,\n  tagName,\n  type\n}) {\n  if (tagName === "OPTION") {\n    tagName = "SELECT";\n  }\n  return Boolean(\n    maskInputOptions[tagName.toLowerCase()] || type && maskInputOptions[type] || type === "password" || // Default to "text" option for inputs without a "type" attribute defined\n    tagName === "INPUT" && !type && maskInputOptions["text"]\n  );\n}\nfunction maskInputValue({\n  isMasked,\n  element,\n  value,\n  maskInputFn\n}) {\n  let text = value || "";\n  if (!isMasked) {\n    return text;\n  }\n  if (maskInputFn) {\n    text = maskInputFn(text, element);\n  }\n  return "*".repeat(text.length);\n}\nfunction toLowerCase(str) {\n  return str.toLowerCase();\n}\nfunction toUpperCase(str) {\n  return str.toUpperCase();\n}\nconst ORIGINAL_ATTRIBUTE_NAME = "__rrweb_original__";\nfunction is2DCanvasBlank(canvas) {\n  const ctx = canvas.getContext("2d");\n  if (!ctx) return true;\n  const chunkSize = 50;\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      const getImageData = ctx.getImageData;\n      const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n      const pixelBuffer = new Uint32Array(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n        originalGetImageData.call(\n          ctx,\n          x,\n          y,\n          Math.min(chunkSize, canvas.width - x),\n          Math.min(chunkSize, canvas.height - y)\n        ).data.buffer\n      );\n      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\nfunction getInputType(element) {\n  const type = element.type;\n  return element.hasAttribute("data-rr-is-password") ? "password" : type ? (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    toLowerCase(type)\n  ) : null;\n}\nfunction getInputValue(el, tagName, type) {\n  if (tagName === "INPUT" && (type === "radio" || type === "checkbox")) {\n    return el.getAttribute("value") || "";\n  }\n  return el.value;\n}\nfunction extractFileExtension(path, baseURL) {\n  let url;\n  try {\n    url = new URL(path, baseURL ?? window.location.href);\n  } catch (err) {\n    return null;\n  }\n  const regex = /\\.([0-9a-z]+)(?:$)/i;\n  const match = url.pathname.match(regex);\n  return match?.[1] ?? null;\n}\nconst cachedImplementations$1 = {};\nfunction getImplementation$1(name) {\n  const cached = cachedImplementations$1[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === "function") {\n    try {\n      const sandbox = document2.createElement("iframe");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {\n    }\n  }\n  return cachedImplementations$1[name] = impl.bind(\n    window\n  );\n}\nfunction setTimeout$2(...rest) {\n  return getImplementation$1("setTimeout")(...rest);\n}\nfunction clearTimeout$1(...rest) {\n  return getImplementation$1("clearTimeout")(...rest);\n}\nfunction getIframeContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {\n  }\n}\nlet _id = 1;\nconst tagNameRegex = new RegExp("[^a-z0-9-_:]");\nconst IGNORED_NODE = -2;\nfunction genId() {\n  return _id++;\n}\nfunction getValidTagName$1(element) {\n  if (element instanceof HTMLFormElement) {\n    return "form";\n  }\n  const processedTagName = toLowerCase(element.tagName);\n  if (tagNameRegex.test(processedTagName)) {\n    return "div";\n  }\n  return processedTagName;\n}\nfunction extractOrigin(url) {\n  let origin = "";\n  if (url.indexOf("//") > -1) {\n    origin = url.split("/").slice(0, 3).join("/");\n  } else {\n    origin = url.split("/")[0];\n  }\n  origin = origin.split("?")[0];\n  return origin;\n}\nlet canvasService;\nlet canvasCtx;\nconst URL_IN_CSS_REF = /url\\((?:(\')([^\']*)\'|(")(.*?)"|([^)]*))\\)/gm;\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nconst URL_WWW_MATCH = /^www\\..*/i;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absoluteToStylesheet(cssText, href) {\n  return (cssText || "").replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || "";\n      if (!filePath) {\n        return origin;\n      }\n      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === "/") {\n        return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\n      }\n      const stack = href.split("/");\n      const parts = filePath.split("/");\n      stack.pop();\n      for (const part of parts) {\n        if (part === ".") {\n          continue;\n        } else if (part === "..") {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join("/")}${maybeQuote})`;\n    }\n  );\n}\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n  if (attributeValue.trim() === "") {\n    return attributeValue;\n  }\n  let pos = 0;\n  function collectCharacters(regEx) {\n    let chars2;\n    const match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars2 = match[0];\n      pos += chars2.length;\n      return chars2;\n    }\n    return "";\n  }\n  const output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === ",") {\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      output.push(url);\n    } else {\n      let descriptorsStr = "";\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        const c2 = attributeValue.charAt(pos);\n        if (c2 === "") {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c2 === ",") {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break;\n          } else if (c2 === "(") {\n            inParens = true;\n          }\n        } else {\n          if (c2 === ")") {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c2;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(", ");\n}\nconst cachedDocument = /* @__PURE__ */ new WeakMap();\nfunction absoluteToDoc(doc, attributeValue) {\n  if (!attributeValue || attributeValue.trim() === "") {\n    return attributeValue;\n  }\n  return getHref(doc, attributeValue);\n}\nfunction isSVGElement(el) {\n  return Boolean(el.tagName === "svg" || el.ownerSVGElement);\n}\nfunction getHref(doc, customHref) {\n  let a2 = cachedDocument.get(doc);\n  if (!a2) {\n    a2 = doc.createElement("a");\n    cachedDocument.set(doc, a2);\n  }\n  if (!customHref) {\n    customHref = "";\n  } else if (customHref.startsWith("blob:") || customHref.startsWith("data:")) {\n    return customHref;\n  }\n  a2.setAttribute("href", customHref);\n  return a2.href;\n}\nfunction transformAttribute(doc, tagName, name, value, element, maskAttributeFn) {\n  if (!value) {\n    return value;\n  }\n  if (name === "src" || name === "href" && !(tagName === "use" && value[0] === "#")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === "xlink:href" && value[0] !== "#") {\n    return absoluteToDoc(doc, value);\n  } else if (name === "background" && (tagName === "table" || tagName === "td" || tagName === "th")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === "srcset") {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === "style") {\n    return absoluteToStylesheet(value, getHref(doc));\n  } else if (tagName === "object" && name === "data") {\n    return absoluteToDoc(doc, value);\n  }\n  if (typeof maskAttributeFn === "function") {\n    return maskAttributeFn(name, value, element);\n  }\n  return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n  return (tagName === "video" || tagName === "audio") && name === "autoplay";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\n  try {\n    if (unblockSelector && element.matches(unblockSelector)) {\n      return false;\n    }\n    if (typeof blockClass === "string") {\n      if (element.classList.contains(blockClass)) {\n        return true;\n      }\n    } else {\n      for (let eIndex = element.classList.length; eIndex--; ) {\n        const className = element.classList[eIndex];\n        if (blockClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (blockSelector) {\n      return element.matches(blockSelector);\n    }\n  } catch (e2) {\n  }\n  return false;\n}\nfunction elementClassMatchesRegex(el, regex) {\n  for (let eIndex = el.classList.length; eIndex--; ) {\n    const className = el.classList[eIndex];\n    if (regex.test(className)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\n  if (!node) return -1;\n  if (node.nodeType !== node.ELEMENT_NODE) return -1;\n  if (distance > limit) return -1;\n  if (matchPredicate(node)) return distance;\n  return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\n}\nfunction createMatchPredicate(className, selector) {\n  return (node) => {\n    const el = node;\n    if (el === null) return false;\n    try {\n      if (className) {\n        if (typeof className === "string") {\n          if (el.matches(`.${className}`)) return true;\n        } else if (elementClassMatchesRegex(el, className)) {\n          return true;\n        }\n      }\n      if (selector && el.matches(selector)) return true;\n      return false;\n    } catch {\n      return false;\n    }\n  };\n}\nfunction needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    if (el === null) return false;\n    if (el.tagName === "INPUT") {\n      const autocomplete = el.getAttribute("autocomplete");\n      const disallowedAutocompleteValues = [\n        "current-password",\n        "new-password",\n        "cc-number",\n        "cc-exp",\n        "cc-exp-month",\n        "cc-exp-year",\n        "cc-csc"\n      ];\n      if (disallowedAutocompleteValues.includes(autocomplete)) {\n        return true;\n      }\n    }\n    let maskDistance = -1;\n    let unmaskDistance = -1;\n    if (maskAllText) {\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector)\n      );\n      if (unmaskDistance < 0) {\n        return true;\n      }\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector),\n        unmaskDistance >= 0 ? unmaskDistance : Infinity\n      );\n    } else {\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector)\n      );\n      if (maskDistance < 0) {\n        return false;\n      }\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector),\n        maskDistance >= 0 ? maskDistance : Infinity\n      );\n    }\n    return maskDistance >= 0 ? unmaskDistance >= 0 ? maskDistance <= unmaskDistance : true : unmaskDistance >= 0 ? false : !!maskAllText;\n  } catch (e2) {\n  }\n  return !!maskAllText;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  let fired = false;\n  let readyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== "complete") {\n    const timer = setTimeout$2(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener("load", () => {\n      clearTimeout$1(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  const blankUrl = "about:blank";\n  if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === "") {\n    setTimeout$2(listener, 0);\n    return iframeEl.addEventListener("load", listener);\n  }\n  iframeEl.addEventListener("load", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n  let fired = false;\n  let styleSheetLoaded;\n  try {\n    styleSheetLoaded = link.sheet;\n  } catch (error) {\n    return;\n  }\n  if (styleSheetLoaded) return;\n  const timer = setTimeout$2(() => {\n    if (!fired) {\n      listener();\n      fired = true;\n    }\n  }, styleSheetLoadTimeout);\n  link.addEventListener("load", () => {\n    clearTimeout$1(timer);\n    fired = true;\n    listener();\n  });\n}\nfunction serializeNode(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskAttributeFn,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false\n  } = options;\n  const rootId = getRootId(doc, mirror2);\n  switch (n2.nodeType) {\n    case n2.DOCUMENT_NODE:\n      if (n2.compatMode !== "CSS1Compat") {\n        return {\n          type: NodeType$2.Document,\n          childNodes: [],\n          compatMode: n2.compatMode\n          // probably "BackCompat"\n        };\n      } else {\n        return {\n          type: NodeType$2.Document,\n          childNodes: []\n        };\n      }\n    case n2.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType$2.DocumentType,\n        name: n2.name,\n        publicId: n2.publicId,\n        systemId: n2.systemId,\n        rootId\n      };\n    case n2.ELEMENT_NODE:\n      return serializeElementNode(n2, {\n        doc,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        inlineStylesheet,\n        maskAttributeFn,\n        maskInputOptions,\n        maskInputFn,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        keepIframeSrcFn,\n        newlyAddedElement,\n        rootId,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector\n      });\n    case n2.TEXT_NODE:\n      return serializeTextNode(n2, {\n        doc,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        maskTextFn,\n        maskInputOptions,\n        maskInputFn,\n        rootId\n      });\n    case n2.CDATA_SECTION_NODE:\n      return {\n        type: NodeType$2.CDATA,\n        textContent: "",\n        rootId\n      };\n    case n2.COMMENT_NODE:\n      return {\n        type: NodeType$2.Comment,\n        textContent: n2.textContent || "",\n        rootId\n      };\n    default:\n      return false;\n  }\n}\nfunction getRootId(doc, mirror2) {\n  if (!mirror2.hasNode(doc)) return void 0;\n  const docId = mirror2.getId(doc);\n  return docId === 1 ? void 0 : docId;\n}\nfunction serializeTextNode(n2, options) {\n  const {\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    maskTextFn,\n    maskInputOptions,\n    maskInputFn,\n    rootId\n  } = options;\n  const parentTagName = n2.parentNode && n2.parentNode.tagName;\n  let textContent = n2.textContent;\n  const isStyle = parentTagName === "STYLE" ? true : void 0;\n  const isScript = parentTagName === "SCRIPT" ? true : void 0;\n  const isTextarea = parentTagName === "TEXTAREA" ? true : void 0;\n  if (isStyle && textContent) {\n    try {\n      if (n2.nextSibling || n2.previousSibling) {\n      } else if (n2.parentNode.sheet?.cssRules) {\n        textContent = stringifyStylesheet(\n          n2.parentNode.sheet\n        );\n      }\n    } catch (err) {\n      console.warn(\n        `Cannot get CSS styles from text\'s parentNode. Error: ${err}`,\n        n2\n      );\n    }\n    textContent = absoluteToStylesheet(textContent, getHref(options.doc));\n  }\n  if (isScript) {\n    textContent = "SCRIPT_PLACEHOLDER";\n  }\n  const forceMask = needMaskingText(\n    n2,\n    maskTextClass,\n    maskTextSelector,\n    unmaskTextClass,\n    unmaskTextSelector,\n    maskAllText\n  );\n  if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\n    textContent = maskTextFn ? maskTextFn(textContent, n2.parentElement) : textContent.replace(/[\\S]/g, "*");\n  }\n  if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\n    textContent = maskInputFn ? maskInputFn(textContent, n2.parentNode) : textContent.replace(/[\\S]/g, "*");\n  }\n  if (parentTagName === "OPTION" && textContent) {\n    const isInputMasked = shouldMaskInput({\n      type: null,\n      tagName: parentTagName,\n      maskInputOptions\n    });\n    textContent = maskInputValue({\n      isMasked: needMaskingText(\n        n2,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        isInputMasked\n      ),\n      element: n2,\n      value: textContent,\n      maskInputFn\n    });\n  }\n  return {\n    type: NodeType$2.Text,\n    textContent: textContent || "",\n    isStyle,\n    rootId\n  };\n}\nfunction serializeElementNode(n2, options) {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n    rootId,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector\n  } = options;\n  const needBlock = _isBlockedElement(\n    n2,\n    blockClass,\n    blockSelector,\n    unblockSelector\n  );\n  const tagName = getValidTagName$1(n2);\n  let attributes2 = {};\n  const len = n2.attributes.length;\n  for (let i2 = 0; i2 < len; i2++) {\n    const attr = n2.attributes[i2];\n    if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\n      attributes2[attr.name] = transformAttribute(\n        doc,\n        tagName,\n        toLowerCase(attr.name),\n        attr.value,\n        n2,\n        maskAttributeFn\n      );\n    }\n  }\n  if (tagName === "link" && inlineStylesheet) {\n    const stylesheet = Array.from(doc.styleSheets).find((s2) => {\n      return s2.href === n2.href;\n    });\n    let cssText = null;\n    if (stylesheet) {\n      cssText = stringifyStylesheet(stylesheet);\n    }\n    if (cssText) {\n      attributes2.rel = null;\n      attributes2.href = null;\n      attributes2.crossorigin = null;\n      attributes2._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n    }\n  }\n  if (tagName === "style" && n2.sheet && // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n  !(n2.innerText || n2.textContent || "").trim().length) {\n    const cssText = stringifyStylesheet(\n      n2.sheet\n    );\n    if (cssText) {\n      attributes2._cssText = absoluteToStylesheet(cssText, getHref(doc));\n    }\n  }\n  if (tagName === "input" || tagName === "textarea" || tagName === "select" || tagName === "option") {\n    const el = n2;\n    const type = getInputType(el);\n    const value = getInputValue(el, toUpperCase(tagName), type);\n    const checked = el.checked;\n    if (type !== "submit" && type !== "button" && value) {\n      const forceMask = needMaskingText(\n        el,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        shouldMaskInput({\n          type,\n          tagName: toUpperCase(tagName),\n          maskInputOptions\n        })\n      );\n      attributes2.value = maskInputValue({\n        isMasked: forceMask,\n        element: el,\n        value,\n        maskInputFn\n      });\n    }\n    if (checked) {\n      attributes2.checked = checked;\n    }\n  }\n  if (tagName === "option") {\n    if (n2.selected && !maskInputOptions["select"]) {\n      attributes2.selected = true;\n    } else {\n      delete attributes2.selected;\n    }\n  }\n  if (tagName === "canvas" && recordCanvas) {\n    if (n2.__context === "2d") {\n      if (!is2DCanvasBlank(n2)) {\n        attributes2.rr_dataURL = n2.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      }\n    } else if (!("__context" in n2)) {\n      const canvasDataURL = n2.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      const blankCanvas = doc.createElement("canvas");\n      blankCanvas.width = n2.width;\n      blankCanvas.height = n2.height;\n      const blankCanvasDataURL = blankCanvas.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      if (canvasDataURL !== blankCanvasDataURL) {\n        attributes2.rr_dataURL = canvasDataURL;\n      }\n    }\n  }\n  if (tagName === "img" && inlineImages) {\n    if (!canvasService) {\n      canvasService = doc.createElement("canvas");\n      canvasCtx = canvasService.getContext("2d");\n    }\n    const image = n2;\n    const imageSrc = image.currentSrc || image.getAttribute("src") || "<unknown-src>";\n    const priorCrossOrigin = image.crossOrigin;\n    const recordInlineImage = () => {\n      image.removeEventListener("load", recordInlineImage);\n      try {\n        canvasService.width = image.naturalWidth;\n        canvasService.height = image.naturalHeight;\n        canvasCtx.drawImage(image, 0, 0);\n        attributes2.rr_dataURL = canvasService.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      } catch (err) {\n        if (image.crossOrigin !== "anonymous") {\n          image.crossOrigin = "anonymous";\n          if (image.complete && image.naturalWidth !== 0)\n            recordInlineImage();\n          else image.addEventListener("load", recordInlineImage);\n          return;\n        } else {\n          console.warn(\n            `Cannot inline img src=${imageSrc}! Error: ${err}`\n          );\n        }\n      }\n      if (image.crossOrigin === "anonymous") {\n        priorCrossOrigin ? attributes2.crossOrigin = priorCrossOrigin : image.removeAttribute("crossorigin");\n      }\n    };\n    if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n    else image.addEventListener("load", recordInlineImage);\n  }\n  if (tagName === "audio" || tagName === "video") {\n    attributes2.rr_mediaState = n2.paused ? "paused" : "played";\n    attributes2.rr_mediaCurrentTime = n2.currentTime;\n  }\n  if (!newlyAddedElement) {\n    if (n2.scrollLeft) {\n      attributes2.rr_scrollLeft = n2.scrollLeft;\n    }\n    if (n2.scrollTop) {\n      attributes2.rr_scrollTop = n2.scrollTop;\n    }\n  }\n  if (needBlock) {\n    const { width, height } = n2.getBoundingClientRect();\n    attributes2 = {\n      class: attributes2.class,\n      rr_width: `${width}px`,\n      rr_height: `${height}px`\n    };\n  }\n  if (tagName === "iframe" && !keepIframeSrcFn(attributes2.src)) {\n    if (!needBlock && !getIframeContentDocument(n2)) {\n      attributes2.rr_src = attributes2.src;\n    }\n    delete attributes2.src;\n  }\n  let isCustomElement;\n  try {\n    if (customElements.get(tagName)) isCustomElement = true;\n  } catch (e2) {\n  }\n  return {\n    type: NodeType$2.Element,\n    tagName,\n    attributes: attributes2,\n    childNodes: [],\n    isSVG: isSVGElement(n2) || void 0,\n    needBlock,\n    rootId,\n    isCustom: isCustomElement\n  };\n}\nfunction lowerIfExists(maybeAttr) {\n  if (maybeAttr === void 0 || maybeAttr === null) {\n    return "";\n  } else {\n    return maybeAttr.toLowerCase();\n  }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n  if (slimDOMOptions.comment && sn.type === NodeType$2.Comment) {\n    return true;\n  } else if (sn.type === NodeType$2.Element) {\n    if (slimDOMOptions.script && // script tag\n    (sn.tagName === "script" || // (module)preload link\n    sn.tagName === "link" && (sn.attributes.rel === "preload" || sn.attributes.rel === "modulepreload") || // prefetch link\n    sn.tagName === "link" && sn.attributes.rel === "prefetch" && typeof sn.attributes.href === "string" && extractFileExtension(sn.attributes.href) === "js")) {\n      return true;\n    } else if (slimDOMOptions.headFavicon && (sn.tagName === "link" && sn.attributes.rel === "shortcut icon" || sn.tagName === "meta" && (lowerIfExists(sn.attributes.name).match(\n      /^msapplication-tile(image|color)$/\n    ) || lowerIfExists(sn.attributes.name) === "application-name" || lowerIfExists(sn.attributes.rel) === "icon" || lowerIfExists(sn.attributes.rel) === "apple-touch-icon" || lowerIfExists(sn.attributes.rel) === "shortcut icon"))) {\n      return true;\n    } else if (sn.tagName === "meta") {\n      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n        return true;\n      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n      lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === "pinterest")) {\n        return true;\n      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === "robots" || lowerIfExists(sn.attributes.name) === "googlebot" || lowerIfExists(sn.attributes.name) === "bingbot")) {\n        return true;\n      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes["http-equiv"] !== void 0) {\n        return true;\n      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === "author" || lowerIfExists(sn.attributes.name) === "generator" || lowerIfExists(sn.attributes.name) === "framework" || lowerIfExists(sn.attributes.name) === "publisher" || lowerIfExists(sn.attributes.name) === "progid" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n        return true;\n      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === "google-site-verification" || lowerIfExists(sn.attributes.name) === "yandex-verification" || lowerIfExists(sn.attributes.name) === "csrf-token" || lowerIfExists(sn.attributes.name) === "p:domain_verify" || lowerIfExists(sn.attributes.name) === "verify-v1" || lowerIfExists(sn.attributes.name) === "verification" || lowerIfExists(sn.attributes.name) === "shopify-checkout-api-token")) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction serializeNodeWithId(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5e3,\n    onStylesheetLoad,\n    stylesheetLoadTimeout = 5e3,\n    keepIframeSrcFn = () => false,\n    newlyAddedElement = false\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n2, {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    maskAllText,\n    unblockSelector,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement\n  });\n  if (!_serializedNode) {\n    console.warn(n2, "not serialized");\n    return null;\n  }\n  let id;\n  if (mirror2.hasNode(n2)) {\n    id = mirror2.getId(n2);\n  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$2.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, "").length) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode2 = Object.assign(_serializedNode, { id });\n  mirror2.add(n2, serializedNode2);\n  if (id === IGNORED_NODE) {\n    return null;\n  }\n  if (onSerialize) {\n    onSerialize(n2);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode2.type === NodeType$2.Element) {\n    recordChild = recordChild && !serializedNode2.needBlock;\n    delete serializedNode2.needBlock;\n    const shadowRoot = n2.shadowRoot;\n    if (shadowRoot && isNativeShadowDom(shadowRoot))\n      serializedNode2.isShadowHost = true;\n  }\n  if ((serializedNode2.type === NodeType$2.Document || serializedNode2.type === NodeType$2.Element) && recordChild) {\n    if (slimDOMOptions.headWhitespace && serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === "head") {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      mirror: mirror2,\n      blockClass,\n      blockSelector,\n      maskAllText,\n      unblockSelector,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      onStylesheetLoad,\n      stylesheetLoadTimeout,\n      keepIframeSrcFn\n    };\n    for (const childN of Array.from(n2.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode2.childNodes.push(serializedChildNode);\n      }\n    }\n    if (isElement$1(n2) && n2.shadowRoot) {\n      for (const childN of Array.from(n2.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          isNativeShadowDom(n2.shadowRoot) && (serializedChildNode.isShadow = true);\n          serializedNode2.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n  if (n2.parentNode && isShadowRoot(n2.parentNode) && isNativeShadowDom(n2.parentNode)) {\n    serializedNode2.isShadow = true;\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === "iframe" && !_isBlockedElement(\n    n2,\n    blockClass,\n    blockSelector,\n    unblockSelector\n  )) {\n    onceIframeLoaded(\n      n2,\n      () => {\n        const iframeDoc = getIframeContentDocument(n2);\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n          });\n          if (serializedIframeNode) {\n            onIframeLoad(\n              n2,\n              serializedIframeNode\n            );\n          }\n        }\n      },\n      iframeLoadTimeout\n    );\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === "link" && typeof serializedNode2.attributes.rel === "string" && (serializedNode2.attributes.rel === "stylesheet" || serializedNode2.attributes.rel === "preload" && typeof serializedNode2.attributes.href === "string" && extractFileExtension(serializedNode2.attributes.href) === "css")) {\n    onceStylesheetLoaded(\n      n2,\n      () => {\n        if (onStylesheetLoad) {\n          const serializedLinkNode = serializeNodeWithId(n2, {\n            doc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n          });\n          if (serializedLinkNode) {\n            onStylesheetLoad(\n              n2,\n              serializedLinkNode\n            );\n          }\n        }\n      },\n      stylesheetLoadTimeout\n    );\n  }\n  return serializedNode2;\n}\nfunction snapshot(n2, options) {\n  const {\n    mirror: mirror2 = new Mirror(),\n    blockClass = "rr-block",\n    blockSelector = null,\n    unblockSelector = null,\n    maskAllText = false,\n    maskTextClass = "rr-mask",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn = () => false\n  } = options || {};\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    "datetime-local": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true\n  } : maskAllInputs === false ? {} : maskAllInputs;\n  const slimDOMOptions = slimDOM === true || slimDOM === "all" ? (\n    // if true: set of sensible options that should not throw away any information\n    {\n      script: true,\n      comment: true,\n      headFavicon: true,\n      headWhitespace: true,\n      headMetaDescKeywords: slimDOM === "all",\n      // destructive\n      headMetaSocial: true,\n      headMetaRobots: true,\n      headMetaHttpEquiv: true,\n      headMetaAuthorship: true,\n      headMetaVerification: true\n    }\n  ) : slimDOM === false ? {} : slimDOM;\n  return serializeNodeWithId(n2, {\n    doc: n2,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild: false,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn,\n    newlyAddedElement: false\n  });\n}\nfunction on(type, fn, target = document) {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\nconst DEPARTED_MIRROR_ACCESS_WARNING = "Please stop import mirror directly. Instead of that,\\r\\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\\r\\nor you can use record.mirror to access the mirror instance during recording.";\nlet _mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  }\n};\nif (typeof window !== "undefined" && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === "map") {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction throttle$1(func, wait, options = {}) {\n  let timeout = null;\n  let previous = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    const context = this;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout$2(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout$1(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\nfunction hookSetter(target, key, d, isRevoked, win = window) {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked ? d : {\n      set(value) {\n        setTimeout$1(() => {\n          d.set.call(this, value);\n        }, 0);\n        if (original && original.set) {\n          original.set.call(this, value);\n        }\n      }\n    }\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return () => {\n      };\n    }\n    const original = source[name];\n    const wrapped = replacement(original);\n    if (typeof wrapped === "function") {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    }\n    source[name] = wrapped;\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => {\n    };\n  }\n}\nlet nowTimestamp = Date.now;\nif (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {\n  nowTimestamp = () => (/* @__PURE__ */ new Date()).getTime();\n}\nfunction getWindowScroll(win) {\n  const doc = win.document;\n  return {\n    left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc?.documentElement.scrollLeft || doc?.body?.parentElement?.scrollLeft || doc?.body?.scrollLeft || 0,\n    top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : doc?.documentElement.scrollTop || doc?.body?.parentElement?.scrollTop || doc?.body?.scrollTop || 0\n  };\n}\nfunction getWindowHeight() {\n  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction closestElementOfNode(node) {\n  if (!node) {\n    return null;\n  }\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    return el;\n  } catch (error) {\n    return null;\n  }\n}\nfunction isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\n  if (!node) {\n    return false;\n  }\n  const el = closestElementOfNode(node);\n  if (!el) {\n    return false;\n  }\n  const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\n  if (!checkAncestors) {\n    const isUnblocked = unblockSelector && el.matches(unblockSelector);\n    return blockedPredicate(el) && !isUnblocked;\n  }\n  const blockDistance = distanceToMatch(el, blockedPredicate);\n  let unblockDistance = -1;\n  if (blockDistance < 0) {\n    return false;\n  }\n  if (unblockSelector) {\n    unblockDistance = distanceToMatch(\n      el,\n      createMatchPredicate(null, unblockSelector)\n    );\n  }\n  if (blockDistance > -1 && unblockDistance < 0) {\n    return true;\n  }\n  return blockDistance < unblockDistance;\n}\nfunction isSerialized(n2, mirror2) {\n  return mirror2.getId(n2) !== -1;\n}\nfunction isIgnored(n2, mirror2) {\n  return mirror2.getId(n2) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror2) {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror2.getId(target);\n  if (!mirror2.has(id)) {\n    return true;\n  }\n  if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {\n    return false;\n  }\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved(target.parentNode, mirror2);\n}\nfunction legacy_isTouchEvent(event) {\n  return Boolean(event.changedTouches);\n}\nfunction polyfill$1(win = window) {\n  if ("NodeList" in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = Array.prototype.forEach;\n  }\n  if ("DOMTokenList" in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = (...args) => {\n      let node = args[0];\n      if (!(0 in args)) {\n        throw new TypeError("1 argument is required");\n      }\n      do {\n        if (this === node) {\n          return true;\n        }\n      } while (node = node && node.parentNode);\n      return false;\n    };\n  }\n}\nfunction isSerializedIframe(n2, mirror2) {\n  return Boolean(n2.nodeName === "IFRAME" && mirror2.getMeta(n2));\n}\nfunction isSerializedStylesheet(n2, mirror2) {\n  return Boolean(\n    n2.nodeName === "LINK" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute("rel") === "stylesheet" && mirror2.getMeta(n2)\n  );\n}\nfunction hasShadowRoot(n2) {\n  return Boolean(n2?.shadowRoot);\n}\nclass StyleSheetMirror {\n  constructor() {\n    this.id = 1;\n    this.styleIDMap = /* @__PURE__ */ new WeakMap();\n    this.idStyleMap = /* @__PURE__ */ new Map();\n  }\n  getId(stylesheet) {\n    return this.styleIDMap.get(stylesheet) ?? -1;\n  }\n  has(stylesheet) {\n    return this.styleIDMap.has(stylesheet);\n  }\n  /**\n   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.\n   */\n  add(stylesheet, id) {\n    if (this.has(stylesheet)) return this.getId(stylesheet);\n    let newId;\n    if (id === void 0) {\n      newId = this.id++;\n    } else newId = id;\n    this.styleIDMap.set(stylesheet, newId);\n    this.idStyleMap.set(newId, stylesheet);\n    return newId;\n  }\n  getStyle(id) {\n    return this.idStyleMap.get(id) || null;\n  }\n  reset() {\n    this.styleIDMap = /* @__PURE__ */ new WeakMap();\n    this.idStyleMap = /* @__PURE__ */ new Map();\n    this.id = 1;\n  }\n  generateId() {\n    return this.id++;\n  }\n}\nfunction getShadowHost(n2) {\n  let shadowHost = null;\n  if (n2.getRootNode?.()?.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n2.getRootNode().host)\n    shadowHost = n2.getRootNode().host;\n  return shadowHost;\n}\nfunction getRootShadowHost(n2) {\n  let rootShadowHost = n2;\n  let shadowHost;\n  while (shadowHost = getShadowHost(rootShadowHost))\n    rootShadowHost = shadowHost;\n  return rootShadowHost;\n}\nfunction shadowHostInDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  const shadowHost = getRootShadowHost(n2);\n  return doc.contains(shadowHost);\n}\nfunction inDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  return doc.contains(n2) || shadowHostInDom(n2);\n}\nconst cachedImplementations = {};\nfunction getImplementation(name) {\n  const cached = cachedImplementations[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === "function") {\n    try {\n      const sandbox = document2.createElement("iframe");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {\n    }\n  }\n  return cachedImplementations[name] = impl.bind(\n    window\n  );\n}\nfunction onRequestAnimationFrame(...rest) {\n  return getImplementation("requestAnimationFrame")(...rest);\n}\nfunction setTimeout$1(...rest) {\n  return getImplementation("setTimeout")(...rest);\n}\nfunction clearTimeout$2(...rest) {\n  return getImplementation("clearTimeout")(...rest);\n}\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2["DomContentLoaded"] = 0] = "DomContentLoaded";\n  EventType2[EventType2["Load"] = 1] = "Load";\n  EventType2[EventType2["FullSnapshot"] = 2] = "FullSnapshot";\n  EventType2[EventType2["IncrementalSnapshot"] = 3] = "IncrementalSnapshot";\n  EventType2[EventType2["Meta"] = 4] = "Meta";\n  EventType2[EventType2["Custom"] = 5] = "Custom";\n  EventType2[EventType2["Plugin"] = 6] = "Plugin";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2["Mutation"] = 0] = "Mutation";\n  IncrementalSource2[IncrementalSource2["MouseMove"] = 1] = "MouseMove";\n  IncrementalSource2[IncrementalSource2["MouseInteraction"] = 2] = "MouseInteraction";\n  IncrementalSource2[IncrementalSource2["Scroll"] = 3] = "Scroll";\n  IncrementalSource2[IncrementalSource2["ViewportResize"] = 4] = "ViewportResize";\n  IncrementalSource2[IncrementalSource2["Input"] = 5] = "Input";\n  IncrementalSource2[IncrementalSource2["TouchMove"] = 6] = "TouchMove";\n  IncrementalSource2[IncrementalSource2["MediaInteraction"] = 7] = "MediaInteraction";\n  IncrementalSource2[IncrementalSource2["StyleSheetRule"] = 8] = "StyleSheetRule";\n  IncrementalSource2[IncrementalSource2["CanvasMutation"] = 9] = "CanvasMutation";\n  IncrementalSource2[IncrementalSource2["Font"] = 10] = "Font";\n  IncrementalSource2[IncrementalSource2["Log"] = 11] = "Log";\n  IncrementalSource2[IncrementalSource2["Drag"] = 12] = "Drag";\n  IncrementalSource2[IncrementalSource2["StyleDeclaration"] = 13] = "StyleDeclaration";\n  IncrementalSource2[IncrementalSource2["Selection"] = 14] = "Selection";\n  IncrementalSource2[IncrementalSource2["AdoptedStyleSheet"] = 15] = "AdoptedStyleSheet";\n  IncrementalSource2[IncrementalSource2["CustomElement"] = 16] = "CustomElement";\n  return IncrementalSource2;\n})(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {\n  MouseInteractions2[MouseInteractions2["MouseUp"] = 0] = "MouseUp";\n  MouseInteractions2[MouseInteractions2["MouseDown"] = 1] = "MouseDown";\n  MouseInteractions2[MouseInteractions2["Click"] = 2] = "Click";\n  MouseInteractions2[MouseInteractions2["ContextMenu"] = 3] = "ContextMenu";\n  MouseInteractions2[MouseInteractions2["DblClick"] = 4] = "DblClick";\n  MouseInteractions2[MouseInteractions2["Focus"] = 5] = "Focus";\n  MouseInteractions2[MouseInteractions2["Blur"] = 6] = "Blur";\n  MouseInteractions2[MouseInteractions2["TouchStart"] = 7] = "TouchStart";\n  MouseInteractions2[MouseInteractions2["TouchMove_Departed"] = 8] = "TouchMove_Departed";\n  MouseInteractions2[MouseInteractions2["TouchEnd"] = 9] = "TouchEnd";\n  MouseInteractions2[MouseInteractions2["TouchCancel"] = 10] = "TouchCancel";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {\n  PointerTypes2[PointerTypes2["Mouse"] = 0] = "Mouse";\n  PointerTypes2[PointerTypes2["Pen"] = 1] = "Pen";\n  PointerTypes2[PointerTypes2["Touch"] = 2] = "Touch";\n  return PointerTypes2;\n})(PointerTypes || {});\nvar MediaInteractions = /* @__PURE__ */ ((MediaInteractions2) => {\n  MediaInteractions2[MediaInteractions2["Play"] = 0] = "Play";\n  MediaInteractions2[MediaInteractions2["Pause"] = 1] = "Pause";\n  MediaInteractions2[MediaInteractions2["Seeked"] = 2] = "Seeked";\n  MediaInteractions2[MediaInteractions2["VolumeChange"] = 3] = "VolumeChange";\n  MediaInteractions2[MediaInteractions2["RateChange"] = 4] = "RateChange";\n  return MediaInteractions2;\n})(MediaInteractions || {});\nfunction getIFrameContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {\n  }\n}\nfunction getIFrameContentWindow(iframe) {\n  try {\n    return iframe.contentWindow;\n  } catch (e2) {\n  }\n}\nfunction isNodeInLinkedList(n2) {\n  return "__ln" in n2;\n}\nclass DoubleLinkedList {\n  constructor() {\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n  }\n  get(position) {\n    if (position >= this.length) {\n      throw new Error("Position outside of list range");\n    }\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = current?.next || null;\n    }\n    return current;\n  }\n  addNode(n2) {\n    const node = {\n      value: n2,\n      previous: null,\n      next: null\n    };\n    n2.__ln = node;\n    if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {\n      const current = n2.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n2.previousSibling.__ln;\n      n2.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {\n      const current = n2.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n2.nextSibling.__ln;\n      n2.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    if (node.next === null) {\n      this.tail = node;\n    }\n    this.length++;\n  }\n  removeNode(n2) {\n    const current = n2.__ln;\n    if (!this.head) {\n      return;\n    }\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      } else {\n        this.tail = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      } else {\n        this.tail = current.previous;\n      }\n    }\n    if (n2.__ln) {\n      delete n2.__ln;\n    }\n    this.length--;\n  }\n}\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\nclass MutationBuffer {\n  constructor() {\n    this.frozen = false;\n    this.locked = false;\n    this.texts = [];\n    this.attributes = [];\n    this.attributeMap = /* @__PURE__ */ new WeakMap();\n    this.removes = [];\n    this.mapRemoves = [];\n    this.movedMap = {};\n    this.addedSet = /* @__PURE__ */ new Set();\n    this.movedSet = /* @__PURE__ */ new Set();\n    this.droppedSet = /* @__PURE__ */ new Set();\n    this.processMutations = (mutations) => {\n      mutations.forEach(this.processMutation);\n      this.emit();\n    };\n    this.emit = () => {\n      if (this.frozen || this.locked) {\n        return;\n      }\n      const adds = [];\n      const addedIds = /* @__PURE__ */ new Set();\n      const addList = new DoubleLinkedList();\n      const getNextId = (n2) => {\n        let ns = n2;\n        let nextId = IGNORED_NODE;\n        while (nextId === IGNORED_NODE) {\n          ns = ns && ns.nextSibling;\n          nextId = ns && this.mirror.getId(ns);\n        }\n        return nextId;\n      };\n      const pushAdd = (n2) => {\n        if (!n2.parentNode || !inDom(n2)) {\n          return;\n        }\n        const parentId = isShadowRoot(n2.parentNode) ? this.mirror.getId(getShadowHost(n2)) : this.mirror.getId(n2.parentNode);\n        const nextId = getNextId(n2);\n        if (parentId === -1 || nextId === -1) {\n          return addList.addNode(n2);\n        }\n        const sn = serializeNodeWithId(n2, {\n          doc: this.doc,\n          mirror: this.mirror,\n          blockClass: this.blockClass,\n          blockSelector: this.blockSelector,\n          maskAllText: this.maskAllText,\n          unblockSelector: this.unblockSelector,\n          maskTextClass: this.maskTextClass,\n          unmaskTextClass: this.unmaskTextClass,\n          maskTextSelector: this.maskTextSelector,\n          unmaskTextSelector: this.unmaskTextSelector,\n          skipChild: true,\n          newlyAddedElement: true,\n          inlineStylesheet: this.inlineStylesheet,\n          maskInputOptions: this.maskInputOptions,\n          maskAttributeFn: this.maskAttributeFn,\n          maskTextFn: this.maskTextFn,\n          maskInputFn: this.maskInputFn,\n          slimDOMOptions: this.slimDOMOptions,\n          dataURLOptions: this.dataURLOptions,\n          recordCanvas: this.recordCanvas,\n          inlineImages: this.inlineImages,\n          onSerialize: (currentN) => {\n            if (isSerializedIframe(currentN, this.mirror) && !isBlocked(\n              currentN,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            )) {\n              this.iframeManager.addIframe(currentN);\n            }\n            if (isSerializedStylesheet(currentN, this.mirror)) {\n              this.stylesheetManager.trackLinkElement(\n                currentN\n              );\n            }\n            if (hasShadowRoot(n2)) {\n              this.shadowDomManager.addShadowRoot(n2.shadowRoot, this.doc);\n            }\n          },\n          onIframeLoad: (iframe, childSn) => {\n            if (isBlocked(\n              iframe,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            )) {\n              return;\n            }\n            this.iframeManager.attachIframe(iframe, childSn);\n            if (iframe.contentWindow) {\n              this.canvasManager.addWindow(iframe.contentWindow);\n            }\n            this.shadowDomManager.observeAttachShadow(iframe);\n          },\n          onStylesheetLoad: (link, childSn) => {\n            this.stylesheetManager.attachLinkElement(link, childSn);\n          }\n        });\n        if (sn) {\n          adds.push({\n            parentId,\n            nextId,\n            node: sn\n          });\n          addedIds.add(sn.id);\n        }\n      };\n      while (this.mapRemoves.length) {\n        this.mirror.removeNodeFromMap(this.mapRemoves.shift());\n      }\n      for (const n2 of this.movedSet) {\n        if (isParentRemoved(this.removes, n2, this.mirror) && !this.movedSet.has(n2.parentNode)) {\n          continue;\n        }\n        pushAdd(n2);\n      }\n      for (const n2 of this.addedSet) {\n        if (!isAncestorInSet(this.droppedSet, n2) && !isParentRemoved(this.removes, n2, this.mirror)) {\n          pushAdd(n2);\n        } else if (isAncestorInSet(this.movedSet, n2)) {\n          pushAdd(n2);\n        } else {\n          this.droppedSet.add(n2);\n        }\n      }\n      let candidate = null;\n      while (addList.length) {\n        let node = null;\n        if (candidate) {\n          const parentId = this.mirror.getId(candidate.value.parentNode);\n          const nextId = getNextId(candidate.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = candidate;\n          }\n        }\n        if (!node) {\n          let tailNode = addList.tail;\n          while (tailNode) {\n            const _node = tailNode;\n            tailNode = tailNode.previous;\n            if (_node) {\n              const parentId = this.mirror.getId(_node.value.parentNode);\n              const nextId = getNextId(_node.value);\n              if (nextId === -1) continue;\n              else if (parentId !== -1) {\n                node = _node;\n                break;\n              } else {\n                const unhandledNode = _node.value;\n                if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                  const shadowHost = unhandledNode.parentNode.host;\n                  const parentId2 = this.mirror.getId(shadowHost);\n                  if (parentId2 !== -1) {\n                    node = _node;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (!node) {\n          while (addList.head) {\n            addList.removeNode(addList.head.value);\n          }\n          break;\n        }\n        candidate = node.previous;\n        addList.removeNode(node.value);\n        pushAdd(node.value);\n      }\n      const payload = {\n        texts: this.texts.map((text) => ({\n          id: this.mirror.getId(text.node),\n          value: text.value\n        })).filter((text) => !addedIds.has(text.id)).filter((text) => this.mirror.has(text.id)),\n        attributes: this.attributes.map((attribute) => {\n          const { attributes } = attribute;\n          if (typeof attributes.style === "string") {\n            const diffAsStr = JSON.stringify(attribute.styleDiff);\n            const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n            if (diffAsStr.length < attributes.style.length) {\n              if ((diffAsStr + unchangedAsStr).split("var(").length === attributes.style.split("var(").length) {\n                attributes.style = attribute.styleDiff;\n              }\n            }\n          }\n          return {\n            id: this.mirror.getId(attribute.node),\n            attributes\n          };\n        }).filter((attribute) => !addedIds.has(attribute.id)).filter((attribute) => this.mirror.has(attribute.id)),\n        removes: this.removes,\n        adds\n      };\n      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n        return;\n      }\n      this.texts = [];\n      this.attributes = [];\n      this.attributeMap = /* @__PURE__ */ new WeakMap();\n      this.removes = [];\n      this.addedSet = /* @__PURE__ */ new Set();\n      this.movedSet = /* @__PURE__ */ new Set();\n      this.droppedSet = /* @__PURE__ */ new Set();\n      this.movedMap = {};\n      this.mutationCb(payload);\n    };\n    this.processMutation = (m) => {\n      if (isIgnored(m.target, this.mirror)) {\n        return;\n      }\n      switch (m.type) {\n        case "characterData": {\n          const value = m.target.textContent;\n          if (!isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            false\n          ) && value !== m.oldValue) {\n            this.texts.push({\n              value: needMaskingText(\n                m.target,\n                this.maskTextClass,\n                this.maskTextSelector,\n                this.unmaskTextClass,\n                this.unmaskTextSelector,\n                this.maskAllText\n              ) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\\S]/g, "*") : value,\n              node: m.target\n            });\n          }\n          break;\n        }\n        case "attributes": {\n          const target = m.target;\n          let attributeName = m.attributeName;\n          let value = m.target.getAttribute(attributeName);\n          if (attributeName === "value") {\n            const type = getInputType(target);\n            const tagName = target.tagName;\n            value = getInputValue(target, tagName, type);\n            const isInputMasked = shouldMaskInput({\n              maskInputOptions: this.maskInputOptions,\n              tagName,\n              type\n            });\n            const forceMask = needMaskingText(\n              m.target,\n              this.maskTextClass,\n              this.maskTextSelector,\n              this.unmaskTextClass,\n              this.unmaskTextSelector,\n              isInputMasked\n            );\n            value = maskInputValue({\n              isMasked: forceMask,\n              element: target,\n              value,\n              maskInputFn: this.maskInputFn\n            });\n          }\n          if (isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            false\n          ) || value === m.oldValue) {\n            return;\n          }\n          let item = this.attributeMap.get(m.target);\n          if (target.tagName === "IFRAME" && attributeName === "src" && !this.keepIframeSrcFn(value)) {\n            const iframeDoc = getIFrameContentDocument(\n              target\n            );\n            if (!iframeDoc) {\n              attributeName = "rr_src";\n            } else {\n              return;\n            }\n          }\n          if (!item) {\n            item = {\n              node: m.target,\n              attributes: {},\n              styleDiff: {},\n              _unchangedStyles: {}\n            };\n            this.attributes.push(item);\n            this.attributeMap.set(m.target, item);\n          }\n          if (attributeName === "type" && target.tagName === "INPUT" && (m.oldValue || "").toLowerCase() === "password") {\n            target.setAttribute("data-rr-is-password", "true");\n          }\n          if (!ignoreAttribute(target.tagName, attributeName)) {\n            item.attributes[attributeName] = transformAttribute(\n              this.doc,\n              toLowerCase(target.tagName),\n              toLowerCase(attributeName),\n              value,\n              target,\n              this.maskAttributeFn\n            );\n            if (attributeName === "style") {\n              if (!this.unattachedDoc) {\n                try {\n                  this.unattachedDoc = document.implementation.createHTMLDocument();\n                } catch (e2) {\n                  this.unattachedDoc = this.doc;\n                }\n              }\n              const old = this.unattachedDoc.createElement("span");\n              if (m.oldValue) {\n                old.setAttribute("style", m.oldValue);\n              }\n              for (const pname of Array.from(target.style)) {\n                const newValue = target.style.getPropertyValue(pname);\n                const newPriority = target.style.getPropertyPriority(pname);\n                if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                  if (newPriority === "") {\n                    item.styleDiff[pname] = newValue;\n                  } else {\n                    item.styleDiff[pname] = [newValue, newPriority];\n                  }\n                } else {\n                  item._unchangedStyles[pname] = [newValue, newPriority];\n                }\n              }\n              for (const pname of Array.from(old.style)) {\n                if (target.style.getPropertyValue(pname) === "") {\n                  item.styleDiff[pname] = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n        case "childList": {\n          if (isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            true\n          )) {\n            return;\n          }\n          m.addedNodes.forEach((n2) => this.genAdds(n2, m.target));\n          m.removedNodes.forEach((n2) => {\n            const nodeId = this.mirror.getId(n2);\n            const parentId = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);\n            if (isBlocked(\n              m.target,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            ) || isIgnored(n2, this.mirror) || !isSerialized(n2, this.mirror)) {\n              return;\n            }\n            if (this.addedSet.has(n2)) {\n              deepDelete(this.addedSet, n2);\n              this.droppedSet.add(n2);\n            } else if (this.addedSet.has(m.target) && nodeId === -1) ;\n            else if (isAncestorRemoved(m.target, this.mirror)) ;\n            else if (this.movedSet.has(n2) && this.movedMap[moveKey(nodeId, parentId)]) {\n              deepDelete(this.movedSet, n2);\n            } else {\n              this.removes.push({\n                parentId,\n                id: nodeId,\n                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0\n              });\n            }\n            this.mapRemoves.push(n2);\n          });\n          break;\n        }\n      }\n    };\n    this.genAdds = (n2, target) => {\n      if (this.processedNodeManager.inOtherBuffer(n2, this)) return;\n      if (this.addedSet.has(n2) || this.movedSet.has(n2)) return;\n      if (this.mirror.hasNode(n2)) {\n        if (isIgnored(n2, this.mirror)) {\n          return;\n        }\n        this.movedSet.add(n2);\n        let targetId = null;\n        if (target && this.mirror.hasNode(target)) {\n          targetId = this.mirror.getId(target);\n        }\n        if (targetId && targetId !== -1) {\n          this.movedMap[moveKey(this.mirror.getId(n2), targetId)] = true;\n        }\n      } else {\n        this.addedSet.add(n2);\n        this.droppedSet.delete(n2);\n      }\n      if (!isBlocked(\n        n2,\n        this.blockClass,\n        this.blockSelector,\n        this.unblockSelector,\n        false\n      )) {\n        n2.childNodes.forEach((childN) => this.genAdds(childN));\n        if (hasShadowRoot(n2)) {\n          n2.shadowRoot.childNodes.forEach((childN) => {\n            this.processedNodeManager.add(childN, this);\n            this.genAdds(childN, n2);\n          });\n        }\n      }\n    };\n  }\n  init(options) {\n    [\n      "mutationCb",\n      "blockClass",\n      "blockSelector",\n      "unblockSelector",\n      "maskAllText",\n      "maskTextClass",\n      "unmaskTextClass",\n      "maskTextSelector",\n      "unmaskTextSelector",\n      "inlineStylesheet",\n      "maskInputOptions",\n      "maskAttributeFn",\n      "maskTextFn",\n      "maskInputFn",\n      "keepIframeSrcFn",\n      "recordCanvas",\n      "inlineImages",\n      "slimDOMOptions",\n      "dataURLOptions",\n      "doc",\n      "mirror",\n      "iframeManager",\n      "stylesheetManager",\n      "shadowDomManager",\n      "canvasManager",\n      "processedNodeManager"\n    ].forEach((key) => {\n      this[key] = options[key];\n    });\n  }\n  freeze() {\n    this.frozen = true;\n    this.canvasManager.freeze();\n  }\n  unfreeze() {\n    this.frozen = false;\n    this.canvasManager.unfreeze();\n    this.emit();\n  }\n  isFrozen() {\n    return this.frozen;\n  }\n  lock() {\n    this.locked = true;\n    this.canvasManager.lock();\n  }\n  unlock() {\n    this.locked = false;\n    this.canvasManager.unlock();\n    this.emit();\n  }\n  reset() {\n    this.shadowDomManager.reset();\n    this.canvasManager.reset();\n  }\n}\nfunction deepDelete(addsSet, n2) {\n  addsSet.delete(n2);\n  n2.childNodes.forEach((childN) => deepDelete(addsSet, childN));\n}\nfunction isParentRemoved(removes, n2, mirror2) {\n  if (removes.length === 0) return false;\n  return _isParentRemoved(removes, n2, mirror2);\n}\nfunction _isParentRemoved(removes, n2, mirror2) {\n  let node = n2.parentNode;\n  while (node) {\n    const parentId = mirror2.getId(node);\n    if (removes.some((r2) => r2.id === parentId)) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\nfunction isAncestorInSet(set, n2) {\n  if (set.size === 0) return false;\n  return _isAncestorInSet(set, n2);\n}\nfunction _isAncestorInSet(set, n2) {\n  const { parentNode } = n2;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return _isAncestorInSet(set, parentNode);\n}\nlet errorHandler;\nfunction registerErrorHandler(handler) {\n  errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n  errorHandler = void 0;\n}\nconst callbackWrapper = (cb) => {\n  if (!errorHandler) {\n    return cb;\n  }\n  const rrwebWrapped = (...rest) => {\n    try {\n      return cb(...rest);\n    } catch (error) {\n      if (errorHandler && errorHandler(error) === true) {\n        return () => {\n        };\n      }\n      throw error;\n    }\n  };\n  return rrwebWrapped;\n};\nconst mutationBuffers = [];\nfunction getEventTarget(event) {\n  try {\n    if ("composedPath" in event) {\n      const path = event.composedPath();\n      if (path.length) {\n        return path[0];\n      }\n    } else if ("path" in event && event.path.length) {\n      return event.path[0];\n    }\n  } catch {\n  }\n  return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n  const mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  mutationBuffer.init(options);\n  let mutationObserverCtor = window.MutationObserver || /**\n  * Some websites may disable MutationObserver by removing it from the window object.\n  * If someone is using rrweb to build a browser extention or things like it, they\n  * could not change the website\'s code but can have an opportunity to inject some\n  * code before the website executing its JS logic.\n  * Then they can do this to store the native MutationObserver:\n  * window.__rrMutationObserver = MutationObserver\n  */\n  window.__rrMutationObserver;\n  const angularZoneSymbol = window?.Zone?.__symbol__?.("MutationObserver");\n  if (angularZoneSymbol && window[angularZoneSymbol]) {\n    mutationObserverCtor = window[angularZoneSymbol];\n  }\n  const observer = new mutationObserverCtor(\n    callbackWrapper((mutations) => {\n      if (options.onMutation && options.onMutation(mutations) === false) {\n        return;\n      }\n      mutationBuffer.processMutations.bind(mutationBuffer)(mutations);\n    })\n  );\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\nfunction initMoveObserver({\n  mousemoveCb,\n  sampling,\n  doc,\n  mirror: mirror2\n}) {\n  if (sampling.mousemove === false) {\n    return () => {\n    };\n  }\n  const threshold = typeof sampling.mousemove === "number" ? sampling.mousemove : 50;\n  const callbackThreshold = typeof sampling.mousemoveCallback === "number" ? sampling.mousemoveCallback : 500;\n  let positions = [];\n  let timeBaseline;\n  const wrappedCb = throttle$1(\n    callbackWrapper(\n      (source) => {\n        const totalOffset = Date.now() - timeBaseline;\n        mousemoveCb(\n          positions.map((p) => {\n            p.timeOffset -= totalOffset;\n            return p;\n          }),\n          source\n        );\n        positions = [];\n        timeBaseline = null;\n      }\n    ),\n    callbackThreshold\n  );\n  const updatePosition = callbackWrapper(\n    throttle$1(\n      callbackWrapper((evt) => {\n        const target = getEventTarget(evt);\n        const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;\n        if (!timeBaseline) {\n          timeBaseline = nowTimestamp();\n        }\n        positions.push({\n          x: clientX,\n          y: clientY,\n          id: mirror2.getId(target),\n          timeOffset: nowTimestamp() - timeBaseline\n        });\n        wrappedCb(\n          typeof DragEvent !== "undefined" && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove\n        );\n      }),\n      threshold,\n      {\n        trailing: false\n      }\n    )\n  );\n  const handlers = [\n    on("mousemove", updatePosition, doc),\n    on("touchmove", updatePosition, doc),\n    on("drag", updatePosition, doc)\n  ];\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initMouseInteractionObserver({\n  mouseInteractionCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  if (sampling.mouseInteraction === false) {\n    return () => {\n    };\n  }\n  const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;\n  const handlers = [];\n  let currentPointerType = null;\n  const getHandler = (eventKey) => {\n    return (event) => {\n      const target = getEventTarget(event);\n      if (isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n        return;\n      }\n      let pointerType = null;\n      let thisEventKey = eventKey;\n      if ("pointerType" in event) {\n        switch (event.pointerType) {\n          case "mouse":\n            pointerType = PointerTypes.Mouse;\n            break;\n          case "touch":\n            pointerType = PointerTypes.Touch;\n            break;\n          case "pen":\n            pointerType = PointerTypes.Pen;\n            break;\n        }\n        if (pointerType === PointerTypes.Touch) {\n          if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n            thisEventKey = "TouchStart";\n          } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n            thisEventKey = "TouchEnd";\n          }\n        } else if (pointerType === PointerTypes.Pen) ;\n      } else if (legacy_isTouchEvent(event)) {\n        pointerType = PointerTypes.Touch;\n      }\n      if (pointerType !== null) {\n        currentPointerType = pointerType;\n        if (thisEventKey.startsWith("Touch") && pointerType === PointerTypes.Touch || thisEventKey.startsWith("Mouse") && pointerType === PointerTypes.Mouse) {\n          pointerType = null;\n        }\n      } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n        pointerType = currentPointerType;\n        currentPointerType = null;\n      }\n      const e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n      if (!e2) {\n        return;\n      }\n      const id = mirror2.getId(target);\n      const { clientX, clientY } = e2;\n      callbackWrapper(mouseInteractionCb)({\n        type: MouseInteractions[thisEventKey],\n        id,\n        x: clientX,\n        y: clientY,\n        ...pointerType !== null && { pointerType }\n      });\n    };\n  };\n  Object.keys(MouseInteractions).filter(\n    (key) => Number.isNaN(Number(key)) && !key.endsWith("_Departed") && disableMap[key] !== false\n  ).forEach((eventKey) => {\n    let eventName = toLowerCase(eventKey);\n    const handler = getHandler(eventKey);\n    if (window.PointerEvent) {\n      switch (MouseInteractions[eventKey]) {\n        case MouseInteractions.MouseDown:\n        case MouseInteractions.MouseUp:\n          eventName = eventName.replace(\n            "mouse",\n            "pointer"\n          );\n          break;\n        case MouseInteractions.TouchStart:\n        case MouseInteractions.TouchEnd:\n          return;\n      }\n    }\n    handlers.push(on(eventName, handler, doc));\n  });\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initScrollObserver({\n  scrollCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  const updatePosition = callbackWrapper(\n    throttle$1(\n      callbackWrapper((evt) => {\n        const target = getEventTarget(evt);\n        if (!target || isBlocked(\n          target,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        )) {\n          return;\n        }\n        const id = mirror2.getId(target);\n        if (target === doc && doc.defaultView) {\n          const scrollLeftTop = getWindowScroll(doc.defaultView);\n          scrollCb({\n            id,\n            x: scrollLeftTop.left,\n            y: scrollLeftTop.top\n          });\n        } else {\n          scrollCb({\n            id,\n            x: target.scrollLeft,\n            y: target.scrollTop\n          });\n        }\n      }),\n      sampling.scroll || 100\n    )\n  );\n  return on("scroll", updatePosition, doc);\n}\nfunction initViewportResizeObserver({ viewportResizeCb }, { win }) {\n  let lastH = -1;\n  let lastW = -1;\n  const updateDimension = callbackWrapper(\n    throttle$1(\n      callbackWrapper(() => {\n        const height = getWindowHeight();\n        const width = getWindowWidth();\n        if (lastH !== height || lastW !== width) {\n          viewportResizeCb({\n            width: Number(width),\n            height: Number(height)\n          });\n          lastH = height;\n          lastW = width;\n        }\n      }),\n      200\n    )\n  );\n  return on("resize", updateDimension, win);\n}\nconst INPUT_TAGS = ["INPUT", "TEXTAREA", "SELECT"];\nconst lastInputValueMap = /* @__PURE__ */ new WeakMap();\nfunction initInputObserver({\n  inputCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  ignoreClass,\n  ignoreSelector,\n  maskInputOptions,\n  maskInputFn,\n  sampling,\n  userTriggeredOnInput,\n  maskTextClass,\n  unmaskTextClass,\n  maskTextSelector,\n  unmaskTextSelector\n}) {\n  function eventHandler(event) {\n    let target = getEventTarget(event);\n    const userTriggered = event.isTrusted;\n    const tagName = target && toUpperCase(target.tagName);\n    if (tagName === "OPTION") target = target.parentElement;\n    if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(\n      target,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      true\n    )) {\n      return;\n    }\n    const el = target;\n    if (el.classList.contains(ignoreClass) || ignoreSelector && el.matches(ignoreSelector)) {\n      return;\n    }\n    const type = getInputType(target);\n    let text = getInputValue(el, tagName, type);\n    let isChecked = false;\n    const isInputMasked = shouldMaskInput({\n      maskInputOptions,\n      tagName,\n      type\n    });\n    const forceMask = needMaskingText(\n      target,\n      maskTextClass,\n      maskTextSelector,\n      unmaskTextClass,\n      unmaskTextSelector,\n      isInputMasked\n    );\n    if (type === "radio" || type === "checkbox") {\n      isChecked = target.checked;\n    }\n    text = maskInputValue({\n      isMasked: forceMask,\n      element: target,\n      value: text,\n      maskInputFn\n    });\n    cbWithDedup(\n      target,\n      userTriggeredOnInput ? { text, isChecked, userTriggered } : { text, isChecked }\n    );\n    const name = target.name;\n    if (type === "radio" && name && isChecked) {\n      doc.querySelectorAll(`input[type="radio"][name="${name}"]`).forEach((el2) => {\n        if (el2 !== target) {\n          const text2 = maskInputValue({\n            // share mask behavior of `target`\n            isMasked: forceMask,\n            element: el2,\n            value: getInputValue(el2, tagName, type),\n            maskInputFn\n          });\n          cbWithDedup(\n            el2,\n            userTriggeredOnInput ? { text: text2, isChecked: !isChecked, userTriggered: false } : { text: text2, isChecked: !isChecked }\n          );\n        }\n      });\n    }\n  }\n  function cbWithDedup(target, v2) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {\n      lastInputValueMap.set(target, v2);\n      const id = mirror2.getId(target);\n      callbackWrapper(inputCb)({\n        ...v2,\n        id\n      });\n    }\n  }\n  const events = sampling.input === "last" ? ["change"] : ["input", "change"];\n  const handlers = events.map(\n    (eventName) => on(eventName, callbackWrapper(eventHandler), doc)\n  );\n  const currentWindow = doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n      handlers.forEach((h) => h());\n    };\n  }\n  const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(\n    currentWindow.HTMLInputElement.prototype,\n    "value"\n  );\n  const hookProperties = [\n    [currentWindow.HTMLInputElement.prototype, "value"],\n    [currentWindow.HTMLInputElement.prototype, "checked"],\n    [currentWindow.HTMLSelectElement.prototype, "value"],\n    [currentWindow.HTMLTextAreaElement.prototype, "value"],\n    // Some UI library use selectedIndex to set select value\n    [currentWindow.HTMLSelectElement.prototype, "selectedIndex"],\n    [currentWindow.HTMLOptionElement.prototype, "selected"]\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map(\n        (p) => hookSetter(\n          p[0],\n          p[1],\n          {\n            set() {\n              callbackWrapper(eventHandler)({\n                target: this,\n                isTrusted: false\n                // userTriggered to false as this could well be programmatic\n              });\n            }\n          },\n          false,\n          currentWindow\n        )\n      )\n    );\n  }\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction getNestedCSSRulePositions(rule) {\n  const positions = [];\n  function recurse(childRule, pos) {\n    if (hasNestedCSSRule("CSSGroupingRule") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && childRule.parentRule instanceof CSSConditionRule) {\n      const rules2 = Array.from(\n        childRule.parentRule.cssRules\n      );\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    } else if (childRule.parentStyleSheet) {\n      const rules2 = Array.from(childRule.parentStyleSheet.cssRules);\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    }\n    return pos;\n  }\n  return recurse(rule, positions);\n}\nfunction getIdAndStyleId(sheet, mirror2, styleMirror) {\n  let id, styleId;\n  if (!sheet) return {};\n  if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);\n  else styleId = styleMirror.getId(sheet);\n  return {\n    styleId,\n    id\n  };\n}\nfunction initStyleSheetObserver({ styleSheetRuleCb, mirror: mirror2, stylesheetManager }, { win }) {\n  if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n    return () => {\n    };\n  }\n  const insertRule = win.CSSStyleSheet.prototype.insertRule;\n  win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [rule, index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(\n          thisArg,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            adds: [{ rule, index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n  win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(\n          thisArg,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            removes: [{ index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  let replace;\n  if (win.CSSStyleSheet.prototype.replace) {\n    replace = win.CSSStyleSheet.prototype.replace;\n    win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n      apply: callbackWrapper(\n        (target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(\n            thisArg,\n            mirror2,\n            stylesheetManager.styleMirror\n          );\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replace: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        }\n      )\n    });\n  }\n  let replaceSync;\n  if (win.CSSStyleSheet.prototype.replaceSync) {\n    replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n    win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n      apply: callbackWrapper(\n        (target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(\n            thisArg,\n            mirror2,\n            stylesheetManager.styleMirror\n          );\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replaceSync: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        }\n      )\n    });\n  }\n  const supportedNestedCSSRuleTypes = {};\n  if (canMonkeyPatchNestedCSSRule("CSSGroupingRule")) {\n    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n  } else {\n    if (canMonkeyPatchNestedCSSRule("CSSMediaRule")) {\n      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n    }\n    if (canMonkeyPatchNestedCSSRule("CSSConditionRule")) {\n      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n    }\n    if (canMonkeyPatchNestedCSSRule("CSSSupportsRule")) {\n      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n    }\n  }\n  const unmodifiedFunctions = {};\n  Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n    unmodifiedFunctions[typeKey] = {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      insertRule: type.prototype.insertRule,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      deleteRule: type.prototype.deleteRule\n    };\n    type.prototype.insertRule = new Proxy(\n      unmodifiedFunctions[typeKey].insertRule,\n      {\n        apply: callbackWrapper(\n          (target, thisArg, argumentsList) => {\n            const [rule, index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(\n              thisArg.parentStyleSheet,\n              mirror2,\n              stylesheetManager.styleMirror\n            );\n            if (id && id !== -1 || styleId && styleId !== -1) {\n              styleSheetRuleCb({\n                id,\n                styleId,\n                adds: [\n                  {\n                    rule,\n                    index: [\n                      ...getNestedCSSRulePositions(thisArg),\n                      index || 0\n                      // defaults to 0\n                    ]\n                  }\n                ]\n              });\n            }\n            return target.apply(thisArg, argumentsList);\n          }\n        )\n      }\n    );\n    type.prototype.deleteRule = new Proxy(\n      unmodifiedFunctions[typeKey].deleteRule,\n      {\n        apply: callbackWrapper(\n          (target, thisArg, argumentsList) => {\n            const [index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(\n              thisArg.parentStyleSheet,\n              mirror2,\n              stylesheetManager.styleMirror\n            );\n            if (id && id !== -1 || styleId && styleId !== -1) {\n              styleSheetRuleCb({\n                id,\n                styleId,\n                removes: [\n                  { index: [...getNestedCSSRulePositions(thisArg), index] }\n                ]\n              });\n            }\n            return target.apply(thisArg, argumentsList);\n          }\n        )\n      }\n    );\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleSheet.prototype.insertRule = insertRule;\n    win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n    replace && (win.CSSStyleSheet.prototype.replace = replace);\n    replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n    });\n  });\n}\nfunction initAdoptedStyleSheetObserver({\n  mirror: mirror2,\n  stylesheetManager\n}, host) {\n  let hostId = null;\n  if (host.nodeName === "#document") hostId = mirror2.getId(host);\n  else hostId = mirror2.getId(host.host);\n  const patchTarget = host.nodeName === "#document" ? host.defaultView?.Document : host.ownerDocument?.defaultView?.ShadowRoot;\n  const originalPropertyDescriptor = patchTarget?.prototype ? Object.getOwnPropertyDescriptor(\n    patchTarget?.prototype,\n    "adoptedStyleSheets"\n  ) : void 0;\n  if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor)\n    return () => {\n    };\n  Object.defineProperty(host, "adoptedStyleSheets", {\n    configurable: originalPropertyDescriptor.configurable,\n    enumerable: originalPropertyDescriptor.enumerable,\n    get() {\n      return originalPropertyDescriptor.get?.call(this);\n    },\n    set(sheets) {\n      const result = originalPropertyDescriptor.set?.call(this, sheets);\n      if (hostId !== null && hostId !== -1) {\n        try {\n          stylesheetManager.adoptStyleSheets(sheets, hostId);\n        } catch (e2) {\n        }\n      }\n      return result;\n    }\n  });\n  return callbackWrapper(() => {\n    Object.defineProperty(host, "adoptedStyleSheets", {\n      configurable: originalPropertyDescriptor.configurable,\n      enumerable: originalPropertyDescriptor.enumerable,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      get: originalPropertyDescriptor.get,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      set: originalPropertyDescriptor.set\n    });\n  });\n}\nfunction initStyleDeclarationObserver({\n  styleDeclarationCb,\n  mirror: mirror2,\n  ignoreCSSAttributes,\n  stylesheetManager\n}, { win }) {\n  const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n  win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [property, value, priority] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return setProperty.apply(thisArg, [property, value, priority]);\n        }\n        const { id, styleId } = getIdAndStyleId(\n          thisArg.parentRule?.parentStyleSheet,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            set: {\n              property,\n              value,\n              priority\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n  win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [property] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return removeProperty.apply(thisArg, [property]);\n        }\n        const { id, styleId } = getIdAndStyleId(\n          thisArg.parentRule?.parentStyleSheet,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            remove: {\n              property\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n  });\n}\nfunction initMediaInteractionObserver({\n  mediaInteractionCb,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  mirror: mirror2,\n  sampling,\n  doc\n}) {\n  const handler = callbackWrapper(\n    (type) => throttle$1(\n      callbackWrapper((event) => {\n        const target = getEventTarget(event);\n        if (!target || isBlocked(\n          target,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        )) {\n          return;\n        }\n        const { currentTime, volume, muted, playbackRate } = target;\n        mediaInteractionCb({\n          type,\n          id: mirror2.getId(target),\n          currentTime,\n          volume,\n          muted,\n          playbackRate\n        });\n      }),\n      sampling.media || 500\n    )\n  );\n  const handlers = [\n    on("play", handler(MediaInteractions.Play), doc),\n    on("pause", handler(MediaInteractions.Pause), doc),\n    on("seeked", handler(MediaInteractions.Seeked), doc),\n    on("volumechange", handler(MediaInteractions.VolumeChange), doc),\n    on("ratechange", handler(MediaInteractions.RateChange), doc)\n  ];\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initFontObserver({ fontCb, doc }) {\n  const win = doc.defaultView;\n  if (!win) {\n    return () => {\n    };\n  }\n  const handlers = [];\n  const fontMap = /* @__PURE__ */ new WeakMap();\n  const originalFontFace = win.FontFace;\n  win.FontFace = function FontFace2(family, source, descriptors) {\n    const fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family,\n      buffer: typeof source !== "string",\n      descriptors,\n      fontSource: typeof source === "string" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n    });\n    return fontFace;\n  };\n  const restoreHandler = patch(\n    doc.fonts,\n    "add",\n    function(original) {\n      return function(fontFace) {\n        setTimeout$1(\n          callbackWrapper(() => {\n            const p = fontMap.get(fontFace);\n            if (p) {\n              fontCb(p);\n              fontMap.delete(fontFace);\n            }\n          }),\n          0\n        );\n        return original.apply(this, [fontFace]);\n      };\n    }\n  );\n  handlers.push(() => {\n    win.FontFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initSelectionObserver(param) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    selectionCb\n  } = param;\n  let collapsed = true;\n  const updateSelection = callbackWrapper(() => {\n    const selection = doc.getSelection();\n    if (!selection || collapsed && selection?.isCollapsed) return;\n    collapsed = selection.isCollapsed || false;\n    const ranges = [];\n    const count = selection.rangeCount || 0;\n    for (let i2 = 0; i2 < count; i2++) {\n      const range = selection.getRangeAt(i2);\n      const { startContainer, startOffset, endContainer, endOffset } = range;\n      const blocked = isBlocked(\n        startContainer,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        true\n      ) || isBlocked(\n        endContainer,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        true\n      );\n      if (blocked) continue;\n      ranges.push({\n        start: mirror2.getId(startContainer),\n        startOffset,\n        end: mirror2.getId(endContainer),\n        endOffset\n      });\n    }\n    selectionCb({ ranges });\n  });\n  updateSelection();\n  return on("selectionchange", updateSelection);\n}\nfunction initCustomElementObserver({\n  doc,\n  customElementCb\n}) {\n  const win = doc.defaultView;\n  if (!win || !win.customElements) return () => {\n  };\n  const restoreHandler = patch(\n    win.customElements,\n    "define",\n    function(original) {\n      return function(name, constructor, options) {\n        try {\n          customElementCb({\n            define: {\n              name\n            }\n          });\n        } catch (e2) {\n        }\n        return original.apply(this, [name, constructor, options]);\n      };\n    }\n  );\n  return restoreHandler;\n}\nfunction initObservers(o2, _hooks = {}) {\n  const currentWindow = o2.doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n    };\n  }\n  let mutationObserver;\n  if (o2.recordDOM) {\n    mutationObserver = initMutationObserver(o2, o2.doc);\n  }\n  const mousemoveHandler = initMoveObserver(o2);\n  const mouseInteractionHandler = initMouseInteractionObserver(o2);\n  const scrollHandler = initScrollObserver(o2);\n  const viewportResizeHandler = initViewportResizeObserver(o2, {\n    win: currentWindow\n  });\n  const inputHandler = initInputObserver(o2);\n  const mediaInteractionHandler = initMediaInteractionObserver(o2);\n  let styleSheetObserver = () => {\n  };\n  let adoptedStyleSheetObserver = () => {\n  };\n  let styleDeclarationObserver = () => {\n  };\n  let fontObserver = () => {\n  };\n  if (o2.recordDOM) {\n    styleSheetObserver = initStyleSheetObserver(o2, { win: currentWindow });\n    adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);\n    styleDeclarationObserver = initStyleDeclarationObserver(o2, {\n      win: currentWindow\n    });\n    if (o2.collectFonts) {\n      fontObserver = initFontObserver(o2);\n    }\n  }\n  const selectionObserver = initSelectionObserver(o2);\n  const customElementObserver = initCustomElementObserver(o2);\n  const pluginHandlers = [];\n  for (const plugin of o2.plugins) {\n    pluginHandlers.push(\n      plugin.observer(plugin.callback, currentWindow, plugin.options)\n    );\n  }\n  return callbackWrapper(() => {\n    mutationBuffers.forEach((b) => b.reset());\n    mutationObserver?.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    adoptedStyleSheetObserver();\n    styleDeclarationObserver();\n    fontObserver();\n    selectionObserver();\n    customElementObserver();\n    pluginHandlers.forEach((h) => h());\n  });\n}\nfunction hasNestedCSSRule(prop) {\n  return typeof window[prop] !== "undefined";\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n  return Boolean(\n    typeof window[prop] !== "undefined" && // Note: Generally, this check _shouldn\'t_ be necessary\n    // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here\n    window[prop].prototype && "insertRule" in window[prop].prototype && "deleteRule" in window[prop].prototype\n  );\n}\nclass CrossOriginIframeMirror {\n  constructor(generateIdFn) {\n    this.generateIdFn = generateIdFn;\n    this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n    this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n  }\n  getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n    const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n    let id = idToRemoteIdMap.get(remoteId);\n    if (!id) {\n      id = this.generateIdFn();\n      idToRemoteIdMap.set(remoteId, id);\n      remoteIdToIdMap.set(id, remoteId);\n    }\n    return id;\n  }\n  getIds(iframe, remoteId) {\n    const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return remoteId.map(\n      (id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap)\n    );\n  }\n  getRemoteId(iframe, id, map) {\n    const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n    if (typeof id !== "number") return id;\n    const remoteId = remoteIdToIdMap.get(id);\n    if (!remoteId) return -1;\n    return remoteId;\n  }\n  getRemoteIds(iframe, ids) {\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));\n  }\n  reset(iframe) {\n    if (!iframe) {\n      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n      this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n      return;\n    }\n    this.iframeIdToRemoteIdMap.delete(iframe);\n    this.iframeRemoteIdToIdMap.delete(iframe);\n  }\n  getIdToRemoteIdMap(iframe) {\n    let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n    if (!idToRemoteIdMap) {\n      idToRemoteIdMap = /* @__PURE__ */ new Map();\n      this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n    }\n    return idToRemoteIdMap;\n  }\n  getRemoteIdToIdMap(iframe) {\n    let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n    if (!remoteIdToIdMap) {\n      remoteIdToIdMap = /* @__PURE__ */ new Map();\n      this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n    }\n    return remoteIdToIdMap;\n  }\n}\nclass IframeManagerNoop {\n  constructor() {\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n  }\n  addIframe() {\n  }\n  addLoadListener() {\n  }\n  attachIframe() {\n  }\n}\nclass IframeManager {\n  constructor(options) {\n    this.iframes = /* @__PURE__ */ new WeakMap();\n    this.crossOriginIframeMap = /* @__PURE__ */ new WeakMap();\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n    this.mutationCb = options.mutationCb;\n    this.wrappedEmit = options.wrappedEmit;\n    this.stylesheetManager = options.stylesheetManager;\n    this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n    this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(\n      this.stylesheetManager.styleMirror.generateId.bind(\n        this.stylesheetManager.styleMirror\n      )\n    );\n    this.mirror = options.mirror;\n    if (this.recordCrossOriginIframes) {\n      window.addEventListener("message", this.handleMessage.bind(this));\n    }\n  }\n  addIframe(iframeEl) {\n    this.iframes.set(iframeEl, true);\n    if (iframeEl.contentWindow)\n      this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n  }\n  addLoadListener(cb) {\n    this.loadListener = cb;\n  }\n  attachIframe(iframeEl, childSn) {\n    this.mutationCb({\n      adds: [\n        {\n          parentId: this.mirror.getId(iframeEl),\n          nextId: null,\n          node: childSn\n        }\n      ],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true\n    });\n    if (this.recordCrossOriginIframes)\n      iframeEl.contentWindow?.addEventListener(\n        "message",\n        this.handleMessage.bind(this)\n      );\n    this.loadListener?.(iframeEl);\n    const iframeDoc = getIFrameContentDocument(iframeEl);\n    if (iframeDoc && iframeDoc.adoptedStyleSheets && iframeDoc.adoptedStyleSheets.length > 0)\n      this.stylesheetManager.adoptStyleSheets(\n        iframeDoc.adoptedStyleSheets,\n        this.mirror.getId(iframeDoc)\n      );\n  }\n  handleMessage(message) {\n    const crossOriginMessageEvent = message;\n    if (crossOriginMessageEvent.data.type !== "rrweb" || // To filter out the rrweb messages which are forwarded by some sites.\n    crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)\n      return;\n    const iframeSourceWindow = message.source;\n    if (!iframeSourceWindow) return;\n    const iframeEl = this.crossOriginIframeMap.get(message.source);\n    if (!iframeEl) return;\n    const transformedEvent = this.transformCrossOriginEvent(\n      iframeEl,\n      crossOriginMessageEvent.data.event\n    );\n    if (transformedEvent)\n      this.wrappedEmit(\n        transformedEvent,\n        crossOriginMessageEvent.data.isCheckout\n      );\n  }\n  transformCrossOriginEvent(iframeEl, e2) {\n    switch (e2.type) {\n      case EventType.FullSnapshot: {\n        this.crossOriginIframeMirror.reset(iframeEl);\n        this.crossOriginIframeStyleMirror.reset(iframeEl);\n        this.replaceIdOnNode(e2.data.node, iframeEl);\n        const rootId = e2.data.node.id;\n        this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n        this.patchRootIdOnNode(e2.data.node, rootId);\n        return {\n          timestamp: e2.timestamp,\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.Mutation,\n            adds: [\n              {\n                parentId: this.mirror.getId(iframeEl),\n                nextId: null,\n                node: e2.data.node\n              }\n            ],\n            removes: [],\n            texts: [],\n            attributes: [],\n            isAttachIframe: true\n          }\n        };\n      }\n      case EventType.Meta:\n      case EventType.Load:\n      case EventType.DomContentLoaded: {\n        return false;\n      }\n      case EventType.Plugin: {\n        return e2;\n      }\n      case EventType.Custom: {\n        this.replaceIds(\n          e2.data.payload,\n          iframeEl,\n          ["id", "parentId", "previousId", "nextId"]\n        );\n        return e2;\n      }\n      case EventType.IncrementalSnapshot: {\n        switch (e2.data.source) {\n          case IncrementalSource.Mutation: {\n            e2.data.adds.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\n                "parentId",\n                "nextId",\n                "previousId"\n              ]);\n              this.replaceIdOnNode(n2.node, iframeEl);\n              const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\n              rootId && this.patchRootIdOnNode(n2.node, rootId);\n            });\n            e2.data.removes.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, ["parentId", "id"]);\n            });\n            e2.data.attributes.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, ["id"]);\n            });\n            e2.data.texts.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, ["id"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.Drag:\n          case IncrementalSource.TouchMove:\n          case IncrementalSource.MouseMove: {\n            e2.data.positions.forEach((p) => {\n              this.replaceIds(p, iframeEl, ["id"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.ViewportResize: {\n            return false;\n          }\n          case IncrementalSource.MediaInteraction:\n          case IncrementalSource.MouseInteraction:\n          case IncrementalSource.Scroll:\n          case IncrementalSource.CanvasMutation:\n          case IncrementalSource.Input: {\n            this.replaceIds(e2.data, iframeEl, ["id"]);\n            return e2;\n          }\n          case IncrementalSource.StyleSheetRule:\n          case IncrementalSource.StyleDeclaration: {\n            this.replaceIds(e2.data, iframeEl, ["id"]);\n            this.replaceStyleIds(e2.data, iframeEl, ["styleId"]);\n            return e2;\n          }\n          case IncrementalSource.Font: {\n            return e2;\n          }\n          case IncrementalSource.Selection: {\n            e2.data.ranges.forEach((range) => {\n              this.replaceIds(range, iframeEl, ["start", "end"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.AdoptedStyleSheet: {\n            this.replaceIds(e2.data, iframeEl, ["id"]);\n            this.replaceStyleIds(e2.data, iframeEl, ["styleIds"]);\n            e2.data.styles?.forEach((style) => {\n              this.replaceStyleIds(style, iframeEl, ["styleId"]);\n            });\n            return e2;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  replace(iframeMirror, obj, iframeEl, keys) {\n    for (const key of keys) {\n      if (!Array.isArray(obj[key]) && typeof obj[key] !== "number") continue;\n      if (Array.isArray(obj[key])) {\n        obj[key] = iframeMirror.getIds(\n          iframeEl,\n          obj[key]\n        );\n      } else {\n        obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n      }\n    }\n    return obj;\n  }\n  replaceIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n  }\n  replaceStyleIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n  }\n  replaceIdOnNode(node, iframeEl) {\n    this.replaceIds(node, iframeEl, ["id", "rootId"]);\n    if ("childNodes" in node) {\n      node.childNodes.forEach((child) => {\n        this.replaceIdOnNode(child, iframeEl);\n      });\n    }\n  }\n  patchRootIdOnNode(node, rootId) {\n    if (node.type !== NodeType$2.Document && !node.rootId) node.rootId = rootId;\n    if ("childNodes" in node) {\n      node.childNodes.forEach((child) => {\n        this.patchRootIdOnNode(child, rootId);\n      });\n    }\n  }\n}\nclass ShadowDomManagerNoop {\n  init() {\n  }\n  addShadowRoot() {\n  }\n  observeAttachShadow() {\n  }\n  reset() {\n  }\n}\nclass ShadowDomManager {\n  constructor(options) {\n    this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    this.restoreHandlers = [];\n    this.mutationCb = options.mutationCb;\n    this.scrollCb = options.scrollCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n    this.init();\n  }\n  init() {\n    this.reset();\n    this.patchAttachShadow(Element, document);\n  }\n  addShadowRoot(shadowRoot, doc) {\n    if (!isNativeShadowDom(shadowRoot)) return;\n    if (this.shadowDoms.has(shadowRoot)) return;\n    this.shadowDoms.add(shadowRoot);\n    this.bypassOptions.canvasManager.addShadowRoot(shadowRoot);\n    const observer = initMutationObserver(\n      {\n        ...this.bypassOptions,\n        doc,\n        mutationCb: this.mutationCb,\n        mirror: this.mirror,\n        shadowDomManager: this\n      },\n      shadowRoot\n    );\n    this.restoreHandlers.push(() => observer.disconnect());\n    this.restoreHandlers.push(\n      initScrollObserver({\n        ...this.bypassOptions,\n        scrollCb: this.scrollCb,\n        // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813\n        // scroll is not allowed to pass the boundary, so we need to listen the shadow document\n        doc: shadowRoot,\n        mirror: this.mirror\n      })\n    );\n    setTimeout$1(() => {\n      if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0)\n        this.bypassOptions.stylesheetManager.adoptStyleSheets(\n          shadowRoot.adoptedStyleSheets,\n          this.mirror.getId(shadowRoot.host)\n        );\n      this.restoreHandlers.push(\n        initAdoptedStyleSheetObserver(\n          {\n            mirror: this.mirror,\n            stylesheetManager: this.bypassOptions.stylesheetManager\n          },\n          shadowRoot\n        )\n      );\n    }, 0);\n  }\n  /**\n   * Monkey patch \'attachShadow\' of an IFrameElement to observe newly added shadow doms.\n   */\n  observeAttachShadow(iframeElement) {\n    const iframeDoc = getIFrameContentDocument(iframeElement);\n    const iframeWindow = getIFrameContentWindow(iframeElement);\n    if (!iframeDoc || !iframeWindow) return;\n    this.patchAttachShadow(\n      iframeWindow.Element,\n      iframeDoc\n    );\n  }\n  /**\n   * Patch \'attachShadow\' to observe newly added shadow doms.\n   */\n  patchAttachShadow(element, doc) {\n    const manager = this;\n    this.restoreHandlers.push(\n      patch(\n        element.prototype,\n        "attachShadow",\n        function(original) {\n          return function(option) {\n            const shadowRoot = original.call(this, option);\n            if (this.shadowRoot && inDom(this))\n              manager.addShadowRoot(this.shadowRoot, doc);\n            return shadowRoot;\n          };\n        }\n      )\n    );\n  }\n  reset() {\n    this.restoreHandlers.forEach((handler) => {\n      try {\n        handler();\n      } catch (e2) {\n      }\n    });\n    this.restoreHandlers = [];\n    this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    this.bypassOptions.canvasManager.resetShadowRoots();\n  }\n}\nvar chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\nvar lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);\nfor (var i$1 = 0; i$1 < chars.length; i$1++) {\n  lookup[chars.charCodeAt(i$1)] = i$1;\n}\nclass CanvasManagerNoop {\n  reset() {\n  }\n  freeze() {\n  }\n  unfreeze() {\n  }\n  lock() {\n  }\n  unlock() {\n  }\n  snapshot() {\n  }\n  addWindow() {\n  }\n  addShadowRoot() {\n  }\n  resetShadowRoots() {\n  }\n}\nclass StylesheetManager {\n  constructor(options) {\n    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n    this.styleMirror = new StyleSheetMirror();\n    this.mutationCb = options.mutationCb;\n    this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n  }\n  attachLinkElement(linkEl, childSn) {\n    if ("_cssText" in childSn.attributes)\n      this.mutationCb({\n        adds: [],\n        removes: [],\n        texts: [],\n        attributes: [\n          {\n            id: childSn.id,\n            attributes: childSn.attributes\n          }\n        ]\n      });\n    this.trackLinkElement(linkEl);\n  }\n  trackLinkElement(linkEl) {\n    if (this.trackedLinkElements.has(linkEl)) return;\n    this.trackedLinkElements.add(linkEl);\n    this.trackStylesheetInLinkElement(linkEl);\n  }\n  adoptStyleSheets(sheets, hostId) {\n    if (sheets.length === 0) return;\n    const adoptedStyleSheetData = {\n      id: hostId,\n      styleIds: []\n    };\n    const styles = [];\n    for (const sheet of sheets) {\n      let styleId;\n      if (!this.styleMirror.has(sheet)) {\n        styleId = this.styleMirror.add(sheet);\n        styles.push({\n          styleId,\n          rules: Array.from(sheet.rules || CSSRule, (r2, index) => ({\n            rule: stringifyRule(r2),\n            index\n          }))\n        });\n      } else styleId = this.styleMirror.getId(sheet);\n      adoptedStyleSheetData.styleIds.push(styleId);\n    }\n    if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n    this.adoptedStyleSheetCb(adoptedStyleSheetData);\n  }\n  reset() {\n    this.styleMirror.reset();\n    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n  }\n  // TODO: take snapshot on stylesheet reload by applying event listener\n  trackStylesheetInLinkElement(_linkEl) {\n  }\n}\nclass ProcessedNodeManager {\n  constructor() {\n    this.nodeMap = /* @__PURE__ */ new WeakMap();\n    this.active = false;\n  }\n  inOtherBuffer(node, thisBuffer) {\n    const buffers = this.nodeMap.get(node);\n    return buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer);\n  }\n  add(node, buffer) {\n    if (!this.active) {\n      this.active = true;\n      onRequestAnimationFrame(() => {\n        this.nodeMap = /* @__PURE__ */ new WeakMap();\n        this.active = false;\n      });\n    }\n    this.nodeMap.set(node, (this.nodeMap.get(node) || /* @__PURE__ */ new Set()).add(buffer));\n  }\n  destroy() {\n  }\n}\nlet wrappedEmit;\nlet _takeFullSnapshot;\ntry {\n  if (Array.from([1], (x) => x * 2)[0] !== 2) {\n    const cleanFrame = document.createElement("iframe");\n    document.body.appendChild(cleanFrame);\n    Array.from = cleanFrame.contentWindow?.Array.from || Array.from;\n    document.body.removeChild(cleanFrame);\n  }\n} catch (err) {\n  console.debug("Unable to override Array.from", err);\n}\nconst mirror = createMirror$2();\nfunction record(options = {}) {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = "rr-block",\n    blockSelector = null,\n    unblockSelector = null,\n    ignoreClass = "rr-ignore",\n    ignoreSelector = null,\n    maskAllText = false,\n    maskTextClass = "rr-mask",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    slimDOMOptions: _slimDOMOptions,\n    maskAttributeFn,\n    maskInputFn,\n    maskTextFn,\n    maxCanvasSize = null,\n    packFn,\n    sampling = {},\n    dataURLOptions = {},\n    mousemoveWait,\n    recordDOM = true,\n    recordCanvas = false,\n    recordCrossOriginIframes = false,\n    recordAfter = options.recordAfter === "DOMContentLoaded" ? options.recordAfter : "load",\n    userTriggeredOnInput = false,\n    collectFonts = false,\n    inlineImages = false,\n    plugins,\n    keepIframeSrcFn = () => false,\n    ignoreCSSAttributes = /* @__PURE__ */ new Set([]),\n    errorHandler: errorHandler2,\n    onMutation,\n    getCanvasManager\n  } = options;\n  registerErrorHandler(errorHandler2);\n  const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n  let passEmitsToParent = false;\n  if (!inEmittingFrame) {\n    try {\n      if (window.parent.document) {\n        passEmitsToParent = false;\n      }\n    } catch (e2) {\n      passEmitsToParent = true;\n    }\n  }\n  if (inEmittingFrame && !emit) {\n    throw new Error("emit function is required");\n  }\n  if (!inEmittingFrame && !passEmitsToParent) {\n    return () => {\n    };\n  }\n  if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {\n    sampling.mousemove = mousemoveWait;\n  }\n  mirror.reset();\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    "datetime-local": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true,\n    radio: true,\n    checkbox: true\n  } : _maskInputOptions !== void 0 ? _maskInputOptions : {};\n  const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === "all" ? {\n    script: true,\n    comment: true,\n    headFavicon: true,\n    headWhitespace: true,\n    headMetaSocial: true,\n    headMetaRobots: true,\n    headMetaHttpEquiv: true,\n    headMetaVerification: true,\n    // the following are off for slimDOMOptions === true,\n    // as they destroy some (hidden) info:\n    headMetaAuthorship: _slimDOMOptions === "all",\n    headMetaDescKeywords: _slimDOMOptions === "all"\n  } : _slimDOMOptions ? _slimDOMOptions : {};\n  polyfill$1();\n  let lastFullSnapshotEvent;\n  let incrementalSnapshotCount = 0;\n  const eventProcessor = (e2) => {\n    for (const plugin of plugins || []) {\n      if (plugin.eventProcessor) {\n        e2 = plugin.eventProcessor(e2);\n      }\n    }\n    if (packFn && // Disable packing events which will be emitted to parent frames.\n    !passEmitsToParent) {\n      e2 = packFn(e2);\n    }\n    return e2;\n  };\n  wrappedEmit = (r2, isCheckout) => {\n    const e2 = r2;\n    e2.timestamp = nowTimestamp();\n    if (mutationBuffers[0]?.isFrozen() && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {\n      mutationBuffers.forEach((buf) => buf.unfreeze());\n    }\n    if (inEmittingFrame) {\n      emit?.(eventProcessor(e2), isCheckout);\n    } else if (passEmitsToParent) {\n      const message = {\n        type: "rrweb",\n        event: eventProcessor(e2),\n        origin: window.location.origin,\n        isCheckout\n      };\n      window.parent.postMessage(message, "*");\n    }\n    if (e2.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e2;\n      incrementalSnapshotCount = 0;\n    } else if (e2.type === EventType.IncrementalSnapshot) {\n      if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {\n        return;\n      }\n      incrementalSnapshotCount++;\n      const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime = checkoutEveryNms && lastFullSnapshotEvent && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot2(true);\n      }\n    }\n  };\n  const wrappedMutationEmit = (m) => {\n    wrappedEmit({\n      type: EventType.IncrementalSnapshot,\n      data: {\n        source: IncrementalSource.Mutation,\n        ...m\n      }\n    });\n  };\n  const wrappedScrollEmit = (p) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.Scroll,\n      ...p\n    }\n  });\n  const wrappedCanvasMutationEmit = (p) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.CanvasMutation,\n      ...p\n    }\n  });\n  const wrappedAdoptedStyleSheetEmit = (a2) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.AdoptedStyleSheet,\n      ...a2\n    }\n  });\n  const stylesheetManager = new StylesheetManager({\n    mutationCb: wrappedMutationEmit,\n    adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n  });\n  const iframeManager = typeof __RRWEB_EXCLUDE_IFRAME__ === "boolean" && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop() : new IframeManager({\n    mirror,\n    mutationCb: wrappedMutationEmit,\n    stylesheetManager,\n    recordCrossOriginIframes,\n    wrappedEmit\n  });\n  for (const plugin of plugins || []) {\n    if (plugin.getMirror)\n      plugin.getMirror({\n        nodeMirror: mirror,\n        crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n        crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n      });\n  }\n  const processedNodeManager = new ProcessedNodeManager();\n  const canvasManager = _getCanvasManager(\n    getCanvasManager,\n    {\n      mirror,\n      win: window,\n      mutationCb: (p) => wrappedEmit({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.CanvasMutation,\n          ...p\n        }\n      }),\n      recordCanvas,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maxCanvasSize,\n      sampling: sampling["canvas"],\n      dataURLOptions,\n      errorHandler: errorHandler2\n    }\n  );\n  const shadowDomManager = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ === "boolean" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop() : new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    scrollCb: wrappedScrollEmit,\n    bypassOptions: {\n      onMutation,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      dataURLOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      recordCanvas,\n      inlineImages,\n      sampling,\n      slimDOMOptions,\n      iframeManager,\n      stylesheetManager,\n      canvasManager,\n      keepIframeSrcFn,\n      processedNodeManager\n    },\n    mirror\n  });\n  const takeFullSnapshot2 = (isCheckout = false) => {\n    if (!recordDOM) {\n      return;\n    }\n    wrappedEmit(\n      {\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight()\n        }\n      },\n      isCheckout\n    );\n    stylesheetManager.reset();\n    shadowDomManager.init();\n    mutationBuffers.forEach((buf) => buf.lock());\n    const node = snapshot(document, {\n      mirror,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskAttributeFn,\n      maskInputFn,\n      maskTextFn,\n      slimDOM: slimDOMOptions,\n      dataURLOptions,\n      recordCanvas,\n      inlineImages,\n      onSerialize: (n2) => {\n        if (isSerializedIframe(n2, mirror)) {\n          iframeManager.addIframe(n2);\n        }\n        if (isSerializedStylesheet(n2, mirror)) {\n          stylesheetManager.trackLinkElement(n2);\n        }\n        if (hasShadowRoot(n2)) {\n          shadowDomManager.addShadowRoot(n2.shadowRoot, document);\n        }\n      },\n      onIframeLoad: (iframe, childSn) => {\n        iframeManager.attachIframe(iframe, childSn);\n        if (iframe.contentWindow) {\n          canvasManager.addWindow(iframe.contentWindow);\n        }\n        shadowDomManager.observeAttachShadow(iframe);\n      },\n      onStylesheetLoad: (linkEl, childSn) => {\n        stylesheetManager.attachLinkElement(linkEl, childSn);\n      },\n      keepIframeSrcFn\n    });\n    if (!node) {\n      return console.warn("Failed to snapshot the document");\n    }\n    wrappedEmit({\n      type: EventType.FullSnapshot,\n      data: {\n        node,\n        initialOffset: getWindowScroll(window)\n      }\n    });\n    mutationBuffers.forEach((buf) => buf.unlock());\n    if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)\n      stylesheetManager.adoptStyleSheets(\n        document.adoptedStyleSheets,\n        mirror.getId(document)\n      );\n  };\n  _takeFullSnapshot = takeFullSnapshot2;\n  try {\n    const handlers = [];\n    const observe = (doc) => {\n      return callbackWrapper(initObservers)(\n        {\n          onMutation,\n          mutationCb: wrappedMutationEmit,\n          mousemoveCb: (positions, source) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source,\n              positions\n            }\n          }),\n          mouseInteractionCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MouseInteraction,\n              ...d\n            }\n          }),\n          scrollCb: wrappedScrollEmit,\n          viewportResizeCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.ViewportResize,\n              ...d\n            }\n          }),\n          inputCb: (v2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Input,\n              ...v2\n            }\n          }),\n          mediaInteractionCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MediaInteraction,\n              ...p\n            }\n          }),\n          styleSheetRuleCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleSheetRule,\n              ...r2\n            }\n          }),\n          styleDeclarationCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleDeclaration,\n              ...r2\n            }\n          }),\n          canvasMutationCb: wrappedCanvasMutationEmit,\n          fontCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Font,\n              ...p\n            }\n          }),\n          selectionCb: (p) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.Selection,\n                ...p\n              }\n            });\n          },\n          customElementCb: (c2) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.CustomElement,\n                ...c2\n              }\n            });\n          },\n          blockClass,\n          ignoreClass,\n          ignoreSelector,\n          maskAllText,\n          maskTextClass,\n          unmaskTextClass,\n          maskTextSelector,\n          unmaskTextSelector,\n          maskInputOptions,\n          inlineStylesheet,\n          sampling,\n          recordDOM,\n          recordCanvas,\n          inlineImages,\n          userTriggeredOnInput,\n          collectFonts,\n          doc,\n          maskAttributeFn,\n          maskInputFn,\n          maskTextFn,\n          keepIframeSrcFn,\n          blockSelector,\n          unblockSelector,\n          slimDOMOptions,\n          dataURLOptions,\n          mirror,\n          iframeManager,\n          stylesheetManager,\n          shadowDomManager,\n          processedNodeManager,\n          canvasManager,\n          ignoreCSSAttributes,\n          plugins: plugins?.filter((p) => p.observer)?.map((p) => ({\n            observer: p.observer,\n            options: p.options,\n            callback: (payload) => wrappedEmit({\n              type: EventType.Plugin,\n              data: {\n                plugin: p.name,\n                payload\n              }\n            })\n          })) || []\n        },\n        {}\n      );\n    };\n    iframeManager.addLoadListener((iframeEl) => {\n      try {\n        handlers.push(observe(iframeEl.contentDocument));\n      } catch (error) {\n        console.warn(error);\n      }\n    });\n    const init = () => {\n      takeFullSnapshot2();\n      handlers.push(observe(document));\n    };\n    if (document.readyState === "interactive" || document.readyState === "complete") {\n      init();\n    } else {\n      handlers.push(\n        on("DOMContentLoaded", () => {\n          wrappedEmit({\n            type: EventType.DomContentLoaded,\n            data: {}\n          });\n          if (recordAfter === "DOMContentLoaded") init();\n        })\n      );\n      handlers.push(\n        on(\n          "load",\n          () => {\n            wrappedEmit({\n              type: EventType.Load,\n              data: {}\n            });\n            if (recordAfter === "load") init();\n          },\n          window\n        )\n      );\n    }\n    return () => {\n      handlers.forEach((h) => h());\n      processedNodeManager.destroy();\n      _takeFullSnapshot = void 0;\n      unregisterErrorHandler();\n    };\n  } catch (error) {\n    console.warn(error);\n  }\n}\nfunction takeFullSnapshot(isCheckout) {\n  if (!_takeFullSnapshot) {\n    throw new Error("please take full snapshot after start recording");\n  }\n  _takeFullSnapshot(isCheckout);\n}\nrecord.mirror = mirror;\nrecord.takeFullSnapshot = takeFullSnapshot;\nfunction _getCanvasManager(getCanvasManagerFn, options) {\n  try {\n    return getCanvasManagerFn ? getCanvasManagerFn(options) : new CanvasManagerNoop();\n  } catch {\n    console.warn("Unable to initialize CanvasManager");\n    return new CanvasManagerNoop();\n  }\n}\nvar n;\n!function(t2) {\n  t2[t2.NotStarted = 0] = "NotStarted", t2[t2.Running = 1] = "Running", t2[t2.Stopped = 2] = "Stopped";\n}(n || (n = {}));\n\nconst ReplayEventTypeIncrementalSnapshot = 3;\nconst ReplayEventTypeCustom = 5;\n\n/**\n * Converts a timestamp to ms, if it was in s, or keeps it as ms.\n */\nfunction timestampToMs(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp : timestamp * 1000;\n}\n\n/**\n * Converts a timestamp to s, if it was in ms, or keeps it as s.\n */\nfunction timestampToS(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n\n/**\n * Add a breadcrumb event to replay.\n */\nfunction addBreadcrumbEvent(replay, breadcrumb) {\n  if (breadcrumb.category === \'sentry.transaction\') {\n    return;\n  }\n\n  if ([\'ui.click\', \'ui.input\'].includes(breadcrumb.category )) {\n    replay.triggerUserActivity();\n  } else {\n    replay.checkAndHandleExpiredSession();\n  }\n\n  replay.addUpdate(() => {\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      // TODO: We were converting from ms to seconds for breadcrumbs, spans,\n      // but maybe we should just keep them as milliseconds\n      timestamp: (breadcrumb.timestamp || 0) * 1000,\n      data: {\n        tag: \'breadcrumb\',\n        // normalize to max. 10 depth and 1_000 properties per object\n        payload: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_1__.normalize)(breadcrumb, 10, 1000),\n      },\n    });\n\n    // Do not flush after console log messages\n    return breadcrumb.category === \'console\';\n  });\n}\n\nconst INTERACTIVE_SELECTOR = \'button,a\';\n\n/** Get the closest interactive parent element, or else return the given element. */\nfunction getClosestInteractive(element) {\n  const closestInteractive = element.closest(INTERACTIVE_SELECTOR);\n  return closestInteractive || element;\n}\n\n/**\n * For clicks, we check if the target is inside of a button or link\n * If so, we use this as the target instead\n * This is useful because if you click on the image in <button><img></button>,\n * The target will be the image, not the button, which we don\'t want here\n */\nfunction getClickTargetNode(event) {\n  const target = getTargetNode(event);\n\n  if (!target || !(target instanceof Element)) {\n    return target;\n  }\n\n  return getClosestInteractive(target);\n}\n\n/** Get the event target node. */\nfunction getTargetNode(event) {\n  if (isEventWithTarget(event)) {\n    return event.target ;\n  }\n\n  return event;\n}\n\nfunction isEventWithTarget(event) {\n  return typeof event === \'object\' && !!event && \'target\' in event;\n}\n\nlet handlers;\n\n/**\n * Register a handler to be called when `window.open()` is called.\n * Returns a cleanup function.\n */\nfunction onWindowOpen(cb) {\n  // Ensure to only register this once\n  if (!handlers) {\n    handlers = [];\n    monkeyPatchWindowOpen();\n  }\n\n  handlers.push(cb);\n\n  return () => {\n    const pos = handlers ? handlers.indexOf(cb) : -1;\n    if (pos > -1) {\n      (handlers ).splice(pos, 1);\n    }\n  };\n}\n\nfunction monkeyPatchWindowOpen() {\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_2__.fill)(WINDOW, \'open\', function (originalWindowOpen) {\n    return function (...args) {\n      if (handlers) {\n        try {\n          handlers.forEach(handler => handler());\n        } catch (e) {\n          // ignore errors in here\n        }\n      }\n\n      return originalWindowOpen.apply(WINDOW, args);\n    };\n  });\n}\n\n/** Any IncrementalSource for rrweb that we interpret as a kind of mutation. */\nconst IncrementalMutationSources = new Set([\n  IncrementalSource.Mutation,\n  IncrementalSource.StyleSheetRule,\n  IncrementalSource.StyleDeclaration,\n  IncrementalSource.AdoptedStyleSheet,\n  IncrementalSource.CanvasMutation,\n  IncrementalSource.Selection,\n  IncrementalSource.MediaInteraction,\n]);\n\n/** Handle a click. */\nfunction handleClick(clickDetector, clickBreadcrumb, node) {\n  clickDetector.handleClick(clickBreadcrumb, node);\n}\n\n/** A click detector class that can be used to detect slow or rage clicks on elements. */\nclass ClickDetector  {\n  // protected for testing\n\n   constructor(\n    replay,\n    slowClickConfig,\n    // Just for easier testing\n    _addBreadcrumbEvent = addBreadcrumbEvent,\n  ) {\n    this._lastMutation = 0;\n    this._lastScroll = 0;\n    this._clicks = [];\n\n    // We want everything in s, but options are in ms\n    this._timeout = slowClickConfig.timeout / 1000;\n    this._threshold = slowClickConfig.threshold / 1000;\n    this._scrollTimeout = slowClickConfig.scrollTimeout / 1000;\n    this._replay = replay;\n    this._ignoreSelector = slowClickConfig.ignoreSelector;\n    this._addBreadcrumbEvent = _addBreadcrumbEvent;\n  }\n\n  /** Register click detection handlers on mutation or scroll. */\n   addListeners() {\n    const cleanupWindowOpen = onWindowOpen(() => {\n      // Treat window.open as mutation\n      this._lastMutation = nowInSeconds();\n    });\n\n    this._teardown = () => {\n      cleanupWindowOpen();\n\n      this._clicks = [];\n      this._lastMutation = 0;\n      this._lastScroll = 0;\n    };\n  }\n\n  /** Clean up listeners. */\n   removeListeners() {\n    if (this._teardown) {\n      this._teardown();\n    }\n\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n  }\n\n  /** @inheritDoc */\n   handleClick(breadcrumb, node) {\n    if (ignoreElement(node, this._ignoreSelector) || !isClickBreadcrumb(breadcrumb)) {\n      return;\n    }\n\n    const newClick = {\n      timestamp: timestampToS(breadcrumb.timestamp),\n      clickBreadcrumb: breadcrumb,\n      // Set this to 0 so we know it originates from the click breadcrumb\n      clickCount: 0,\n      node,\n    };\n\n    // If there was a click in the last 1s on the same element, ignore it - only keep a single reference per second\n    if (\n      this._clicks.some(click => click.node === newClick.node && Math.abs(click.timestamp - newClick.timestamp) < 1)\n    ) {\n      return;\n    }\n\n    this._clicks.push(newClick);\n\n    // If this is the first new click, set a timeout to check for multi clicks\n    if (this._clicks.length === 1) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** @inheritDoc */\n   registerMutation(timestamp = Date.now()) {\n    this._lastMutation = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n   registerScroll(timestamp = Date.now()) {\n    this._lastScroll = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n   registerClick(element) {\n    const node = getClosestInteractive(element);\n    this._handleMultiClick(node );\n  }\n\n  /** Count multiple clicks on elements. */\n   _handleMultiClick(node) {\n    this._getClicks(node).forEach(click => {\n      click.clickCount++;\n    });\n  }\n\n  /** Get all pending clicks for a given node. */\n   _getClicks(node) {\n    return this._clicks.filter(click => click.node === node);\n  }\n\n  /** Check the clicks that happened. */\n   _checkClicks() {\n    const timedOutClicks = [];\n\n    const now = nowInSeconds();\n\n    this._clicks.forEach(click => {\n      if (!click.mutationAfter && this._lastMutation) {\n        click.mutationAfter = click.timestamp <= this._lastMutation ? this._lastMutation - click.timestamp : undefined;\n      }\n      if (!click.scrollAfter && this._lastScroll) {\n        click.scrollAfter = click.timestamp <= this._lastScroll ? this._lastScroll - click.timestamp : undefined;\n      }\n\n      // All of these are in seconds!\n      if (click.timestamp + this._timeout <= now) {\n        timedOutClicks.push(click);\n      }\n    });\n\n    // Remove "old" clicks\n    for (const click of timedOutClicks) {\n      const pos = this._clicks.indexOf(click);\n\n      if (pos > -1) {\n        this._generateBreadcrumbs(click);\n        this._clicks.splice(pos, 1);\n      }\n    }\n\n    // Trigger new check, unless no clicks left\n    if (this._clicks.length) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** Generate matching breadcrumb(s) for the click. */\n   _generateBreadcrumbs(click) {\n    const replay = this._replay;\n    const hadScroll = click.scrollAfter && click.scrollAfter <= this._scrollTimeout;\n    const hadMutation = click.mutationAfter && click.mutationAfter <= this._threshold;\n\n    const isSlowClick = !hadScroll && !hadMutation;\n    const { clickCount, clickBreadcrumb } = click;\n\n    // Slow click\n    if (isSlowClick) {\n      // If `mutationAfter` is set, it means a mutation happened after the threshold, but before the timeout\n      // If not, it means we just timed out without scroll & mutation\n      const timeAfterClickMs = Math.min(click.mutationAfter || this._timeout, this._timeout) * 1000;\n      const endReason = timeAfterClickMs < this._timeout * 1000 ? \'mutation\' : \'timeout\';\n\n      const breadcrumb = {\n        type: \'default\',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: \'ui.slowClickDetected\',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          timeAfterClickMs,\n          endReason,\n          // If clickCount === 0, it means multiClick was not correctly captured here\n          // - we still want to send 1 in this case\n          clickCount: clickCount || 1,\n        },\n      };\n\n      this._addBreadcrumbEvent(replay, breadcrumb);\n      return;\n    }\n\n    // Multi click\n    if (clickCount > 1) {\n      const breadcrumb = {\n        type: \'default\',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: \'ui.multiClick\',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          clickCount,\n          metric: true,\n        },\n      };\n\n      this._addBreadcrumbEvent(replay, breadcrumb);\n    }\n  }\n\n  /** Schedule to check current clicks. */\n   _scheduleCheckClicks() {\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n\n    this._checkClickTimeout = (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__.setTimeout)(() => this._checkClicks(), 1000);\n  }\n}\n\nconst SLOW_CLICK_TAGS = [\'A\', \'BUTTON\', \'INPUT\'];\n\n/** exported for tests only */\nfunction ignoreElement(node, ignoreSelector) {\n  if (!SLOW_CLICK_TAGS.includes(node.tagName)) {\n    return true;\n  }\n\n  // If <input> tag, we only want to consider input[type=\'submit\'] & input[type=\'button\']\n  if (node.tagName === \'INPUT\' && ![\'submit\', \'button\'].includes(node.getAttribute(\'type\') || \'\')) {\n    return true;\n  }\n\n  // If <a> tag, detect special variants that may not lead to an action\n  // If target !== _self, we may open the link somewhere else, which would lead to no action\n  // Also, when downloading a file, we may not leave the page, but still not trigger an action\n  if (\n    node.tagName === \'A\' &&\n    (node.hasAttribute(\'download\') || (node.hasAttribute(\'target\') && node.getAttribute(\'target\') !== \'_self\'))\n  ) {\n    return true;\n  }\n\n  if (ignoreSelector && node.matches(ignoreSelector)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isClickBreadcrumb(breadcrumb) {\n  return !!(breadcrumb.data && typeof breadcrumb.data.nodeId === \'number\' && breadcrumb.timestamp);\n}\n\n// This is good enough for us, and is easier to test/mock than `timestampInSeconds`\nfunction nowInSeconds() {\n  return Date.now() / 1000;\n}\n\n/** Update the click detector based on a recording event of rrweb. */\nfunction updateClickDetectorForRecordingEvent(clickDetector, event) {\n  try {\n    // note: We only consider incremental snapshots here\n    // This means that any full snapshot is ignored for mutation detection - the reason is that we simply cannot know if a mutation happened here.\n    // E.g. think that we are buffering, an error happens and we take a full snapshot because we switched to session mode -\n    // in this scenario, we would not know if a dead click happened because of the error, which is a key dead click scenario.\n    // Instead, by ignoring full snapshots, we have the risk that we generate a false positive\n    // (if a mutation _did_ happen but was "swallowed" by the full snapshot)\n    // But this should be more unlikely as we\'d generally capture the incremental snapshot right away\n\n    if (!isIncrementalEvent(event)) {\n      return;\n    }\n\n    const { source } = event.data;\n    if (IncrementalMutationSources.has(source)) {\n      clickDetector.registerMutation(event.timestamp);\n    }\n\n    if (source === IncrementalSource.Scroll) {\n      clickDetector.registerScroll(event.timestamp);\n    }\n\n    if (isIncrementalMouseInteraction(event)) {\n      const { type, id } = event.data;\n      const node = record.mirror.getNode(id);\n\n      if (node instanceof HTMLElement && type === MouseInteractions.Click) {\n        clickDetector.registerClick(node);\n      }\n    }\n  } catch {\n    // ignore errors here, e.g. if accessing something that does not exist\n  }\n}\n\nfunction isIncrementalEvent(event) {\n  return event.type === ReplayEventTypeIncrementalSnapshot;\n}\n\nfunction isIncrementalMouseInteraction(\n  event,\n) {\n  return event.data.source === IncrementalSource.MouseInteraction;\n}\n\n/**\n * Create a breadcrumb for a replay.\n */\nfunction createBreadcrumb(\n  breadcrumb,\n) {\n  return {\n    timestamp: Date.now() / 1000,\n    type: \'default\',\n    ...breadcrumb,\n  };\n}\n\nvar NodeType = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2["Document"] = 0] = "Document";\n  NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";\n  NodeType2[NodeType2["Element"] = 2] = "Element";\n  NodeType2[NodeType2["Text"] = 3] = "Text";\n  NodeType2[NodeType2["CDATA"] = 4] = "CDATA";\n  NodeType2[NodeType2["Comment"] = 5] = "Comment";\n  return NodeType2;\n})(NodeType || {});\n\n// Note that these are the serialized attributes and not attributes directly on\n// the DOM Node. Attributes we are interested in:\nconst ATTRIBUTES_TO_RECORD = new Set([\n  \'id\',\n  \'class\',\n  \'aria-label\',\n  \'role\',\n  \'name\',\n  \'alt\',\n  \'title\',\n  \'data-test-id\',\n  \'data-testid\',\n  \'disabled\',\n  \'aria-disabled\',\n  \'data-sentry-component\',\n]);\n\n/**\n * Inclusion list of attributes that we want to record from the DOM element\n */\nfunction getAttributesToRecord(attributes) {\n  const obj = {};\n  if (!attributes[\'data-sentry-component\'] && attributes[\'data-sentry-element\']) {\n    attributes[\'data-sentry-component\'] = attributes[\'data-sentry-element\'];\n  }\n  for (const key in attributes) {\n    if (ATTRIBUTES_TO_RECORD.has(key)) {\n      let normalizedKey = key;\n\n      if (key === \'data-testid\' || key === \'data-test-id\') {\n        normalizedKey = \'testId\';\n      }\n\n      obj[normalizedKey] = attributes[key];\n    }\n  }\n\n  return obj;\n}\n\nconst handleDomListener = (\n  replay,\n) => {\n  return (handlerData) => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n\n    const result = handleDom(handlerData);\n\n    if (!result) {\n      return;\n    }\n\n    const isClick = handlerData.name === \'click\';\n    const event = isClick ? (handlerData.event ) : undefined;\n    // Ignore clicks if ctrl/alt/meta/shift keys are held down as they alter behavior of clicks (e.g. open in new tab)\n    if (\n      isClick &&\n      replay.clickDetector &&\n      event &&\n      event.target &&\n      !event.altKey &&\n      !event.metaKey &&\n      !event.ctrlKey &&\n      !event.shiftKey\n    ) {\n      handleClick(\n        replay.clickDetector,\n        result ,\n        getClickTargetNode(handlerData.event ) ,\n      );\n    }\n\n    addBreadcrumbEvent(replay, result);\n  };\n};\n\n/** Get the base DOM breadcrumb. */\nfunction getBaseDomBreadcrumb(target, message) {\n  const nodeId = record.mirror.getId(target);\n  const node = nodeId && record.mirror.getNode(nodeId);\n  const meta = node && record.mirror.getMeta(node);\n  const element = meta && isElement(meta) ? meta : null;\n\n  return {\n    message,\n    data: element\n      ? {\n          nodeId,\n          node: {\n            id: nodeId,\n            tagName: element.tagName,\n            textContent: Array.from(element.childNodes)\n              .map((node) => node.type === NodeType.Text && node.textContent)\n              .filter(Boolean) // filter out empty values\n              .map(text => (text ).trim())\n              .join(\'\'),\n            attributes: getAttributesToRecord(element.attributes),\n          },\n        }\n      : {},\n  };\n}\n\n/**\n * An event handler to react to DOM events.\n * Exported for tests.\n */\nfunction handleDom(handlerData) {\n  const { target, message } = getDomTarget(handlerData);\n\n  return createBreadcrumb({\n    category: `ui.${handlerData.name}`,\n    ...getBaseDomBreadcrumb(target, message),\n  });\n}\n\nfunction getDomTarget(handlerData) {\n  const isClick = handlerData.name === \'click\';\n\n  let message;\n  let target = null;\n\n  // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n  try {\n    target = isClick ? getClickTargetNode(handlerData.event ) : getTargetNode(handlerData.event );\n    message = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_4__.htmlTreeAsString)(target, { maxStringLength: 200 }) || \'<unknown>\';\n  } catch (e) {\n    message = \'<unknown>\';\n  }\n\n  return { target, message };\n}\n\nfunction isElement(node) {\n  return node.type === NodeType.Element;\n}\n\n/** Handle keyboard events & create breadcrumbs. */\nfunction handleKeyboardEvent(replay, event) {\n  if (!replay.isEnabled()) {\n    return;\n  }\n\n  // Update user activity, but do not restart recording as it can create\n  // noisy/low-value replays (e.g. user comes back from idle, hits alt-tab, new\n  // session with a single "keydown" breadcrumb is created)\n  replay.updateUserActivity();\n\n  const breadcrumb = getKeyboardBreadcrumb(event);\n\n  if (!breadcrumb) {\n    return;\n  }\n\n  addBreadcrumbEvent(replay, breadcrumb);\n}\n\n/** exported only for tests */\nfunction getKeyboardBreadcrumb(event) {\n  const { metaKey, shiftKey, ctrlKey, altKey, key, target } = event;\n\n  // never capture for input fields\n  if (!target || isInputElement(target ) || !key) {\n    return null;\n  }\n\n  // Note: We do not consider shift here, as that means "uppercase"\n  const hasModifierKey = metaKey || ctrlKey || altKey;\n  const isCharacterKey = key.length === 1; // other keys like Escape, Tab, etc have a longer length\n\n  // Do not capture breadcrumb if only a word key is pressed\n  // This could leak e.g. user input\n  if (!hasModifierKey && isCharacterKey) {\n    return null;\n  }\n\n  const message = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_4__.htmlTreeAsString)(target, { maxStringLength: 200 }) || \'<unknown>\';\n  const baseBreadcrumb = getBaseDomBreadcrumb(target , message);\n\n  return createBreadcrumb({\n    category: \'ui.keyDown\',\n    message,\n    data: {\n      ...baseBreadcrumb.data,\n      metaKey,\n      shiftKey,\n      ctrlKey,\n      altKey,\n      key,\n    },\n  });\n}\n\nfunction isInputElement(target) {\n  return target.tagName === \'INPUT\' || target.tagName === \'TEXTAREA\' || target.isContentEditable;\n}\n\n// Map entryType -> function to normalize data for event\nconst ENTRY_TYPES\n\n = {\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  resource: createResourceEntry,\n  paint: createPaintEntry,\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  navigation: createNavigationEntry,\n};\n\n/**\n * Handler creater for web vitals\n */\nfunction webVitalHandler(\n  getter,\n  replay,\n) {\n  return ({ metric }) => void replay.replayPerformanceEntries.push(getter(metric));\n}\n\n/**\n * Create replay performance entries from the browser performance entries.\n */\nfunction createPerformanceEntries(\n  entries,\n) {\n  return entries.map(createPerformanceEntry).filter(Boolean) ;\n}\n\nfunction createPerformanceEntry(entry) {\n  const entryType = ENTRY_TYPES[entry.entryType];\n  if (!entryType) {\n    return null;\n  }\n\n  return entryType(entry);\n}\n\nfunction getAbsoluteTime(time) {\n  // browserPerformanceTimeOrigin can be undefined if `performance` or\n  // `performance.now` doesn\'t exist, but this is already checked by this integration\n  return (((0,_sentry_core__WEBPACK_IMPORTED_MODULE_5__.browserPerformanceTimeOrigin)() || WINDOW.performance.timeOrigin) + time) / 1000;\n}\n\nfunction createPaintEntry(entry) {\n  const { duration, entryType, name, startTime } = entry;\n\n  const start = getAbsoluteTime(startTime);\n  return {\n    type: entryType,\n    name,\n    start,\n    end: start + duration,\n    data: undefined,\n  };\n}\n\nfunction createNavigationEntry(entry) {\n  const {\n    entryType,\n    name,\n    decodedBodySize,\n    duration,\n    domComplete,\n    encodedBodySize,\n    domContentLoadedEventStart,\n    domContentLoadedEventEnd,\n    domInteractive,\n    loadEventStart,\n    loadEventEnd,\n    redirectCount,\n    startTime,\n    transferSize,\n    type,\n  } = entry;\n\n  // Ignore entries with no duration, they do not seem to be useful and cause dupes\n  if (duration === 0) {\n    return null;\n  }\n\n  return {\n    type: `${entryType}.${type}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(domComplete),\n    name,\n    data: {\n      size: transferSize,\n      decodedBodySize,\n      encodedBodySize,\n      duration,\n      domInteractive,\n      domContentLoadedEventStart,\n      domContentLoadedEventEnd,\n      loadEventStart,\n      loadEventEnd,\n      domComplete,\n      redirectCount,\n    },\n  };\n}\n\nfunction createResourceEntry(\n  entry,\n) {\n  const {\n    entryType,\n    initiatorType,\n    name,\n    responseEnd,\n    startTime,\n    decodedBodySize,\n    encodedBodySize,\n    responseStatus,\n    transferSize,\n  } = entry;\n\n  // Core SDK handles these\n  if ([\'fetch\', \'xmlhttprequest\'].includes(initiatorType)) {\n    return null;\n  }\n\n  return {\n    type: `${entryType}.${initiatorType}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(responseEnd),\n    name,\n    data: {\n      size: transferSize,\n      statusCode: responseStatus,\n      decodedBodySize,\n      encodedBodySize,\n    },\n  };\n}\n\n/**\n * Add a LCP event to the replay based on a LCP metric.\n */\nfunction getLargestContentfulPaint(metric) {\n  const lastEntry = metric.entries[metric.entries.length - 1] ;\n  const node = lastEntry?.element ? [lastEntry.element] : undefined;\n  return getWebVital(metric, \'largest-contentful-paint\', node);\n}\n\nfunction isLayoutShift(entry) {\n  return (entry ).sources !== undefined;\n}\n\n/**\n * Add a CLS event to the replay based on a CLS metric.\n */\nfunction getCumulativeLayoutShift(metric) {\n  const layoutShifts = [];\n  const nodes = [];\n  for (const entry of metric.entries) {\n    if (isLayoutShift(entry)) {\n      const nodeIds = [];\n      for (const source of entry.sources) {\n        if (source.node) {\n          nodes.push(source.node);\n          const nodeId = record.mirror.getId(source.node);\n          if (nodeId) {\n            nodeIds.push(nodeId);\n          }\n        }\n      }\n      layoutShifts.push({ value: entry.value, nodeIds: nodeIds.length ? nodeIds : undefined });\n    }\n  }\n\n  return getWebVital(metric, \'cumulative-layout-shift\', nodes, layoutShifts);\n}\n\n/**\n * Add a FID event to the replay based on a FID metric.\n */\nfunction getFirstInputDelay(metric) {\n  const lastEntry = metric.entries[metric.entries.length - 1] ;\n  const node = lastEntry?.target ? [lastEntry.target] : undefined;\n  return getWebVital(metric, \'first-input-delay\', node);\n}\n\n/**\n * Add an INP event to the replay based on an INP metric.\n */\nfunction getInteractionToNextPaint(metric) {\n  const lastEntry = metric.entries[metric.entries.length - 1] ;\n  const node = lastEntry?.target ? [lastEntry.target] : undefined;\n  return getWebVital(metric, \'interaction-to-next-paint\', node);\n}\n\n/**\n * Add an web vital event to the replay based on the web vital metric.\n */\nfunction getWebVital(\n  metric,\n  name,\n  nodes,\n  attributions,\n) {\n  const value = metric.value;\n  const rating = metric.rating;\n\n  const end = getAbsoluteTime(value);\n\n  return {\n    type: \'web-vital\',\n    name,\n    start: end,\n    end,\n    data: {\n      value,\n      size: value,\n      rating,\n      nodeIds: nodes ? nodes.map(node => record.mirror.getId(node)) : undefined,\n      attributions,\n    },\n  };\n}\n\n/**\n * Sets up a PerformanceObserver to listen to all performance entry types.\n * Returns a callback to stop observing.\n */\nfunction setupPerformanceObserver(replay) {\n  function addPerformanceEntry(entry) {\n    // It is possible for entries to come up multiple times\n    if (!replay.performanceEntries.includes(entry)) {\n      replay.performanceEntries.push(entry);\n    }\n  }\n\n  function onEntries({ entries }) {\n    entries.forEach(addPerformanceEntry);\n  }\n\n  const clearCallbacks = [];\n\n  ([\'navigation\', \'paint\', \'resource\'] ).forEach(type => {\n    clearCallbacks.push((0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_6__.addPerformanceInstrumentationHandler)(type, onEntries));\n  });\n\n  clearCallbacks.push(\n    (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_6__.addLcpInstrumentationHandler)(webVitalHandler(getLargestContentfulPaint, replay)),\n    (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_6__.addClsInstrumentationHandler)(webVitalHandler(getCumulativeLayoutShift, replay)),\n    (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_6__.addFidInstrumentationHandler)(webVitalHandler(getFirstInputDelay, replay)),\n    (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_6__.addInpInstrumentationHandler)(webVitalHandler(getInteractionToNextPaint, replay)),\n  );\n\n  // A callback to cleanup all handlers\n  return () => {\n    clearCallbacks.forEach(clearCallback => clearCallback());\n  };\n}\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === \'undefined\' || __SENTRY_DEBUG__);\n\nconst r = `var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),s=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),a=function(t,e){for(var i=new n(31),s=0;s<31;++s)i[s]=e+=1<<t[s-1];var a=new r(i[30]);for(s=1;s<30;++s)for(var o=i[s];o<i[s+1];++o)a[o]=o-i[s]<<5|s;return{b:i,r:a}},o=a(e,2),h=o.b,f=o.r;h[28]=258,f[258]=28;for(var l=a(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,s=0,a=new n(r);s<i;++s)t[s]&&++a[t[s]-1];var o,h=new n(r);for(s=1;s<r;++s)h[s]=h[s-1]+a[s-1]<<1;if(e){o=new n(1<<r);var f=15-r;for(s=0;s<i;++s)if(t[s])for(var l=s<<4|t[s],c=r-t[s],v=h[t[s]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>f]=l}else for(o=new n(i),s=0;s<i;++s)t[s]&&(o[s]=u[h[t[s]-1]++]>>15-t[s]);return o},p=new t(288);for(c=0;c<144;++c)p[c]=8;for(c=144;c<256;++c)p[c]=9;for(c=256;c<280;++c)p[c]=7;for(c=280;c<288;++c)p[c]=8;var g=new t(32);for(c=0;c<32;++c)g[c]=5;var w=d(p,9,0),y=d(g,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},_=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},x=function(r,e){for(var i=[],s=0;s<r.length;++s)r[s]&&i.push({s:s,f:r[s]});var a=i.length,o=i.slice();if(!a)return{t:F,l:0};if(1==a){var h=new t(i[0].s+1);return h[i[0].s]=1,{t:h,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var f=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:f.f+l.f,l:f,r:l};c!=a-1;)f=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:f.f+l.f,l:f,r:l};var d=o[0].s;for(s=1;s<a;++s)o[s].s>d&&(d=o[s].s);var p=new n(d+1),g=A(i[c-1],p,0);if(g>e){s=0;var w=0,y=g-e,m=1<<y;for(o.sort((function(t,n){return p[n.s]-p[t.s]||t.f-n.f}));s<a;++s){var b=o[s].s;if(!(p[b]>e))break;w+=m-(1<<g-p[b]),p[b]=e}for(w>>=y;w>0;){var M=o[s].s;p[M]<e?w-=1<<e-p[M]++-1:++s}for(;s>=0&&w;--s){var E=o[s].s;p[E]==e&&(--p[E],++w)}g=e}return{t:new t(p),l:g}},A=function(t,n,r){return-1==t.s?Math.max(A(t.l,n,r+1),A(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,s=t[0],a=1,o=function(t){e[i++]=t},h=1;h<=r;++h)if(t[h]==s&&h!=r)++a;else{if(!s&&a>2){for(;a>138;a-=138)o(32754);a>2&&(o(a>10?a-11<<5|28690:a-3<<5|12305),a=0)}else if(a>3){for(o(s),--a;a>6;a-=6)o(8304);a>2&&(o(a-3<<5|8208),a=0)}for(;a--;)o(s);a=1,s=t[h]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var s=0;s<e;++s)t[i+s+4]=r[s];return 8*(i+4+e)},U=function(t,r,a,o,h,f,l,u,c,v,m){z(r,m++,a),++h[256];for(var b=x(h,15),M=b.t,E=b.l,A=x(f,15),U=A.t,C=A.l,F=D(M),I=F.c,S=F.n,L=D(U),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=x(q,7),H=G.t,J=G.l,K=19;K>4&&!H[s[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(h,p)+T(f,g)+l,X=T(h,M)+T(f,U)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(U,C,0),R=U;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[s[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=w,P=p,Q=y,R=g;for(B=0;B<u;++B){var rt=o[B];if(rt>255){_(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;_(r,m,Q[et]),m+=R[et],et>3&&(_(r,m,rt>>5&8191),m+=i[et])}else _(r,m,N[rt]),m+=P[rt]}return _(r,m,N[256]),m+P[256]},C=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}},L=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,s=0|r.length,a=0;a!=s;){for(var o=Math.min(a+2655,s);a<o;++a)i+=e+=r[a];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},O=function(s,a,o,h,u){if(!u&&(u={l:1},a.dictionary)){var c=a.dictionary.subarray(-32768),v=new t(c.length+s.length);v.set(c),v.set(s,c.length),s=v,u.w=c.length}return function(s,a,o,h,u,c){var v=c.z||s.length,d=new t(h+v+5*(1+Math.ceil(v/7e3))+u),p=d.subarray(h,d.length-u),g=c.l,w=7&(c.r||0);if(a){w&&(p[0]=c.r>>3);for(var y=C[a-1],M=y>>13,E=8191&y,z=(1<<o)-1,_=c.p||new n(32768),x=c.h||new n(z+1),A=Math.ceil(o/3),D=2*A,T=function(t){return(s[t]^s[t+1]<<A^s[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=x[H];if(_[J]=K,x[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!g)){w=U(s,p,0,F,I,S,O,q,G,j-G,w),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(s[j+Q]==s[j+Q-W]){for(var $=0;$<Z&&s[j+$]==s[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-_[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=_[J])&32767}if(R){F[q++]=268435456|f[Q]<<18|l[R];var it=31&f[Q],st=31&l[R];O+=e[it]+i[st],++I[257+it],++S[st],B=j+Q,++L}else F[q++]=s[j],++I[s[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=s[j],++I[s[j]];w=U(s,p,g,F,I,S,O,q,G,j-G,w),g||(c.r=7&w|p[w/8|0]<<3,w-=7,c.h=x,c.p=_,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+g;j+=65535){var at=j+65535;at>=v&&(p[w/8|0]=g,at=v),w=k(p,w+1,s.subarray(j,at))}c.i=v}return b(d,0,h+m(w)+u)}(s,null==a.level?6:a.level,null==a.mem?u.l?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(s.length)))):20:12+a.mem,o,h,u)},j=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},q=function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&j(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}},B=function(t){return 10+(t.filename?t.filename.length+1:0)},G=function(){function n(n,r){if("function"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(O(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var s=this.b.length-this.s.z;this.b.set(n.subarray(0,s),this.s.z),this.s.z=this.b.length,this.p(this.b,!1),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(s),32768),this.s.z=n.length-s+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n.prototype.flush=function(){this.ondata||E(5),this.s.l&&E(4),this.p(this.b,!1),this.s.w=this.s.i,this.s.i-=2},n}();var H=function(){function t(t,n){this.c=L(),this.v=1,G.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),G.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=O(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=L();i.p(n.dictionary),j(t,2,i.d())}}(r,this.o),this.v=0),n&&j(r,r.length-4,this.c.d()),this.ondata(r,n)},t.prototype.flush=function(){G.prototype.flush.call(this)},t}(),J="undefined"!=typeof TextEncoder&&new TextEncoder,K="undefined"!=typeof TextDecoder&&new TextDecoder;try{K.decode(F,{stream:!0})}catch(t){}var N=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(P(t),this.d=n||!1)},t}();function P(n,r){if(J)return J.encode(n);for(var e=n.length,i=new t(n.length+(n.length>>1)),s=0,a=function(t){i[s++]=t},o=0;o<e;++o){if(s+5>i.length){var h=new t(s+8+(e-o<<1));h.set(i),i=h}var f=n.charCodeAt(o);f<128||r?a(f):f<2048?(a(192|f>>6),a(128|63&f)):f>55295&&f<57344?(a(240|(f=65536+(1047552&f)|1023&n.charCodeAt(++o))>>18),a(128|f>>12&63),a(128|f>>6&63),a(128|63&f)):(a(224|f>>12),a(128|f>>6&63),a(128|63&f))}return b(i,0,s)}function Q(t){return function(t,n){n||(n={});var r=S(),e=t.length;r.p(t);var i=O(t,n,B(n),8),s=i.length;return q(i,n),j(i,s-8,r.d()),j(i,s-4,e),i}(P(t))}const R=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error("Adding invalid event");const n=this._hasEvents?",":"";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push("]",!0);const t=function(t){let n=0;for(const r of t)n+=r.length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new H,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new N(((t,n)=>{this.deflate.push(t,n)})),this.stream.push("[")}},V={clear:()=>{R.clear()},addEvent:t=>R.addEvent(t),finish:()=>R.finish(),compress:t=>Q(t)};addEventListener("message",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in V&&"function"==typeof V[n])try{const t=V[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:"init",success:!0,response:void 0});`;\n\nfunction e(){const e=new Blob([r]);return URL.createObjectURL(e)}\n\nconst CONSOLE_LEVELS = [\'info\', \'warn\', \'error\', \'log\'] ;\nconst PREFIX = \'[Replay] \';\n\nfunction _addBreadcrumb(message, level = \'info\') {\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_7__.addBreadcrumb)(\n    {\n      category: \'console\',\n      data: {\n        logger: \'replay\',\n      },\n      level,\n      message: `${PREFIX}${message}`,\n    },\n    { level },\n  );\n}\n\nfunction makeReplayLogger() {\n  let _capture = false;\n  let _trace = false;\n\n  const _logger = {\n    exception: () => undefined,\n    infoTick: () => undefined,\n    setConfig: (opts) => {\n      _capture = !!opts.captureExceptions;\n      _trace = !!opts.traceInternals;\n    },\n  };\n\n  if (DEBUG_BUILD) {\n    CONSOLE_LEVELS.forEach(name => {\n      _logger[name] = (...args) => {\n        _sentry_core__WEBPACK_IMPORTED_MODULE_8__.logger[name](PREFIX, ...args);\n        if (_trace) {\n          _addBreadcrumb(args.join(\'\'), (0,_sentry_core__WEBPACK_IMPORTED_MODULE_9__.severityLevelFromString)(name));\n        }\n      };\n    });\n\n    _logger.exception = (error, ...message) => {\n      if (message.length && _logger.error) {\n        _logger.error(...message);\n      }\n\n      _sentry_core__WEBPACK_IMPORTED_MODULE_8__.logger.error(PREFIX, error);\n\n      if (_capture) {\n        (0,_sentry_core__WEBPACK_IMPORTED_MODULE_10__.captureException)(error);\n      } else if (_trace) {\n        // No need for a breadcrumb if `_capture` is enabled since it should be\n        // captured as an exception\n        _addBreadcrumb(error, \'error\');\n      }\n    };\n\n    _logger.infoTick = (...args) => {\n      _sentry_core__WEBPACK_IMPORTED_MODULE_8__.logger.info(PREFIX, ...args);\n      if (_trace) {\n        // Wait a tick here to avoid race conditions for some initial logs\n        // which may be added before replay is initialized\n        setTimeout(() => _addBreadcrumb(args[0]), 0);\n      }\n    };\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      _logger[name] = () => undefined;\n    });\n  }\n\n  return _logger ;\n}\n\nconst logger = makeReplayLogger();\n\n/** This error indicates that the event buffer size exceeded the limit.. */\nclass EventBufferSizeExceededError extends Error {\n   constructor() {\n    super(`Event buffer exceeded maximum size of ${REPLAY_MAX_EVENT_BUFFER_SIZE}.`);\n  }\n}\n\n/**\n * A basic event buffer that does not do any compression.\n * Used as fallback if the compression worker cannot be loaded or is disabled.\n */\nclass EventBufferArray  {\n  /** All the events that are buffered to be sent. */\n\n  /** @inheritdoc */\n\n  /** @inheritdoc */\n\n   constructor() {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n    this.waitForCheckout = false;\n  }\n\n  /** @inheritdoc */\n   get hasEvents() {\n    return this.events.length > 0;\n  }\n\n  /** @inheritdoc */\n   get type() {\n    return \'sync\';\n  }\n\n  /** @inheritdoc */\n   destroy() {\n    this.events = [];\n  }\n\n  /** @inheritdoc */\n   async addEvent(event) {\n    const eventSize = JSON.stringify(event).length;\n    this._totalSize += eventSize;\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      throw new EventBufferSizeExceededError();\n    }\n\n    this.events.push(event);\n  }\n\n  /** @inheritdoc */\n   finish() {\n    return new Promise(resolve => {\n      // Make a copy of the events array reference and immediately clear the\n      // events member so that we do not lose new events while uploading\n      // attachment.\n      const eventsRet = this.events;\n      this.clear();\n      resolve(JSON.stringify(eventsRet));\n    });\n  }\n\n  /** @inheritdoc */\n   clear() {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n  }\n\n  /** @inheritdoc */\n   getEarliestTimestamp() {\n    const timestamp = this.events.map(event => event.timestamp).sort()[0];\n\n    if (!timestamp) {\n      return null;\n    }\n\n    return timestampToMs(timestamp);\n  }\n}\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nclass WorkerHandler {\n\n   constructor(worker) {\n    this._worker = worker;\n    this._id = 0;\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occurred.\n   */\n   ensureReady() {\n    // Ensure we only check once\n    if (this._ensureReadyPromise) {\n      return this._ensureReadyPromise;\n    }\n\n    this._ensureReadyPromise = new Promise((resolve, reject) => {\n      this._worker.addEventListener(\n        \'message\',\n        ({ data }) => {\n          if ((data ).success) {\n            resolve();\n          } else {\n            reject();\n          }\n        },\n        { once: true },\n      );\n\n      this._worker.addEventListener(\n        \'error\',\n        error => {\n          reject(error);\n        },\n        { once: true },\n      );\n    });\n\n    return this._ensureReadyPromise;\n  }\n\n  /**\n   * Destroy the worker.\n   */\n   destroy() {\n    DEBUG_BUILD && logger.info(\'Destroying compression worker\');\n    this._worker.terminate();\n  }\n\n  /**\n   * Post message to worker and wait for response before resolving promise.\n   */\n   postMessage(method, arg) {\n    const id = this._getAndIncrementId();\n\n    return new Promise((resolve, reject) => {\n      const listener = ({ data }) => {\n        const response = data ;\n        if (response.method !== method) {\n          return;\n        }\n\n        // There can be multiple listeners for a single method, the id ensures\n        // that the response matches the caller.\n        if (response.id !== id) {\n          return;\n        }\n\n        // At this point, we\'ll always want to remove listener regardless of result status\n        this._worker.removeEventListener(\'message\', listener);\n\n        if (!response.success) {\n          // TODO: Do some error handling, not sure what\n          DEBUG_BUILD && logger.error(\'Error in compression worker: \', response.response);\n\n          reject(new Error(\'Error in compression worker\'));\n          return;\n        }\n\n        resolve(response.response );\n      };\n\n      // Note: we can\'t use `once` option because it\'s possible it needs to\n      // listen to multiple messages\n      this._worker.addEventListener(\'message\', listener);\n      this._worker.postMessage({ id, method, arg });\n    });\n  }\n\n  /** Get the current ID and increment it for the next call. */\n   _getAndIncrementId() {\n    return this._id++;\n  }\n}\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nclass EventBufferCompressionWorker  {\n  /** @inheritdoc */\n\n  /** @inheritdoc */\n\n   constructor(worker) {\n    this._worker = new WorkerHandler(worker);\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n    this.waitForCheckout = false;\n  }\n\n  /** @inheritdoc */\n   get hasEvents() {\n    return !!this._earliestTimestamp;\n  }\n\n  /** @inheritdoc */\n   get type() {\n    return \'worker\';\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occurred.\n   */\n   ensureReady() {\n    return this._worker.ensureReady();\n  }\n\n  /**\n   * Destroy the event buffer.\n   */\n   destroy() {\n    this._worker.destroy();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfully received and processed by worker.\n   */\n   addEvent(event) {\n    const timestamp = timestampToMs(event.timestamp);\n    if (!this._earliestTimestamp || timestamp < this._earliestTimestamp) {\n      this._earliestTimestamp = timestamp;\n    }\n\n    const data = JSON.stringify(event);\n    this._totalSize += data.length;\n\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      return Promise.reject(new EventBufferSizeExceededError());\n    }\n\n    return this._sendEventToWorker(data);\n  }\n\n  /**\n   * Finish the event buffer and return the compressed data.\n   */\n   finish() {\n    return this._finishRequest();\n  }\n\n  /** @inheritdoc */\n   clear() {\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n\n    // We do not wait on this, as we assume the order of messages is consistent for the worker\n    this._worker.postMessage(\'clear\').then(null, e => {\n      DEBUG_BUILD && logger.exception(e, \'Sending "clear" message to worker failed\', e);\n    });\n  }\n\n  /** @inheritdoc */\n   getEarliestTimestamp() {\n    return this._earliestTimestamp;\n  }\n\n  /**\n   * Send the event to the worker.\n   */\n   _sendEventToWorker(data) {\n    return this._worker.postMessage(\'addEvent\', data);\n  }\n\n  /**\n   * Finish the request and return the compressed data from the worker.\n   */\n   async _finishRequest() {\n    const response = await this._worker.postMessage(\'finish\');\n\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n\n    return response;\n  }\n}\n\n/**\n * This proxy will try to use the compression worker, and fall back to use the simple buffer if an error occurs there.\n * This can happen e.g. if the worker cannot be loaded.\n * Exported only for testing.\n */\nclass EventBufferProxy  {\n\n   constructor(worker) {\n    this._fallback = new EventBufferArray();\n    this._compression = new EventBufferCompressionWorker(worker);\n    this._used = this._fallback;\n\n    this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded();\n  }\n\n  /** @inheritdoc */\n   get waitForCheckout() {\n    return this._used.waitForCheckout;\n  }\n\n  /** @inheritdoc */\n   get type() {\n    return this._used.type;\n  }\n\n  /** @inheritDoc */\n   get hasEvents() {\n    return this._used.hasEvents;\n  }\n\n  /** @inheritdoc */\n   get hasCheckout() {\n    return this._used.hasCheckout;\n  }\n  /** @inheritdoc */\n   set hasCheckout(value) {\n    this._used.hasCheckout = value;\n  }\n\n  /** @inheritdoc */\n  // eslint-disable-next-line @typescript-eslint/adjacent-overload-signatures\n   set waitForCheckout(value) {\n    this._used.waitForCheckout = value;\n  }\n\n  /** @inheritDoc */\n   destroy() {\n    this._fallback.destroy();\n    this._compression.destroy();\n  }\n\n  /** @inheritdoc */\n   clear() {\n    return this._used.clear();\n  }\n\n  /** @inheritdoc */\n   getEarliestTimestamp() {\n    return this._used.getEarliestTimestamp();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfully added.\n   */\n   addEvent(event) {\n    return this._used.addEvent(event);\n  }\n\n  /** @inheritDoc */\n   async finish() {\n    // Ensure the worker is loaded, so the sent event is compressed\n    await this.ensureWorkerIsLoaded();\n\n    return this._used.finish();\n  }\n\n  /** Ensure the worker has loaded. */\n   ensureWorkerIsLoaded() {\n    return this._ensureWorkerIsLoadedPromise;\n  }\n\n  /** Actually check if the worker has been loaded. */\n   async _ensureWorkerIsLoaded() {\n    try {\n      await this._compression.ensureReady();\n    } catch (error) {\n      // If the worker fails to load, we fall back to the simple buffer.\n      // Nothing more to do from our side here\n      DEBUG_BUILD && logger.exception(error, \'Failed to load the compression worker, falling back to simple buffer\');\n      return;\n    }\n\n    // Now we need to switch over the array buffer to the compression worker\n    await this._switchToCompressionWorker();\n  }\n\n  /** Switch the used buffer to the compression worker. */\n   async _switchToCompressionWorker() {\n    const { events, hasCheckout, waitForCheckout } = this._fallback;\n\n    const addEventPromises = [];\n    for (const event of events) {\n      addEventPromises.push(this._compression.addEvent(event));\n    }\n\n    this._compression.hasCheckout = hasCheckout;\n    this._compression.waitForCheckout = waitForCheckout;\n\n    // We switch over to the new buffer immediately - any further events will be added\n    // after the previously buffered ones\n    this._used = this._compression;\n\n    // Wait for original events to be re-added before resolving\n    try {\n      await Promise.all(addEventPromises);\n\n      // Can now clear fallback buffer as it\'s no longer necessary\n      this._fallback.clear();\n    } catch (error) {\n      DEBUG_BUILD && logger.exception(error, \'Failed to add events when switching buffers.\');\n    }\n  }\n}\n\n/**\n * Create an event buffer for replays.\n */\nfunction createEventBuffer({\n  useCompression,\n  workerUrl: customWorkerUrl,\n}) {\n  if (\n    useCompression &&\n    // eslint-disable-next-line no-restricted-globals\n    window.Worker\n  ) {\n    const worker = _loadWorker(customWorkerUrl);\n\n    if (worker) {\n      return worker;\n    }\n  }\n\n  DEBUG_BUILD && logger.info(\'Using simple buffer\');\n  return new EventBufferArray();\n}\n\nfunction _loadWorker(customWorkerUrl) {\n  try {\n    const workerUrl = customWorkerUrl || _getWorkerUrl();\n\n    if (!workerUrl) {\n      return;\n    }\n\n    DEBUG_BUILD && logger.info(`Using compression worker${customWorkerUrl ? ` from ${customWorkerUrl}` : \'\'}`);\n    const worker = new Worker(workerUrl);\n    return new EventBufferProxy(worker);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, \'Failed to create compression worker\');\n    // Fall back to use simple event buffer array\n  }\n}\n\nfunction _getWorkerUrl() {\n  if (typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ === \'undefined\' || !__SENTRY_EXCLUDE_REPLAY_WORKER__) {\n    return e();\n  }\n\n  return \'\';\n}\n\n/** If sessionStorage is available. */\nfunction hasSessionStorage() {\n  try {\n    // This can throw, e.g. when being accessed in a sandboxed iframe\n    return \'sessionStorage\' in WINDOW && !!WINDOW.sessionStorage;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Removes the session from Session Storage and unsets session in replay instance\n */\nfunction clearSession(replay) {\n  deleteSession();\n  replay.session = undefined;\n}\n\n/**\n * Deletes a session from storage\n */\nfunction deleteSession() {\n  if (!hasSessionStorage()) {\n    return;\n  }\n\n  try {\n    WINDOW.sessionStorage.removeItem(REPLAY_SESSION_KEY);\n  } catch {\n    // Ignore potential SecurityError exceptions\n  }\n}\n\n/**\n * Given a sample rate, returns true if replay should be sampled.\n *\n * 1.0 = 100% sampling\n * 0.0 = 0% sampling\n */\nfunction isSampled(sampleRate) {\n  if (sampleRate === undefined) {\n    return false;\n  }\n\n  // Math.random() returns a number in range of 0 to 1 (inclusive of 0, but not 1)\n  return Math.random() < sampleRate;\n}\n\n/**\n * Save a session to session storage.\n */\nfunction saveSession(session) {\n  if (!hasSessionStorage()) {\n    return;\n  }\n\n  try {\n    WINDOW.sessionStorage.setItem(REPLAY_SESSION_KEY, JSON.stringify(session));\n  } catch {\n    // Ignore potential SecurityError exceptions\n  }\n}\n\n/**\n * Get a session with defaults & applied sampling.\n */\nfunction makeSession(session) {\n  const now = Date.now();\n  const id = session.id || (0,_sentry_core__WEBPACK_IMPORTED_MODULE_11__.uuid4)();\n  // Note that this means we cannot set a started/lastActivity of `0`, but this should not be relevant outside of tests.\n  const started = session.started || now;\n  const lastActivity = session.lastActivity || now;\n  const segmentId = session.segmentId || 0;\n  const sampled = session.sampled;\n  const previousSessionId = session.previousSessionId;\n\n  return {\n    id,\n    started,\n    lastActivity,\n    segmentId,\n    sampled,\n    previousSessionId,\n  };\n}\n\n/**\n * Get the sampled status for a session based on sample rates & current sampled status.\n */\nfunction getSessionSampleType(sessionSampleRate, allowBuffering) {\n  return isSampled(sessionSampleRate) ? \'session\' : allowBuffering ? \'buffer\' : false;\n}\n\n/**\n * Create a new session, which in its current implementation is a Sentry event\n * that all replays will be saved to as attachments. Currently, we only expect\n * one of these Sentry events per "replay session".\n */\nfunction createSession(\n  { sessionSampleRate, allowBuffering, stickySession = false },\n  { previousSessionId } = {},\n) {\n  const sampled = getSessionSampleType(sessionSampleRate, allowBuffering);\n  const session = makeSession({\n    sampled,\n    previousSessionId,\n  });\n\n  if (stickySession) {\n    saveSession(session);\n  }\n\n  return session;\n}\n\n/**\n * Fetches a session from storage\n */\nfunction fetchSession() {\n  if (!hasSessionStorage()) {\n    return null;\n  }\n\n  try {\n    // This can throw if cookies are disabled\n    const sessionStringFromStorage = WINDOW.sessionStorage.getItem(REPLAY_SESSION_KEY);\n\n    if (!sessionStringFromStorage) {\n      return null;\n    }\n\n    const sessionObj = JSON.parse(sessionStringFromStorage) ;\n\n    DEBUG_BUILD && logger.infoTick(\'Loading existing session\');\n\n    return makeSession(sessionObj);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Given an initial timestamp and an expiry duration, checks to see if current\n * time should be considered as expired.\n */\nfunction isExpired(\n  initialTime,\n  expiry,\n  targetTime = +new Date(),\n) {\n  // Always expired if < 0\n  if (initialTime === null || expiry === undefined || expiry < 0) {\n    return true;\n  }\n\n  // Never expires if == 0\n  if (expiry === 0) {\n    return false;\n  }\n\n  return initialTime + expiry <= targetTime;\n}\n\n/**\n * Checks to see if session is expired\n */\nfunction isSessionExpired(\n  session,\n  {\n    maxReplayDuration,\n    sessionIdleExpire,\n    targetTime = Date.now(),\n  },\n) {\n  return (\n    // First, check that maximum session length has not been exceeded\n    isExpired(session.started, maxReplayDuration, targetTime) ||\n    // check that the idle timeout has not been exceeded (i.e. user has\n    // performed an action within the last `sessionIdleExpire` ms)\n    isExpired(session.lastActivity, sessionIdleExpire, targetTime)\n  );\n}\n\n/** If the session should be refreshed or not. */\nfunction shouldRefreshSession(\n  session,\n  { sessionIdleExpire, maxReplayDuration },\n) {\n  // If not expired, all good, just keep the session\n  if (!isSessionExpired(session, { sessionIdleExpire, maxReplayDuration })) {\n    return false;\n  }\n\n  // If we are buffering & haven\'t ever flushed yet, always continue\n  if (session.sampled === \'buffer\' && session.segmentId === 0) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Get or create a session, when initializing the replay.\n * Returns a session that may be unsampled.\n */\nfunction loadOrCreateSession(\n  {\n    sessionIdleExpire,\n    maxReplayDuration,\n    previousSessionId,\n  }\n\n,\n  sessionOptions,\n) {\n  const existingSession = sessionOptions.stickySession && fetchSession();\n\n  // No session exists yet, just create a new one\n  if (!existingSession) {\n    DEBUG_BUILD && logger.infoTick(\'Creating new session\');\n    return createSession(sessionOptions, { previousSessionId });\n  }\n\n  if (!shouldRefreshSession(existingSession, { sessionIdleExpire, maxReplayDuration })) {\n    return existingSession;\n  }\n\n  DEBUG_BUILD && logger.infoTick(\'Session in sessionStorage is expired, creating new one...\');\n  return createSession(sessionOptions, { previousSessionId: existingSession.id });\n}\n\nfunction isCustomEvent(event) {\n  return event.type === EventType.Custom;\n}\n\n/**\n * Add an event to the event buffer.\n * In contrast to `addEvent`, this does not return a promise & does not wait for the adding of the event to succeed/fail.\n * Instead this returns `true` if we tried to add the event, else false.\n * It returns `false` e.g. if we are paused, disabled, or out of the max replay duration.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nfunction addEventSync(replay, event, isCheckout) {\n  if (!shouldAddEvent(replay, event)) {\n    return false;\n  }\n\n  // This should never reject\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  _addEvent(replay, event, isCheckout);\n\n  return true;\n}\n\n/**\n * Add an event to the event buffer.\n * Resolves to `null` if no event was added, else to `void`.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nfunction addEvent(\n  replay,\n  event,\n  isCheckout,\n) {\n  if (!shouldAddEvent(replay, event)) {\n    return Promise.resolve(null);\n  }\n\n  return _addEvent(replay, event, isCheckout);\n}\n\nasync function _addEvent(\n  replay,\n  event,\n  isCheckout,\n) {\n  const { eventBuffer } = replay;\n\n  if (!eventBuffer || (eventBuffer.waitForCheckout && !isCheckout)) {\n    return null;\n  }\n\n  const isBufferMode = replay.recordingMode === \'buffer\';\n\n  try {\n    if (isCheckout && isBufferMode) {\n      eventBuffer.clear();\n    }\n\n    if (isCheckout) {\n      eventBuffer.hasCheckout = true;\n      eventBuffer.waitForCheckout = false;\n    }\n\n    const replayOptions = replay.getOptions();\n\n    const eventAfterPossibleCallback = maybeApplyCallback(event, replayOptions.beforeAddRecordingEvent);\n\n    if (!eventAfterPossibleCallback) {\n      return;\n    }\n\n    return await eventBuffer.addEvent(eventAfterPossibleCallback);\n  } catch (error) {\n    const isExceeded = error && error instanceof EventBufferSizeExceededError;\n    const reason = isExceeded ? \'addEventSizeExceeded\' : \'addEvent\';\n\n    if (isExceeded && isBufferMode) {\n      // Clear buffer and wait for next checkout\n      eventBuffer.clear();\n      eventBuffer.waitForCheckout = true;\n\n      return null;\n    }\n\n    replay.handleException(error);\n\n    await replay.stop({ reason });\n\n    const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n\n    if (client) {\n      client.recordDroppedEvent(\'internal_sdk_error\', \'replay\');\n    }\n  }\n}\n\n/** Exported only for tests. */\nfunction shouldAddEvent(replay, event) {\n  if (!replay.eventBuffer || replay.isPaused() || !replay.isEnabled()) {\n    return false;\n  }\n\n  const timestampInMs = timestampToMs(event.timestamp);\n\n  // Throw out events that happen more than 5 minutes ago. This can happen if\n  // page has been left open and idle for a long period of time and user\n  // comes back to trigger a new session. The performance entries rely on\n  // `performance.timeOrigin`, which is when the page first opened.\n  if (timestampInMs + replay.timeouts.sessionIdlePause < Date.now()) {\n    return false;\n  }\n\n  // Throw out events that are +60min from the initial timestamp\n  if (timestampInMs > replay.getContext().initialTimestamp + replay.getOptions().maxReplayDuration) {\n    DEBUG_BUILD &&\n      logger.infoTick(`Skipping event with timestamp ${timestampInMs} because it is after maxReplayDuration`);\n    return false;\n  }\n\n  return true;\n}\n\nfunction maybeApplyCallback(\n  event,\n  callback,\n) {\n  try {\n    if (typeof callback === \'function\' && isCustomEvent(event)) {\n      return callback(event);\n    }\n  } catch (error) {\n    DEBUG_BUILD &&\n      logger.exception(error, \'An error occurred in the `beforeAddRecordingEvent` callback, skipping the event...\');\n    return null;\n  }\n\n  return event;\n}\n\n/** If the event is an error event */\nfunction isErrorEvent(event) {\n  return !event.type;\n}\n\n/** If the event is a transaction event */\nfunction isTransactionEvent(event) {\n  return event.type === \'transaction\';\n}\n\n/** If the event is an replay event */\nfunction isReplayEvent(event) {\n  return event.type === \'replay_event\';\n}\n\n/** If the event is a feedback event */\nfunction isFeedbackEvent(event) {\n  return event.type === \'feedback\';\n}\n\n/**\n * Returns a listener to be added to `client.on(\'afterSendErrorEvent, listener)`.\n */\nfunction handleAfterSendEvent(replay) {\n  return (event, sendResponse) => {\n    if (!replay.isEnabled() || (!isErrorEvent(event) && !isTransactionEvent(event))) {\n      return;\n    }\n\n    const statusCode = sendResponse?.statusCode;\n\n    // We only want to do stuff on successful error sending, otherwise you get error replays without errors attached\n    // If not using the base transport, we allow `undefined` response (as a custom transport may not implement this correctly yet)\n    // If we do use the base transport, we skip if we encountered an non-OK status code\n    if (!statusCode || statusCode < 200 || statusCode >= 300) {\n      return;\n    }\n\n    if (isTransactionEvent(event)) {\n      handleTransactionEvent(replay, event);\n      return;\n    }\n\n    handleErrorEvent(replay, event);\n  };\n}\n\nfunction handleTransactionEvent(replay, event) {\n  const replayContext = replay.getContext();\n\n  // Collect traceIds in _context regardless of `recordingMode`\n  // In error mode, _context gets cleared on every checkout\n  // We limit to max. 100 transactions linked\n  if (event.contexts?.trace?.trace_id && replayContext.traceIds.size < 100) {\n    replayContext.traceIds.add(event.contexts.trace.trace_id);\n  }\n}\n\nfunction handleErrorEvent(replay, event) {\n  const replayContext = replay.getContext();\n\n  // Add error to list of errorIds of replay. This is ok to do even if not\n  // sampled because context will get reset at next checkout.\n  // XXX: There is also a race condition where it\'s possible to capture an\n  // error to Sentry before Replay SDK has loaded, but response returns after\n  // it was loaded, and this gets called.\n  // We limit to max. 100 errors linked\n  if (event.event_id && replayContext.errorIds.size < 100) {\n    replayContext.errorIds.add(event.event_id);\n  }\n\n  // If error event is tagged with replay id it means it was sampled (when in buffer mode)\n  // Need to be very careful that this does not cause an infinite loop\n  if (replay.recordingMode !== \'buffer\' || !event.tags || !event.tags.replayId) {\n    return;\n  }\n\n  const { beforeErrorSampling } = replay.getOptions();\n  if (typeof beforeErrorSampling === \'function\' && !beforeErrorSampling(event)) {\n    return;\n  }\n\n  (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__.setTimeout)(async () => {\n    try {\n      // Capture current event buffer as new replay\n      await replay.sendBufferedReplayOrFlush();\n    } catch (err) {\n      replay.handleException(err);\n    }\n  });\n}\n\n/**\n * Returns a listener to be added to `client.on(\'afterSendErrorEvent, listener)`.\n */\nfunction handleBeforeSendEvent(replay) {\n  return (event) => {\n    if (!replay.isEnabled() || !isErrorEvent(event)) {\n      return;\n    }\n\n    handleHydrationError(replay, event);\n  };\n}\n\nfunction handleHydrationError(replay, event) {\n  const exceptionValue = event.exception?.values?.[0]?.value;\n  if (typeof exceptionValue !== \'string\') {\n    return;\n  }\n\n  if (\n    // Only matches errors in production builds of react-dom\n    // Example https://reactjs.org/docs/error-decoder.html?invariant=423\n    // With newer React versions, the messages changed to a different website https://react.dev/errors/418\n    exceptionValue.match(\n      /(reactjs\\.org\\/docs\\/error-decoder\\.html\\?invariant=|react\\.dev\\/errors\\/)(418|419|422|423|425)/,\n    ) ||\n    // Development builds of react-dom\n    // Error 1: Hydration failed because the initial UI does not match what was rendered on the server.\n    // Error 2: Text content does not match server-rendered HTML. Warning: Text content did not match.\n    exceptionValue.match(/(does not match server-rendered HTML|Hydration failed because)/i)\n  ) {\n    const breadcrumb = createBreadcrumb({\n      category: \'replay.hydrate-error\',\n      data: {\n        url: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_4__.getLocationHref)(),\n      },\n    });\n    addBreadcrumbEvent(replay, breadcrumb);\n  }\n}\n\n/**\n * Handle breadcrumbs that Sentry captures, and make sure to capture relevant breadcrumbs to Replay as well.\n */\nfunction handleBreadcrumbs(replay) {\n  const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n\n  if (!client) {\n    return;\n  }\n\n  client.on(\'beforeAddBreadcrumb\', breadcrumb => beforeAddBreadcrumb(replay, breadcrumb));\n}\n\nfunction beforeAddBreadcrumb(replay, breadcrumb) {\n  if (!replay.isEnabled() || !isBreadcrumbWithCategory(breadcrumb)) {\n    return;\n  }\n\n  const result = normalizeBreadcrumb(breadcrumb);\n  if (result) {\n    addBreadcrumbEvent(replay, result);\n  }\n}\n\n/** Exported only for tests. */\nfunction normalizeBreadcrumb(breadcrumb) {\n  if (\n    !isBreadcrumbWithCategory(breadcrumb) ||\n    [\n      // fetch & xhr are handled separately,in handleNetworkBreadcrumbs\n      \'fetch\',\n      \'xhr\',\n      // These two are breadcrumbs for emitted sentry events, we don\'t care about them\n      \'sentry.event\',\n      \'sentry.transaction\',\n    ].includes(breadcrumb.category) ||\n    // We capture UI breadcrumbs separately\n    breadcrumb.category.startsWith(\'ui.\')\n  ) {\n    return null;\n  }\n\n  if (breadcrumb.category === \'console\') {\n    return normalizeConsoleBreadcrumb(breadcrumb);\n  }\n\n  return createBreadcrumb(breadcrumb);\n}\n\n/** exported for tests only */\nfunction normalizeConsoleBreadcrumb(\n  breadcrumb,\n) {\n  const args = breadcrumb.data?.arguments;\n\n  if (!Array.isArray(args) || args.length === 0) {\n    return createBreadcrumb(breadcrumb);\n  }\n\n  let isTruncated = false;\n\n  // Avoid giant args captures\n  const normalizedArgs = args.map(arg => {\n    if (!arg) {\n      return arg;\n    }\n    if (typeof arg === \'string\') {\n      if (arg.length > CONSOLE_ARG_MAX_SIZE) {\n        isTruncated = true;\n        return `${arg.slice(0, CONSOLE_ARG_MAX_SIZE)}…`;\n      }\n\n      return arg;\n    }\n    if (typeof arg === \'object\') {\n      try {\n        const normalizedArg = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_1__.normalize)(arg, 7);\n        const stringified = JSON.stringify(normalizedArg);\n        if (stringified.length > CONSOLE_ARG_MAX_SIZE) {\n          isTruncated = true;\n          // We use the pretty printed JSON string here as a base\n          return `${JSON.stringify(normalizedArg, null, 2).slice(0, CONSOLE_ARG_MAX_SIZE)}…`;\n        }\n        return normalizedArg;\n      } catch {\n        // fall back to default\n      }\n    }\n\n    return arg;\n  });\n\n  return createBreadcrumb({\n    ...breadcrumb,\n    data: {\n      ...breadcrumb.data,\n      arguments: normalizedArgs,\n      ...(isTruncated ? { _meta: { warnings: [\'CONSOLE_ARG_TRUNCATED\'] } } : {}),\n    },\n  });\n}\n\nfunction isBreadcrumbWithCategory(breadcrumb) {\n  return !!breadcrumb.category;\n}\n\n/**\n * Returns true if we think the given event is an error originating inside of rrweb.\n */\nfunction isRrwebError(event, hint) {\n  if (event.type || !event.exception || !event.exception.values || !event.exception.values.length) {\n    return false;\n  }\n\n  // @ts-expect-error this may be set by rrweb when it finds errors\n  if (hint.originalException?.__rrweb__) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Reset the `replay_id` field on the DSC.\n */\nfunction resetReplayIdOnDynamicSamplingContext() {\n  // Reset DSC on the current scope, if there is one\n  const dsc = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getCurrentScope)().getPropagationContext().dsc;\n  if (dsc) {\n    delete dsc.replay_id;\n  }\n\n  // Clear it from frozen DSC on the active span\n  const activeSpan = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_13__.getActiveSpan)();\n  if (activeSpan) {\n    const dsc = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_14__.getDynamicSamplingContextFromSpan)(activeSpan);\n    delete (dsc ).replay_id;\n  }\n}\n\n/**\n * Add a feedback breadcrumb event to replay.\n */\nfunction addFeedbackBreadcrumb(replay, event) {\n  replay.triggerUserActivity();\n  replay.addUpdate(() => {\n    if (!event.timestamp) {\n      // Ignore events that don\'t have timestamps (this shouldn\'t happen, more of a typing issue)\n      // Return true here so that we don\'t flush\n      return true;\n    }\n\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: event.timestamp * 1000,\n      data: {\n        tag: \'breadcrumb\',\n        payload: {\n          timestamp: event.timestamp,\n          type: \'default\',\n          category: \'sentry.feedback\',\n          data: {\n            feedbackId: event.event_id,\n          },\n        },\n      },\n    } );\n\n    return false;\n  });\n}\n\n/**\n * Determine if event should be sampled (only applies in buffer mode).\n * When an event is captured by `handleGlobalEvent`, when in buffer mode\n * we determine if we want to sample the error or not.\n */\nfunction shouldSampleForBufferEvent(replay, event) {\n  if (replay.recordingMode !== \'buffer\') {\n    return false;\n  }\n\n  // ignore this error because otherwise we could loop indefinitely with\n  // trying to capture replay and failing\n  if (event.message === UNABLE_TO_SEND_REPLAY) {\n    return false;\n  }\n\n  // Require the event to be an error event & to have an exception\n  if (!event.exception || event.type) {\n    return false;\n  }\n\n  return isSampled(replay.getOptions().errorSampleRate);\n}\n\n/**\n * Returns a listener to be added to `addEventProcessor(listener)`.\n */\nfunction handleGlobalEventListener(replay) {\n  return Object.assign(\n    (event, hint) => {\n      // Do nothing if replay has been disabled or paused\n      if (!replay.isEnabled() || replay.isPaused()) {\n        return event;\n      }\n\n      if (isReplayEvent(event)) {\n        // Replays have separate set of breadcrumbs, do not include breadcrumbs\n        // from core SDK\n        delete event.breadcrumbs;\n        return event;\n      }\n\n      // We only want to handle errors, transactions, and feedbacks, nothing else\n      if (!isErrorEvent(event) && !isTransactionEvent(event) && !isFeedbackEvent(event)) {\n        return event;\n      }\n\n      // Ensure we do not add replay_id if the session is expired\n      const isSessionActive = replay.checkAndHandleExpiredSession();\n      if (!isSessionActive) {\n        // prevent exceeding replay durations by removing the expired replayId from the DSC\n        resetReplayIdOnDynamicSamplingContext();\n        return event;\n      }\n\n      if (isFeedbackEvent(event)) {\n        // This should never reject\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        replay.flush();\n        event.contexts.feedback.replay_id = replay.getSessionId();\n        // Add a replay breadcrumb for this piece of feedback\n        addFeedbackBreadcrumb(replay, event);\n        return event;\n      }\n\n      // Unless `captureExceptions` is enabled, we want to ignore errors coming from rrweb\n      // As there can be a bunch of stuff going wrong in internals there, that we don\'t want to bubble up to users\n      if (isRrwebError(event, hint) && !replay.getOptions()._experiments.captureExceptions) {\n        DEBUG_BUILD && logger.log(\'Ignoring error from rrweb internals\', event);\n        return null;\n      }\n\n      // When in buffer mode, we decide to sample here.\n      // Later, in `handleAfterSendEvent`, if the replayId is set, we know that we sampled\n      // And convert the buffer session to a full session\n      const isErrorEventSampled = shouldSampleForBufferEvent(replay, event);\n\n      // Tag errors if it has been sampled in buffer mode, or if it is session mode\n      // Only tag transactions if in session mode\n      const shouldTagReplayId = isErrorEventSampled || replay.recordingMode === \'session\';\n\n      if (shouldTagReplayId) {\n        event.tags = { ...event.tags, replayId: replay.getSessionId() };\n      }\n\n      return event;\n    },\n    { id: \'Replay\' },\n  );\n}\n\n/**\n * Create a "span" for each performance entry.\n */\nfunction createPerformanceSpans(\n  replay,\n  entries,\n) {\n  return entries.map(({ type, start, end, name, data }) => {\n    const response = replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: start,\n      data: {\n        tag: \'performanceSpan\',\n        payload: {\n          op: type,\n          description: name,\n          startTimestamp: start,\n          endTimestamp: end,\n          data,\n        },\n      },\n    });\n\n    // If response is a string, it means its either THROTTLED or SKIPPED\n    return typeof response === \'string\' ? Promise.resolve(null) : response;\n  });\n}\n\nfunction handleHistory(handlerData) {\n  const { from, to } = handlerData;\n\n  const now = Date.now() / 1000;\n\n  return {\n    type: \'navigation.push\',\n    start: now,\n    end: now,\n    name: to,\n    data: {\n      previous: from,\n    },\n  };\n}\n\n/**\n * Returns a listener to be added to `addHistoryInstrumentationHandler(listener)`.\n */\nfunction handleHistorySpanListener(replay) {\n  return (handlerData) => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n\n    const result = handleHistory(handlerData);\n\n    if (result === null) {\n      return;\n    }\n\n    // Need to collect visited URLs\n    replay.getContext().urls.push(result.name);\n    replay.triggerUserActivity();\n\n    replay.addUpdate(() => {\n      createPerformanceSpans(replay, [result]);\n      // Returning false to flush\n      return false;\n    });\n  };\n}\n\n/**\n * Check whether a given request URL should be filtered out. This is so we\n * don\'t log Sentry ingest requests.\n */\nfunction shouldFilterRequest(replay, url) {\n  // If we enabled the `traceInternals` experiment, we want to trace everything\n  if (DEBUG_BUILD && replay.getOptions()._experiments.traceInternals) {\n    return false;\n  }\n\n  return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_15__.isSentryRequestUrl)(url, (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)());\n}\n\n/** Add a performance entry breadcrumb */\nfunction addNetworkBreadcrumb(\n  replay,\n  result,\n) {\n  if (!replay.isEnabled()) {\n    return;\n  }\n\n  if (result === null) {\n    return;\n  }\n\n  if (shouldFilterRequest(replay, result.name)) {\n    return;\n  }\n\n  replay.addUpdate(() => {\n    createPerformanceSpans(replay, [result]);\n    // Returning true will cause `addUpdate` to not flush\n    // We do not want network requests to cause a flush. This will prevent\n    // recurring/polling requests from keeping the replay session alive.\n    return true;\n  });\n}\n\n/** Get the size of a body. */\nfunction getBodySize(body) {\n  if (!body) {\n    return undefined;\n  }\n\n  const textEncoder = new TextEncoder();\n\n  try {\n    if (typeof body === \'string\') {\n      return textEncoder.encode(body).length;\n    }\n\n    if (body instanceof URLSearchParams) {\n      return textEncoder.encode(body.toString()).length;\n    }\n\n    if (body instanceof FormData) {\n      const formDataStr = (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_16__.serializeFormData)(body);\n      return textEncoder.encode(formDataStr).length;\n    }\n\n    if (body instanceof Blob) {\n      return body.size;\n    }\n\n    if (body instanceof ArrayBuffer) {\n      return body.byteLength;\n    }\n\n    // Currently unhandled types: ArrayBufferView, ReadableStream\n  } catch {\n    // just return undefined\n  }\n\n  return undefined;\n}\n\n/** Convert a Content-Length header to number/undefined.  */\nfunction parseContentLengthHeader(header) {\n  if (!header) {\n    return undefined;\n  }\n\n  const size = parseInt(header, 10);\n  return isNaN(size) ? undefined : size;\n}\n\n/** Merge a warning into an existing network request/response. */\nfunction mergeWarning(\n  info,\n  warning,\n) {\n  if (!info) {\n    return {\n      headers: {},\n      size: undefined,\n      _meta: {\n        warnings: [warning],\n      },\n    };\n  }\n\n  const newMeta = { ...info._meta };\n  const existingWarnings = newMeta.warnings || [];\n  newMeta.warnings = [...existingWarnings, warning];\n\n  info._meta = newMeta;\n  return info;\n}\n\n/** Convert ReplayNetworkRequestData to a PerformanceEntry. */\nfunction makeNetworkReplayBreadcrumb(\n  type,\n  data,\n) {\n  if (!data) {\n    return null;\n  }\n\n  const { startTimestamp, endTimestamp, url, method, statusCode, request, response } = data;\n\n  const result = {\n    type,\n    start: startTimestamp / 1000,\n    end: endTimestamp / 1000,\n    name: url,\n    data: {\n      method,\n      statusCode,\n      request,\n      response,\n    },\n  };\n\n  return result;\n}\n\n/** Build the request or response part of a replay network breadcrumb that was skipped. */\nfunction buildSkippedNetworkRequestOrResponse(bodySize) {\n  return {\n    headers: {},\n    size: bodySize,\n    _meta: {\n      warnings: [\'URL_SKIPPED\'],\n    },\n  };\n}\n\n/** Build the request or response part of a replay network breadcrumb. */\nfunction buildNetworkRequestOrResponse(\n  headers,\n  bodySize,\n  body,\n) {\n  if (!bodySize && Object.keys(headers).length === 0) {\n    return undefined;\n  }\n\n  if (!bodySize) {\n    return {\n      headers,\n    };\n  }\n\n  if (!body) {\n    return {\n      headers,\n      size: bodySize,\n    };\n  }\n\n  const info = {\n    headers,\n    size: bodySize,\n  };\n\n  const { body: normalizedBody, warnings } = normalizeNetworkBody(body);\n  info.body = normalizedBody;\n  if (warnings?.length) {\n    info._meta = {\n      warnings,\n    };\n  }\n\n  return info;\n}\n\n/** Filter a set of headers */\nfunction getAllowedHeaders(headers, allowedHeaders) {\n  return Object.entries(headers).reduce((filteredHeaders, [key, value]) => {\n    const normalizedKey = key.toLowerCase();\n    // Avoid putting empty strings into the headers\n    if (allowedHeaders.includes(normalizedKey) && headers[key]) {\n      filteredHeaders[normalizedKey] = value;\n    }\n    return filteredHeaders;\n  }, {});\n}\n\nfunction normalizeNetworkBody(body)\n\n {\n  if (!body || typeof body !== \'string\') {\n    return {\n      body,\n    };\n  }\n\n  const exceedsSizeLimit = body.length > NETWORK_BODY_MAX_SIZE;\n  const isProbablyJson = _strIsProbablyJson(body);\n\n  if (exceedsSizeLimit) {\n    const truncatedBody = body.slice(0, NETWORK_BODY_MAX_SIZE);\n\n    if (isProbablyJson) {\n      return {\n        body: truncatedBody,\n        warnings: [\'MAYBE_JSON_TRUNCATED\'],\n      };\n    }\n\n    return {\n      body: `${truncatedBody}…`,\n      warnings: [\'TEXT_TRUNCATED\'],\n    };\n  }\n\n  if (isProbablyJson) {\n    try {\n      const jsonBody = JSON.parse(body);\n      return {\n        body: jsonBody,\n      };\n    } catch {\n      // fall back to just send the body as string\n    }\n  }\n\n  return {\n    body,\n  };\n}\n\nfunction _strIsProbablyJson(str) {\n  const first = str[0];\n  const last = str[str.length - 1];\n\n  // Simple check: If this does not start & end with {} or [], it\'s not JSON\n  return (first === \'[\' && last === \']\') || (first === \'{\' && last === \'}\');\n}\n\n/** Match an URL against a list of strings/Regex. */\nfunction urlMatches(url, urls) {\n  const fullUrl = getFullUrl(url);\n\n  return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_17__.stringMatchesSomePattern)(fullUrl, urls);\n}\n\n/** exported for tests */\nfunction getFullUrl(url, baseURI = WINDOW.document.baseURI) {\n  // Short circuit for common cases:\n  if (url.startsWith(\'http://\') || url.startsWith(\'https://\') || url.startsWith(WINDOW.location.origin)) {\n    return url;\n  }\n  const fixedUrl = new URL(url, baseURI);\n\n  // If these do not match, we are not dealing with a relative URL, so just return it\n  if (fixedUrl.origin !== new URL(baseURI).origin) {\n    return url;\n  }\n\n  const fullUrl = fixedUrl.href;\n\n  // Remove trailing slashes, if they don\'t match the original URL\n  if (!url.endsWith(\'/\') && fullUrl.endsWith(\'/\')) {\n    return fullUrl.slice(0, -1);\n  }\n\n  return fullUrl;\n}\n\n/**\n * Capture a fetch breadcrumb to a replay.\n * This adds additional data (where appropriate).\n */\nasync function captureFetchBreadcrumbToReplay(\n  breadcrumb,\n  hint,\n  options\n\n,\n) {\n  try {\n    const data = await _prepareFetchData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb(\'resource.fetch\', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, \'Failed to capture fetch breadcrumb\');\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nfunction enrichFetchBreadcrumb(\n  breadcrumb,\n  hint,\n) {\n  const { input, response } = hint;\n\n  const body = input ? (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_16__.getFetchRequestArgBody)(input) : undefined;\n  const reqSize = getBodySize(body);\n\n  const resSize = response ? parseContentLengthHeader(response.headers.get(\'content-length\')) : undefined;\n\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\n\nasync function _prepareFetchData(\n  breadcrumb,\n  hint,\n  options,\n) {\n  const now = Date.now();\n  const { startTimestamp = now, endTimestamp = now } = hint;\n\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize,\n  } = breadcrumb.data;\n\n  const captureDetails =\n    urlMatches(url, options.networkDetailAllowUrls) && !urlMatches(url, options.networkDetailDenyUrls);\n\n  const request = captureDetails\n    ? _getRequestInfo(options, hint.input, requestBodySize)\n    : buildSkippedNetworkRequestOrResponse(requestBodySize);\n  const response = await _getResponseInfo(captureDetails, options, hint.response, responseBodySize);\n\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request,\n    response,\n  };\n}\n\nfunction _getRequestInfo(\n  { networkCaptureBodies, networkRequestHeaders },\n  input,\n  requestBodySize,\n) {\n  const headers = input ? getRequestHeaders(input, networkRequestHeaders) : {};\n\n  if (!networkCaptureBodies) {\n    return buildNetworkRequestOrResponse(headers, requestBodySize, undefined);\n  }\n\n  // We only want to transmit string or string-like bodies\n  const requestBody = (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_16__.getFetchRequestArgBody)(input);\n  const [bodyStr, warning] = (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_16__.getBodyString)(requestBody, logger);\n  const data = buildNetworkRequestOrResponse(headers, requestBodySize, bodyStr);\n\n  if (warning) {\n    return mergeWarning(data, warning);\n  }\n\n  return data;\n}\n\n/** Exported only for tests. */\nasync function _getResponseInfo(\n  captureDetails,\n  {\n    networkCaptureBodies,\n    networkResponseHeaders,\n  },\n  response,\n  responseBodySize,\n) {\n  if (!captureDetails && responseBodySize !== undefined) {\n    return buildSkippedNetworkRequestOrResponse(responseBodySize);\n  }\n\n  const headers = response ? getAllHeaders(response.headers, networkResponseHeaders) : {};\n\n  if (!response || (!networkCaptureBodies && responseBodySize !== undefined)) {\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n\n  const [bodyText, warning] = await _parseFetchResponseBody(response);\n  const result = getResponseData(bodyText, {\n    networkCaptureBodies,\n\n    responseBodySize,\n    captureDetails,\n    headers,\n  });\n\n  if (warning) {\n    return mergeWarning(result, warning);\n  }\n\n  return result;\n}\n\nfunction getResponseData(\n  bodyText,\n  {\n    networkCaptureBodies,\n    responseBodySize,\n    captureDetails,\n    headers,\n  }\n\n,\n) {\n  try {\n    const size = bodyText?.length && responseBodySize === undefined ? getBodySize(bodyText) : responseBodySize;\n\n    if (!captureDetails) {\n      return buildSkippedNetworkRequestOrResponse(size);\n    }\n\n    if (networkCaptureBodies) {\n      return buildNetworkRequestOrResponse(headers, size, bodyText);\n    }\n\n    return buildNetworkRequestOrResponse(headers, size, undefined);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, \'Failed to serialize response body\');\n    // fallback\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n}\n\nasync function _parseFetchResponseBody(response) {\n  const res = _tryCloneResponse(response);\n\n  if (!res) {\n    return [undefined, \'BODY_PARSE_ERROR\'];\n  }\n\n  try {\n    const text = await _tryGetResponseText(res);\n    return [text];\n  } catch (error) {\n    if (error instanceof Error && error.message.indexOf(\'Timeout\') > -1) {\n      DEBUG_BUILD && logger.warn(\'Parsing text body from response timed out\');\n      return [undefined, \'BODY_PARSE_TIMEOUT\'];\n    }\n\n    DEBUG_BUILD && logger.exception(error, \'Failed to get text body from response\');\n    return [undefined, \'BODY_PARSE_ERROR\'];\n  }\n}\n\nfunction getAllHeaders(headers, allowedHeaders) {\n  const allHeaders = {};\n\n  allowedHeaders.forEach(header => {\n    if (headers.get(header)) {\n      allHeaders[header] = headers.get(header) ;\n    }\n  });\n\n  return allHeaders;\n}\n\nfunction getRequestHeaders(fetchArgs, allowedHeaders) {\n  if (fetchArgs.length === 1 && typeof fetchArgs[0] !== \'string\') {\n    return getHeadersFromOptions(fetchArgs[0] , allowedHeaders);\n  }\n\n  if (fetchArgs.length === 2) {\n    return getHeadersFromOptions(fetchArgs[1] , allowedHeaders);\n  }\n\n  return {};\n}\n\nfunction getHeadersFromOptions(\n  input,\n  allowedHeaders,\n) {\n  if (!input) {\n    return {};\n  }\n\n  const headers = input.headers;\n\n  if (!headers) {\n    return {};\n  }\n\n  if (headers instanceof Headers) {\n    return getAllHeaders(headers, allowedHeaders);\n  }\n\n  // We do not support this, as it is not really documented (anymore?)\n  if (Array.isArray(headers)) {\n    return {};\n  }\n\n  return getAllowedHeaders(headers, allowedHeaders);\n}\n\nfunction _tryCloneResponse(response) {\n  try {\n    // We have to clone this, as the body can only be read once\n    return response.clone();\n  } catch (error) {\n    // this can throw if the response was already consumed before\n    DEBUG_BUILD && logger.exception(error, \'Failed to clone response body\');\n  }\n}\n\n/**\n * Get the response body of a fetch request, or timeout after 500ms.\n * Fetch can return a streaming body, that may not resolve (or not for a long time).\n * If that happens, we rather abort after a short time than keep waiting for this.\n */\nfunction _tryGetResponseText(response) {\n  return new Promise((resolve, reject) => {\n    const timeout = (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__.setTimeout)(() => reject(new Error(\'Timeout while trying to read response body\')), 500);\n\n    _getResponseText(response)\n      .then(\n        txt => resolve(txt),\n        reason => reject(reason),\n      )\n      .finally(() => clearTimeout(timeout));\n  });\n}\n\nasync function _getResponseText(response) {\n  // Force this to be a promise, just to be safe\n  // eslint-disable-next-line no-return-await\n  return await response.text();\n}\n\n/**\n * Capture an XHR breadcrumb to a replay.\n * This adds additional data (where appropriate).\n */\nasync function captureXhrBreadcrumbToReplay(\n  breadcrumb,\n  hint,\n  options,\n) {\n  try {\n    const data = _prepareXhrData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb(\'resource.xhr\', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, \'Failed to capture xhr breadcrumb\');\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nfunction enrichXhrBreadcrumb(\n  breadcrumb,\n  hint,\n) {\n  const { xhr, input } = hint;\n\n  if (!xhr) {\n    return;\n  }\n\n  const reqSize = getBodySize(input);\n  const resSize = xhr.getResponseHeader(\'content-length\')\n    ? parseContentLengthHeader(xhr.getResponseHeader(\'content-length\'))\n    : _getBodySize(xhr.response, xhr.responseType);\n\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\n\nfunction _prepareXhrData(\n  breadcrumb,\n  hint,\n  options,\n) {\n  const now = Date.now();\n  const { startTimestamp = now, endTimestamp = now, input, xhr } = hint;\n\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize,\n  } = breadcrumb.data;\n\n  if (!url) {\n    return null;\n  }\n\n  if (!xhr || !urlMatches(url, options.networkDetailAllowUrls) || urlMatches(url, options.networkDetailDenyUrls)) {\n    const request = buildSkippedNetworkRequestOrResponse(requestBodySize);\n    const response = buildSkippedNetworkRequestOrResponse(responseBodySize);\n    return {\n      startTimestamp,\n      endTimestamp,\n      url,\n      method,\n      statusCode,\n      request,\n      response,\n    };\n  }\n\n  // ---- This additional network data below is only captured for URLs defined in `networkDetailAllowUrls` ----\n\n  const xhrInfo = xhr[_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_18__.SENTRY_XHR_DATA_KEY];\n  const networkRequestHeaders = xhrInfo\n    ? getAllowedHeaders(xhrInfo.request_headers, options.networkRequestHeaders)\n    : {};\n  const networkResponseHeaders = getAllowedHeaders(getResponseHeaders(xhr), options.networkResponseHeaders);\n\n  const [requestBody, requestWarning] = options.networkCaptureBodies ? (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_16__.getBodyString)(input, logger) : [undefined];\n  const [responseBody, responseWarning] = options.networkCaptureBodies ? _getXhrResponseBody(xhr) : [undefined];\n\n  const request = buildNetworkRequestOrResponse(networkRequestHeaders, requestBodySize, requestBody);\n  const response = buildNetworkRequestOrResponse(networkResponseHeaders, responseBodySize, responseBody);\n\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request: requestWarning ? mergeWarning(request, requestWarning) : request,\n    response: responseWarning ? mergeWarning(response, responseWarning) : response,\n  };\n}\n\nfunction getResponseHeaders(xhr) {\n  const headers = xhr.getAllResponseHeaders();\n\n  if (!headers) {\n    return {};\n  }\n\n  return headers.split(\'\\r\\n\').reduce((acc, line) => {\n    const [key, value] = line.split(\': \') ;\n    if (value) {\n      acc[key.toLowerCase()] = value;\n    }\n    return acc;\n  }, {});\n}\n\nfunction _getXhrResponseBody(xhr) {\n  // We collect errors that happen, but only log them if we can\'t get any response body\n  const errors = [];\n\n  try {\n    return [xhr.responseText];\n  } catch (e) {\n    errors.push(e);\n  }\n\n  // Try to manually parse the response body, if responseText fails\n  try {\n    return _parseXhrResponse(xhr.response, xhr.responseType);\n  } catch (e) {\n    errors.push(e);\n  }\n\n  DEBUG_BUILD && logger.warn(\'Failed to get xhr response body\', ...errors);\n\n  return [undefined];\n}\n\n/**\n * Get the string representation of the XHR response.\n * Based on MDN, these are the possible types of the response:\n * string\n * ArrayBuffer\n * Blob\n * Document\n * POJO\n *\n * Exported only for tests.\n */\nfunction _parseXhrResponse(\n  body,\n  responseType,\n) {\n  try {\n    if (typeof body === \'string\') {\n      return [body];\n    }\n\n    if (body instanceof Document) {\n      return [body.body.outerHTML];\n    }\n\n    if (responseType === \'json\' && body && typeof body === \'object\') {\n      return [JSON.stringify(body)];\n    }\n\n    if (!body) {\n      return [undefined];\n    }\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, \'Failed to serialize body\', body);\n    return [undefined, \'BODY_PARSE_ERROR\'];\n  }\n\n  DEBUG_BUILD && logger.info(\'Skipping network body because of body type\', body);\n\n  return [undefined, \'UNPARSEABLE_BODY_TYPE\'];\n}\n\nfunction _getBodySize(\n  body,\n  responseType,\n) {\n  try {\n    const bodyStr = responseType === \'json\' && body && typeof body === \'object\' ? JSON.stringify(body) : body;\n    return getBodySize(bodyStr);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * This method does two things:\n * - It enriches the regular XHR/fetch breadcrumbs with request/response size data\n * - It captures the XHR/fetch breadcrumbs to the replay\n *   (enriching it with further data that is _not_ added to the regular breadcrumbs)\n */\nfunction handleNetworkBreadcrumbs(replay) {\n  const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n\n  try {\n    const {\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders,\n    } = replay.getOptions();\n\n    const options = {\n      replay,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders,\n    };\n\n    if (client) {\n      client.on(\'beforeAddBreadcrumb\', (breadcrumb, hint) => beforeAddNetworkBreadcrumb(options, breadcrumb, hint));\n    }\n  } catch {\n    // Do nothing\n  }\n}\n\n/** just exported for tests */\nfunction beforeAddNetworkBreadcrumb(\n  options,\n  breadcrumb,\n  hint,\n) {\n  if (!breadcrumb.data) {\n    return;\n  }\n\n  try {\n    if (_isXhrBreadcrumb(breadcrumb) && _isXhrHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichXhrBreadcrumb(breadcrumb, hint);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureXhrBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n\n    if (_isFetchBreadcrumb(breadcrumb) && _isFetchHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichFetchBreadcrumb(breadcrumb, hint);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureFetchBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n  } catch (e) {\n    DEBUG_BUILD && logger.exception(e, \'Error when enriching network breadcrumb\');\n  }\n}\n\nfunction _isXhrBreadcrumb(breadcrumb) {\n  return breadcrumb.category === \'xhr\';\n}\n\nfunction _isFetchBreadcrumb(breadcrumb) {\n  return breadcrumb.category === \'fetch\';\n}\n\nfunction _isXhrHint(hint) {\n  return hint?.xhr;\n}\n\nfunction _isFetchHint(hint) {\n  return hint?.response;\n}\n\n/**\n * Add global listeners that cannot be removed.\n */\nfunction addGlobalListeners(\n  replay,\n  { autoFlushOnFeedback },\n) {\n  // Listeners from core SDK //\n  const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n\n  (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_19__.addClickKeypressInstrumentationHandler)(handleDomListener(replay));\n  (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_20__.addHistoryInstrumentationHandler)(handleHistorySpanListener(replay));\n  handleBreadcrumbs(replay);\n  handleNetworkBreadcrumbs(replay);\n\n  // Tag all (non replay) events that get sent to Sentry with the current\n  // replay ID so that we can reference them later in the UI\n  const eventProcessor = handleGlobalEventListener(replay);\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_10__.addEventProcessor)(eventProcessor);\n\n  // If a custom client has no hooks yet, we continue to use the "old" implementation\n  if (client) {\n    client.on(\'beforeSendEvent\', handleBeforeSendEvent(replay));\n    client.on(\'afterSendEvent\', handleAfterSendEvent(replay));\n    client.on(\'createDsc\', (dsc) => {\n      const replayId = replay.getSessionId();\n      // We do not want to set the DSC when in buffer mode, as that means the replay has not been sent (yet)\n      if (replayId && replay.isEnabled() && replay.recordingMode === \'session\') {\n        // Ensure to check that the session is still active - it could have expired in the meanwhile\n        const isSessionActive = replay.checkAndHandleExpiredSession();\n        if (isSessionActive) {\n          dsc.replay_id = replayId;\n        }\n      }\n    });\n\n    client.on(\'spanStart\', span => {\n      replay.lastActiveSpan = span;\n    });\n\n    // We may be missing the initial spanStart due to timing issues,\n    // so we capture it on finish again.\n    client.on(\'spanEnd\', span => {\n      replay.lastActiveSpan = span;\n    });\n\n    // We want to attach the replay id to the feedback event\n    client.on(\'beforeSendFeedback\', async (feedbackEvent, options) => {\n      const replayId = replay.getSessionId();\n      if (options?.includeReplay && replay.isEnabled() && replayId && feedbackEvent.contexts?.feedback) {\n        // In case the feedback is sent via API and not through our widget, we want to flush replay\n        if (feedbackEvent.contexts.feedback.source === \'api\' && autoFlushOnFeedback) {\n          await replay.flush();\n        }\n        feedbackEvent.contexts.feedback.replay_id = replayId;\n      }\n    });\n\n    if (autoFlushOnFeedback) {\n      client.on(\'openFeedbackWidget\', async () => {\n        await replay.flush();\n      });\n    }\n  }\n}\n\n/**\n * Create a "span" for the total amount of memory being used by JS objects\n * (including v8 internal objects).\n */\nasync function addMemoryEntry(replay) {\n  // window.performance.memory is a non-standard API and doesn\'t work on all browsers, so we try-catch this\n  try {\n    return Promise.all(\n      createPerformanceSpans(replay, [\n        // @ts-expect-error memory doesn\'t exist on type Performance as the API is non-standard (we check that it exists above)\n        createMemoryEntry(WINDOW.performance.memory),\n      ]),\n    );\n  } catch (error) {\n    // Do nothing\n    return [];\n  }\n}\n\nfunction createMemoryEntry(memoryEntry) {\n  const { jsHeapSizeLimit, totalJSHeapSize, usedJSHeapSize } = memoryEntry;\n  // we don\'t want to use `getAbsoluteTime` because it adds the event time to the\n  // time origin, so we get the current timestamp instead\n  const time = Date.now() / 1000;\n  return {\n    type: \'memory\',\n    name: \'memory\',\n    start: time,\n    end: time,\n    data: {\n      memory: {\n        jsHeapSizeLimit,\n        totalJSHeapSize,\n        usedJSHeapSize,\n      },\n    },\n  };\n}\n\n/**\n * Heavily simplified debounce function based on lodash.debounce.\n *\n * This function takes a callback function (@param fun) and delays its invocation\n * by @param wait milliseconds. Optionally, a maxWait can be specified in @param options,\n * which ensures that the callback is invoked at least once after the specified max. wait time.\n *\n * @param func the function whose invocation is to be debounced\n * @param wait the minimum time until the function is invoked after it was called once\n * @param options the options object, which can contain the `maxWait` property\n *\n * @returns the debounced version of the function, which needs to be called at least once to start the\n *          debouncing process. Subsequent calls will reset the debouncing timer and, in case @paramfunc\n *          was already invoked in the meantime, return @param func\'s return value.\n *          The debounced function has two additional properties:\n *          - `flush`: Invokes the debounced function immediately and returns its return value\n *          - `cancel`: Cancels the debouncing process and resets the debouncing timer\n */\nfunction debounce(func, wait, options) {\n  let callbackReturnValue;\n\n  let timerId;\n  let maxTimerId;\n\n  const maxWait = options?.maxWait ? Math.max(options.maxWait, wait) : 0;\n\n  function invokeFunc() {\n    cancelTimers();\n    callbackReturnValue = func();\n    return callbackReturnValue;\n  }\n\n  function cancelTimers() {\n    timerId !== undefined && clearTimeout(timerId);\n    maxTimerId !== undefined && clearTimeout(maxTimerId);\n    timerId = maxTimerId = undefined;\n  }\n\n  function flush() {\n    if (timerId !== undefined || maxTimerId !== undefined) {\n      return invokeFunc();\n    }\n    return callbackReturnValue;\n  }\n\n  function debounced() {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__.setTimeout)(invokeFunc, wait);\n\n    if (maxWait && maxTimerId === undefined) {\n      maxTimerId = (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__.setTimeout)(invokeFunc, maxWait);\n    }\n\n    return callbackReturnValue;\n  }\n\n  debounced.cancel = cancelTimers;\n  debounced.flush = flush;\n  return debounced;\n}\n\nconst NAVIGATOR = _sentry_core__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ.navigator;\n\n/**\n *  Disable sampling mousemove events on iOS browsers as this can cause blocking the main thread\n *  https://github.com/getsentry/sentry-javascript/issues/14534\n */\nfunction getRecordingSamplingOptions() {\n  if (\n    /iPhone|iPad|iPod/i.test(NAVIGATOR?.userAgent ?? \'\') ||\n    (/Macintosh/i.test(NAVIGATOR?.userAgent ?? \'\') && NAVIGATOR?.maxTouchPoints && NAVIGATOR?.maxTouchPoints > 1)\n  ) {\n    return {\n      sampling: {\n        mousemove: false,\n      },\n    };\n  }\n\n  return {};\n}\n\n/**\n * Handler for recording events.\n *\n * Adds to event buffer, and has varying flushing behaviors if the event was a checkout.\n */\nfunction getHandleRecordingEmit(replay) {\n  let hadFirstEvent = false;\n\n  return (event, _isCheckout) => {\n    // If this is false, it means session is expired, create and a new session and wait for checkout\n    if (!replay.checkAndHandleExpiredSession()) {\n      DEBUG_BUILD && logger.warn(\'Received replay event after session expired.\');\n\n      return;\n    }\n\n    // `_isCheckout` is only set when the checkout is due to `checkoutEveryNms`\n    // We also want to treat the first event as a checkout, so we handle this specifically here\n    const isCheckout = _isCheckout || !hadFirstEvent;\n    hadFirstEvent = true;\n\n    if (replay.clickDetector) {\n      updateClickDetectorForRecordingEvent(replay.clickDetector, event);\n    }\n\n    // The handler returns `true` if we do not want to trigger debounced flush, `false` if we want to debounce flush.\n    replay.addUpdate(() => {\n      // The session is always started immediately on pageload/init, but for\n      // error-only replays, it should reflect the most recent checkout\n      // when an error occurs. Clear any state that happens before this current\n      // checkout. This needs to happen before `addEvent()` which updates state\n      // dependent on this reset.\n      if (replay.recordingMode === \'buffer\' && isCheckout) {\n        replay.setInitialState();\n      }\n\n      // If the event is not added (e.g. due to being paused, disabled, or out of the max replay duration),\n      // Skip all further steps\n      if (!addEventSync(replay, event, isCheckout)) {\n        // Return true to skip scheduling a debounced flush\n        return true;\n      }\n\n      // Different behavior for full snapshots (type=2), ignore other event types\n      // See https://github.com/rrweb-io/rrweb/blob/d8f9290ca496712aa1e7d472549480c4e7876594/packages/rrweb/src/types.ts#L16\n      if (!isCheckout) {\n        return false;\n      }\n\n      const session = replay.session;\n\n      // Additionally, create a meta event that will capture certain SDK settings.\n      // In order to handle buffer mode, this needs to either be done when we\n      // receive checkout events or at flush time. We have an experimental mode\n      // to perform multiple checkouts a session (the idea is to improve\n      // seeking during playback), so also only include if segmentId is 0\n      // (handled in `addSettingsEvent`).\n      //\n      // `isCheckout` is always true, but want to be explicit that it should\n      // only be added for checkouts\n      addSettingsEvent(replay, isCheckout);\n\n      // When in buffer mode, make sure we adjust the session started date to the current earliest event of the buffer\n      // this should usually be the timestamp of the checkout event, but to be safe...\n      if (replay.recordingMode === \'buffer\' && session && replay.eventBuffer) {\n        const earliestEvent = replay.eventBuffer.getEarliestTimestamp();\n        if (earliestEvent) {\n          DEBUG_BUILD &&\n            logger.info(`Updating session start time to earliest event in buffer to ${new Date(earliestEvent)}`);\n\n          session.started = earliestEvent;\n\n          if (replay.getOptions().stickySession) {\n            saveSession(session);\n          }\n        }\n      }\n\n      // If there is a previousSessionId after a full snapshot occurs, then\n      // the replay session was started due to session expiration. The new session\n      // is started before triggering a new checkout and contains the id\n      // of the previous session. Do not immediately flush in this case\n      // to avoid capturing only the checkout and instead the replay will\n      // be captured if they perform any follow-up actions.\n      if (session?.previousSessionId) {\n        return true;\n      }\n\n      if (replay.recordingMode === \'session\') {\n        // If the full snapshot is due to an initial load, we will not have\n        // a previous session ID. In this case, we want to buffer events\n        // for a set amount of time before flushing. This can help avoid\n        // capturing replays of users that immediately close the window.\n\n        // This should never reject\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        void replay.flush();\n      }\n\n      return true;\n    });\n  };\n}\n\n/**\n * Exported for tests\n */\nfunction createOptionsEvent(replay) {\n  const options = replay.getOptions();\n  return {\n    type: EventType.Custom,\n    timestamp: Date.now(),\n    data: {\n      tag: \'options\',\n      payload: {\n        shouldRecordCanvas: replay.isRecordingCanvas(),\n        sessionSampleRate: options.sessionSampleRate,\n        errorSampleRate: options.errorSampleRate,\n        useCompressionOption: options.useCompression,\n        blockAllMedia: options.blockAllMedia,\n        maskAllText: options.maskAllText,\n        maskAllInputs: options.maskAllInputs,\n        useCompression: replay.eventBuffer ? replay.eventBuffer.type === \'worker\' : false,\n        networkDetailHasUrls: options.networkDetailAllowUrls.length > 0,\n        networkCaptureBodies: options.networkCaptureBodies,\n        networkRequestHasHeaders: options.networkRequestHeaders.length > 0,\n        networkResponseHasHeaders: options.networkResponseHeaders.length > 0,\n      },\n    },\n  };\n}\n\n/**\n * Add a "meta" event that contains a simplified view on current configuration\n * options. This should only be included on the first segment of a recording.\n */\nfunction addSettingsEvent(replay, isCheckout) {\n  // Only need to add this event when sending the first segment\n  if (!isCheckout || !replay.session || replay.session.segmentId !== 0) {\n    return;\n  }\n\n  addEventSync(replay, createOptionsEvent(replay), false);\n}\n\n/**\n * Create a replay envelope ready to be sent.\n * This includes both the replay event, as well as the recording data.\n */\nfunction createReplayEnvelope(\n  replayEvent,\n  recordingData,\n  dsn,\n  tunnel,\n) {\n  return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_21__.createEnvelope)(\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_21__.createEventEnvelopeHeaders)(replayEvent, (0,_sentry_core__WEBPACK_IMPORTED_MODULE_21__.getSdkMetadataForEnvelopeHeader)(replayEvent), tunnel, dsn),\n    [\n      [{ type: \'replay_event\' }, replayEvent],\n      [\n        {\n          type: \'replay_recording\',\n          // If string then we need to encode to UTF8, otherwise will have\n          // wrong size. TextEncoder has similar browser support to\n          // MutationObserver, although it does not accept IE11.\n          length:\n            typeof recordingData === \'string\' ? new TextEncoder().encode(recordingData).length : recordingData.length,\n        },\n        recordingData,\n      ],\n    ],\n  );\n}\n\n/**\n * Prepare the recording data ready to be sent.\n */\nfunction prepareRecordingData({\n  recordingData,\n  headers,\n}\n\n) {\n  let payloadWithSequence;\n\n  // XXX: newline is needed to separate sequence id from events\n  const replayHeaders = `${JSON.stringify(headers)}\n`;\n\n  if (typeof recordingData === \'string\') {\n    payloadWithSequence = `${replayHeaders}${recordingData}`;\n  } else {\n    const enc = new TextEncoder();\n    // XXX: newline is needed to separate sequence id from events\n    const sequence = enc.encode(replayHeaders);\n    // Merge the two Uint8Arrays\n    payloadWithSequence = new Uint8Array(sequence.length + recordingData.length);\n    payloadWithSequence.set(sequence);\n    payloadWithSequence.set(recordingData, sequence.length);\n  }\n\n  return payloadWithSequence;\n}\n\n/**\n * Prepare a replay event & enrich it with the SDK metadata.\n */\nasync function prepareReplayEvent({\n  client,\n  scope,\n  replayId: event_id,\n  event,\n}\n\n) {\n  const integrations =\n    typeof client[\'_integrations\'] === \'object\' &&\n    client[\'_integrations\'] !== null &&\n    !Array.isArray(client[\'_integrations\'])\n      ? Object.keys(client[\'_integrations\'])\n      : undefined;\n\n  const eventHint = { event_id, integrations };\n\n  client.emit(\'preprocessEvent\', event, eventHint);\n\n  const preparedEvent = (await (0,_sentry_core__WEBPACK_IMPORTED_MODULE_22__.prepareEvent)(\n    client.getOptions(),\n    event,\n    eventHint,\n    scope,\n    client,\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getIsolationScope)(),\n  )) ;\n\n  // If e.g. a global event processor returned null\n  if (!preparedEvent) {\n    return null;\n  }\n\n  client.emit(\'postprocessEvent\', preparedEvent, eventHint);\n\n  // This normally happens in browser client "_prepareEvent"\n  // but since we do not use this private method from the client, but rather the plain import\n  // we need to do this manually.\n  preparedEvent.platform = preparedEvent.platform || \'javascript\';\n\n  // extract the SDK name because `client._prepareEvent` doesn\'t add it to the event\n  const metadata = client.getSdkMetadata();\n  const { name, version } = metadata?.sdk || {};\n\n  preparedEvent.sdk = {\n    ...preparedEvent.sdk,\n    name: name || \'sentry.javascript.unknown\',\n    version: version || \'0.0.0\',\n  };\n\n  return preparedEvent;\n}\n\n/**\n * Send replay attachment using `fetch()`\n */\nasync function sendReplayRequest({\n  recordingData,\n  replayId,\n  segmentId: segment_id,\n  eventContext,\n  timestamp,\n  session,\n}) {\n  const preparedRecordingData = prepareRecordingData({\n    recordingData,\n    headers: {\n      segment_id,\n    },\n  });\n\n  const { urls, errorIds, traceIds, initialTimestamp } = eventContext;\n\n  const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n  const scope = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getCurrentScope)();\n  const transport = client?.getTransport();\n  const dsn = client?.getDsn();\n\n  if (!client || !transport || !dsn || !session.sampled) {\n    return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_23__.resolvedSyncPromise)({});\n  }\n\n  const baseEvent = {\n    type: REPLAY_EVENT_NAME,\n    replay_start_timestamp: initialTimestamp / 1000,\n    timestamp: timestamp / 1000,\n    error_ids: errorIds,\n    trace_ids: traceIds,\n    urls,\n    replay_id: replayId,\n    segment_id,\n    replay_type: session.sampled,\n  };\n\n  const replayEvent = await prepareReplayEvent({ scope, client, replayId, event: baseEvent });\n\n  if (!replayEvent) {\n    // Taken from baseclient\'s `_processEvent` method, where this is handled for errors/transactions\n    client.recordDroppedEvent(\'event_processor\', \'replay\');\n    DEBUG_BUILD && logger.info(\'An event processor returned `null`, will not send event.\');\n    return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_23__.resolvedSyncPromise)({});\n  }\n\n  /*\n  For reference, the fully built event looks something like this:\n  {\n      "type": "replay_event",\n      "timestamp": 1670837008.634,\n      "error_ids": [\n          "errorId"\n      ],\n      "trace_ids": [\n          "traceId"\n      ],\n      "urls": [\n          "https://example.com"\n      ],\n      "replay_id": "eventId",\n      "segment_id": 3,\n      "replay_type": "error",\n      "platform": "javascript",\n      "event_id": "eventId",\n      "environment": "production",\n      "sdk": {\n          "integrations": [\n              "BrowserTracing",\n              "Replay"\n          ],\n          "name": "sentry.javascript.browser",\n          "version": "7.25.0"\n      },\n      "sdkProcessingMetadata": {},\n      "contexts": {\n      },\n  }\n  */\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don\'t happen to be using it at some point in the future, let\'s not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete replayEvent.sdkProcessingMetadata;\n\n  const envelope = createReplayEnvelope(replayEvent, preparedRecordingData, dsn, client.getOptions().tunnel);\n\n  let response;\n\n  try {\n    response = await transport.send(envelope);\n  } catch (err) {\n    const error = new Error(UNABLE_TO_SEND_REPLAY);\n\n    try {\n      // In case browsers don\'t allow this property to be writable\n      // @ts-expect-error This needs lib es2022 and newer\n      error.cause = err;\n    } catch {\n      // nothing to do\n    }\n    throw error;\n  }\n\n  // If the status code is invalid, we want to immediately stop & not retry\n  if (typeof response.statusCode === \'number\' && (response.statusCode < 200 || response.statusCode >= 300)) {\n    throw new TransportStatusCodeError(response.statusCode);\n  }\n\n  const rateLimits = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_24__.updateRateLimits)({}, response);\n  if ((0,_sentry_core__WEBPACK_IMPORTED_MODULE_24__.isRateLimited)(rateLimits, \'replay\')) {\n    throw new RateLimitError(rateLimits);\n  }\n\n  return response;\n}\n\n/**\n * This error indicates that the transport returned an invalid status code.\n */\nclass TransportStatusCodeError extends Error {\n   constructor(statusCode) {\n    super(`Transport returned status code ${statusCode}`);\n  }\n}\n\n/**\n * This error indicates that we hit a rate limit API error.\n */\nclass RateLimitError extends Error {\n\n   constructor(rateLimits) {\n    super(\'Rate limit hit\');\n    this.rateLimits = rateLimits;\n  }\n}\n\n/**\n * Finalize and send the current replay event to Sentry\n */\nasync function sendReplay(\n  replayData,\n  retryConfig = {\n    count: 0,\n    interval: RETRY_BASE_INTERVAL,\n  },\n) {\n  const { recordingData, onError } = replayData;\n\n  // short circuit if there\'s no events to upload (this shouldn\'t happen as _runFlush makes this check)\n  if (!recordingData.length) {\n    return;\n  }\n\n  try {\n    await sendReplayRequest(replayData);\n    return true;\n  } catch (err) {\n    if (err instanceof TransportStatusCodeError || err instanceof RateLimitError) {\n      throw err;\n    }\n\n    // Capture error for every failed replay\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_10__.setContext)(\'Replays\', {\n      _retryCount: retryConfig.count,\n    });\n\n    if (onError) {\n      onError(err);\n    }\n\n    // If an error happened here, it\'s likely that uploading the attachment\n    // failed, we\'ll can retry with the same events payload\n    if (retryConfig.count >= RETRY_MAX_COUNT) {\n      const error = new Error(`${UNABLE_TO_SEND_REPLAY} - max retries exceeded`);\n\n      try {\n        // In case browsers don\'t allow this property to be writable\n        // @ts-expect-error This needs lib es2022 and newer\n        error.cause = err;\n      } catch {\n        // nothing to do\n      }\n\n      throw error;\n    }\n\n    // will retry in intervals of 5, 10, 30\n    retryConfig.interval *= ++retryConfig.count;\n\n    return new Promise((resolve, reject) => {\n      (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__.setTimeout)(async () => {\n        try {\n          await sendReplay(replayData, retryConfig);\n          resolve(true);\n        } catch (err) {\n          reject(err);\n        }\n      }, retryConfig.interval);\n    });\n  }\n}\n\nconst THROTTLED = \'__THROTTLED\';\nconst SKIPPED = \'__SKIPPED\';\n\n/**\n * Create a throttled function off a given function.\n * When calling the throttled function, it will call the original function only\n * if it hasn\'t been called more than `maxCount` times in the last `durationSeconds`.\n *\n * Returns `THROTTLED` if throttled for the first time, after that `SKIPPED`,\n * or else the return value of the original function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction throttle(\n  fn,\n  maxCount,\n  durationSeconds,\n) {\n  const counter = new Map();\n\n  const _cleanup = (now) => {\n    const threshold = now - durationSeconds;\n    counter.forEach((_value, key) => {\n      if (key < threshold) {\n        counter.delete(key);\n      }\n    });\n  };\n\n  const _getTotalCount = () => {\n    return [...counter.values()].reduce((a, b) => a + b, 0);\n  };\n\n  let isThrottled = false;\n\n  return (...rest) => {\n    // Date in second-precision, which we use as basis for the throttling\n    const now = Math.floor(Date.now() / 1000);\n\n    // First, make sure to delete any old entries\n    _cleanup(now);\n\n    // If already over limit, do nothing\n    if (_getTotalCount() >= maxCount) {\n      const wasThrottled = isThrottled;\n      isThrottled = true;\n      return wasThrottled ? SKIPPED : THROTTLED;\n    }\n\n    isThrottled = false;\n    const count = counter.get(now) || 0;\n    counter.set(now, count + 1);\n\n    return fn(...rest);\n  };\n}\n\n/**\n * The main replay container class, which holds all the state and methods for recording and sending replays.\n */\nclass ReplayContainer  {\n\n  /**\n   * Recording can happen in one of two modes:\n   *   - session: Record the whole session, sending it continuously\n   *   - buffer: Always keep the last 60s of recording, requires:\n   *     - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs\n   *     - or calling `flush()` to send the replay\n   */\n\n  /**\n   * The current or last active span.\n   * This is only available when performance is enabled.\n   */\n\n  /**\n   * These are here so we can overwrite them in tests etc.\n   * @hidden\n   */\n\n  /** The replay has to be manually started, because no sample rate (neither session or error) was provided. */\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n\n  /**\n   * Timestamp of the last user activity. This lives across sessions.\n   */\n\n  /**\n   * Is the integration currently active?\n   */\n\n  /**\n   * Paused is a state where:\n   * - DOM Recording is not listening at all\n   * - Nothing will be added to event buffer (e.g. core SDK events)\n   */\n\n  /**\n   * Have we attached listeners to the core SDK?\n   * Note we have to track this as there is no way to remove instrumentation handlers.\n   */\n\n  /**\n   * Function to stop recording\n   */\n\n  /**\n   * Internal use for canvas recording options\n   */\n\n  /**\n   * Handle when visibility of the page content changes. Opening a new tab will\n   * cause the state to change to hidden because of content of current page will\n   * be hidden. Likewise, moving a different window to cover the contents of the\n   * page will also trigger a change to a hidden state.\n   */\n\n  /**\n   * Handle when page is blurred\n   */\n\n  /**\n   * Handle when page is focused\n   */\n\n  /** Ensure page remains active when a key is pressed. */\n\n   constructor({\n    options,\n    recordingOptions,\n  }\n\n) {\n    this.eventBuffer = null;\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n    this.recordingMode = \'session\';\n    this.timeouts = {\n      sessionIdlePause: SESSION_IDLE_PAUSE_DURATION,\n      sessionIdleExpire: SESSION_IDLE_EXPIRE_DURATION,\n    } ;\n    this._lastActivity = Date.now();\n    this._isEnabled = false;\n    this._isPaused = false;\n    this._requiresManualStart = false;\n    this._hasInitializedCoreListeners = false;\n    this._context = {\n      errorIds: new Set(),\n      traceIds: new Set(),\n      urls: [],\n      initialTimestamp: Date.now(),\n      initialUrl: \'\',\n    };\n\n    this._recordingOptions = recordingOptions;\n    this._options = options;\n\n    this._debouncedFlush = debounce(() => this._flush(), this._options.flushMinDelay, {\n      maxWait: this._options.flushMaxDelay,\n    });\n\n    this._throttledAddEvent = throttle(\n      (event, isCheckout) => addEvent(this, event, isCheckout),\n      // Max 300 events...\n      300,\n      // ... per 5s\n      5,\n    );\n\n    const { slowClickTimeout, slowClickIgnoreSelectors } = this.getOptions();\n\n    const slowClickConfig = slowClickTimeout\n      ? {\n          threshold: Math.min(SLOW_CLICK_THRESHOLD, slowClickTimeout),\n          timeout: slowClickTimeout,\n          scrollTimeout: SLOW_CLICK_SCROLL_TIMEOUT,\n          ignoreSelector: slowClickIgnoreSelectors ? slowClickIgnoreSelectors.join(\',\') : \'\',\n        }\n      : undefined;\n\n    if (slowClickConfig) {\n      this.clickDetector = new ClickDetector(this, slowClickConfig);\n    }\n\n    // Configure replay logger w/ experimental options\n    if (DEBUG_BUILD) {\n      const experiments = options._experiments;\n      logger.setConfig({\n        captureExceptions: !!experiments.captureExceptions,\n        traceInternals: !!experiments.traceInternals,\n      });\n    }\n\n    // We set these handler properties as class properties, to make binding/unbinding them easier\n    this._handleVisibilityChange = () => {\n      if (WINDOW.document.visibilityState === \'visible\') {\n        this._doChangeToForegroundTasks();\n      } else {\n        this._doChangeToBackgroundTasks();\n      }\n    };\n\n    /**\n     * Handle when page is blurred\n     */\n    this._handleWindowBlur = () => {\n      const breadcrumb = createBreadcrumb({\n        category: \'ui.blur\',\n      });\n\n      // Do not count blur as a user action -- it\'s part of the process of them\n      // leaving the page\n      this._doChangeToBackgroundTasks(breadcrumb);\n    };\n\n    this._handleWindowFocus = () => {\n      const breadcrumb = createBreadcrumb({\n        category: \'ui.focus\',\n      });\n\n      // Do not count focus as a user action -- instead wait until they focus and\n      // interactive with page\n      this._doChangeToForegroundTasks(breadcrumb);\n    };\n\n    /** Ensure page remains active when a key is pressed. */\n    this._handleKeyboardEvent = (event) => {\n      handleKeyboardEvent(this, event);\n    };\n  }\n\n  /** Get the event context. */\n   getContext() {\n    return this._context;\n  }\n\n  /** If recording is currently enabled. */\n   isEnabled() {\n    return this._isEnabled;\n  }\n\n  /** If recording is currently paused. */\n   isPaused() {\n    return this._isPaused;\n  }\n\n  /**\n   * Determine if canvas recording is enabled\n   */\n   isRecordingCanvas() {\n    return Boolean(this._canvas);\n  }\n\n  /** Get the replay integration options. */\n   getOptions() {\n    return this._options;\n  }\n\n  /** A wrapper to conditionally capture exceptions. */\n   handleException(error) {\n    DEBUG_BUILD && logger.exception(error);\n    if (this._options.onError) {\n      this._options.onError(error);\n    }\n  }\n\n  /**\n   * Initializes the plugin based on sampling configuration. Should not be\n   * called outside of constructor.\n   */\n   initializeSampling(previousSessionId) {\n    const { errorSampleRate, sessionSampleRate } = this._options;\n\n    // If neither sample rate is > 0, then do nothing - user will need to call one of\n    // `start()` or `startBuffering` themselves.\n    const requiresManualStart = errorSampleRate <= 0 && sessionSampleRate <= 0;\n\n    this._requiresManualStart = requiresManualStart;\n\n    if (requiresManualStart) {\n      return;\n    }\n\n    // Otherwise if there is _any_ sample rate set, try to load an existing\n    // session, or create a new one.\n    this._initializeSessionForSampling(previousSessionId);\n\n    if (!this.session) {\n      // This should not happen, something wrong has occurred\n      DEBUG_BUILD && logger.exception(new Error(\'Unable to initialize and create session\'));\n      return;\n    }\n\n    if (this.session.sampled === false) {\n      // This should only occur if `errorSampleRate` is 0 and was unsampled for\n      // session-based replay. In this case there is nothing to do.\n      return;\n    }\n\n    // If segmentId > 0, it means we\'ve previously already captured this session\n    // In this case, we still want to continue in `session` recording mode\n    this.recordingMode = this.session.sampled === \'buffer\' && this.session.segmentId === 0 ? \'buffer\' : \'session\';\n\n    DEBUG_BUILD && logger.infoTick(`Starting replay in ${this.recordingMode} mode`);\n\n    this._initializeRecording();\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will log a message if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * _performanceObserver, Recording, Sentry SDK, etc)\n   */\n   start() {\n    if (this._isEnabled && this.recordingMode === \'session\') {\n      DEBUG_BUILD && logger.info(\'Recording is already in progress\');\n      return;\n    }\n\n    if (this._isEnabled && this.recordingMode === \'buffer\') {\n      DEBUG_BUILD && logger.info(\'Buffering is in progress, call `flush()` to save the replay\');\n      return;\n    }\n\n    DEBUG_BUILD && logger.infoTick(\'Starting replay in session mode\');\n\n    // Required as user activity is initially set in\n    // constructor, so if `start()` is called after\n    // session idle expiration, a replay will not be\n    // created due to an idle timeout.\n    this._updateUserActivity();\n\n    const session = loadOrCreateSession(\n      {\n        maxReplayDuration: this._options.maxReplayDuration,\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n      },\n      {\n        stickySession: this._options.stickySession,\n        // This is intentional: create a new session-based replay when calling `start()`\n        sessionSampleRate: 1,\n        allowBuffering: false,\n      },\n    );\n\n    this.session = session;\n\n    this._initializeRecording();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, an error occurs.\n   */\n   startBuffering() {\n    if (this._isEnabled) {\n      DEBUG_BUILD && logger.info(\'Buffering is in progress, call `flush()` to save the replay\');\n      return;\n    }\n\n    DEBUG_BUILD && logger.infoTick(\'Starting replay in buffer mode\');\n\n    const session = loadOrCreateSession(\n      {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n      },\n      {\n        stickySession: this._options.stickySession,\n        sessionSampleRate: 0,\n        allowBuffering: true,\n      },\n    );\n\n    this.session = session;\n\n    this.recordingMode = \'buffer\';\n    this._initializeRecording();\n  }\n\n  /**\n   * Start recording.\n   *\n   * Note that this will cause a new DOM checkout\n   */\n   startRecording() {\n    try {\n      const canvasOptions = this._canvas;\n\n      this._stopRecording = record({\n        ...this._recordingOptions,\n        // When running in error sampling mode, we need to overwrite `checkoutEveryNms`\n        // Without this, it would record forever, until an error happens, which we don\'t want\n        // instead, we\'ll always keep the last 60 seconds of replay before an error happened\n        ...(this.recordingMode === \'buffer\'\n          ? { checkoutEveryNms: BUFFER_CHECKOUT_TIME }\n          : // Otherwise, use experimental option w/ min checkout time of 6 minutes\n            // This is to improve playback seeking as there could potentially be\n            // less mutations to process in the worse cases.\n            //\n            // checkout by "N" events is probably ideal, but means we have less\n            // control about the number of checkouts we make (which generally\n            // increases replay size)\n            this._options._experiments.continuousCheckout && {\n              // Minimum checkout time is 6 minutes\n              checkoutEveryNms: Math.max(360000, this._options._experiments.continuousCheckout),\n            }),\n        emit: getHandleRecordingEmit(this),\n        ...getRecordingSamplingOptions(),\n        onMutation: this._onMutationHandler.bind(this),\n        ...(canvasOptions\n          ? {\n              recordCanvas: canvasOptions.recordCanvas,\n              getCanvasManager: canvasOptions.getCanvasManager,\n              sampling: canvasOptions.sampling,\n              dataURLOptions: canvasOptions.dataURLOptions,\n            }\n          : {}),\n      });\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Stops the recording, if it was running.\n   *\n   * Returns true if it was previously stopped, or is now stopped,\n   * otherwise false.\n   */\n   stopRecording() {\n    try {\n      if (this._stopRecording) {\n        this._stopRecording();\n        this._stopRecording = undefined;\n      }\n\n      return true;\n    } catch (err) {\n      this.handleException(err);\n      return false;\n    }\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n   async stop({ forceFlush = false, reason } = {}) {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    // We can\'t move `_isEnabled` after awaiting a flush, otherwise we can\n    // enter into an infinite loop when `stop()` is called while flushing.\n    this._isEnabled = false;\n\n    try {\n      DEBUG_BUILD && logger.info(`Stopping Replay${reason ? ` triggered by ${reason}` : \'\'}`);\n\n      resetReplayIdOnDynamicSamplingContext();\n\n      this._removeListeners();\n      this.stopRecording();\n\n      this._debouncedFlush.cancel();\n      // See comment above re: `_isEnabled`, we "force" a flush, ignoring the\n      // `_isEnabled` state of the plugin since it was disabled above.\n      if (forceFlush) {\n        await this._flush({ force: true });\n      }\n\n      // After flush, destroy event buffer\n      this.eventBuffer?.destroy();\n      this.eventBuffer = null;\n\n      // Clear session from session storage, note this means if a new session\n      // is started after, it will not have `previousSessionId`\n      clearSession(this);\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Pause some replay functionality. See comments for `_isPaused`.\n   * This differs from stop as this only stops DOM recording, it is\n   * not as thorough of a shutdown as `stop()`.\n   */\n   pause() {\n    if (this._isPaused) {\n      return;\n    }\n\n    this._isPaused = true;\n    this.stopRecording();\n\n    DEBUG_BUILD && logger.info(\'Pausing replay\');\n  }\n\n  /**\n   * Resumes recording, see notes for `pause().\n   *\n   * Note that calling `startRecording()` here will cause a\n   * new DOM checkout.`\n   */\n   resume() {\n    if (!this._isPaused || !this._checkSession()) {\n      return;\n    }\n\n    this._isPaused = false;\n    this.startRecording();\n\n    DEBUG_BUILD && logger.info(\'Resuming replay\');\n  }\n\n  /**\n   * If not in "session" recording mode, flush event buffer which will create a new replay.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a "session"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n   async sendBufferedReplayOrFlush({ continueRecording = true } = {}) {\n    if (this.recordingMode === \'session\') {\n      return this.flushImmediate();\n    }\n\n    const activityTime = Date.now();\n\n    DEBUG_BUILD && logger.info(\'Converting buffer to session\');\n\n    // Allow flush to complete before resuming as a session recording, otherwise\n    // the checkout from `startRecording` may be included in the payload.\n    // Prefer to keep the error replay as a separate (and smaller) segment\n    // than the session replay.\n    await this.flushImmediate();\n\n    const hasStoppedRecording = this.stopRecording();\n\n    if (!continueRecording || !hasStoppedRecording) {\n      return;\n    }\n\n    // To avoid race conditions where this is called multiple times, we check here again that we are still buffering\n    if ((this.recordingMode ) === \'session\') {\n      return;\n    }\n\n    // Re-start recording in session-mode\n    this.recordingMode = \'session\';\n\n    // Once this session ends, we do not want to refresh it\n    if (this.session) {\n      this._updateUserActivity(activityTime);\n      this._updateSessionActivity(activityTime);\n      this._maybeSaveSession();\n    }\n\n    this.startRecording();\n  }\n\n  /**\n   * We want to batch uploads of replay events. Save events only if\n   * `<flushMinDelay>` milliseconds have elapsed since the last event\n   * *OR* if `<flushMaxDelay>` milliseconds have elapsed.\n   *\n   * Accepts a callback to perform side-effects and returns true to stop batch\n   * processing and hand back control to caller.\n   */\n   addUpdate(cb) {\n    // We need to always run `cb` (e.g. in the case of `this.recordingMode == \'buffer\'`)\n    const cbResult = cb();\n\n    // If this option is turned on then we will only want to call `flush`\n    // explicitly\n    if (this.recordingMode === \'buffer\') {\n      return;\n    }\n\n    // If callback is true, we do not want to continue with flushing -- the\n    // caller will need to handle it.\n    if (cbResult === true) {\n      return;\n    }\n\n    // addUpdate is called quite frequently - use _debouncedFlush so that it\n    // respects the flush delays and does not flush immediately\n    this._debouncedFlush();\n  }\n\n  /**\n   * Updates the user activity timestamp and resumes recording. This should be\n   * called in an event handler for a user action that we consider as the user\n   * being "active" (e.g. a mouse click).\n   */\n   triggerUserActivity() {\n    this._updateUserActivity();\n\n    // This case means that recording was once stopped due to inactivity.\n    // Ensure that recording is resumed.\n    if (!this._stopRecording) {\n      // Create a new session, otherwise when the user action is flushed, it\n      // will get rejected due to an expired session.\n      if (!this._checkSession()) {\n        return;\n      }\n\n      // Note: This will cause a new DOM checkout\n      this.resume();\n      return;\n    }\n\n    // Otherwise... recording was never suspended, continue as normalish\n    this.checkAndHandleExpiredSession();\n\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Updates the user activity timestamp *without* resuming\n   * recording. Some user events (e.g. keydown) can be create\n   * low-value replays that only contain the keypress as a\n   * breadcrumb. Instead this would require other events to\n   * create a new replay after a session has expired.\n   */\n   updateUserActivity() {\n    this._updateUserActivity();\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Only flush if `this.recordingMode === \'session\'`\n   */\n   conditionalFlush() {\n    if (this.recordingMode === \'buffer\') {\n      return Promise.resolve();\n    }\n\n    return this.flushImmediate();\n  }\n\n  /**\n   * Flush using debounce flush\n   */\n   flush() {\n    return this._debouncedFlush() ;\n  }\n\n  /**\n   * Always flush via `_debouncedFlush` so that we do not have flushes triggered\n   * from calling both `flush` and `_debouncedFlush`. Otherwise, there could be\n   * cases of multiple flushes happening closely together.\n   */\n   flushImmediate() {\n    this._debouncedFlush();\n    // `.flush` is provided by the debounced function, analogously to lodash.debounce\n    return this._debouncedFlush.flush() ;\n  }\n\n  /**\n   * Cancels queued up flushes.\n   */\n   cancelFlush() {\n    this._debouncedFlush.cancel();\n  }\n\n  /** Get the current session (=replay) ID */\n   getSessionId() {\n    return this.session?.id;\n  }\n\n  /**\n   * Checks if recording should be stopped due to user inactivity. Otherwise\n   * check if session is expired and create a new session if so. Triggers a new\n   * full snapshot on new session.\n   *\n   * Returns true if session is not expired, false otherwise.\n   * @hidden\n   */\n   checkAndHandleExpiredSession() {\n    // Prevent starting a new session if the last user activity is older than\n    // SESSION_IDLE_PAUSE_DURATION. Otherwise non-user activity can trigger a new\n    // session+recording. This creates noisy replays that do not have much\n    // content in them.\n    if (\n      this._lastActivity &&\n      isExpired(this._lastActivity, this.timeouts.sessionIdlePause) &&\n      this.session &&\n      this.session.sampled === \'session\'\n    ) {\n      // Pause recording only for session-based replays. Otherwise, resuming\n      // will create a new replay and will conflict with users who only choose\n      // to record error-based replays only. (e.g. the resumed replay will not\n      // contain a reference to an error)\n      this.pause();\n      return;\n    }\n\n    // --- There is recent user activity --- //\n    // This will create a new session if expired, based on expiry length\n    if (!this._checkSession()) {\n      // Check session handles the refreshing itself\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Capture some initial state that can change throughout the lifespan of the\n   * replay. This is required because otherwise they would be captured at the\n   * first flush.\n   */\n   setInitialState() {\n    const urlPath = `${WINDOW.location.pathname}${WINDOW.location.hash}${WINDOW.location.search}`;\n    const url = `${WINDOW.location.origin}${urlPath}`;\n\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n\n    // Reset _context as well\n    this._clearContext();\n\n    this._context.initialUrl = url;\n    this._context.initialTimestamp = Date.now();\n    this._context.urls.push(url);\n  }\n\n  /**\n   * Add a breadcrumb event, that may be throttled.\n   * If it was throttled, we add a custom breadcrumb to indicate that.\n   */\n   throttledAddEvent(\n    event,\n    isCheckout,\n  ) {\n    const res = this._throttledAddEvent(event, isCheckout);\n\n    // If this is THROTTLED, it means we have throttled the event for the first time\n    // In this case, we want to add a breadcrumb indicating that something was skipped\n    if (res === THROTTLED) {\n      const breadcrumb = createBreadcrumb({\n        category: \'replay.throttled\',\n      });\n\n      this.addUpdate(() => {\n        // Return `false` if the event _was_ added, as that means we schedule a flush\n        return !addEventSync(this, {\n          type: ReplayEventTypeCustom,\n          timestamp: breadcrumb.timestamp || 0,\n          data: {\n            tag: \'breadcrumb\',\n            payload: breadcrumb,\n            metric: true,\n          },\n        });\n      });\n    }\n\n    return res;\n  }\n\n  /**\n   * This will get the parametrized route name of the current page.\n   * This is only available if performance is enabled, and if an instrumented router is used.\n   */\n   getCurrentRoute() {\n    const lastActiveSpan = this.lastActiveSpan || (0,_sentry_core__WEBPACK_IMPORTED_MODULE_13__.getActiveSpan)();\n    const lastRootSpan = lastActiveSpan && (0,_sentry_core__WEBPACK_IMPORTED_MODULE_13__.getRootSpan)(lastActiveSpan);\n\n    const attributes = (lastRootSpan && (0,_sentry_core__WEBPACK_IMPORTED_MODULE_13__.spanToJSON)(lastRootSpan).data) || {};\n    const source = attributes[_sentry_core__WEBPACK_IMPORTED_MODULE_25__.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n    if (!lastRootSpan || !source || ![\'route\', \'custom\'].includes(source)) {\n      return undefined;\n    }\n\n    return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_13__.spanToJSON)(lastRootSpan).description;\n  }\n\n  /**\n   * Initialize and start all listeners to varying events (DOM,\n   * Performance Observer, Recording, Sentry SDK, etc)\n   */\n   _initializeRecording() {\n    this.setInitialState();\n\n    // this method is generally called on page load or manually - in both cases\n    // we should treat it as an activity\n    this._updateSessionActivity();\n\n    this.eventBuffer = createEventBuffer({\n      useCompression: this._options.useCompression,\n      workerUrl: this._options.workerUrl,\n    });\n\n    this._removeListeners();\n    this._addListeners();\n\n    // Need to set as enabled before we start recording, as `record()` can trigger a flush with a new checkout\n    this._isEnabled = true;\n    this._isPaused = false;\n\n    this.startRecording();\n  }\n\n  /**\n   * Loads (or refreshes) the current session.\n   */\n   _initializeSessionForSampling(previousSessionId) {\n    // Whenever there is _any_ error sample rate, we always allow buffering\n    // Because we decide on sampling when an error occurs, we need to buffer at all times if sampling for errors\n    const allowBuffering = this._options.errorSampleRate > 0;\n\n    const session = loadOrCreateSession(\n      {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n        previousSessionId,\n      },\n      {\n        stickySession: this._options.stickySession,\n        sessionSampleRate: this._options.sessionSampleRate,\n        allowBuffering,\n      },\n    );\n\n    this.session = session;\n  }\n\n  /**\n   * Checks and potentially refreshes the current session.\n   * Returns false if session is not recorded.\n   */\n   _checkSession() {\n    // If there is no session yet, we do not want to refresh anything\n    // This should generally not happen, but to be safe....\n    if (!this.session) {\n      return false;\n    }\n\n    const currentSession = this.session;\n\n    if (\n      shouldRefreshSession(currentSession, {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n      })\n    ) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._refreshSession(currentSession);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Refresh a session with a new one.\n   * This stops the current session (without forcing a flush, as that would never work since we are expired),\n   * and then does a new sampling based on the refreshed session.\n   */\n   async _refreshSession(session) {\n    if (!this._isEnabled) {\n      return;\n    }\n    await this.stop({ reason: \'refresh session\' });\n    this.initializeSampling(session.id);\n  }\n\n  /**\n   * Adds listeners to record events for the replay\n   */\n   _addListeners() {\n    try {\n      WINDOW.document.addEventListener(\'visibilitychange\', this._handleVisibilityChange);\n      WINDOW.addEventListener(\'blur\', this._handleWindowBlur);\n      WINDOW.addEventListener(\'focus\', this._handleWindowFocus);\n      WINDOW.addEventListener(\'keydown\', this._handleKeyboardEvent);\n\n      if (this.clickDetector) {\n        this.clickDetector.addListeners();\n      }\n\n      // There is no way to remove these listeners, so ensure they are only added once\n      if (!this._hasInitializedCoreListeners) {\n        addGlobalListeners(this, { autoFlushOnFeedback: this._options._experiments.autoFlushOnFeedback });\n\n        this._hasInitializedCoreListeners = true;\n      }\n    } catch (err) {\n      this.handleException(err);\n    }\n\n    this._performanceCleanupCallback = setupPerformanceObserver(this);\n  }\n\n  /**\n   * Cleans up listeners that were created in `_addListeners`\n   */\n   _removeListeners() {\n    try {\n      WINDOW.document.removeEventListener(\'visibilitychange\', this._handleVisibilityChange);\n\n      WINDOW.removeEventListener(\'blur\', this._handleWindowBlur);\n      WINDOW.removeEventListener(\'focus\', this._handleWindowFocus);\n      WINDOW.removeEventListener(\'keydown\', this._handleKeyboardEvent);\n\n      if (this.clickDetector) {\n        this.clickDetector.removeListeners();\n      }\n\n      if (this._performanceCleanupCallback) {\n        this._performanceCleanupCallback();\n      }\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Tasks to run when we consider a page to be hidden (via blurring and/or visibility)\n   */\n   _doChangeToBackgroundTasks(breadcrumb) {\n    if (!this.session) {\n      return;\n    }\n\n    const expired = isSessionExpired(this.session, {\n      maxReplayDuration: this._options.maxReplayDuration,\n      sessionIdleExpire: this.timeouts.sessionIdleExpire,\n    });\n\n    if (expired) {\n      return;\n    }\n\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Send replay when the page/tab becomes hidden. There is no reason to send\n    // replay if it becomes visible, since no actions we care about were done\n    // while it was hidden\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    void this.conditionalFlush();\n  }\n\n  /**\n   * Tasks to run when we consider a page to be visible (via focus and/or visibility)\n   */\n   _doChangeToForegroundTasks(breadcrumb) {\n    if (!this.session) {\n      return;\n    }\n\n    const isSessionActive = this.checkAndHandleExpiredSession();\n\n    if (!isSessionActive) {\n      // If the user has come back to the page within SESSION_IDLE_PAUSE_DURATION\n      // ms, we will re-use the existing session, otherwise create a new\n      // session\n      DEBUG_BUILD && logger.info(\'Document has become active, but session has expired\');\n      return;\n    }\n\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n  }\n\n  /**\n   * Update user activity (across session lifespans)\n   */\n   _updateUserActivity(_lastActivity = Date.now()) {\n    this._lastActivity = _lastActivity;\n  }\n\n  /**\n   * Updates the session\'s last activity timestamp\n   */\n   _updateSessionActivity(_lastActivity = Date.now()) {\n    if (this.session) {\n      this.session.lastActivity = _lastActivity;\n      this._maybeSaveSession();\n    }\n  }\n\n  /**\n   * Helper to create (and buffer) a replay breadcrumb from a core SDK breadcrumb\n   */\n   _createCustomBreadcrumb(breadcrumb) {\n    this.addUpdate(() => {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.throttledAddEvent({\n        type: EventType.Custom,\n        timestamp: breadcrumb.timestamp || 0,\n        data: {\n          tag: \'breadcrumb\',\n          payload: breadcrumb,\n        },\n      });\n    });\n  }\n\n  /**\n   * Observed performance events are added to `this.performanceEntries`. These\n   * are included in the replay event before it is finished and sent to Sentry.\n   */\n   _addPerformanceEntries() {\n    let performanceEntries = createPerformanceEntries(this.performanceEntries).concat(this.replayPerformanceEntries);\n\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n\n    // If we are manually starting, we want to ensure we only include performance entries\n    // that are after the initial timestamp\n    // The reason for this is that we may have performance entries from the page load, but may decide to start\n    // the replay later on, in which case we do not want to include these entries.\n    // without this, manually started replays can have events long before the actual replay recording starts,\n    // which messes with the timeline etc.\n    if (this._requiresManualStart) {\n      const initialTimestampInSeconds = this._context.initialTimestamp / 1000;\n      performanceEntries = performanceEntries.filter(entry => entry.start >= initialTimestampInSeconds);\n    }\n\n    return Promise.all(createPerformanceSpans(this, performanceEntries));\n  }\n\n  /**\n   * Clear _context\n   */\n   _clearContext() {\n    // XXX: `initialTimestamp` and `initialUrl` do not get cleared\n    this._context.errorIds.clear();\n    this._context.traceIds.clear();\n    this._context.urls = [];\n  }\n\n  /** Update the initial timestamp based on the buffer content. */\n   _updateInitialTimestampFromEventBuffer() {\n    const { session, eventBuffer } = this;\n    // If replay was started manually (=no sample rate was given),\n    // We do not want to back-port the initial timestamp\n    if (!session || !eventBuffer || this._requiresManualStart) {\n      return;\n    }\n\n    // we only ever update this on the initial segment\n    if (session.segmentId) {\n      return;\n    }\n\n    const earliestEvent = eventBuffer.getEarliestTimestamp();\n    if (earliestEvent && earliestEvent < this._context.initialTimestamp) {\n      this._context.initialTimestamp = earliestEvent;\n    }\n  }\n\n  /**\n   * Return and clear _context\n   */\n   _popEventContext() {\n    const _context = {\n      initialTimestamp: this._context.initialTimestamp,\n      initialUrl: this._context.initialUrl,\n      errorIds: Array.from(this._context.errorIds),\n      traceIds: Array.from(this._context.traceIds),\n      urls: this._context.urls,\n    };\n\n    this._clearContext();\n\n    return _context;\n  }\n\n  /**\n   * Flushes replay event buffer to Sentry.\n   *\n   * Performance events are only added right before flushing - this is\n   * due to the buffered performance observer events.\n   *\n   * Should never be called directly, only by `flush`\n   */\n   async _runFlush() {\n    const replayId = this.getSessionId();\n\n    if (!this.session || !this.eventBuffer || !replayId) {\n      DEBUG_BUILD && logger.error(\'No session or eventBuffer found to flush.\');\n      return;\n    }\n\n    await this._addPerformanceEntries();\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer?.hasEvents) {\n      return;\n    }\n\n    // Only attach memory event if eventBuffer is not empty\n    await addMemoryEntry(this);\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer) {\n      return;\n    }\n\n    // if this changed in the meanwhile, e.g. because the session was refreshed or similar, we abort here\n    if (replayId !== this.getSessionId()) {\n      return;\n    }\n\n    try {\n      // This uses the data from the eventBuffer, so we need to call this before `finish()\n      this._updateInitialTimestampFromEventBuffer();\n\n      const timestamp = Date.now();\n\n      // Check total duration again, to avoid sending outdated stuff\n      // We leave 30s wiggle room to accommodate late flushing etc.\n      // This _could_ happen when the browser is suspended during flushing, in which case we just want to stop\n      if (timestamp - this._context.initialTimestamp > this._options.maxReplayDuration + 30000) {\n        throw new Error(\'Session is too long, not sending replay\');\n      }\n\n      const eventContext = this._popEventContext();\n      // Always increment segmentId regardless of outcome of sending replay\n      const segmentId = this.session.segmentId++;\n      this._maybeSaveSession();\n\n      // Note this empties the event buffer regardless of outcome of sending replay\n      const recordingData = await this.eventBuffer.finish();\n\n      await sendReplay({\n        replayId,\n        recordingData,\n        segmentId,\n        eventContext,\n        session: this.session,\n        timestamp,\n        onError: err => this.handleException(err),\n      });\n    } catch (err) {\n      this.handleException(err);\n\n      // This means we retried 3 times and all of them failed,\n      // or we ran into a problem we don\'t want to retry, like rate limiting.\n      // In this case, we want to completely stop the replay - otherwise, we may get inconsistent segments\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.stop({ reason: \'sendReplay\' });\n\n      const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n\n      if (client) {\n        const dropReason = err instanceof RateLimitError ? \'ratelimit_backoff\' : \'send_error\';\n        client.recordDroppedEvent(dropReason, \'replay\');\n      }\n    }\n  }\n\n  /**\n   * Flush recording data to Sentry. Creates a lock so that only a single flush\n   * can be active at a time. Do not call this directly.\n   */\n   async _flush({\n    force = false,\n  }\n\n = {}) {\n    if (!this._isEnabled && !force) {\n      // This can happen if e.g. the replay was stopped because of exceeding the retry limit\n      return;\n    }\n\n    if (!this.checkAndHandleExpiredSession()) {\n      DEBUG_BUILD && logger.error(\'Attempting to finish replay event after session expired.\');\n      return;\n    }\n\n    if (!this.session) {\n      // should never happen, as we would have bailed out before\n      return;\n    }\n\n    const start = this.session.started;\n    const now = Date.now();\n    const duration = now - start;\n\n    // A flush is about to happen, cancel any queued flushes\n    this._debouncedFlush.cancel();\n\n    // If session is too short, or too long (allow some wiggle room over maxReplayDuration), do not send it\n    // This _should_ not happen, but it may happen if flush is triggered due to a page activity change or similar\n    const tooShort = duration < this._options.minReplayDuration;\n    const tooLong = duration > this._options.maxReplayDuration + 5000;\n    if (tooShort || tooLong) {\n      DEBUG_BUILD &&\n        logger.info(\n          `Session duration (${Math.floor(duration / 1000)}s) is too ${\n            tooShort ? \'short\' : \'long\'\n          }, not sending replay.`,\n        );\n\n      if (tooShort) {\n        this._debouncedFlush();\n      }\n      return;\n    }\n\n    const eventBuffer = this.eventBuffer;\n    if (eventBuffer && this.session.segmentId === 0 && !eventBuffer.hasCheckout) {\n      DEBUG_BUILD && logger.info(\'Flushing initial segment without checkout.\');\n      // TODO FN: Evaluate if we want to stop here, or remove this again?\n    }\n\n    const _flushInProgress = !!this._flushLock;\n\n    // this._flushLock acts as a lock so that future calls to `_flush()` will\n    // be blocked until current flush is finished (i.e. this promise resolves)\n    if (!this._flushLock) {\n      this._flushLock = this._runFlush();\n    }\n\n    try {\n      await this._flushLock;\n    } catch (err) {\n      this.handleException(err);\n    } finally {\n      this._flushLock = undefined;\n\n      if (_flushInProgress) {\n        // Wait for previous flush to finish, then call the debounced\n        // `_flush()`. It\'s possible there are other flush requests queued and\n        // waiting for it to resolve. We want to reduce all outstanding\n        // requests (as well as any new flush requests that occur within a\n        // second of the locked flush completing) into a single flush.\n        this._debouncedFlush();\n      }\n    }\n  }\n\n  /** Save the session, if it is sticky */\n   _maybeSaveSession() {\n    if (this.session && this._options.stickySession) {\n      saveSession(this.session);\n    }\n  }\n\n  /** Handler for rrweb.record.onMutation */\n   _onMutationHandler(mutations) {\n    const count = mutations.length;\n\n    const mutationLimit = this._options.mutationLimit;\n    const mutationBreadcrumbLimit = this._options.mutationBreadcrumbLimit;\n    const overMutationLimit = mutationLimit && count > mutationLimit;\n\n    // Create a breadcrumb if a lot of mutations happen at the same time\n    // We can show this in the UI as an information with potential performance improvements\n    if (count > mutationBreadcrumbLimit || overMutationLimit) {\n      const breadcrumb = createBreadcrumb({\n        category: \'replay.mutations\',\n        data: {\n          count,\n          limit: overMutationLimit,\n        },\n      });\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Stop replay if over the mutation limit\n    if (overMutationLimit) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.stop({ reason: \'mutationLimit\', forceFlush: this.recordingMode === \'session\' });\n      return false;\n    }\n\n    // `true` means we use the regular mutation handling by rrweb\n    return true;\n  }\n}\n\nfunction getOption(selectors, defaultSelectors) {\n  return [\n    ...selectors,\n    // sentry defaults\n    ...defaultSelectors,\n  ].join(\',\');\n}\n\n/**\n * Returns privacy related configuration for use in rrweb\n */\nfunction getPrivacyOptions({ mask, unmask, block, unblock, ignore }) {\n  const defaultBlockedElements = [\'base\', \'iframe[srcdoc]:not([src])\'];\n\n  const maskSelector = getOption(mask, [\'.sentry-mask\', \'[data-sentry-mask]\']);\n  const unmaskSelector = getOption(unmask, []);\n\n  const options = {\n    // We are making the decision to make text and input selectors the same\n    maskTextSelector: maskSelector,\n    unmaskTextSelector: unmaskSelector,\n\n    blockSelector: getOption(block, [\'.sentry-block\', \'[data-sentry-block]\', ...defaultBlockedElements]),\n    unblockSelector: getOption(unblock, []),\n    ignoreSelector: getOption(ignore, [\'.sentry-ignore\', \'[data-sentry-ignore]\', \'input[type="file"]\']),\n  };\n\n  return options;\n}\n\n/**\n * Masks an attribute if necessary, otherwise return attribute value as-is.\n */\nfunction maskAttribute({\n  el,\n  key,\n  maskAttributes,\n  maskAllText,\n  privacyOptions,\n  value,\n}) {\n  // We only mask attributes if `maskAllText` is true\n  if (!maskAllText) {\n    return value;\n  }\n\n  // unmaskTextSelector takes precedence\n  if (privacyOptions.unmaskTextSelector && el.matches(privacyOptions.unmaskTextSelector)) {\n    return value;\n  }\n\n  if (\n    maskAttributes.includes(key) ||\n    // Need to mask `value` attribute for `<input>` if it\'s a button-like\n    // type\n    (key === \'value\' && el.tagName === \'INPUT\' && [\'submit\', \'button\'].includes(el.getAttribute(\'type\') || \'\'))\n  ) {\n    return value.replace(/[\\S]/g, \'*\');\n  }\n\n  return value;\n}\n\nconst MEDIA_SELECTORS =\n  \'img,image,svg,video,object,picture,embed,map,audio,link[rel="icon"],link[rel="apple-touch-icon"]\';\n\nconst DEFAULT_NETWORK_HEADERS = [\'content-length\', \'content-type\', \'accept\'];\n\nlet _initialized = false;\n\n/**\n * Sentry integration for [Session Replay](https://sentry.io/for/session-replay/).\n *\n * See the [Replay documentation](https://docs.sentry.io/platforms/javascript/guides/session-replay/) for more information.\n *\n * @example\n *\n * ```\n * Sentry.init({\n *   dsn: \'__DSN__\',\n *   integrations: [Sentry.replayIntegration()],\n * });\n * ```\n */\nconst replayIntegration = ((options) => {\n  return new Replay(options);\n}) ;\n\n/**\n * Replay integration\n */\nclass Replay  {\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n\n  /**\n   * Initial options passed to the replay integration, merged with default values.\n   * Note: `sessionSampleRate` and `errorSampleRate` are not required here, as they\n   * can only be finally set when setupOnce() is called.\n   *\n   * @private\n   */\n\n   constructor({\n    flushMinDelay = DEFAULT_FLUSH_MIN_DELAY,\n    flushMaxDelay = DEFAULT_FLUSH_MAX_DELAY,\n    minReplayDuration = MIN_REPLAY_DURATION,\n    maxReplayDuration = MAX_REPLAY_DURATION,\n    stickySession = true,\n    useCompression = true,\n    workerUrl,\n    _experiments = {},\n    maskAllText = true,\n    maskAllInputs = true,\n    blockAllMedia = true,\n\n    mutationBreadcrumbLimit = 750,\n    mutationLimit = 10000,\n\n    slowClickTimeout = 7000,\n    slowClickIgnoreSelectors = [],\n\n    networkDetailAllowUrls = [],\n    networkDetailDenyUrls = [],\n    networkCaptureBodies = true,\n    networkRequestHeaders = [],\n    networkResponseHeaders = [],\n\n    mask = [],\n    maskAttributes = [\'title\', \'placeholder\', \'aria-label\'],\n    unmask = [],\n    block = [],\n    unblock = [],\n    ignore = [],\n    maskFn,\n\n    beforeAddRecordingEvent,\n    beforeErrorSampling,\n    onError,\n  } = {}) {\n    this.name = \'Replay\';\n\n    const privacyOptions = getPrivacyOptions({\n      mask,\n      unmask,\n      block,\n      unblock,\n      ignore,\n    });\n\n    this._recordingOptions = {\n      maskAllInputs,\n      maskAllText,\n      maskInputOptions: { password: true },\n      maskTextFn: maskFn,\n      maskInputFn: maskFn,\n      maskAttributeFn: (key, value, el) =>\n        maskAttribute({\n          maskAttributes,\n          maskAllText,\n          privacyOptions,\n          key,\n          value,\n          el,\n        }),\n\n      ...privacyOptions,\n\n      // Our defaults\n      slimDOMOptions: \'all\',\n      inlineStylesheet: true,\n      // Disable inline images as it will increase segment/replay size\n      inlineImages: false,\n      // collect fonts, but be aware that `sentry.io` needs to be an allowed\n      // origin for playback\n      collectFonts: true,\n      errorHandler: (err) => {\n        try {\n          err.__rrweb__ = true;\n        } catch (error) {\n          // ignore errors here\n          // this can happen if the error is frozen or does not allow mutation for other reasons\n        }\n      },\n      // experimental support for recording iframes from different origins\n      recordCrossOriginIframes: Boolean(_experiments.recordCrossOriginIframes),\n    };\n\n    this._initialOptions = {\n      flushMinDelay,\n      flushMaxDelay,\n      minReplayDuration: Math.min(minReplayDuration, MIN_REPLAY_DURATION_LIMIT),\n      maxReplayDuration: Math.min(maxReplayDuration, MAX_REPLAY_DURATION),\n      stickySession,\n      useCompression,\n      workerUrl,\n      blockAllMedia,\n      maskAllInputs,\n      maskAllText,\n      mutationBreadcrumbLimit,\n      mutationLimit,\n      slowClickTimeout,\n      slowClickIgnoreSelectors,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders: _getMergedNetworkHeaders(networkRequestHeaders),\n      networkResponseHeaders: _getMergedNetworkHeaders(networkResponseHeaders),\n      beforeAddRecordingEvent,\n      beforeErrorSampling,\n      onError,\n\n      _experiments,\n    };\n\n    if (this._initialOptions.blockAllMedia) {\n      // `blockAllMedia` is a more user friendly option to configure blocking\n      // embedded media elements\n      this._recordingOptions.blockSelector = !this._recordingOptions.blockSelector\n        ? MEDIA_SELECTORS\n        : `${this._recordingOptions.blockSelector},${MEDIA_SELECTORS}`;\n    }\n\n    if (this._isInitialized && (0,_sentry_core__WEBPACK_IMPORTED_MODULE_26__.isBrowser)()) {\n      throw new Error(\'Multiple Sentry Session Replay instances are not supported\');\n    }\n\n    this._isInitialized = true;\n  }\n\n  /** If replay has already been initialized */\n   get _isInitialized() {\n    return _initialized;\n  }\n\n  /** Update _isInitialized */\n   set _isInitialized(value) {\n    _initialized = value;\n  }\n\n  /**\n   * Setup and initialize replay container\n   */\n   afterAllSetup(client) {\n    if (!(0,_sentry_core__WEBPACK_IMPORTED_MODULE_26__.isBrowser)() || this._replay) {\n      return;\n    }\n\n    this._setup(client);\n    this._initialize(client);\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will log a message if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * PerformanceObserver, Recording, Sentry SDK, etc)\n   */\n   start() {\n    if (!this._replay) {\n      return;\n    }\n    this._replay.start();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, until an error occurs.\n   */\n   startBuffering() {\n    if (!this._replay) {\n      return;\n    }\n\n    this._replay.startBuffering();\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n   stop() {\n    if (!this._replay) {\n      return Promise.resolve();\n    }\n\n    return this._replay.stop({ forceFlush: this._replay.recordingMode === \'session\' });\n  }\n\n  /**\n   * If not in "session" recording mode, flush event buffer which will create a new replay.\n   * If replay is not enabled, a new session replay is started.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a "session"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n   flush(options) {\n    if (!this._replay) {\n      return Promise.resolve();\n    }\n\n    // assuming a session should be recorded in this case\n    if (!this._replay.isEnabled()) {\n      this._replay.start();\n      return Promise.resolve();\n    }\n\n    return this._replay.sendBufferedReplayOrFlush(options);\n  }\n\n  /**\n   * Get the current session ID.\n   */\n   getReplayId() {\n    if (!this._replay?.isEnabled()) {\n      return;\n    }\n\n    return this._replay.getSessionId();\n  }\n\n  /**\n   * Get the current recording mode. This can be either `session` or `buffer`.\n   *\n   * `session`: Recording the whole session, sending it continuously\n   * `buffer`: Always keeping the last 60s of recording, requires:\n   *   - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs\n   *   - or calling `flush()` to send the replay\n   */\n   getRecordingMode() {\n    if (!this._replay?.isEnabled()) {\n      return;\n    }\n\n    return this._replay.recordingMode;\n  }\n\n  /**\n   * Initializes replay.\n   */\n   _initialize(client) {\n    if (!this._replay) {\n      return;\n    }\n\n    this._maybeLoadFromReplayCanvasIntegration(client);\n    this._replay.initializeSampling();\n  }\n\n  /** Setup the integration. */\n   _setup(client) {\n    // Client is not available in constructor, so we need to wait until setupOnce\n    const finalOptions = loadReplayOptionsFromClient(this._initialOptions, client);\n\n    this._replay = new ReplayContainer({\n      options: finalOptions,\n      recordingOptions: this._recordingOptions,\n    });\n  }\n\n  /** Get canvas options from ReplayCanvas integration, if it is also added. */\n   _maybeLoadFromReplayCanvasIntegration(client) {\n    // To save bundle size, we skip checking for stuff here\n    // and instead just try-catch everything - as generally this should all be defined\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\n    try {\n      const canvasIntegration = client.getIntegrationByName(\'ReplayCanvas\')\n\n;\n      if (!canvasIntegration) {\n        return;\n      }\n\n      this._replay[\'_canvas\'] = canvasIntegration.getOptions();\n    } catch {\n      // ignore errors here\n    }\n    /* eslint-enable @typescript-eslint/no-non-null-assertion */\n  }\n}\n\n/** Parse Replay-related options from SDK options */\nfunction loadReplayOptionsFromClient(initialOptions, client) {\n  const opt = client.getOptions() ;\n\n  const finalOptions = {\n    sessionSampleRate: 0,\n    errorSampleRate: 0,\n    ...initialOptions,\n  };\n\n  const replaysSessionSampleRate = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_27__.parseSampleRate)(opt.replaysSessionSampleRate);\n  const replaysOnErrorSampleRate = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_27__.parseSampleRate)(opt.replaysOnErrorSampleRate);\n\n  if (replaysSessionSampleRate == null && replaysOnErrorSampleRate == null) {\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_8__.consoleSandbox)(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \'Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.\',\n      );\n    });\n  }\n\n  if (replaysSessionSampleRate != null) {\n    finalOptions.sessionSampleRate = replaysSessionSampleRate;\n  }\n\n  if (replaysOnErrorSampleRate != null) {\n    finalOptions.errorSampleRate = replaysOnErrorSampleRate;\n  }\n\n  return finalOptions;\n}\n\nfunction _getMergedNetworkHeaders(headers) {\n  return [...DEFAULT_NETWORK_HEADERS, ...headers.map(header => header.toLowerCase())];\n}\n\n/**\n * This is a small utility to get a type-safe instance of the Replay integration.\n */\nfunction getReplay() {\n  const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n  return client?.getIntegrationByName(\'Replay\');\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2VudHJ5LWludGVybmFsL3JlcGxheS9idWlsZC9ucG0vZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1bkI7QUFDcFA7O0FBRW5ZO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvREFBVTs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQSxrRkFBa0YsNkRBQTZEO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0RBQXdEO0FBQ3ZHO0FBQ0EsaUNBQWlDO0FBQ2pDLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBLHVDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBLElBQUk7QUFDSiw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVSxHQUFH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QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxVQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHlCQUF5QjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMseUJBQXlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMseUJBQXlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxHQUFHLEdBQUcsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1REFBUztBQUMxQixPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxrREFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhCQUE4Qjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QiwwRUFBWTtBQUMxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFdBQVc7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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QUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSx1Q0FBdUM7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBELDJCQUEyQixnQkFBZ0IsT0FBTztBQUM1RztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0RBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBMEQ7QUFDOUQsSUFBSSxvQkFBb0IsSUFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQTtBQUNBLG1DQUFtQyxzQ0FBc0M7QUFDekU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtQkFBbUI7QUFDOUQ7O0FBRUEsK0NBQStDLHNDQUFzQztBQUNyRjtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLHVDQUF1QztBQUNoRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsUUFBUTs7QUFFaEMsbUJBQW1CLHdEQUFTOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGVBQWU7QUFDdEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFTOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0EsaUJBQWlCLHdE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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksNkNBQTZDOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseURBQXlELG9CQUFvQjs7QUFFN0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCLElBQUk7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCwwQkFBMEIsT0FBTyxPQUFPOztBQUUzRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMkJBQTJCLElBQUk7QUFDcEU7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCOztBQUV4QyxxQkFBcUIs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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQVM7QUFDMUI7QUFDQTs7QUFFd0M7QUFDeEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcMVxcRG93bmxvYWRzXFx0YWJvckFjYWRlbXlVcGRhdGVkXFx0YWJvci1hY2FkZW15XFxub2RlX21vZHVsZXNcXEBzZW50cnktaW50ZXJuYWxcXHJlcGxheVxcYnVpbGRcXG5wbVxcZXNtXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHTE9CQUxfT0JKLCBub3JtYWxpemUsIGZpbGwsIGh0bWxUcmVlQXNTdHJpbmcsIGJyb3dzZXJQZXJmb3JtYW5jZVRpbWVPcmlnaW4sIGxvZ2dlciBhcyBsb2dnZXIkMSwgc2V2ZXJpdHlMZXZlbEZyb21TdHJpbmcsIGNhcHR1cmVFeGNlcHRpb24sIGFkZEJyZWFkY3J1bWIsIHV1aWQ0LCBnZXRDbGllbnQsIGdldExvY2F0aW9uSHJlZiwgZ2V0Q3VycmVudFNjb3BlLCBnZXRBY3RpdmVTcGFuLCBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4sIGlzU2VudHJ5UmVxdWVzdFVybCwgc3RyaW5nTWF0Y2hlc1NvbWVQYXR0ZXJuLCBhZGRFdmVudFByb2Nlc3NvciwgY3JlYXRlRW52ZWxvcGUsIGNyZWF0ZUV2ZW50RW52ZWxvcGVIZWFkZXJzLCBnZXRTZGtNZXRhZGF0YUZvckVudmVsb3BlSGVhZGVyLCBwcmVwYXJlRXZlbnQsIGdldElzb2xhdGlvblNjb3BlLCByZXNvbHZlZFN5bmNQcm9taXNlLCB1cGRhdGVSYXRlTGltaXRzLCBpc1JhdGVMaW1pdGVkLCBzZXRDb250ZXh0LCBnZXRSb290U3Bhbiwgc3BhblRvSlNPTiwgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0UsIGlzQnJvd3NlciwgcGFyc2VTYW1wbGVSYXRlLCBjb25zb2xlU2FuZGJveCB9IGZyb20gJ0BzZW50cnkvY29yZSc7XG5pbXBvcnQgeyBzZXRUaW1lb3V0IGFzIHNldFRpbWVvdXQkMywgYWRkUGVyZm9ybWFuY2VJbnN0cnVtZW50YXRpb25IYW5kbGVyLCBhZGRMY3BJbnN0cnVtZW50YXRpb25IYW5kbGVyLCBhZGRDbHNJbnN0cnVtZW50YXRpb25IYW5kbGVyLCBhZGRGaWRJbnN0cnVtZW50YXRpb25IYW5kbGVyLCBhZGRJbnBJbnN0cnVtZW50YXRpb25IYW5kbGVyLCBzZXJpYWxpemVGb3JtRGF0YSwgZ2V0RmV0Y2hSZXF1ZXN0QXJnQm9keSwgZ2V0Qm9keVN0cmluZywgU0VOVFJZX1hIUl9EQVRBX0tFWSwgYWRkQ2xpY2tLZXlwcmVzc0luc3RydW1lbnRhdGlvbkhhbmRsZXIsIGFkZEhpc3RvcnlJbnN0cnVtZW50YXRpb25IYW5kbGVyIH0gZnJvbSAnQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzJztcblxuLy8gZXhwb3J0aW5nIGEgc2VwYXJhdGUgY29weSBvZiBgV0lORE9XYCByYXRoZXIgdGhhbiBleHBvcnRpbmcgdGhlIG9uZSBmcm9tIGBAc2VudHJ5L2Jyb3dzZXJgXG4vLyBwcmV2ZW50cyB0aGUgYnJvd3NlciBwYWNrYWdlIGZyb20gYmVpbmcgYnVuZGxlZCBpbiB0aGUgQ0ROIGJ1bmRsZSwgYW5kIGF2b2lkcyBhXG4vLyBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gdGhlIGJyb3dzZXIgYW5kIHJlcGxheSBwYWNrYWdlcyBzaG91bGQgYEBzZW50cnkvYnJvd3NlcmAgaW1wb3J0XG4vLyBmcm9tIGBAc2VudHJ5L3JlcGxheWAgaW4gdGhlIGZ1dHVyZVxuY29uc3QgV0lORE9XID0gR0xPQkFMX09CSiA7XG5cbmNvbnN0IFJFUExBWV9TRVNTSU9OX0tFWSA9ICdzZW50cnlSZXBsYXlTZXNzaW9uJztcbmNvbnN0IFJFUExBWV9FVkVOVF9OQU1FID0gJ3JlcGxheV9ldmVudCc7XG5jb25zdCBVTkFCTEVfVE9fU0VORF9SRVBMQVkgPSAnVW5hYmxlIHRvIHNlbmQgUmVwbGF5JztcblxuLy8gVGhlIGlkbGUgbGltaXQgZm9yIGEgc2Vzc2lvbiBhZnRlciB3aGljaCByZWNvcmRpbmcgaXMgcGF1c2VkLlxuY29uc3QgU0VTU0lPTl9JRExFX1BBVVNFX0RVUkFUSU9OID0gMzAwMDAwOyAvLyA1IG1pbnV0ZXMgaW4gbXNcblxuLy8gVGhlIGlkbGUgbGltaXQgZm9yIGEgc2Vzc2lvbiBhZnRlciB3aGljaCB0aGUgc2Vzc2lvbiBleHBpcmVzLlxuY29uc3QgU0VTU0lPTl9JRExFX0VYUElSRV9EVVJBVElPTiA9IDkwMDAwMDsgLy8gMTUgbWludXRlcyBpbiBtc1xuXG4vKiogRGVmYXVsdCBmbHVzaCBkZWxheXMgKi9cbmNvbnN0IERFRkFVTFRfRkxVU0hfTUlOX0RFTEFZID0gNTAwMDtcbi8vIFhYWDogVGVtcCBmaXggZm9yIG91ciBkZWJvdW5jZSBsb2dpYyB3aGVyZSBgbWF4V2FpdGAgd291bGQgbmV2ZXIgb2NjdXIgaWYgaXRcbi8vIHdhcyB0aGUgc2FtZSBhcyBgd2FpdGBcbmNvbnN0IERFRkFVTFRfRkxVU0hfTUFYX0RFTEFZID0gNTUwMDtcblxuLyogSG93IGxvbmcgdG8gd2FpdCBmb3IgZXJyb3IgY2hlY2tvdXRzICovXG5jb25zdCBCVUZGRVJfQ0hFQ0tPVVRfVElNRSA9IDYwMDAwO1xuXG5jb25zdCBSRVRSWV9CQVNFX0lOVEVSVkFMID0gNTAwMDtcbmNvbnN0IFJFVFJZX01BWF9DT1VOVCA9IDM7XG5cbi8qIFRoZSBtYXggKHVuY29tcHJlc3NlZCkgc2l6ZSBpbiBieXRlcyBvZiBhIG5ldHdvcmsgYm9keS4gQW55IGJvZHkgbGFyZ2VyIHRoYW4gdGhpcyB3aWxsIGJlIHRydW5jYXRlZC4gKi9cbmNvbnN0IE5FVFdPUktfQk9EWV9NQVhfU0laRSA9IDE1MDAwMDtcblxuLyogVGhlIG1heCBzaXplIG9mIGEgc2luZ2xlIGNvbnNvbGUgYXJnIHRoYXQgaXMgY2FwdHVyZWQuIEFueSBhcmcgbGFyZ2VyIHRoYW4gdGhpcyB3aWxsIGJlIHRydW5jYXRlZC4gKi9cbmNvbnN0IENPTlNPTEVfQVJHX01BWF9TSVpFID0gNTAwMDtcblxuLyogTWluLiB0aW1lIHRvIHdhaXQgYmVmb3JlIHdlIGNvbnNpZGVyIHNvbWV0aGluZyBhIHNsb3cgY2xpY2suICovXG5jb25zdCBTTE9XX0NMSUNLX1RIUkVTSE9MRCA9IDMwMDA7XG4vKiBGb3Igc2Nyb2xsIGFjdGlvbnMgYWZ0ZXIgYSBjbGljaywgd2Ugb25seSBsb29rIGZvciBhIHZlcnkgc2hvcnQgdGltZSBwZXJpb2QgdG8gZGV0ZWN0IHByb2dyYW1tYXRpYyBzY3JvbGxpbmcuICovXG5jb25zdCBTTE9XX0NMSUNLX1NDUk9MTF9USU1FT1VUID0gMzAwO1xuXG4vKiogV2hlbiBlbmNvdW50ZXJpbmcgYSB0b3RhbCBzZWdtZW50IHNpemUgZXhjZWVkaW5nIHRoaXMgc2l6ZSwgc3RvcCB0aGUgcmVwbGF5IChhcyB3ZSBjYW5ub3QgcHJvcGVybHkgaW5nZXN0IGl0KS4gKi9cbmNvbnN0IFJFUExBWV9NQVhfRVZFTlRfQlVGRkVSX1NJWkUgPSAyMDAwMDAwMDsgLy8gfjIwTUJcblxuLyoqIFJlcGxheXMgbXVzdCBiZSBtaW4uIDVzIGxvbmcgYmVmb3JlIHdlIHNlbmQgdGhlbS4gKi9cbmNvbnN0IE1JTl9SRVBMQVlfRFVSQVRJT04gPSA0OTk5O1xuLyogVGhlIG1heC4gYWxsb3dlZCB2YWx1ZSB0aGF0IHRoZSBtaW5SZXBsYXlEdXJhdGlvbiBjYW4gYmUgc2V0IHRvLiAqL1xuY29uc3QgTUlOX1JFUExBWV9EVVJBVElPTl9MSU1JVCA9IDE1MDAwO1xuXG4vKiogVGhlIG1heC4gbGVuZ3RoIG9mIGEgcmVwbGF5LiAqL1xuY29uc3QgTUFYX1JFUExBWV9EVVJBVElPTiA9IDM2MDAwMDA7IC8vIDYwIG1pbnV0ZXMgaW4gbXM7XG5cbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xudmFyIE5vZGVUeXBlJDIgPSAvKiBAX19QVVJFX18gKi8gKChOb2RlVHlwZTIpID0+IHtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50XCJdID0gMF0gPSBcIkRvY3VtZW50XCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJEb2N1bWVudFR5cGVcIl0gPSAxXSA9IFwiRG9jdW1lbnRUeXBlXCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJFbGVtZW50XCJdID0gMl0gPSBcIkVsZW1lbnRcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIlRleHRcIl0gPSAzXSA9IFwiVGV4dFwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ0RBVEFcIl0gPSA0XSA9IFwiQ0RBVEFcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkNvbW1lbnRcIl0gPSA1XSA9IFwiQ29tbWVudFwiO1xuICByZXR1cm4gTm9kZVR5cGUyO1xufSkoTm9kZVR5cGUkMiB8fCB7fSk7XG5mdW5jdGlvbiBpc0VsZW1lbnQkMShuMikge1xuICByZXR1cm4gbjIubm9kZVR5cGUgPT09IG4yLkVMRU1FTlRfTk9ERTtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChuMikge1xuICBjb25zdCBob3N0ID0gbjI/Lmhvc3Q7XG4gIHJldHVybiBCb29sZWFuKGhvc3Q/LnNoYWRvd1Jvb3QgPT09IG4yKTtcbn1cbmZ1bmN0aW9uIGlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzaGFkb3dSb290KSA9PT0gXCJbb2JqZWN0IFNoYWRvd1Jvb3RdXCI7XG59XG5mdW5jdGlvbiBmaXhCcm93c2VyQ29tcGF0aWJpbGl0eUlzc3Vlc0luQ1NTKGNzc1RleHQpIHtcbiAgaWYgKGNzc1RleHQuaW5jbHVkZXMoXCIgYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1wiKSAmJiAhY3NzVGV4dC5pbmNsdWRlcyhcIiAtd2Via2l0LWJhY2tncm91bmQtY2xpcDogdGV4dDtcIikpIHtcbiAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKFxuICAgICAgL1xcc2JhY2tncm91bmQtY2xpcDpcXHMqdGV4dDsvZyxcbiAgICAgIFwiIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0OyBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XCJcbiAgICApO1xuICB9XG4gIHJldHVybiBjc3NUZXh0O1xufVxuZnVuY3Rpb24gZXNjYXBlSW1wb3J0U3RhdGVtZW50KHJ1bGUpIHtcbiAgY29uc3QgeyBjc3NUZXh0IH0gPSBydWxlO1xuICBpZiAoY3NzVGV4dC5zcGxpdCgnXCInKS5sZW5ndGggPCAzKSByZXR1cm4gY3NzVGV4dDtcbiAgY29uc3Qgc3RhdGVtZW50ID0gW1wiQGltcG9ydFwiLCBgdXJsKCR7SlNPTi5zdHJpbmdpZnkocnVsZS5ocmVmKX0pYF07XG4gIGlmIChydWxlLmxheWVyTmFtZSA9PT0gXCJcIikge1xuICAgIHN0YXRlbWVudC5wdXNoKGBsYXllcmApO1xuICB9IGVsc2UgaWYgKHJ1bGUubGF5ZXJOYW1lKSB7XG4gICAgc3RhdGVtZW50LnB1c2goYGxheWVyKCR7cnVsZS5sYXllck5hbWV9KWApO1xuICB9XG4gIGlmIChydWxlLnN1cHBvcnRzVGV4dCkge1xuICAgIHN0YXRlbWVudC5wdXNoKGBzdXBwb3J0cygke3J1bGUuc3VwcG9ydHNUZXh0fSlgKTtcbiAgfVxuICBpZiAocnVsZS5tZWRpYS5sZW5ndGgpIHtcbiAgICBzdGF0ZW1lbnQucHVzaChydWxlLm1lZGlhLm1lZGlhVGV4dCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlbWVudC5qb2luKFwiIFwiKSArIFwiO1wiO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGVzaGVldChzMikge1xuICB0cnkge1xuICAgIGNvbnN0IHJ1bGVzMiA9IHMyLnJ1bGVzIHx8IHMyLmNzc1J1bGVzO1xuICAgIHJldHVybiBydWxlczIgPyBmaXhCcm93c2VyQ29tcGF0aWJpbGl0eUlzc3Vlc0luQ1NTKFxuICAgICAgQXJyYXkuZnJvbShydWxlczIsIHN0cmluZ2lmeVJ1bGUpLmpvaW4oXCJcIilcbiAgICApIDogbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZml4QWxsQ3NzUHJvcGVydHkocnVsZSkge1xuICBsZXQgc3R5bGVzID0gXCJcIjtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHJ1bGUuc3R5bGUubGVuZ3RoOyBpMisrKSB7XG4gICAgY29uc3Qgc3R5bGVEZWNsYXJhdGlvbiA9IHJ1bGUuc3R5bGU7XG4gICAgY29uc3QgYXR0cmlidXRlID0gc3R5bGVEZWNsYXJhdGlvbltpMl07XG4gICAgY29uc3QgaXNJbXBvcnRhbnQgPSBzdHlsZURlY2xhcmF0aW9uLmdldFByb3BlcnR5UHJpb3JpdHkoYXR0cmlidXRlKTtcbiAgICBzdHlsZXMgKz0gYCR7YXR0cmlidXRlfToke3N0eWxlRGVjbGFyYXRpb24uZ2V0UHJvcGVydHlWYWx1ZShhdHRyaWJ1dGUpfSR7aXNJbXBvcnRhbnQgPyBgICFpbXBvcnRhbnRgIDogXCJcIn07YDtcbiAgfVxuICByZXR1cm4gYCR7cnVsZS5zZWxlY3RvclRleHR9IHsgJHtzdHlsZXN9IH1gO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UnVsZShydWxlKSB7XG4gIGxldCBpbXBvcnRTdHJpbmdpZmllZDtcbiAgaWYgKGlzQ1NTSW1wb3J0UnVsZShydWxlKSkge1xuICAgIHRyeSB7XG4gICAgICBpbXBvcnRTdHJpbmdpZmllZCA9IC8vIGZvciBzYW1lLW9yaWdpbiBzdHlsZXNoZWV0cyxcbiAgICAgIC8vIHdlIGNhbiBhY2Nlc3MgdGhlIGltcG9ydGVkIHN0eWxlc2hlZXQgcnVsZXMgZGlyZWN0bHlcbiAgICAgIHN0cmluZ2lmeVN0eWxlc2hlZXQocnVsZS5zdHlsZVNoZWV0KSB8fCAvLyB3b3JrIGFyb3VuZCBicm93c2VyIGlzc3VlcyB3aXRoIHRoZSByYXcgc3RyaW5nIGBAaW1wb3J0IHVybCguLi4pYCBzdGF0ZW1lbnRcbiAgICAgIGVzY2FwZUltcG9ydFN0YXRlbWVudChydWxlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0NTU1N0eWxlUnVsZShydWxlKSkge1xuICAgIGxldCBjc3NUZXh0ID0gcnVsZS5jc3NUZXh0O1xuICAgIGNvbnN0IG5lZWRzU2FmYXJpQ29sb25GaXggPSBydWxlLnNlbGVjdG9yVGV4dC5pbmNsdWRlcyhcIjpcIik7XG4gICAgY29uc3QgbmVlZHNBbGxGaXggPSB0eXBlb2YgcnVsZS5zdHlsZVtcImFsbFwiXSA9PT0gXCJzdHJpbmdcIiAmJiBydWxlLnN0eWxlW1wiYWxsXCJdO1xuICAgIGlmIChuZWVkc0FsbEZpeCkge1xuICAgICAgY3NzVGV4dCA9IGZpeEFsbENzc1Byb3BlcnR5KHJ1bGUpO1xuICAgIH1cbiAgICBpZiAobmVlZHNTYWZhcmlDb2xvbkZpeCkge1xuICAgICAgY3NzVGV4dCA9IGZpeFNhZmFyaUNvbG9ucyhjc3NUZXh0KTtcbiAgICB9XG4gICAgaWYgKG5lZWRzU2FmYXJpQ29sb25GaXggfHwgbmVlZHNBbGxGaXgpIHtcbiAgICAgIHJldHVybiBjc3NUZXh0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW1wb3J0U3RyaW5naWZpZWQgfHwgcnVsZS5jc3NUZXh0O1xufVxuZnVuY3Rpb24gZml4U2FmYXJpQ29sb25zKGNzc1N0cmluZ2lmaWVkKSB7XG4gIGNvbnN0IHJlZ2V4ID0gLyhcXFsoPzpbXFx3LV0rKVteXFxcXF0pKDooPzpbXFx3LV0rKVxcXSkvZ207XG4gIHJldHVybiBjc3NTdHJpbmdpZmllZC5yZXBsYWNlKHJlZ2V4LCBcIiQxXFxcXCQyXCIpO1xufVxuZnVuY3Rpb24gaXNDU1NJbXBvcnRSdWxlKHJ1bGUpIHtcbiAgcmV0dXJuIFwic3R5bGVTaGVldFwiIGluIHJ1bGU7XG59XG5mdW5jdGlvbiBpc0NTU1N0eWxlUnVsZShydWxlKSB7XG4gIHJldHVybiBcInNlbGVjdG9yVGV4dFwiIGluIHJ1bGU7XG59XG5jbGFzcyBNaXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpZE5vZGVNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibm9kZU1ldGFNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICB9XG4gIGdldElkKG4yKSB7XG4gICAgaWYgKCFuMikgcmV0dXJuIC0xO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXRNZXRhKG4yKT8uaWQ7XG4gICAgcmV0dXJuIGlkID8/IC0xO1xuICB9XG4gIGdldE5vZGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pZE5vZGVNYXAuZ2V0KGlkKSB8fCBudWxsO1xuICB9XG4gIGdldElkcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmlkTm9kZU1hcC5rZXlzKCkpO1xuICB9XG4gIGdldE1ldGEobjIpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlTWV0YU1hcC5nZXQobjIpIHx8IG51bGw7XG4gIH1cbiAgLy8gcmVtb3ZlcyB0aGUgbm9kZSBmcm9tIGlkTm9kZU1hcFxuICAvLyBkb2Vzbid0IHJlbW92ZSB0aGUgbm9kZSBmcm9tIG5vZGVNZXRhTWFwXG4gIHJlbW92ZU5vZGVGcm9tTWFwKG4yKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldElkKG4yKTtcbiAgICB0aGlzLmlkTm9kZU1hcC5kZWxldGUoaWQpO1xuICAgIGlmIChuMi5jaGlsZE5vZGVzKSB7XG4gICAgICBuMi5jaGlsZE5vZGVzLmZvckVhY2goXG4gICAgICAgIChjaGlsZE5vZGUpID0+IHRoaXMucmVtb3ZlTm9kZUZyb21NYXAoY2hpbGROb2RlKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaGFzKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaWROb2RlTWFwLmhhcyhpZCk7XG4gIH1cbiAgaGFzTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZU1ldGFNYXAuaGFzKG5vZGUpO1xuICB9XG4gIGFkZChuMiwgbWV0YSkge1xuICAgIGNvbnN0IGlkID0gbWV0YS5pZDtcbiAgICB0aGlzLmlkTm9kZU1hcC5zZXQoaWQsIG4yKTtcbiAgICB0aGlzLm5vZGVNZXRhTWFwLnNldChuMiwgbWV0YSk7XG4gIH1cbiAgcmVwbGFjZShpZCwgbjIpIHtcbiAgICBjb25zdCBvbGROb2RlID0gdGhpcy5nZXROb2RlKGlkKTtcbiAgICBpZiAob2xkTm9kZSkge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMubm9kZU1ldGFNYXAuZ2V0KG9sZE5vZGUpO1xuICAgICAgaWYgKG1ldGEpIHRoaXMubm9kZU1ldGFNYXAuc2V0KG4yLCBtZXRhKTtcbiAgICB9XG4gICAgdGhpcy5pZE5vZGVNYXAuc2V0KGlkLCBuMik7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5pZE5vZGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubm9kZU1ldGFNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTWlycm9yJDIoKSB7XG4gIHJldHVybiBuZXcgTWlycm9yKCk7XG59XG5mdW5jdGlvbiBzaG91bGRNYXNrSW5wdXQoe1xuICBtYXNrSW5wdXRPcHRpb25zLFxuICB0YWdOYW1lLFxuICB0eXBlXG59KSB7XG4gIGlmICh0YWdOYW1lID09PSBcIk9QVElPTlwiKSB7XG4gICAgdGFnTmFtZSA9IFwiU0VMRUNUXCI7XG4gIH1cbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgbWFza0lucHV0T3B0aW9uc1t0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IHR5cGUgJiYgbWFza0lucHV0T3B0aW9uc1t0eXBlXSB8fCB0eXBlID09PSBcInBhc3N3b3JkXCIgfHwgLy8gRGVmYXVsdCB0byBcInRleHRcIiBvcHRpb24gZm9yIGlucHV0cyB3aXRob3V0IGEgXCJ0eXBlXCIgYXR0cmlidXRlIGRlZmluZWRcbiAgICB0YWdOYW1lID09PSBcIklOUFVUXCIgJiYgIXR5cGUgJiYgbWFza0lucHV0T3B0aW9uc1tcInRleHRcIl1cbiAgKTtcbn1cbmZ1bmN0aW9uIG1hc2tJbnB1dFZhbHVlKHtcbiAgaXNNYXNrZWQsXG4gIGVsZW1lbnQsXG4gIHZhbHVlLFxuICBtYXNrSW5wdXRGblxufSkge1xuICBsZXQgdGV4dCA9IHZhbHVlIHx8IFwiXCI7XG4gIGlmICghaXNNYXNrZWQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICBpZiAobWFza0lucHV0Rm4pIHtcbiAgICB0ZXh0ID0gbWFza0lucHV0Rm4odGV4dCwgZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIFwiKlwiLnJlcGVhdCh0ZXh0Lmxlbmd0aCk7XG59XG5mdW5jdGlvbiB0b0xvd2VyQ2FzZShzdHIpIHtcbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gdG9VcHBlckNhc2Uoc3RyKSB7XG4gIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cbmNvbnN0IE9SSUdJTkFMX0FUVFJJQlVURV9OQU1FID0gXCJfX3Jyd2ViX29yaWdpbmFsX19cIjtcbmZ1bmN0aW9uIGlzMkRDYW52YXNCbGFuayhjYW52YXMpIHtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgaWYgKCFjdHgpIHJldHVybiB0cnVlO1xuICBjb25zdCBjaHVua1NpemUgPSA1MDtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHggKz0gY2h1bmtTaXplKSB7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5ICs9IGNodW5rU2l6ZSkge1xuICAgICAgY29uc3QgZ2V0SW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsR2V0SW1hZ2VEYXRhID0gT1JJR0lOQUxfQVRUUklCVVRFX05BTUUgaW4gZ2V0SW1hZ2VEYXRhID8gZ2V0SW1hZ2VEYXRhW09SSUdJTkFMX0FUVFJJQlVURV9OQU1FXSA6IGdldEltYWdlRGF0YTtcbiAgICAgIGNvbnN0IHBpeGVsQnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgIG9yaWdpbmFsR2V0SW1hZ2VEYXRhLmNhbGwoXG4gICAgICAgICAgY3R4LFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBNYXRoLm1pbihjaHVua1NpemUsIGNhbnZhcy53aWR0aCAtIHgpLFxuICAgICAgICAgIE1hdGgubWluKGNodW5rU2l6ZSwgY2FudmFzLmhlaWdodCAtIHkpXG4gICAgICAgICkuZGF0YS5idWZmZXJcbiAgICAgICk7XG4gICAgICBpZiAocGl4ZWxCdWZmZXIuc29tZSgocGl4ZWwpID0+IHBpeGVsICE9PSAwKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldElucHV0VHlwZShlbGVtZW50KSB7XG4gIGNvbnN0IHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRhdGEtcnItaXMtcGFzc3dvcmRcIikgPyBcInBhc3N3b3JkXCIgOiB0eXBlID8gKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cbiAgICB0b0xvd2VyQ2FzZSh0eXBlKVxuICApIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldElucHV0VmFsdWUoZWwsIHRhZ05hbWUsIHR5cGUpIHtcbiAgaWYgKHRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiAodHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIikpIHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgfHwgXCJcIjtcbiAgfVxuICByZXR1cm4gZWwudmFsdWU7XG59XG5mdW5jdGlvbiBleHRyYWN0RmlsZUV4dGVuc2lvbihwYXRoLCBiYXNlVVJMKSB7XG4gIGxldCB1cmw7XG4gIHRyeSB7XG4gICAgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVVJMID8/IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVnZXggPSAvXFwuKFswLTlhLXpdKykoPzokKS9pO1xuICBjb25zdCBtYXRjaCA9IHVybC5wYXRobmFtZS5tYXRjaChyZWdleCk7XG4gIHJldHVybiBtYXRjaD8uWzFdID8/IG51bGw7XG59XG5jb25zdCBjYWNoZWRJbXBsZW1lbnRhdGlvbnMkMSA9IHt9O1xuZnVuY3Rpb24gZ2V0SW1wbGVtZW50YXRpb24kMShuYW1lKSB7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlZEltcGxlbWVudGF0aW9ucyQxW25hbWVdO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCBkb2N1bWVudDIgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gIGxldCBpbXBsID0gd2luZG93W25hbWVdO1xuICBpZiAoZG9jdW1lbnQyICYmIHR5cGVvZiBkb2N1bWVudDIuY3JlYXRlRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNhbmRib3ggPSBkb2N1bWVudDIuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgIHNhbmRib3guaGlkZGVuID0gdHJ1ZTtcbiAgICAgIGRvY3VtZW50Mi5oZWFkLmFwcGVuZENoaWxkKHNhbmRib3gpO1xuICAgICAgY29uc3QgY29udGVudFdpbmRvdyA9IHNhbmRib3guY29udGVudFdpbmRvdztcbiAgICAgIGlmIChjb250ZW50V2luZG93ICYmIGNvbnRlbnRXaW5kb3dbbmFtZV0pIHtcbiAgICAgICAgaW1wbCA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgY29udGVudFdpbmRvd1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50Mi5oZWFkLnJlbW92ZUNoaWxkKHNhbmRib3gpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYWNoZWRJbXBsZW1lbnRhdGlvbnMkMVtuYW1lXSA9IGltcGwuYmluZChcbiAgICB3aW5kb3dcbiAgKTtcbn1cbmZ1bmN0aW9uIHNldFRpbWVvdXQkMiguLi5yZXN0KSB7XG4gIHJldHVybiBnZXRJbXBsZW1lbnRhdGlvbiQxKFwic2V0VGltZW91dFwiKSguLi5yZXN0KTtcbn1cbmZ1bmN0aW9uIGNsZWFyVGltZW91dCQxKC4uLnJlc3QpIHtcbiAgcmV0dXJuIGdldEltcGxlbWVudGF0aW9uJDEoXCJjbGVhclRpbWVvdXRcIikoLi4ucmVzdCk7XG59XG5mdW5jdGlvbiBnZXRJZnJhbWVDb250ZW50RG9jdW1lbnQoaWZyYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGlmcmFtZS5jb250ZW50RG9jdW1lbnQ7XG4gIH0gY2F0Y2ggKGUyKSB7XG4gIH1cbn1cbmxldCBfaWQgPSAxO1xuY29uc3QgdGFnTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cChcIlteYS16MC05LV86XVwiKTtcbmNvbnN0IElHTk9SRURfTk9ERSA9IC0yO1xuZnVuY3Rpb24gZ2VuSWQoKSB7XG4gIHJldHVybiBfaWQrKztcbn1cbmZ1bmN0aW9uIGdldFZhbGlkVGFnTmFtZSQxKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpIHtcbiAgICByZXR1cm4gXCJmb3JtXCI7XG4gIH1cbiAgY29uc3QgcHJvY2Vzc2VkVGFnTmFtZSA9IHRvTG93ZXJDYXNlKGVsZW1lbnQudGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lUmVnZXgudGVzdChwcm9jZXNzZWRUYWdOYW1lKSkge1xuICAgIHJldHVybiBcImRpdlwiO1xuICB9XG4gIHJldHVybiBwcm9jZXNzZWRUYWdOYW1lO1xufVxuZnVuY3Rpb24gZXh0cmFjdE9yaWdpbih1cmwpIHtcbiAgbGV0IG9yaWdpbiA9IFwiXCI7XG4gIGlmICh1cmwuaW5kZXhPZihcIi8vXCIpID4gLTEpIHtcbiAgICBvcmlnaW4gPSB1cmwuc3BsaXQoXCIvXCIpLnNsaWNlKDAsIDMpLmpvaW4oXCIvXCIpO1xuICB9IGVsc2Uge1xuICAgIG9yaWdpbiA9IHVybC5zcGxpdChcIi9cIilbMF07XG4gIH1cbiAgb3JpZ2luID0gb3JpZ2luLnNwbGl0KFwiP1wiKVswXTtcbiAgcmV0dXJuIG9yaWdpbjtcbn1cbmxldCBjYW52YXNTZXJ2aWNlO1xubGV0IGNhbnZhc0N0eDtcbmNvbnN0IFVSTF9JTl9DU1NfUkVGID0gL3VybFxcKCg/OignKShbXiddKiknfChcIikoLio/KVwifChbXildKikpXFwpL2dtO1xuY29uc3QgVVJMX1BST1RPQ09MX01BVENIID0gL14oPzpbYS16K10rOik/XFwvXFwvL2k7XG5jb25zdCBVUkxfV1dXX01BVENIID0gL153d3dcXC4uKi9pO1xuY29uc3QgREFUQV9VUkkgPSAvXihkYXRhOikoW14sXSopLCguKikvaTtcbmZ1bmN0aW9uIGFic29sdXRlVG9TdHlsZXNoZWV0KGNzc1RleHQsIGhyZWYpIHtcbiAgcmV0dXJuIChjc3NUZXh0IHx8IFwiXCIpLnJlcGxhY2UoXG4gICAgVVJMX0lOX0NTU19SRUYsXG4gICAgKG9yaWdpbiwgcXVvdGUxLCBwYXRoMSwgcXVvdGUyLCBwYXRoMiwgcGF0aDMpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aDEgfHwgcGF0aDIgfHwgcGF0aDM7XG4gICAgICBjb25zdCBtYXliZVF1b3RlID0gcXVvdGUxIHx8IHF1b3RlMiB8fCBcIlwiO1xuICAgICAgaWYgKCFmaWxlUGF0aCkge1xuICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgICAgfVxuICAgICAgaWYgKFVSTF9QUk9UT0NPTF9NQVRDSC50ZXN0KGZpbGVQYXRoKSB8fCBVUkxfV1dXX01BVENILnRlc3QoZmlsZVBhdGgpKSB7XG4gICAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke2ZpbGVQYXRofSR7bWF5YmVRdW90ZX0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChEQVRBX1VSSS50ZXN0KGZpbGVQYXRoKSkge1xuICAgICAgICByZXR1cm4gYHVybCgke21heWJlUXVvdGV9JHtmaWxlUGF0aH0ke21heWJlUXVvdGV9KWA7XG4gICAgICB9XG4gICAgICBpZiAoZmlsZVBhdGhbMF0gPT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke2V4dHJhY3RPcmlnaW4oaHJlZikgKyBmaWxlUGF0aH0ke21heWJlUXVvdGV9KWA7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFjayA9IGhyZWYuc3BsaXQoXCIvXCIpO1xuICAgICAgY29uc3QgcGFydHMgPSBmaWxlUGF0aC5zcGxpdChcIi9cIik7XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICBpZiAocGFydCA9PT0gXCIuXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFjay5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYHVybCgke21heWJlUXVvdGV9JHtzdGFjay5qb2luKFwiL1wiKX0ke21heWJlUXVvdGV9KWA7XG4gICAgfVxuICApO1xufVxuY29uc3QgU1JDU0VUX05PVF9TUEFDRVMgPSAvXlteIFxcdFxcblxcclxcdTAwMGNdKy87XG5jb25zdCBTUkNTRVRfQ09NTUFTX09SX1NQQUNFUyA9IC9eWywgXFx0XFxuXFxyXFx1MDAwY10rLztcbmZ1bmN0aW9uIGdldEFic29sdXRlU3Jjc2V0U3RyaW5nKGRvYywgYXR0cmlidXRlVmFsdWUpIHtcbiAgaWYgKGF0dHJpYnV0ZVZhbHVlLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZTtcbiAgfVxuICBsZXQgcG9zID0gMDtcbiAgZnVuY3Rpb24gY29sbGVjdENoYXJhY3RlcnMocmVnRXgpIHtcbiAgICBsZXQgY2hhcnMyO1xuICAgIGNvbnN0IG1hdGNoID0gcmVnRXguZXhlYyhhdHRyaWJ1dGVWYWx1ZS5zdWJzdHJpbmcocG9zKSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjaGFyczIgPSBtYXRjaFswXTtcbiAgICAgIHBvcyArPSBjaGFyczIubGVuZ3RoO1xuICAgICAgcmV0dXJuIGNoYXJzMjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29sbGVjdENoYXJhY3RlcnMoU1JDU0VUX0NPTU1BU19PUl9TUEFDRVMpO1xuICAgIGlmIChwb3MgPj0gYXR0cmlidXRlVmFsdWUubGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IHVybCA9IGNvbGxlY3RDaGFyYWN0ZXJzKFNSQ1NFVF9OT1RfU1BBQ0VTKTtcbiAgICBpZiAodXJsLnNsaWNlKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgIHVybCA9IGFic29sdXRlVG9Eb2MoZG9jLCB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxKSk7XG4gICAgICBvdXRwdXQucHVzaCh1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVzY3JpcHRvcnNTdHIgPSBcIlwiO1xuICAgICAgdXJsID0gYWJzb2x1dGVUb0RvYyhkb2MsIHVybCk7XG4gICAgICBsZXQgaW5QYXJlbnMgPSBmYWxzZTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGMyID0gYXR0cmlidXRlVmFsdWUuY2hhckF0KHBvcyk7XG4gICAgICAgIGlmIChjMiA9PT0gXCJcIikge1xuICAgICAgICAgIG91dHB1dC5wdXNoKCh1cmwgKyBkZXNjcmlwdG9yc1N0cikudHJpbSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICghaW5QYXJlbnMpIHtcbiAgICAgICAgICBpZiAoYzIgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKCh1cmwgKyBkZXNjcmlwdG9yc1N0cikudHJpbSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYzIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICBpblBhcmVucyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjMiA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgIGluUGFyZW5zID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlc2NyaXB0b3JzU3RyICs9IGMyO1xuICAgICAgICBwb3MgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKFwiLCBcIik7XG59XG5jb25zdCBjYWNoZWREb2N1bWVudCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gYWJzb2x1dGVUb0RvYyhkb2MsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gIGlmICghYXR0cmlidXRlVmFsdWUgfHwgYXR0cmlidXRlVmFsdWUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xuICB9XG4gIHJldHVybiBnZXRIcmVmKGRvYywgYXR0cmlidXRlVmFsdWUpO1xufVxuZnVuY3Rpb24gaXNTVkdFbGVtZW50KGVsKSB7XG4gIHJldHVybiBCb29sZWFuKGVsLnRhZ05hbWUgPT09IFwic3ZnXCIgfHwgZWwub3duZXJTVkdFbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldEhyZWYoZG9jLCBjdXN0b21IcmVmKSB7XG4gIGxldCBhMiA9IGNhY2hlZERvY3VtZW50LmdldChkb2MpO1xuICBpZiAoIWEyKSB7XG4gICAgYTIgPSBkb2MuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgY2FjaGVkRG9jdW1lbnQuc2V0KGRvYywgYTIpO1xuICB9XG4gIGlmICghY3VzdG9tSHJlZikge1xuICAgIGN1c3RvbUhyZWYgPSBcIlwiO1xuICB9IGVsc2UgaWYgKGN1c3RvbUhyZWYuc3RhcnRzV2l0aChcImJsb2I6XCIpIHx8IGN1c3RvbUhyZWYuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgcmV0dXJuIGN1c3RvbUhyZWY7XG4gIH1cbiAgYTIuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBjdXN0b21IcmVmKTtcbiAgcmV0dXJuIGEyLmhyZWY7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1BdHRyaWJ1dGUoZG9jLCB0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgZWxlbWVudCwgbWFza0F0dHJpYnV0ZUZuKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKG5hbWUgPT09IFwic3JjXCIgfHwgbmFtZSA9PT0gXCJocmVmXCIgJiYgISh0YWdOYW1lID09PSBcInVzZVwiICYmIHZhbHVlWzBdID09PSBcIiNcIikpIHtcbiAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChuYW1lID09PSBcInhsaW5rOmhyZWZcIiAmJiB2YWx1ZVswXSAhPT0gXCIjXCIpIHtcbiAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChuYW1lID09PSBcImJhY2tncm91bmRcIiAmJiAodGFnTmFtZSA9PT0gXCJ0YWJsZVwiIHx8IHRhZ05hbWUgPT09IFwidGRcIiB8fCB0YWdOYW1lID09PSBcInRoXCIpKSB7XG4gICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzcmNzZXRcIikge1xuICAgIHJldHVybiBnZXRBYnNvbHV0ZVNyY3NldFN0cmluZyhkb2MsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChuYW1lID09PSBcInN0eWxlXCIpIHtcbiAgICByZXR1cm4gYWJzb2x1dGVUb1N0eWxlc2hlZXQodmFsdWUsIGdldEhyZWYoZG9jKSk7XG4gIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gXCJvYmplY3RcIiAmJiBuYW1lID09PSBcImRhdGFcIikge1xuICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xuICB9XG4gIGlmICh0eXBlb2YgbWFza0F0dHJpYnV0ZUZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gbWFza0F0dHJpYnV0ZUZuKG5hbWUsIHZhbHVlLCBlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpZ25vcmVBdHRyaWJ1dGUodGFnTmFtZSwgbmFtZSwgX3ZhbHVlKSB7XG4gIHJldHVybiAodGFnTmFtZSA9PT0gXCJ2aWRlb1wiIHx8IHRhZ05hbWUgPT09IFwiYXVkaW9cIikgJiYgbmFtZSA9PT0gXCJhdXRvcGxheVwiO1xufVxuZnVuY3Rpb24gX2lzQmxvY2tlZEVsZW1lbnQoZWxlbWVudCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdW5ibG9ja1NlbGVjdG9yKSB7XG4gIHRyeSB7XG4gICAgaWYgKHVuYmxvY2tTZWxlY3RvciAmJiBlbGVtZW50Lm1hdGNoZXModW5ibG9ja1NlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJsb2NrQ2xhc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhibG9ja0NsYXNzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZUluZGV4ID0gZWxlbWVudC5jbGFzc0xpc3QubGVuZ3RoOyBlSW5kZXgtLTsgKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NMaXN0W2VJbmRleF07XG4gICAgICAgIGlmIChibG9ja0NsYXNzLnRlc3QoY2xhc3NOYW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChibG9ja1NlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKGJsb2NrU2VsZWN0b3IpO1xuICAgIH1cbiAgfSBjYXRjaCAoZTIpIHtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBlbGVtZW50Q2xhc3NNYXRjaGVzUmVnZXgoZWwsIHJlZ2V4KSB7XG4gIGZvciAobGV0IGVJbmRleCA9IGVsLmNsYXNzTGlzdC5sZW5ndGg7IGVJbmRleC0tOyApIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBlbC5jbGFzc0xpc3RbZUluZGV4XTtcbiAgICBpZiAocmVnZXgudGVzdChjbGFzc05hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGlzdGFuY2VUb01hdGNoKG5vZGUsIG1hdGNoUHJlZGljYXRlLCBsaW1pdCA9IEluZmluaXR5LCBkaXN0YW5jZSA9IDApIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gLTE7XG4gIGlmIChub2RlLm5vZGVUeXBlICE9PSBub2RlLkVMRU1FTlRfTk9ERSkgcmV0dXJuIC0xO1xuICBpZiAoZGlzdGFuY2UgPiBsaW1pdCkgcmV0dXJuIC0xO1xuICBpZiAobWF0Y2hQcmVkaWNhdGUobm9kZSkpIHJldHVybiBkaXN0YW5jZTtcbiAgcmV0dXJuIGRpc3RhbmNlVG9NYXRjaChub2RlLnBhcmVudE5vZGUsIG1hdGNoUHJlZGljYXRlLCBsaW1pdCwgZGlzdGFuY2UgKyAxKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoUHJlZGljYXRlKGNsYXNzTmFtZSwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgY29uc3QgZWwgPSBub2RlO1xuICAgIGlmIChlbCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKGVsLm1hdGNoZXMoYC4ke2NsYXNzTmFtZX1gKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudENsYXNzTWF0Y2hlc1JlZ2V4KGVsLCBjbGFzc05hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RvciAmJiBlbC5tYXRjaGVzKHNlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbmVlZE1hc2tpbmdUZXh0KG5vZGUsIG1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IsIHVubWFza1RleHRDbGFzcywgdW5tYXNrVGV4dFNlbGVjdG9yLCBtYXNrQWxsVGV4dCkge1xuICB0cnkge1xuICAgIGNvbnN0IGVsID0gbm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5FTEVNRU5UX05PREUgPyBub2RlIDogbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIGlmIChlbCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChlbC50YWdOYW1lID09PSBcIklOUFVUXCIpIHtcbiAgICAgIGNvbnN0IGF1dG9jb21wbGV0ZSA9IGVsLmdldEF0dHJpYnV0ZShcImF1dG9jb21wbGV0ZVwiKTtcbiAgICAgIGNvbnN0IGRpc2FsbG93ZWRBdXRvY29tcGxldGVWYWx1ZXMgPSBbXG4gICAgICAgIFwiY3VycmVudC1wYXNzd29yZFwiLFxuICAgICAgICBcIm5ldy1wYXNzd29yZFwiLFxuICAgICAgICBcImNjLW51bWJlclwiLFxuICAgICAgICBcImNjLWV4cFwiLFxuICAgICAgICBcImNjLWV4cC1tb250aFwiLFxuICAgICAgICBcImNjLWV4cC15ZWFyXCIsXG4gICAgICAgIFwiY2MtY3NjXCJcbiAgICAgIF07XG4gICAgICBpZiAoZGlzYWxsb3dlZEF1dG9jb21wbGV0ZVZhbHVlcy5pbmNsdWRlcyhhdXRvY29tcGxldGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWFza0Rpc3RhbmNlID0gLTE7XG4gICAgbGV0IHVubWFza0Rpc3RhbmNlID0gLTE7XG4gICAgaWYgKG1hc2tBbGxUZXh0KSB7XG4gICAgICB1bm1hc2tEaXN0YW5jZSA9IGRpc3RhbmNlVG9NYXRjaChcbiAgICAgICAgZWwsXG4gICAgICAgIGNyZWF0ZU1hdGNoUHJlZGljYXRlKHVubWFza1RleHRDbGFzcywgdW5tYXNrVGV4dFNlbGVjdG9yKVxuICAgICAgKTtcbiAgICAgIGlmICh1bm1hc2tEaXN0YW5jZSA8IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBtYXNrRGlzdGFuY2UgPSBkaXN0YW5jZVRvTWF0Y2goXG4gICAgICAgIGVsLFxuICAgICAgICBjcmVhdGVNYXRjaFByZWRpY2F0ZShtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yKSxcbiAgICAgICAgdW5tYXNrRGlzdGFuY2UgPj0gMCA/IHVubWFza0Rpc3RhbmNlIDogSW5maW5pdHlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hc2tEaXN0YW5jZSA9IGRpc3RhbmNlVG9NYXRjaChcbiAgICAgICAgZWwsXG4gICAgICAgIGNyZWF0ZU1hdGNoUHJlZGljYXRlKG1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IpXG4gICAgICApO1xuICAgICAgaWYgKG1hc2tEaXN0YW5jZSA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdW5tYXNrRGlzdGFuY2UgPSBkaXN0YW5jZVRvTWF0Y2goXG4gICAgICAgIGVsLFxuICAgICAgICBjcmVhdGVNYXRjaFByZWRpY2F0ZSh1bm1hc2tUZXh0Q2xhc3MsIHVubWFza1RleHRTZWxlY3RvciksXG4gICAgICAgIG1hc2tEaXN0YW5jZSA+PSAwID8gbWFza0Rpc3RhbmNlIDogSW5maW5pdHlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBtYXNrRGlzdGFuY2UgPj0gMCA/IHVubWFza0Rpc3RhbmNlID49IDAgPyBtYXNrRGlzdGFuY2UgPD0gdW5tYXNrRGlzdGFuY2UgOiB0cnVlIDogdW5tYXNrRGlzdGFuY2UgPj0gMCA/IGZhbHNlIDogISFtYXNrQWxsVGV4dDtcbiAgfSBjYXRjaCAoZTIpIHtcbiAgfVxuICByZXR1cm4gISFtYXNrQWxsVGV4dDtcbn1cbmZ1bmN0aW9uIG9uY2VJZnJhbWVMb2FkZWQoaWZyYW1lRWwsIGxpc3RlbmVyLCBpZnJhbWVMb2FkVGltZW91dCkge1xuICBjb25zdCB3aW4gPSBpZnJhbWVFbC5jb250ZW50V2luZG93O1xuICBpZiAoIXdpbikge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZmlyZWQgPSBmYWxzZTtcbiAgbGV0IHJlYWR5U3RhdGU7XG4gIHRyeSB7XG4gICAgcmVhZHlTdGF0ZSA9IHdpbi5kb2N1bWVudC5yZWFkeVN0YXRlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVhZHlTdGF0ZSAhPT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0JDIoKCkgPT4ge1xuICAgICAgaWYgKCFmaXJlZCkge1xuICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgaWZyYW1lTG9hZFRpbWVvdXQpO1xuICAgIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCQxKHRpbWVyKTtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGJsYW5rVXJsID0gXCJhYm91dDpibGFua1wiO1xuICBpZiAod2luLmxvY2F0aW9uLmhyZWYgIT09IGJsYW5rVXJsIHx8IGlmcmFtZUVsLnNyYyA9PT0gYmxhbmtVcmwgfHwgaWZyYW1lRWwuc3JjID09PSBcIlwiKSB7XG4gICAgc2V0VGltZW91dCQyKGxpc3RlbmVyLCAwKTtcbiAgICByZXR1cm4gaWZyYW1lRWwuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbGlzdGVuZXIpO1xuICB9XG4gIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxpc3RlbmVyKTtcbn1cbmZ1bmN0aW9uIG9uY2VTdHlsZXNoZWV0TG9hZGVkKGxpbmssIGxpc3RlbmVyLCBzdHlsZVNoZWV0TG9hZFRpbWVvdXQpIHtcbiAgbGV0IGZpcmVkID0gZmFsc2U7XG4gIGxldCBzdHlsZVNoZWV0TG9hZGVkO1xuICB0cnkge1xuICAgIHN0eWxlU2hlZXRMb2FkZWQgPSBsaW5rLnNoZWV0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc3R5bGVTaGVldExvYWRlZCkgcmV0dXJuO1xuICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQkMigoKSA9PiB7XG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHN0eWxlU2hlZXRMb2FkVGltZW91dCk7XG4gIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgIGNsZWFyVGltZW91dCQxKHRpbWVyKTtcbiAgICBmaXJlZCA9IHRydWU7XG4gICAgbGlzdGVuZXIoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlKG4yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBkb2MsXG4gICAgbWlycm9yOiBtaXJyb3IyLFxuICAgIGJsb2NrQ2xhc3MsXG4gICAgYmxvY2tTZWxlY3RvcixcbiAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgbWFza0FsbFRleHQsXG4gICAgbWFza0F0dHJpYnV0ZUZuLFxuICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgdW5tYXNrVGV4dENsYXNzLFxuICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgdW5tYXNrVGV4dFNlbGVjdG9yLFxuICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgbWFza0lucHV0T3B0aW9ucyA9IHt9LFxuICAgIG1hc2tUZXh0Rm4sXG4gICAgbWFza0lucHV0Rm4sXG4gICAgZGF0YVVSTE9wdGlvbnMgPSB7fSxcbiAgICBpbmxpbmVJbWFnZXMsXG4gICAgcmVjb3JkQ2FudmFzLFxuICAgIGtlZXBJZnJhbWVTcmNGbixcbiAgICBuZXdseUFkZGVkRWxlbWVudCA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByb290SWQgPSBnZXRSb290SWQoZG9jLCBtaXJyb3IyKTtcbiAgc3dpdGNoIChuMi5ub2RlVHlwZSkge1xuICAgIGNhc2UgbjIuRE9DVU1FTlRfTk9ERTpcbiAgICAgIGlmIChuMi5jb21wYXRNb2RlICE9PSBcIkNTUzFDb21wYXRcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlJDIuRG9jdW1lbnQsXG4gICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgY29tcGF0TW9kZTogbjIuY29tcGF0TW9kZVxuICAgICAgICAgIC8vIHByb2JhYmx5IFwiQmFja0NvbXBhdFwiXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlJDIuRG9jdW1lbnQsXG4gICAgICAgICAgY2hpbGROb2RlczogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlIG4yLkRPQ1VNRU5UX1RZUEVfTk9ERTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE5vZGVUeXBlJDIuRG9jdW1lbnRUeXBlLFxuICAgICAgICBuYW1lOiBuMi5uYW1lLFxuICAgICAgICBwdWJsaWNJZDogbjIucHVibGljSWQsXG4gICAgICAgIHN5c3RlbUlkOiBuMi5zeXN0ZW1JZCxcbiAgICAgICAgcm9vdElkXG4gICAgICB9O1xuICAgIGNhc2UgbjIuRUxFTUVOVF9OT0RFOlxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZUVsZW1lbnROb2RlKG4yLCB7XG4gICAgICAgIGRvYyxcbiAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICBtYXNrQXR0cmlidXRlRm4sXG4gICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgIG1hc2tJbnB1dEZuLFxuICAgICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgICByZWNvcmRDYW52YXMsXG4gICAgICAgIGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQsXG4gICAgICAgIHJvb3RJZCxcbiAgICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgICAgdW5tYXNrVGV4dENsYXNzLFxuICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICB1bm1hc2tUZXh0U2VsZWN0b3JcbiAgICAgIH0pO1xuICAgIGNhc2UgbjIuVEVYVF9OT0RFOlxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRleHROb2RlKG4yLCB7XG4gICAgICAgIGRvYyxcbiAgICAgICAgbWFza0FsbFRleHQsXG4gICAgICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgIHVubWFza1RleHRDbGFzcyxcbiAgICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgdW5tYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICBtYXNrVGV4dEZuLFxuICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICBtYXNrSW5wdXRGbixcbiAgICAgICAgcm9vdElkXG4gICAgICB9KTtcbiAgICBjYXNlIG4yLkNEQVRBX1NFQ1RJT05fTk9ERTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE5vZGVUeXBlJDIuQ0RBVEEsXG4gICAgICAgIHRleHRDb250ZW50OiBcIlwiLFxuICAgICAgICByb290SWRcbiAgICAgIH07XG4gICAgY2FzZSBuMi5DT01NRU5UX05PREU6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBOb2RlVHlwZSQyLkNvbW1lbnQsXG4gICAgICAgIHRleHRDb250ZW50OiBuMi50ZXh0Q29udGVudCB8fCBcIlwiLFxuICAgICAgICByb290SWRcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Um9vdElkKGRvYywgbWlycm9yMikge1xuICBpZiAoIW1pcnJvcjIuaGFzTm9kZShkb2MpKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBkb2NJZCA9IG1pcnJvcjIuZ2V0SWQoZG9jKTtcbiAgcmV0dXJuIGRvY0lkID09PSAxID8gdm9pZCAwIDogZG9jSWQ7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVUZXh0Tm9kZShuMiwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbWFza0FsbFRleHQsXG4gICAgbWFza1RleHRDbGFzcyxcbiAgICB1bm1hc2tUZXh0Q2xhc3MsXG4gICAgbWFza1RleHRTZWxlY3RvcixcbiAgICB1bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgbWFza1RleHRGbixcbiAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgIG1hc2tJbnB1dEZuLFxuICAgIHJvb3RJZFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGFyZW50VGFnTmFtZSA9IG4yLnBhcmVudE5vZGUgJiYgbjIucGFyZW50Tm9kZS50YWdOYW1lO1xuICBsZXQgdGV4dENvbnRlbnQgPSBuMi50ZXh0Q29udGVudDtcbiAgY29uc3QgaXNTdHlsZSA9IHBhcmVudFRhZ05hbWUgPT09IFwiU1RZTEVcIiA/IHRydWUgOiB2b2lkIDA7XG4gIGNvbnN0IGlzU2NyaXB0ID0gcGFyZW50VGFnTmFtZSA9PT0gXCJTQ1JJUFRcIiA/IHRydWUgOiB2b2lkIDA7XG4gIGNvbnN0IGlzVGV4dGFyZWEgPSBwYXJlbnRUYWdOYW1lID09PSBcIlRFWFRBUkVBXCIgPyB0cnVlIDogdm9pZCAwO1xuICBpZiAoaXNTdHlsZSAmJiB0ZXh0Q29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAobjIubmV4dFNpYmxpbmcgfHwgbjIucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICB9IGVsc2UgaWYgKG4yLnBhcmVudE5vZGUuc2hlZXQ/LmNzc1J1bGVzKSB7XG4gICAgICAgIHRleHRDb250ZW50ID0gc3RyaW5naWZ5U3R5bGVzaGVldChcbiAgICAgICAgICBuMi5wYXJlbnROb2RlLnNoZWV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBDYW5ub3QgZ2V0IENTUyBzdHlsZXMgZnJvbSB0ZXh0J3MgcGFyZW50Tm9kZS4gRXJyb3I6ICR7ZXJyfWAsXG4gICAgICAgIG4yXG4gICAgICApO1xuICAgIH1cbiAgICB0ZXh0Q29udGVudCA9IGFic29sdXRlVG9TdHlsZXNoZWV0KHRleHRDb250ZW50LCBnZXRIcmVmKG9wdGlvbnMuZG9jKSk7XG4gIH1cbiAgaWYgKGlzU2NyaXB0KSB7XG4gICAgdGV4dENvbnRlbnQgPSBcIlNDUklQVF9QTEFDRUhPTERFUlwiO1xuICB9XG4gIGNvbnN0IGZvcmNlTWFzayA9IG5lZWRNYXNraW5nVGV4dChcbiAgICBuMixcbiAgICBtYXNrVGV4dENsYXNzLFxuICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgdW5tYXNrVGV4dENsYXNzLFxuICAgIHVubWFza1RleHRTZWxlY3RvcixcbiAgICBtYXNrQWxsVGV4dFxuICApO1xuICBpZiAoIWlzU3R5bGUgJiYgIWlzU2NyaXB0ICYmICFpc1RleHRhcmVhICYmIHRleHRDb250ZW50ICYmIGZvcmNlTWFzaykge1xuICAgIHRleHRDb250ZW50ID0gbWFza1RleHRGbiA/IG1hc2tUZXh0Rm4odGV4dENvbnRlbnQsIG4yLnBhcmVudEVsZW1lbnQpIDogdGV4dENvbnRlbnQucmVwbGFjZSgvW1xcU10vZywgXCIqXCIpO1xuICB9XG4gIGlmIChpc1RleHRhcmVhICYmIHRleHRDb250ZW50ICYmIChtYXNrSW5wdXRPcHRpb25zLnRleHRhcmVhIHx8IGZvcmNlTWFzaykpIHtcbiAgICB0ZXh0Q29udGVudCA9IG1hc2tJbnB1dEZuID8gbWFza0lucHV0Rm4odGV4dENvbnRlbnQsIG4yLnBhcmVudE5vZGUpIDogdGV4dENvbnRlbnQucmVwbGFjZSgvW1xcU10vZywgXCIqXCIpO1xuICB9XG4gIGlmIChwYXJlbnRUYWdOYW1lID09PSBcIk9QVElPTlwiICYmIHRleHRDb250ZW50KSB7XG4gICAgY29uc3QgaXNJbnB1dE1hc2tlZCA9IHNob3VsZE1hc2tJbnB1dCh7XG4gICAgICB0eXBlOiBudWxsLFxuICAgICAgdGFnTmFtZTogcGFyZW50VGFnTmFtZSxcbiAgICAgIG1hc2tJbnB1dE9wdGlvbnNcbiAgICB9KTtcbiAgICB0ZXh0Q29udGVudCA9IG1hc2tJbnB1dFZhbHVlKHtcbiAgICAgIGlzTWFza2VkOiBuZWVkTWFza2luZ1RleHQoXG4gICAgICAgIG4yLFxuICAgICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICB1bm1hc2tUZXh0Q2xhc3MsXG4gICAgICAgIHVubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgaXNJbnB1dE1hc2tlZFxuICAgICAgKSxcbiAgICAgIGVsZW1lbnQ6IG4yLFxuICAgICAgdmFsdWU6IHRleHRDb250ZW50LFxuICAgICAgbWFza0lucHV0Rm5cbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IE5vZGVUeXBlJDIuVGV4dCxcbiAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnQgfHwgXCJcIixcbiAgICBpc1N0eWxlLFxuICAgIHJvb3RJZFxuICB9O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRWxlbWVudE5vZGUobjIsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGRvYyxcbiAgICBibG9ja0NsYXNzLFxuICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgbWFza0lucHV0T3B0aW9ucyA9IHt9LFxuICAgIG1hc2tBdHRyaWJ1dGVGbixcbiAgICBtYXNrSW5wdXRGbixcbiAgICBkYXRhVVJMT3B0aW9ucyA9IHt9LFxuICAgIGlubGluZUltYWdlcyxcbiAgICByZWNvcmRDYW52YXMsXG4gICAga2VlcElmcmFtZVNyY0ZuLFxuICAgIG5ld2x5QWRkZWRFbGVtZW50ID0gZmFsc2UsXG4gICAgcm9vdElkLFxuICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgdW5tYXNrVGV4dENsYXNzLFxuICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgdW5tYXNrVGV4dFNlbGVjdG9yXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBuZWVkQmxvY2sgPSBfaXNCbG9ja2VkRWxlbWVudChcbiAgICBuMixcbiAgICBibG9ja0NsYXNzLFxuICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgdW5ibG9ja1NlbGVjdG9yXG4gICk7XG4gIGNvbnN0IHRhZ05hbWUgPSBnZXRWYWxpZFRhZ05hbWUkMShuMik7XG4gIGxldCBhdHRyaWJ1dGVzMiA9IHt9O1xuICBjb25zdCBsZW4gPSBuMi5hdHRyaWJ1dGVzLmxlbmd0aDtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGxlbjsgaTIrKykge1xuICAgIGNvbnN0IGF0dHIgPSBuMi5hdHRyaWJ1dGVzW2kyXTtcbiAgICBpZiAoYXR0ci5uYW1lICYmICFpZ25vcmVBdHRyaWJ1dGUodGFnTmFtZSwgYXR0ci5uYW1lLCBhdHRyLnZhbHVlKSkge1xuICAgICAgYXR0cmlidXRlczJbYXR0ci5uYW1lXSA9IHRyYW5zZm9ybUF0dHJpYnV0ZShcbiAgICAgICAgZG9jLFxuICAgICAgICB0YWdOYW1lLFxuICAgICAgICB0b0xvd2VyQ2FzZShhdHRyLm5hbWUpLFxuICAgICAgICBhdHRyLnZhbHVlLFxuICAgICAgICBuMixcbiAgICAgICAgbWFza0F0dHJpYnV0ZUZuXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgaW5saW5lU3R5bGVzaGVldCkge1xuICAgIGNvbnN0IHN0eWxlc2hlZXQgPSBBcnJheS5mcm9tKGRvYy5zdHlsZVNoZWV0cykuZmluZCgoczIpID0+IHtcbiAgICAgIHJldHVybiBzMi5ocmVmID09PSBuMi5ocmVmO1xuICAgIH0pO1xuICAgIGxldCBjc3NUZXh0ID0gbnVsbDtcbiAgICBpZiAoc3R5bGVzaGVldCkge1xuICAgICAgY3NzVGV4dCA9IHN0cmluZ2lmeVN0eWxlc2hlZXQoc3R5bGVzaGVldCk7XG4gICAgfVxuICAgIGlmIChjc3NUZXh0KSB7XG4gICAgICBhdHRyaWJ1dGVzMi5yZWwgPSBudWxsO1xuICAgICAgYXR0cmlidXRlczIuaHJlZiA9IG51bGw7XG4gICAgICBhdHRyaWJ1dGVzMi5jcm9zc29yaWdpbiA9IG51bGw7XG4gICAgICBhdHRyaWJ1dGVzMi5fY3NzVGV4dCA9IGFic29sdXRlVG9TdHlsZXNoZWV0KGNzc1RleHQsIHN0eWxlc2hlZXQuaHJlZik7XG4gICAgfVxuICB9XG4gIGlmICh0YWdOYW1lID09PSBcInN0eWxlXCIgJiYgbjIuc2hlZXQgJiYgLy8gVE9ETzogQ3VycmVudGx5IHdlIG9ubHkgdHJ5IHRvIGdldCBkeW5hbWljIHN0eWxlc2hlZXQgd2hlbiBpdCBpcyBhbiBlbXB0eSBzdHlsZSBlbGVtZW50XG4gICEobjIuaW5uZXJUZXh0IHx8IG4yLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKS5sZW5ndGgpIHtcbiAgICBjb25zdCBjc3NUZXh0ID0gc3RyaW5naWZ5U3R5bGVzaGVldChcbiAgICAgIG4yLnNoZWV0XG4gICAgKTtcbiAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgYXR0cmlidXRlczIuX2Nzc1RleHQgPSBhYnNvbHV0ZVRvU3R5bGVzaGVldChjc3NUZXh0LCBnZXRIcmVmKGRvYykpO1xuICAgIH1cbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJpbnB1dFwiIHx8IHRhZ05hbWUgPT09IFwidGV4dGFyZWFcIiB8fCB0YWdOYW1lID09PSBcInNlbGVjdFwiIHx8IHRhZ05hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgICBjb25zdCBlbCA9IG4yO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRJbnB1dFR5cGUoZWwpO1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0SW5wdXRWYWx1ZShlbCwgdG9VcHBlckNhc2UodGFnTmFtZSksIHR5cGUpO1xuICAgIGNvbnN0IGNoZWNrZWQgPSBlbC5jaGVja2VkO1xuICAgIGlmICh0eXBlICE9PSBcInN1Ym1pdFwiICYmIHR5cGUgIT09IFwiYnV0dG9uXCIgJiYgdmFsdWUpIHtcbiAgICAgIGNvbnN0IGZvcmNlTWFzayA9IG5lZWRNYXNraW5nVGV4dChcbiAgICAgICAgZWwsXG4gICAgICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgIHVubWFza1RleHRDbGFzcyxcbiAgICAgICAgdW5tYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICBzaG91bGRNYXNrSW5wdXQoe1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgdGFnTmFtZTogdG9VcHBlckNhc2UodGFnTmFtZSksXG4gICAgICAgICAgbWFza0lucHV0T3B0aW9uc1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGF0dHJpYnV0ZXMyLnZhbHVlID0gbWFza0lucHV0VmFsdWUoe1xuICAgICAgICBpc01hc2tlZDogZm9yY2VNYXNrLFxuICAgICAgICBlbGVtZW50OiBlbCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG1hc2tJbnB1dEZuXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgIGF0dHJpYnV0ZXMyLmNoZWNrZWQgPSBjaGVja2VkO1xuICAgIH1cbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJvcHRpb25cIikge1xuICAgIGlmIChuMi5zZWxlY3RlZCAmJiAhbWFza0lucHV0T3B0aW9uc1tcInNlbGVjdFwiXSkge1xuICAgICAgYXR0cmlidXRlczIuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgYXR0cmlidXRlczIuc2VsZWN0ZWQ7XG4gICAgfVxuICB9XG4gIGlmICh0YWdOYW1lID09PSBcImNhbnZhc1wiICYmIHJlY29yZENhbnZhcykge1xuICAgIGlmIChuMi5fX2NvbnRleHQgPT09IFwiMmRcIikge1xuICAgICAgaWYgKCFpczJEQ2FudmFzQmxhbmsobjIpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMyLnJyX2RhdGFVUkwgPSBuMi50b0RhdGFVUkwoXG4gICAgICAgICAgZGF0YVVSTE9wdGlvbnMudHlwZSxcbiAgICAgICAgICBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFwiX19jb250ZXh0XCIgaW4gbjIpKSB7XG4gICAgICBjb25zdCBjYW52YXNEYXRhVVJMID0gbjIudG9EYXRhVVJMKFxuICAgICAgICBkYXRhVVJMT3B0aW9ucy50eXBlLFxuICAgICAgICBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5XG4gICAgICApO1xuICAgICAgY29uc3QgYmxhbmtDYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIGJsYW5rQ2FudmFzLndpZHRoID0gbjIud2lkdGg7XG4gICAgICBibGFua0NhbnZhcy5oZWlnaHQgPSBuMi5oZWlnaHQ7XG4gICAgICBjb25zdCBibGFua0NhbnZhc0RhdGFVUkwgPSBibGFua0NhbnZhcy50b0RhdGFVUkwoXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLnR5cGUsXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLnF1YWxpdHlcbiAgICAgICk7XG4gICAgICBpZiAoY2FudmFzRGF0YVVSTCAhPT0gYmxhbmtDYW52YXNEYXRhVVJMKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMyLnJyX2RhdGFVUkwgPSBjYW52YXNEYXRhVVJMO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJpbWdcIiAmJiBpbmxpbmVJbWFnZXMpIHtcbiAgICBpZiAoIWNhbnZhc1NlcnZpY2UpIHtcbiAgICAgIGNhbnZhc1NlcnZpY2UgPSBkb2MuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIGNhbnZhc0N0eCA9IGNhbnZhc1NlcnZpY2UuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZSA9IG4yO1xuICAgIGNvbnN0IGltYWdlU3JjID0gaW1hZ2UuY3VycmVudFNyYyB8fCBpbWFnZS5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgfHwgXCI8dW5rbm93bi1zcmM+XCI7XG4gICAgY29uc3QgcHJpb3JDcm9zc09yaWdpbiA9IGltYWdlLmNyb3NzT3JpZ2luO1xuICAgIGNvbnN0IHJlY29yZElubGluZUltYWdlID0gKCkgPT4ge1xuICAgICAgaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVjb3JkSW5saW5lSW1hZ2UpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FudmFzU2VydmljZS53aWR0aCA9IGltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgY2FudmFzU2VydmljZS5oZWlnaHQgPSBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICBjYW52YXNDdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgICAgICAgYXR0cmlidXRlczIucnJfZGF0YVVSTCA9IGNhbnZhc1NlcnZpY2UudG9EYXRhVVJMKFxuICAgICAgICAgIGRhdGFVUkxPcHRpb25zLnR5cGUsXG4gICAgICAgICAgZGF0YVVSTE9wdGlvbnMucXVhbGl0eVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChpbWFnZS5jcm9zc09yaWdpbiAhPT0gXCJhbm9ueW1vdXNcIikge1xuICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICAgICAgICBpZiAoaW1hZ2UuY29tcGxldGUgJiYgaW1hZ2UubmF0dXJhbFdpZHRoICE9PSAwKVxuICAgICAgICAgICAgcmVjb3JkSW5saW5lSW1hZ2UoKTtcbiAgICAgICAgICBlbHNlIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlY29yZElubGluZUltYWdlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYENhbm5vdCBpbmxpbmUgaW1nIHNyYz0ke2ltYWdlU3JjfSEgRXJyb3I6ICR7ZXJyfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW1hZ2UuY3Jvc3NPcmlnaW4gPT09IFwiYW5vbnltb3VzXCIpIHtcbiAgICAgICAgcHJpb3JDcm9zc09yaWdpbiA/IGF0dHJpYnV0ZXMyLmNyb3NzT3JpZ2luID0gcHJpb3JDcm9zc09yaWdpbiA6IGltYWdlLnJlbW92ZUF0dHJpYnV0ZShcImNyb3Nzb3JpZ2luXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGltYWdlLmNvbXBsZXRlICYmIGltYWdlLm5hdHVyYWxXaWR0aCAhPT0gMCkgcmVjb3JkSW5saW5lSW1hZ2UoKTtcbiAgICBlbHNlIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlY29yZElubGluZUltYWdlKTtcbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJhdWRpb1wiIHx8IHRhZ05hbWUgPT09IFwidmlkZW9cIikge1xuICAgIGF0dHJpYnV0ZXMyLnJyX21lZGlhU3RhdGUgPSBuMi5wYXVzZWQgPyBcInBhdXNlZFwiIDogXCJwbGF5ZWRcIjtcbiAgICBhdHRyaWJ1dGVzMi5ycl9tZWRpYUN1cnJlbnRUaW1lID0gbjIuY3VycmVudFRpbWU7XG4gIH1cbiAgaWYgKCFuZXdseUFkZGVkRWxlbWVudCkge1xuICAgIGlmIChuMi5zY3JvbGxMZWZ0KSB7XG4gICAgICBhdHRyaWJ1dGVzMi5ycl9zY3JvbGxMZWZ0ID0gbjIuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgaWYgKG4yLnNjcm9sbFRvcCkge1xuICAgICAgYXR0cmlidXRlczIucnJfc2Nyb2xsVG9wID0gbjIuc2Nyb2xsVG9wO1xuICAgIH1cbiAgfVxuICBpZiAobmVlZEJsb2NrKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBuMi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBhdHRyaWJ1dGVzMiA9IHtcbiAgICAgIGNsYXNzOiBhdHRyaWJ1dGVzMi5jbGFzcyxcbiAgICAgIHJyX3dpZHRoOiBgJHt3aWR0aH1weGAsXG4gICAgICBycl9oZWlnaHQ6IGAke2hlaWdodH1weGBcbiAgICB9O1xuICB9XG4gIGlmICh0YWdOYW1lID09PSBcImlmcmFtZVwiICYmICFrZWVwSWZyYW1lU3JjRm4oYXR0cmlidXRlczIuc3JjKSkge1xuICAgIGlmICghbmVlZEJsb2NrICYmICFnZXRJZnJhbWVDb250ZW50RG9jdW1lbnQobjIpKSB7XG4gICAgICBhdHRyaWJ1dGVzMi5ycl9zcmMgPSBhdHRyaWJ1dGVzMi5zcmM7XG4gICAgfVxuICAgIGRlbGV0ZSBhdHRyaWJ1dGVzMi5zcmM7XG4gIH1cbiAgbGV0IGlzQ3VzdG9tRWxlbWVudDtcbiAgdHJ5IHtcbiAgICBpZiAoY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSBpc0N1c3RvbUVsZW1lbnQgPSB0cnVlO1xuICB9IGNhdGNoIChlMikge1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogTm9kZVR5cGUkMi5FbGVtZW50LFxuICAgIHRhZ05hbWUsXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlczIsXG4gICAgY2hpbGROb2RlczogW10sXG4gICAgaXNTVkc6IGlzU1ZHRWxlbWVudChuMikgfHwgdm9pZCAwLFxuICAgIG5lZWRCbG9jayxcbiAgICByb290SWQsXG4gICAgaXNDdXN0b206IGlzQ3VzdG9tRWxlbWVudFxuICB9O1xufVxuZnVuY3Rpb24gbG93ZXJJZkV4aXN0cyhtYXliZUF0dHIpIHtcbiAgaWYgKG1heWJlQXR0ciA9PT0gdm9pZCAwIHx8IG1heWJlQXR0ciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYXliZUF0dHIudG9Mb3dlckNhc2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gc2xpbURPTUV4Y2x1ZGVkKHNuLCBzbGltRE9NT3B0aW9ucykge1xuICBpZiAoc2xpbURPTU9wdGlvbnMuY29tbWVudCAmJiBzbi50eXBlID09PSBOb2RlVHlwZSQyLkNvbW1lbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzbi50eXBlID09PSBOb2RlVHlwZSQyLkVsZW1lbnQpIHtcbiAgICBpZiAoc2xpbURPTU9wdGlvbnMuc2NyaXB0ICYmIC8vIHNjcmlwdCB0YWdcbiAgICAoc24udGFnTmFtZSA9PT0gXCJzY3JpcHRcIiB8fCAvLyAobW9kdWxlKXByZWxvYWQgbGlua1xuICAgIHNuLnRhZ05hbWUgPT09IFwibGlua1wiICYmIChzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJwcmVsb2FkXCIgfHwgc24uYXR0cmlidXRlcy5yZWwgPT09IFwibW9kdWxlcHJlbG9hZFwiKSB8fCAvLyBwcmVmZXRjaCBsaW5rXG4gICAgc24udGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgc24uYXR0cmlidXRlcy5yZWwgPT09IFwicHJlZmV0Y2hcIiAmJiB0eXBlb2Ygc24uYXR0cmlidXRlcy5ocmVmID09PSBcInN0cmluZ1wiICYmIGV4dHJhY3RGaWxlRXh0ZW5zaW9uKHNuLmF0dHJpYnV0ZXMuaHJlZikgPT09IFwianNcIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZEZhdmljb24gJiYgKHNuLnRhZ05hbWUgPT09IFwibGlua1wiICYmIHNuLmF0dHJpYnV0ZXMucmVsID09PSBcInNob3J0Y3V0IGljb25cIiB8fCBzbi50YWdOYW1lID09PSBcIm1ldGFcIiAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpLm1hdGNoKFxuICAgICAgL15tc2FwcGxpY2F0aW9uLXRpbGUoaW1hZ2V8Y29sb3IpJC9cbiAgICApIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJhcHBsaWNhdGlvbi1uYW1lXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09IFwiaWNvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSBcImFwcGxlLXRvdWNoLWljb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gXCJzaG9ydGN1dCBpY29uXCIpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChzbi50YWdOYW1lID09PSBcIm1ldGFcIikge1xuICAgICAgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhRGVzY0tleXdvcmRzICYmIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXmRlc2NyaXB0aW9ufGtleXdvcmRzJC8pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVNvY2lhbCAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXihvZ3x0d2l0dGVyfGZiKTovKSB8fCAvLyBvZyA9IG9wZW5ncmFwaCAoZmFjZWJvb2spXG4gICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkubWF0Y2goL14ob2d8dHdpdHRlcik6LykgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInBpbnRlcmVzdFwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFSb2JvdHMgJiYgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJyb2JvdHNcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiZ29vZ2xlYm90XCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImJpbmdib3RcIikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhSHR0cEVxdWl2ICYmIHNuLmF0dHJpYnV0ZXNbXCJodHRwLWVxdWl2XCJdICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhQXV0aG9yc2hpcCAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImF1dGhvclwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJnZW5lcmF0b3JcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiZnJhbWV3b3JrXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInB1Ymxpc2hlclwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJwcm9naWRcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9eYXJ0aWNsZTovKSB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9ecHJvZHVjdDovKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhVmVyaWZpY2F0aW9uICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiZ29vZ2xlLXNpdGUtdmVyaWZpY2F0aW9uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInlhbmRleC12ZXJpZmljYXRpb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiY3NyZi10b2tlblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJwOmRvbWFpbl92ZXJpZnlcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwidmVyaWZ5LXYxXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInZlcmlmaWNhdGlvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJzaG9waWZ5LWNoZWNrb3V0LWFwaS10b2tlblwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTm9kZVdpdGhJZChuMiwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgZG9jLFxuICAgIG1pcnJvcjogbWlycm9yMixcbiAgICBibG9ja0NsYXNzLFxuICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgIG1hc2tBbGxUZXh0LFxuICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgdW5tYXNrVGV4dENsYXNzLFxuICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgdW5tYXNrVGV4dFNlbGVjdG9yLFxuICAgIHNraXBDaGlsZCA9IGZhbHNlLFxuICAgIGlubGluZVN0eWxlc2hlZXQgPSB0cnVlLFxuICAgIG1hc2tJbnB1dE9wdGlvbnMgPSB7fSxcbiAgICBtYXNrQXR0cmlidXRlRm4sXG4gICAgbWFza1RleHRGbixcbiAgICBtYXNrSW5wdXRGbixcbiAgICBzbGltRE9NT3B0aW9ucyxcbiAgICBkYXRhVVJMT3B0aW9ucyA9IHt9LFxuICAgIGlubGluZUltYWdlcyA9IGZhbHNlLFxuICAgIHJlY29yZENhbnZhcyA9IGZhbHNlLFxuICAgIG9uU2VyaWFsaXplLFxuICAgIG9uSWZyYW1lTG9hZCxcbiAgICBpZnJhbWVMb2FkVGltZW91dCA9IDVlMyxcbiAgICBvblN0eWxlc2hlZXRMb2FkLFxuICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCA9IDVlMyxcbiAgICBrZWVwSWZyYW1lU3JjRm4gPSAoKSA9PiBmYWxzZSxcbiAgICBuZXdseUFkZGVkRWxlbWVudCA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgeyBwcmVzZXJ2ZVdoaXRlU3BhY2UgPSB0cnVlIH0gPSBvcHRpb25zO1xuICBjb25zdCBfc2VyaWFsaXplZE5vZGUgPSBzZXJpYWxpemVOb2RlKG4yLCB7XG4gICAgZG9jLFxuICAgIG1pcnJvcjogbWlycm9yMixcbiAgICBibG9ja0NsYXNzLFxuICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgbWFza0FsbFRleHQsXG4gICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgdW5tYXNrVGV4dENsYXNzLFxuICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgdW5tYXNrVGV4dFNlbGVjdG9yLFxuICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICBtYXNrQXR0cmlidXRlRm4sXG4gICAgbWFza1RleHRGbixcbiAgICBtYXNrSW5wdXRGbixcbiAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICBpbmxpbmVJbWFnZXMsXG4gICAgcmVjb3JkQ2FudmFzLFxuICAgIGtlZXBJZnJhbWVTcmNGbixcbiAgICBuZXdseUFkZGVkRWxlbWVudFxuICB9KTtcbiAgaWYgKCFfc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zb2xlLndhcm4objIsIFwibm90IHNlcmlhbGl6ZWRcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGlkO1xuICBpZiAobWlycm9yMi5oYXNOb2RlKG4yKSkge1xuICAgIGlkID0gbWlycm9yMi5nZXRJZChuMik7XG4gIH0gZWxzZSBpZiAoc2xpbURPTUV4Y2x1ZGVkKF9zZXJpYWxpemVkTm9kZSwgc2xpbURPTU9wdGlvbnMpIHx8ICFwcmVzZXJ2ZVdoaXRlU3BhY2UgJiYgX3NlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDIuVGV4dCAmJiAhX3NlcmlhbGl6ZWROb2RlLmlzU3R5bGUgJiYgIV9zZXJpYWxpemVkTm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nbSwgXCJcIikubGVuZ3RoKSB7XG4gICAgaWQgPSBJR05PUkVEX05PREU7XG4gIH0gZWxzZSB7XG4gICAgaWQgPSBnZW5JZCgpO1xuICB9XG4gIGNvbnN0IHNlcmlhbGl6ZWROb2RlMiA9IE9iamVjdC5hc3NpZ24oX3NlcmlhbGl6ZWROb2RlLCB7IGlkIH0pO1xuICBtaXJyb3IyLmFkZChuMiwgc2VyaWFsaXplZE5vZGUyKTtcbiAgaWYgKGlkID09PSBJR05PUkVEX05PREUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob25TZXJpYWxpemUpIHtcbiAgICBvblNlcmlhbGl6ZShuMik7XG4gIH1cbiAgbGV0IHJlY29yZENoaWxkID0gIXNraXBDaGlsZDtcbiAgaWYgKHNlcmlhbGl6ZWROb2RlMi50eXBlID09PSBOb2RlVHlwZSQyLkVsZW1lbnQpIHtcbiAgICByZWNvcmRDaGlsZCA9IHJlY29yZENoaWxkICYmICFzZXJpYWxpemVkTm9kZTIubmVlZEJsb2NrO1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkTm9kZTIubmVlZEJsb2NrO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBuMi5zaGFkb3dSb290O1xuICAgIGlmIChzaGFkb3dSb290ICYmIGlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3QpKVxuICAgICAgc2VyaWFsaXplZE5vZGUyLmlzU2hhZG93SG9zdCA9IHRydWU7XG4gIH1cbiAgaWYgKChzZXJpYWxpemVkTm9kZTIudHlwZSA9PT0gTm9kZVR5cGUkMi5Eb2N1bWVudCB8fCBzZXJpYWxpemVkTm9kZTIudHlwZSA9PT0gTm9kZVR5cGUkMi5FbGVtZW50KSAmJiByZWNvcmRDaGlsZCkge1xuICAgIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkV2hpdGVzcGFjZSAmJiBzZXJpYWxpemVkTm9kZTIudHlwZSA9PT0gTm9kZVR5cGUkMi5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlMi50YWdOYW1lID09PSBcImhlYWRcIikge1xuICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGJ5cGFzc09wdGlvbnMgPSB7XG4gICAgICBkb2MsXG4gICAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIG1hc2tBbGxUZXh0LFxuICAgICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgIHVubWFza1RleHRDbGFzcyxcbiAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICB1bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICBza2lwQ2hpbGQsXG4gICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgIG1hc2tBdHRyaWJ1dGVGbixcbiAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICBtYXNrSW5wdXRGbixcbiAgICAgIHNsaW1ET01PcHRpb25zLFxuICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICBpbmxpbmVJbWFnZXMsXG4gICAgICByZWNvcmRDYW52YXMsXG4gICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UsXG4gICAgICBvblNlcmlhbGl6ZSxcbiAgICAgIG9uSWZyYW1lTG9hZCxcbiAgICAgIGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICAgIGtlZXBJZnJhbWVTcmNGblxuICAgIH07XG4gICAgZm9yIChjb25zdCBjaGlsZE4gb2YgQXJyYXkuZnJvbShuMi5jaGlsZE5vZGVzKSkge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZENoaWxkTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoY2hpbGROLCBieXBhc3NPcHRpb25zKTtcbiAgICAgIGlmIChzZXJpYWxpemVkQ2hpbGROb2RlKSB7XG4gICAgICAgIHNlcmlhbGl6ZWROb2RlMi5jaGlsZE5vZGVzLnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnQkMShuMikgJiYgbjIuc2hhZG93Um9vdCkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZE4gb2YgQXJyYXkuZnJvbShuMi5zaGFkb3dSb290LmNoaWxkTm9kZXMpKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKGNoaWxkTiwgYnlwYXNzT3B0aW9ucyk7XG4gICAgICAgIGlmIChzZXJpYWxpemVkQ2hpbGROb2RlKSB7XG4gICAgICAgICAgaXNOYXRpdmVTaGFkb3dEb20objIuc2hhZG93Um9vdCkgJiYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUuaXNTaGFkb3cgPSB0cnVlKTtcbiAgICAgICAgICBzZXJpYWxpemVkTm9kZTIuY2hpbGROb2Rlcy5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChuMi5wYXJlbnROb2RlICYmIGlzU2hhZG93Um9vdChuMi5wYXJlbnROb2RlKSAmJiBpc05hdGl2ZVNoYWRvd0RvbShuMi5wYXJlbnROb2RlKSkge1xuICAgIHNlcmlhbGl6ZWROb2RlMi5pc1NoYWRvdyA9IHRydWU7XG4gIH1cbiAgaWYgKHNlcmlhbGl6ZWROb2RlMi50eXBlID09PSBOb2RlVHlwZSQyLkVsZW1lbnQgJiYgc2VyaWFsaXplZE5vZGUyLnRhZ05hbWUgPT09IFwiaWZyYW1lXCIgJiYgIV9pc0Jsb2NrZWRFbGVtZW50KFxuICAgIG4yLFxuICAgIGJsb2NrQ2xhc3MsXG4gICAgYmxvY2tTZWxlY3RvcixcbiAgICB1bmJsb2NrU2VsZWN0b3JcbiAgKSkge1xuICAgIG9uY2VJZnJhbWVMb2FkZWQoXG4gICAgICBuMixcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3QgaWZyYW1lRG9jID0gZ2V0SWZyYW1lQ29udGVudERvY3VtZW50KG4yKTtcbiAgICAgICAgaWYgKGlmcmFtZURvYyAmJiBvbklmcmFtZUxvYWQpIHtcbiAgICAgICAgICBjb25zdCBzZXJpYWxpemVkSWZyYW1lTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoaWZyYW1lRG9jLCB7XG4gICAgICAgICAgICBkb2M6IGlmcmFtZURvYyxcbiAgICAgICAgICAgIG1pcnJvcjogbWlycm9yMixcbiAgICAgICAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgbWFza0FsbFRleHQsXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgdW5tYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgIHVubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgIHNraXBDaGlsZDogZmFsc2UsXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgIG1hc2tBdHRyaWJ1dGVGbixcbiAgICAgICAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICAgICAgICBtYXNrSW5wdXRGbixcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UsXG4gICAgICAgICAgICBvblNlcmlhbGl6ZSxcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZCxcbiAgICAgICAgICAgIGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChzZXJpYWxpemVkSWZyYW1lTm9kZSkge1xuICAgICAgICAgICAgb25JZnJhbWVMb2FkKFxuICAgICAgICAgICAgICBuMixcbiAgICAgICAgICAgICAgc2VyaWFsaXplZElmcmFtZU5vZGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaWZyYW1lTG9hZFRpbWVvdXRcbiAgICApO1xuICB9XG4gIGlmIChzZXJpYWxpemVkTm9kZTIudHlwZSA9PT0gTm9kZVR5cGUkMi5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlMi50YWdOYW1lID09PSBcImxpbmtcIiAmJiB0eXBlb2Ygc2VyaWFsaXplZE5vZGUyLmF0dHJpYnV0ZXMucmVsID09PSBcInN0cmluZ1wiICYmIChzZXJpYWxpemVkTm9kZTIuYXR0cmlidXRlcy5yZWwgPT09IFwic3R5bGVzaGVldFwiIHx8IHNlcmlhbGl6ZWROb2RlMi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJwcmVsb2FkXCIgJiYgdHlwZW9mIHNlcmlhbGl6ZWROb2RlMi5hdHRyaWJ1dGVzLmhyZWYgPT09IFwic3RyaW5nXCIgJiYgZXh0cmFjdEZpbGVFeHRlbnNpb24oc2VyaWFsaXplZE5vZGUyLmF0dHJpYnV0ZXMuaHJlZikgPT09IFwiY3NzXCIpKSB7XG4gICAgb25jZVN0eWxlc2hlZXRMb2FkZWQoXG4gICAgICBuMixcbiAgICAgICgpID0+IHtcbiAgICAgICAgaWYgKG9uU3R5bGVzaGVldExvYWQpIHtcbiAgICAgICAgICBjb25zdCBzZXJpYWxpemVkTGlua05vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCB7XG4gICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgICAgICAgICBibG9ja0NsYXNzLFxuICAgICAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgIG1hc2tBbGxUZXh0LFxuICAgICAgICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgIHVubWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgICB1bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxuICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICBtYXNrQXR0cmlidXRlRm4sXG4gICAgICAgICAgICBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgbWFza0lucHV0Rm4sXG4gICAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgICAgICAgICAgb25TZXJpYWxpemUsXG4gICAgICAgICAgICBvbklmcmFtZUxvYWQsXG4gICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dCxcbiAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQsXG4gICAgICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc2VyaWFsaXplZExpbmtOb2RlKSB7XG4gICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkKFxuICAgICAgICAgICAgICBuMixcbiAgICAgICAgICAgICAgc2VyaWFsaXplZExpbmtOb2RlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWROb2RlMjtcbn1cbmZ1bmN0aW9uIHNuYXBzaG90KG4yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBtaXJyb3I6IG1pcnJvcjIgPSBuZXcgTWlycm9yKCksXG4gICAgYmxvY2tDbGFzcyA9IFwicnItYmxvY2tcIixcbiAgICBibG9ja1NlbGVjdG9yID0gbnVsbCxcbiAgICB1bmJsb2NrU2VsZWN0b3IgPSBudWxsLFxuICAgIG1hc2tBbGxUZXh0ID0gZmFsc2UsXG4gICAgbWFza1RleHRDbGFzcyA9IFwicnItbWFza1wiLFxuICAgIHVubWFza1RleHRDbGFzcyA9IG51bGwsXG4gICAgbWFza1RleHRTZWxlY3RvciA9IG51bGwsXG4gICAgdW5tYXNrVGV4dFNlbGVjdG9yID0gbnVsbCxcbiAgICBpbmxpbmVTdHlsZXNoZWV0ID0gdHJ1ZSxcbiAgICBpbmxpbmVJbWFnZXMgPSBmYWxzZSxcbiAgICByZWNvcmRDYW52YXMgPSBmYWxzZSxcbiAgICBtYXNrQWxsSW5wdXRzID0gZmFsc2UsXG4gICAgbWFza0F0dHJpYnV0ZUZuLFxuICAgIG1hc2tUZXh0Rm4sXG4gICAgbWFza0lucHV0Rm4sXG4gICAgc2xpbURPTSA9IGZhbHNlLFxuICAgIGRhdGFVUkxPcHRpb25zLFxuICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcbiAgICBvblNlcmlhbGl6ZSxcbiAgICBvbklmcmFtZUxvYWQsXG4gICAgaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAga2VlcElmcmFtZVNyY0ZuID0gKCkgPT4gZmFsc2VcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlID8ge1xuICAgIGNvbG9yOiB0cnVlLFxuICAgIGRhdGU6IHRydWUsXG4gICAgXCJkYXRldGltZS1sb2NhbFwiOiB0cnVlLFxuICAgIGVtYWlsOiB0cnVlLFxuICAgIG1vbnRoOiB0cnVlLFxuICAgIG51bWJlcjogdHJ1ZSxcbiAgICByYW5nZTogdHJ1ZSxcbiAgICBzZWFyY2g6IHRydWUsXG4gICAgdGVsOiB0cnVlLFxuICAgIHRleHQ6IHRydWUsXG4gICAgdGltZTogdHJ1ZSxcbiAgICB1cmw6IHRydWUsXG4gICAgd2VlazogdHJ1ZSxcbiAgICB0ZXh0YXJlYTogdHJ1ZSxcbiAgICBzZWxlY3Q6IHRydWVcbiAgfSA6IG1hc2tBbGxJbnB1dHMgPT09IGZhbHNlID8ge30gOiBtYXNrQWxsSW5wdXRzO1xuICBjb25zdCBzbGltRE9NT3B0aW9ucyA9IHNsaW1ET00gPT09IHRydWUgfHwgc2xpbURPTSA9PT0gXCJhbGxcIiA/IChcbiAgICAvLyBpZiB0cnVlOiBzZXQgb2Ygc2Vuc2libGUgb3B0aW9ucyB0aGF0IHNob3VsZCBub3QgdGhyb3cgYXdheSBhbnkgaW5mb3JtYXRpb25cbiAgICB7XG4gICAgICBzY3JpcHQ6IHRydWUsXG4gICAgICBjb21tZW50OiB0cnVlLFxuICAgICAgaGVhZEZhdmljb246IHRydWUsXG4gICAgICBoZWFkV2hpdGVzcGFjZTogdHJ1ZSxcbiAgICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBzbGltRE9NID09PSBcImFsbFwiLFxuICAgICAgLy8gZGVzdHJ1Y3RpdmVcbiAgICAgIGhlYWRNZXRhU29jaWFsOiB0cnVlLFxuICAgICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXG4gICAgICBoZWFkTWV0YUh0dHBFcXVpdjogdHJ1ZSxcbiAgICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogdHJ1ZSxcbiAgICAgIGhlYWRNZXRhVmVyaWZpY2F0aW9uOiB0cnVlXG4gICAgfVxuICApIDogc2xpbURPTSA9PT0gZmFsc2UgPyB7fSA6IHNsaW1ET007XG4gIHJldHVybiBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCB7XG4gICAgZG9jOiBuMixcbiAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgYmxvY2tDbGFzcyxcbiAgICBibG9ja1NlbGVjdG9yLFxuICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICBtYXNrQWxsVGV4dCxcbiAgICBtYXNrVGV4dENsYXNzLFxuICAgIHVubWFza1RleHRDbGFzcyxcbiAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgIHVubWFza1RleHRTZWxlY3RvcixcbiAgICBza2lwQ2hpbGQ6IGZhbHNlLFxuICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICBtYXNrQXR0cmlidXRlRm4sXG4gICAgbWFza1RleHRGbixcbiAgICBtYXNrSW5wdXRGbixcbiAgICBzbGltRE9NT3B0aW9ucyxcbiAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICBpbmxpbmVJbWFnZXMsXG4gICAgcmVjb3JkQ2FudmFzLFxuICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcbiAgICBvblNlcmlhbGl6ZSxcbiAgICBvbklmcmFtZUxvYWQsXG4gICAgaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAga2VlcElmcmFtZVNyY0ZuLFxuICAgIG5ld2x5QWRkZWRFbGVtZW50OiBmYWxzZVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9uKHR5cGUsIGZuLCB0YXJnZXQgPSBkb2N1bWVudCkge1xuICBjb25zdCBvcHRpb25zID0geyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlIH07XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zKTtcbiAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zKTtcbn1cbmNvbnN0IERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyA9IFwiUGxlYXNlIHN0b3AgaW1wb3J0IG1pcnJvciBkaXJlY3RseS4gSW5zdGVhZCBvZiB0aGF0LFxcclxcbm5vdyB5b3UgY2FuIHVzZSByZXBsYXllci5nZXRNaXJyb3IoKSB0byBhY2Nlc3MgdGhlIG1pcnJvciBpbnN0YW5jZSBvZiBhIHJlcGxheWVyLFxcclxcbm9yIHlvdSBjYW4gdXNlIHJlY29yZC5taXJyb3IgdG8gYWNjZXNzIHRoZSBtaXJyb3IgaW5zdGFuY2UgZHVyaW5nIHJlY29yZGluZy5cIjtcbmxldCBfbWlycm9yID0ge1xuICBtYXA6IHt9LFxuICBnZXRJZCgpIHtcbiAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgcmV0dXJuIC0xO1xuICB9LFxuICBnZXROb2RlKCkge1xuICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgcmVtb3ZlTm9kZUZyb21NYXAoKSB7XG4gICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICB9LFxuICBoYXMoKSB7XG4gICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcmVzZXQoKSB7XG4gICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICB9XG59O1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LlByb3h5ICYmIHdpbmRvdy5SZWZsZWN0KSB7XG4gIF9taXJyb3IgPSBuZXcgUHJveHkoX21pcnJvciwge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAocHJvcCA9PT0gXCJtYXBcIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRocm90dGxlJDEoZnVuYywgd2FpdCwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkge1xuICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzO1xuICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQkMih0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQkMSgoKSA9PiB7XG4gICAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBEYXRlLm5vdygpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH0sIHJlbWFpbmluZyk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaG9va1NldHRlcih0YXJnZXQsIGtleSwgZCwgaXNSZXZva2VkLCB3aW4gPSB3aW5kb3cpIHtcbiAgY29uc3Qgb3JpZ2luYWwgPSB3aW4uT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gIHdpbi5PYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgdGFyZ2V0LFxuICAgIGtleSxcbiAgICBpc1Jldm9rZWQgPyBkIDoge1xuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIHNldFRpbWVvdXQkMSgoKSA9PiB7XG4gICAgICAgICAgZC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBpZiAob3JpZ2luYWwgJiYgb3JpZ2luYWwuc2V0KSB7XG4gICAgICAgICAgb3JpZ2luYWwuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICApO1xuICByZXR1cm4gKCkgPT4gaG9va1NldHRlcih0YXJnZXQsIGtleSwgb3JpZ2luYWwgfHwge30sIHRydWUpO1xufVxuZnVuY3Rpb24gcGF0Y2goc291cmNlLCBuYW1lLCByZXBsYWNlbWVudCkge1xuICB0cnkge1xuICAgIGlmICghKG5hbWUgaW4gc291cmNlKSkge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsID0gc291cmNlW25hbWVdO1xuICAgIGNvbnN0IHdyYXBwZWQgPSByZXBsYWNlbWVudChvcmlnaW5hbCk7XG4gICAgaWYgKHR5cGVvZiB3cmFwcGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHdyYXBwZWQucHJvdG90eXBlID0gd3JhcHBlZC5wcm90b3R5cGUgfHwge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3cmFwcGVkLCB7XG4gICAgICAgIF9fcnJ3ZWJfb3JpZ2luYWxfXzoge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgc291cmNlW25hbWVdID0gd3JhcHBlZDtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc291cmNlW25hbWVdID0gb3JpZ2luYWw7XG4gICAgfTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG59XG5sZXQgbm93VGltZXN0YW1wID0gRGF0ZS5ub3c7XG5pZiAoIS8qIEBfX1BVUkVfXyAqLyAvWzEtOV1bMC05XXsxMn0vLnRlc3QoRGF0ZS5ub3coKS50b1N0cmluZygpKSkge1xuICBub3dUaW1lc3RhbXAgPSAoKSA9PiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbCh3aW4pIHtcbiAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGRvYy5zY3JvbGxpbmdFbGVtZW50ID8gZG9jLnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCA6IHdpbi5wYWdlWE9mZnNldCAhPT0gdm9pZCAwID8gd2luLnBhZ2VYT2Zmc2V0IDogZG9jPy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2M/LmJvZHk/LnBhcmVudEVsZW1lbnQ/LnNjcm9sbExlZnQgfHwgZG9jPy5ib2R5Py5zY3JvbGxMZWZ0IHx8IDAsXG4gICAgdG9wOiBkb2Muc2Nyb2xsaW5nRWxlbWVudCA/IGRvYy5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCA6IHdpbi5wYWdlWU9mZnNldCAhPT0gdm9pZCAwID8gd2luLnBhZ2VZT2Zmc2V0IDogZG9jPy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvYz8uYm9keT8ucGFyZW50RWxlbWVudD8uc2Nyb2xsVG9wIHx8IGRvYz8uYm9keT8uc2Nyb2xsVG9wIHx8IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd0hlaWdodCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB8fCBkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0V2luZG93V2lkdGgoKSB7XG4gIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBlbCA9IG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFID8gbm9kZSA6IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICByZXR1cm4gZWw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQmxvY2tlZChub2RlLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB1bmJsb2NrU2VsZWN0b3IsIGNoZWNrQW5jZXN0b3JzKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBlbCA9IGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUpO1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGJsb2NrZWRQcmVkaWNhdGUgPSBjcmVhdGVNYXRjaFByZWRpY2F0ZShibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcbiAgaWYgKCFjaGVja0FuY2VzdG9ycykge1xuICAgIGNvbnN0IGlzVW5ibG9ja2VkID0gdW5ibG9ja1NlbGVjdG9yICYmIGVsLm1hdGNoZXModW5ibG9ja1NlbGVjdG9yKTtcbiAgICByZXR1cm4gYmxvY2tlZFByZWRpY2F0ZShlbCkgJiYgIWlzVW5ibG9ja2VkO1xuICB9XG4gIGNvbnN0IGJsb2NrRGlzdGFuY2UgPSBkaXN0YW5jZVRvTWF0Y2goZWwsIGJsb2NrZWRQcmVkaWNhdGUpO1xuICBsZXQgdW5ibG9ja0Rpc3RhbmNlID0gLTE7XG4gIGlmIChibG9ja0Rpc3RhbmNlIDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodW5ibG9ja1NlbGVjdG9yKSB7XG4gICAgdW5ibG9ja0Rpc3RhbmNlID0gZGlzdGFuY2VUb01hdGNoKFxuICAgICAgZWwsXG4gICAgICBjcmVhdGVNYXRjaFByZWRpY2F0ZShudWxsLCB1bmJsb2NrU2VsZWN0b3IpXG4gICAgKTtcbiAgfVxuICBpZiAoYmxvY2tEaXN0YW5jZSA+IC0xICYmIHVuYmxvY2tEaXN0YW5jZSA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gYmxvY2tEaXN0YW5jZSA8IHVuYmxvY2tEaXN0YW5jZTtcbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZChuMiwgbWlycm9yMikge1xuICByZXR1cm4gbWlycm9yMi5nZXRJZChuMikgIT09IC0xO1xufVxuZnVuY3Rpb24gaXNJZ25vcmVkKG4yLCBtaXJyb3IyKSB7XG4gIHJldHVybiBtaXJyb3IyLmdldElkKG4yKSA9PT0gSUdOT1JFRF9OT0RFO1xufVxuZnVuY3Rpb24gaXNBbmNlc3RvclJlbW92ZWQodGFyZ2V0LCBtaXJyb3IyKSB7XG4gIGlmIChpc1NoYWRvd1Jvb3QodGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBpZCA9IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KTtcbiAgaWYgKCFtaXJyb3IyLmhhcyhpZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodGFyZ2V0LnBhcmVudE5vZGUgJiYgdGFyZ2V0LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IHRhcmdldC5ET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gaXNBbmNlc3RvclJlbW92ZWQodGFyZ2V0LnBhcmVudE5vZGUsIG1pcnJvcjIpO1xufVxuZnVuY3Rpb24gbGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkge1xuICByZXR1cm4gQm9vbGVhbihldmVudC5jaGFuZ2VkVG91Y2hlcyk7XG59XG5mdW5jdGlvbiBwb2x5ZmlsbCQxKHdpbiA9IHdpbmRvdykge1xuICBpZiAoXCJOb2RlTGlzdFwiIGluIHdpbiAmJiAhd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG4gIH1cbiAgaWYgKFwiRE9NVG9rZW5MaXN0XCIgaW4gd2luICYmICF3aW4uRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgd2luLkRPTVRva2VuTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICB9XG4gIGlmICghTm9kZS5wcm90b3R5cGUuY29udGFpbnMpIHtcbiAgICBOb2RlLnByb3RvdHlwZS5jb250YWlucyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBsZXQgbm9kZSA9IGFyZ3NbMF07XG4gICAgICBpZiAoISgwIGluIGFyZ3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCIxIGFyZ3VtZW50IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgZG8ge1xuICAgICAgICBpZiAodGhpcyA9PT0gbm9kZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChub2RlID0gbm9kZSAmJiBub2RlLnBhcmVudE5vZGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZElmcmFtZShuMiwgbWlycm9yMikge1xuICByZXR1cm4gQm9vbGVhbihuMi5ub2RlTmFtZSA9PT0gXCJJRlJBTUVcIiAmJiBtaXJyb3IyLmdldE1ldGEobjIpKTtcbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZFN0eWxlc2hlZXQobjIsIG1pcnJvcjIpIHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgbjIubm9kZU5hbWUgPT09IFwiTElOS1wiICYmIG4yLm5vZGVUeXBlID09PSBuMi5FTEVNRU5UX05PREUgJiYgbjIuZ2V0QXR0cmlidXRlICYmIG4yLmdldEF0dHJpYnV0ZShcInJlbFwiKSA9PT0gXCJzdHlsZXNoZWV0XCIgJiYgbWlycm9yMi5nZXRNZXRhKG4yKVxuICApO1xufVxuZnVuY3Rpb24gaGFzU2hhZG93Um9vdChuMikge1xuICByZXR1cm4gQm9vbGVhbihuMj8uc2hhZG93Um9vdCk7XG59XG5jbGFzcyBTdHlsZVNoZWV0TWlycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pZCA9IDE7XG4gICAgdGhpcy5zdHlsZUlETWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5pZFN0eWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBnZXRJZChzdHlsZXNoZWV0KSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVJRE1hcC5nZXQoc3R5bGVzaGVldCkgPz8gLTE7XG4gIH1cbiAgaGFzKHN0eWxlc2hlZXQpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZUlETWFwLmhhcyhzdHlsZXNoZWV0KTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgSWYgdGhlIHN0eWxlc2hlZXQgaXMgaW4gdGhlIG1pcnJvciwgcmV0dXJucyB0aGUgaWQgb2YgdGhlIHN0eWxlc2hlZXQuIElmIG5vdCwgcmV0dXJuIHRoZSBuZXcgYXNzaWduZWQgaWQuXG4gICAqL1xuICBhZGQoc3R5bGVzaGVldCwgaWQpIHtcbiAgICBpZiAodGhpcy5oYXMoc3R5bGVzaGVldCkpIHJldHVybiB0aGlzLmdldElkKHN0eWxlc2hlZXQpO1xuICAgIGxldCBuZXdJZDtcbiAgICBpZiAoaWQgPT09IHZvaWQgMCkge1xuICAgICAgbmV3SWQgPSB0aGlzLmlkKys7XG4gICAgfSBlbHNlIG5ld0lkID0gaWQ7XG4gICAgdGhpcy5zdHlsZUlETWFwLnNldChzdHlsZXNoZWV0LCBuZXdJZCk7XG4gICAgdGhpcy5pZFN0eWxlTWFwLnNldChuZXdJZCwgc3R5bGVzaGVldCk7XG4gICAgcmV0dXJuIG5ld0lkO1xuICB9XG4gIGdldFN0eWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRTdHlsZU1hcC5nZXQoaWQpIHx8IG51bGw7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdHlsZUlETWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5pZFN0eWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmlkID0gMTtcbiAgfVxuICBnZW5lcmF0ZUlkKCkge1xuICAgIHJldHVybiB0aGlzLmlkKys7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNoYWRvd0hvc3QobjIpIHtcbiAgbGV0IHNoYWRvd0hvc3QgPSBudWxsO1xuICBpZiAobjIuZ2V0Um9vdE5vZGU/LigpPy5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIG4yLmdldFJvb3ROb2RlKCkuaG9zdClcbiAgICBzaGFkb3dIb3N0ID0gbjIuZ2V0Um9vdE5vZGUoKS5ob3N0O1xuICByZXR1cm4gc2hhZG93SG9zdDtcbn1cbmZ1bmN0aW9uIGdldFJvb3RTaGFkb3dIb3N0KG4yKSB7XG4gIGxldCByb290U2hhZG93SG9zdCA9IG4yO1xuICBsZXQgc2hhZG93SG9zdDtcbiAgd2hpbGUgKHNoYWRvd0hvc3QgPSBnZXRTaGFkb3dIb3N0KHJvb3RTaGFkb3dIb3N0KSlcbiAgICByb290U2hhZG93SG9zdCA9IHNoYWRvd0hvc3Q7XG4gIHJldHVybiByb290U2hhZG93SG9zdDtcbn1cbmZ1bmN0aW9uIHNoYWRvd0hvc3RJbkRvbShuMikge1xuICBjb25zdCBkb2MgPSBuMi5vd25lckRvY3VtZW50O1xuICBpZiAoIWRvYykgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBzaGFkb3dIb3N0ID0gZ2V0Um9vdFNoYWRvd0hvc3QobjIpO1xuICByZXR1cm4gZG9jLmNvbnRhaW5zKHNoYWRvd0hvc3QpO1xufVxuZnVuY3Rpb24gaW5Eb20objIpIHtcbiAgY29uc3QgZG9jID0gbjIub3duZXJEb2N1bWVudDtcbiAgaWYgKCFkb2MpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGRvYy5jb250YWlucyhuMikgfHwgc2hhZG93SG9zdEluRG9tKG4yKTtcbn1cbmNvbnN0IGNhY2hlZEltcGxlbWVudGF0aW9ucyA9IHt9O1xuZnVuY3Rpb24gZ2V0SW1wbGVtZW50YXRpb24obmFtZSkge1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZWRJbXBsZW1lbnRhdGlvbnNbbmFtZV07XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IGRvY3VtZW50MiA9IHdpbmRvdy5kb2N1bWVudDtcbiAgbGV0IGltcGwgPSB3aW5kb3dbbmFtZV07XG4gIGlmIChkb2N1bWVudDIgJiYgdHlwZW9mIGRvY3VtZW50Mi5jcmVhdGVFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2FuZGJveCA9IGRvY3VtZW50Mi5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgc2FuZGJveC5oaWRkZW4gPSB0cnVlO1xuICAgICAgZG9jdW1lbnQyLmhlYWQuYXBwZW5kQ2hpbGQoc2FuZGJveCk7XG4gICAgICBjb25zdCBjb250ZW50V2luZG93ID0gc2FuZGJveC5jb250ZW50V2luZG93O1xuICAgICAgaWYgKGNvbnRlbnRXaW5kb3cgJiYgY29udGVudFdpbmRvd1tuYW1lXSkge1xuICAgICAgICBpbXBsID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICBjb250ZW50V2luZG93W25hbWVdO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQyLmhlYWQucmVtb3ZlQ2hpbGQoc2FuZGJveCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhY2hlZEltcGxlbWVudGF0aW9uc1tuYW1lXSA9IGltcGwuYmluZChcbiAgICB3aW5kb3dcbiAgKTtcbn1cbmZ1bmN0aW9uIG9uUmVxdWVzdEFuaW1hdGlvbkZyYW1lKC4uLnJlc3QpIHtcbiAgcmV0dXJuIGdldEltcGxlbWVudGF0aW9uKFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpKC4uLnJlc3QpO1xufVxuZnVuY3Rpb24gc2V0VGltZW91dCQxKC4uLnJlc3QpIHtcbiAgcmV0dXJuIGdldEltcGxlbWVudGF0aW9uKFwic2V0VGltZW91dFwiKSguLi5yZXN0KTtcbn1cbmZ1bmN0aW9uIGNsZWFyVGltZW91dCQyKC4uLnJlc3QpIHtcbiAgcmV0dXJuIGdldEltcGxlbWVudGF0aW9uKFwiY2xlYXJUaW1lb3V0XCIpKC4uLnJlc3QpO1xufVxudmFyIEV2ZW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV2ZW50VHlwZTIpID0+IHtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRG9tQ29udGVudExvYWRlZFwiXSA9IDBdID0gXCJEb21Db250ZW50TG9hZGVkXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkxvYWRcIl0gPSAxXSA9IFwiTG9hZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJGdWxsU25hcHNob3RcIl0gPSAyXSA9IFwiRnVsbFNuYXBzaG90XCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkluY3JlbWVudGFsU25hcHNob3RcIl0gPSAzXSA9IFwiSW5jcmVtZW50YWxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJNZXRhXCJdID0gNF0gPSBcIk1ldGFcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiQ3VzdG9tXCJdID0gNV0gPSBcIkN1c3RvbVwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJQbHVnaW5cIl0gPSA2XSA9IFwiUGx1Z2luXCI7XG4gIHJldHVybiBFdmVudFR5cGUyO1xufSkoRXZlbnRUeXBlIHx8IHt9KTtcbnZhciBJbmNyZW1lbnRhbFNvdXJjZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEluY3JlbWVudGFsU291cmNlMikgPT4ge1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTXV0YXRpb25cIl0gPSAwXSA9IFwiTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlTW92ZVwiXSA9IDFdID0gXCJNb3VzZU1vdmVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlSW50ZXJhY3Rpb25cIl0gPSAyXSA9IFwiTW91c2VJbnRlcmFjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2Nyb2xsXCJdID0gM10gPSBcIlNjcm9sbFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVmlld3BvcnRSZXNpemVcIl0gPSA0XSA9IFwiVmlld3BvcnRSZXNpemVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIklucHV0XCJdID0gNV0gPSBcIklucHV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJUb3VjaE1vdmVcIl0gPSA2XSA9IFwiVG91Y2hNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNZWRpYUludGVyYWN0aW9uXCJdID0gN10gPSBcIk1lZGlhSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlU2hlZXRSdWxlXCJdID0gOF0gPSBcIlN0eWxlU2hlZXRSdWxlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDYW52YXNNdXRhdGlvblwiXSA9IDldID0gXCJDYW52YXNNdXRhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiRm9udFwiXSA9IDEwXSA9IFwiRm9udFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTG9nXCJdID0gMTFdID0gXCJMb2dcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkRyYWdcIl0gPSAxMl0gPSBcIkRyYWdcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlRGVjbGFyYXRpb25cIl0gPSAxM10gPSBcIlN0eWxlRGVjbGFyYXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNlbGVjdGlvblwiXSA9IDE0XSA9IFwiU2VsZWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJBZG9wdGVkU3R5bGVTaGVldFwiXSA9IDE1XSA9IFwiQWRvcHRlZFN0eWxlU2hlZXRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkN1c3RvbUVsZW1lbnRcIl0gPSAxNl0gPSBcIkN1c3RvbUVsZW1lbnRcIjtcbiAgcmV0dXJuIEluY3JlbWVudGFsU291cmNlMjtcbn0pKEluY3JlbWVudGFsU291cmNlIHx8IHt9KTtcbnZhciBNb3VzZUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKE1vdXNlSW50ZXJhY3Rpb25zMikgPT4ge1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VVcFwiXSA9IDBdID0gXCJNb3VzZVVwXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJNb3VzZURvd25cIl0gPSAxXSA9IFwiTW91c2VEb3duXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJDbGlja1wiXSA9IDJdID0gXCJDbGlja1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ29udGV4dE1lbnVcIl0gPSAzXSA9IFwiQ29udGV4dE1lbnVcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkRibENsaWNrXCJdID0gNF0gPSBcIkRibENsaWNrXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJGb2N1c1wiXSA9IDVdID0gXCJGb2N1c1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQmx1clwiXSA9IDZdID0gXCJCbHVyXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaFN0YXJ0XCJdID0gN10gPSBcIlRvdWNoU3RhcnRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoTW92ZV9EZXBhcnRlZFwiXSA9IDhdID0gXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoRW5kXCJdID0gOV0gPSBcIlRvdWNoRW5kXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaENhbmNlbFwiXSA9IDEwXSA9IFwiVG91Y2hDYW5jZWxcIjtcbiAgcmV0dXJuIE1vdXNlSW50ZXJhY3Rpb25zMjtcbn0pKE1vdXNlSW50ZXJhY3Rpb25zIHx8IHt9KTtcbnZhciBQb2ludGVyVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gKChQb2ludGVyVHlwZXMyKSA9PiB7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIk1vdXNlXCJdID0gMF0gPSBcIk1vdXNlXCI7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlBlblwiXSA9IDFdID0gXCJQZW5cIjtcbiAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiVG91Y2hcIl0gPSAyXSA9IFwiVG91Y2hcIjtcbiAgcmV0dXJuIFBvaW50ZXJUeXBlczI7XG59KShQb2ludGVyVHlwZXMgfHwge30pO1xudmFyIE1lZGlhSW50ZXJhY3Rpb25zID0gLyogQF9fUFVSRV9fICovICgoTWVkaWFJbnRlcmFjdGlvbnMyKSA9PiB7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJQbGF5XCJdID0gMF0gPSBcIlBsYXlcIjtcbiAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlBhdXNlXCJdID0gMV0gPSBcIlBhdXNlXCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJTZWVrZWRcIl0gPSAyXSA9IFwiU2Vla2VkXCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJWb2x1bWVDaGFuZ2VcIl0gPSAzXSA9IFwiVm9sdW1lQ2hhbmdlXCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJSYXRlQ2hhbmdlXCJdID0gNF0gPSBcIlJhdGVDaGFuZ2VcIjtcbiAgcmV0dXJuIE1lZGlhSW50ZXJhY3Rpb25zMjtcbn0pKE1lZGlhSW50ZXJhY3Rpb25zIHx8IHt9KTtcbmZ1bmN0aW9uIGdldElGcmFtZUNvbnRlbnREb2N1bWVudChpZnJhbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaWZyYW1lLmNvbnRlbnREb2N1bWVudDtcbiAgfSBjYXRjaCAoZTIpIHtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SUZyYW1lQ29udGVudFdpbmRvdyhpZnJhbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gIH0gY2F0Y2ggKGUyKSB7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTm9kZUluTGlua2VkTGlzdChuMikge1xuICByZXR1cm4gXCJfX2xuXCIgaW4gbjI7XG59XG5jbGFzcyBEb3VibGVMaW5rZWRMaXN0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgfVxuICBnZXQocG9zaXRpb24pIHtcbiAgICBpZiAocG9zaXRpb24gPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIG91dHNpZGUgb2YgbGlzdCByYW5nZVwiKTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBvc2l0aW9uOyBpbmRleCsrKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudD8ubmV4dCB8fCBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuICBhZGROb2RlKG4yKSB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHZhbHVlOiBuMixcbiAgICAgIHByZXZpb3VzOiBudWxsLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgbjIuX19sbiA9IG5vZGU7XG4gICAgaWYgKG4yLnByZXZpb3VzU2libGluZyAmJiBpc05vZGVJbkxpbmtlZExpc3QobjIucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgY29uc3QgY3VycmVudCA9IG4yLnByZXZpb3VzU2libGluZy5fX2xuLm5leHQ7XG4gICAgICBub2RlLm5leHQgPSBjdXJyZW50O1xuICAgICAgbm9kZS5wcmV2aW91cyA9IG4yLnByZXZpb3VzU2libGluZy5fX2xuO1xuICAgICAgbjIucHJldmlvdXNTaWJsaW5nLl9fbG4ubmV4dCA9IG5vZGU7XG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gbm9kZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG4yLm5leHRTaWJsaW5nICYmIGlzTm9kZUluTGlua2VkTGlzdChuMi5uZXh0U2libGluZykgJiYgbjIubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cykge1xuICAgICAgY29uc3QgY3VycmVudCA9IG4yLm5leHRTaWJsaW5nLl9fbG4ucHJldmlvdXM7XG4gICAgICBub2RlLnByZXZpb3VzID0gY3VycmVudDtcbiAgICAgIG5vZGUubmV4dCA9IG4yLm5leHRTaWJsaW5nLl9fbG47XG4gICAgICBuMi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzID0gbm9kZTtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIGN1cnJlbnQubmV4dCA9IG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmhlYWQpIHtcbiAgICAgICAgdGhpcy5oZWFkLnByZXZpb3VzID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUubmV4dCA9IHRoaXMuaGVhZDtcbiAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlLm5leHQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudGFpbCA9IG5vZGU7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoKys7XG4gIH1cbiAgcmVtb3ZlTm9kZShuMikge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBuMi5fX2xuO1xuICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY3VycmVudC5wcmV2aW91cykge1xuICAgICAgdGhpcy5oZWFkID0gY3VycmVudC5uZXh0O1xuICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICB0aGlzLmhlYWQucHJldmlvdXMgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5wcmV2aW91cy5uZXh0ID0gY3VycmVudC5uZXh0O1xuICAgICAgaWYgKGN1cnJlbnQubmV4dCkge1xuICAgICAgICBjdXJyZW50Lm5leHQucHJldmlvdXMgPSBjdXJyZW50LnByZXZpb3VzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50YWlsID0gY3VycmVudC5wcmV2aW91cztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG4yLl9fbG4pIHtcbiAgICAgIGRlbGV0ZSBuMi5fX2xuO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aC0tO1xuICB9XG59XG5jb25zdCBtb3ZlS2V5ID0gKGlkLCBwYXJlbnRJZCkgPT4gYCR7aWR9QCR7cGFyZW50SWR9YDtcbmNsYXNzIE11dGF0aW9uQnVmZmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMudGV4dHMgPSBbXTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcbiAgICB0aGlzLmF0dHJpYnV0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMucmVtb3ZlcyA9IFtdO1xuICAgIHRoaXMubWFwUmVtb3ZlcyA9IFtdO1xuICAgIHRoaXMubW92ZWRNYXAgPSB7fTtcbiAgICB0aGlzLmFkZGVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLm1vdmVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmRyb3BwZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMucHJvY2Vzc011dGF0aW9ucyA9IChtdXRhdGlvbnMpID0+IHtcbiAgICAgIG11dGF0aW9ucy5mb3JFYWNoKHRoaXMucHJvY2Vzc011dGF0aW9uKTtcbiAgICAgIHRoaXMuZW1pdCgpO1xuICAgIH07XG4gICAgdGhpcy5lbWl0ID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZnJvemVuIHx8IHRoaXMubG9ja2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFkZHMgPSBbXTtcbiAgICAgIGNvbnN0IGFkZGVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGNvbnN0IGFkZExpc3QgPSBuZXcgRG91YmxlTGlua2VkTGlzdCgpO1xuICAgICAgY29uc3QgZ2V0TmV4dElkID0gKG4yKSA9PiB7XG4gICAgICAgIGxldCBucyA9IG4yO1xuICAgICAgICBsZXQgbmV4dElkID0gSUdOT1JFRF9OT0RFO1xuICAgICAgICB3aGlsZSAobmV4dElkID09PSBJR05PUkVEX05PREUpIHtcbiAgICAgICAgICBucyA9IG5zICYmIG5zLm5leHRTaWJsaW5nO1xuICAgICAgICAgIG5leHRJZCA9IG5zICYmIHRoaXMubWlycm9yLmdldElkKG5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dElkO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHB1c2hBZGQgPSAobjIpID0+IHtcbiAgICAgICAgaWYgKCFuMi5wYXJlbnROb2RlIHx8ICFpbkRvbShuMikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50SWQgPSBpc1NoYWRvd1Jvb3QobjIucGFyZW50Tm9kZSkgPyB0aGlzLm1pcnJvci5nZXRJZChnZXRTaGFkb3dIb3N0KG4yKSkgOiB0aGlzLm1pcnJvci5nZXRJZChuMi5wYXJlbnROb2RlKTtcbiAgICAgICAgY29uc3QgbmV4dElkID0gZ2V0TmV4dElkKG4yKTtcbiAgICAgICAgaWYgKHBhcmVudElkID09PSAtMSB8fCBuZXh0SWQgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZExpc3QuYWRkTm9kZShuMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc24gPSBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCB7XG4gICAgICAgICAgZG9jOiB0aGlzLmRvYyxcbiAgICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxuICAgICAgICAgIGJsb2NrQ2xhc3M6IHRoaXMuYmxvY2tDbGFzcyxcbiAgICAgICAgICBibG9ja1NlbGVjdG9yOiB0aGlzLmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgbWFza0FsbFRleHQ6IHRoaXMubWFza0FsbFRleHQsXG4gICAgICAgICAgdW5ibG9ja1NlbGVjdG9yOiB0aGlzLnVuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICBtYXNrVGV4dENsYXNzOiB0aGlzLm1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgdW5tYXNrVGV4dENsYXNzOiB0aGlzLnVubWFza1RleHRDbGFzcyxcbiAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiB0aGlzLm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgdW5tYXNrVGV4dFNlbGVjdG9yOiB0aGlzLnVubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICBza2lwQ2hpbGQ6IHRydWUsXG4gICAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQ6IHRydWUsXG4gICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogdGhpcy5pbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IHRoaXMubWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICBtYXNrQXR0cmlidXRlRm46IHRoaXMubWFza0F0dHJpYnV0ZUZuLFxuICAgICAgICAgIG1hc2tUZXh0Rm46IHRoaXMubWFza1RleHRGbixcbiAgICAgICAgICBtYXNrSW5wdXRGbjogdGhpcy5tYXNrSW5wdXRGbixcbiAgICAgICAgICBzbGltRE9NT3B0aW9uczogdGhpcy5zbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICBkYXRhVVJMT3B0aW9uczogdGhpcy5kYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICByZWNvcmRDYW52YXM6IHRoaXMucmVjb3JkQ2FudmFzLFxuICAgICAgICAgIGlubGluZUltYWdlczogdGhpcy5pbmxpbmVJbWFnZXMsXG4gICAgICAgICAgb25TZXJpYWxpemU6IChjdXJyZW50TikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZElmcmFtZShjdXJyZW50TiwgdGhpcy5taXJyb3IpICYmICFpc0Jsb2NrZWQoXG4gICAgICAgICAgICAgIGN1cnJlbnROLFxuICAgICAgICAgICAgICB0aGlzLmJsb2NrQ2xhc3MsXG4gICAgICAgICAgICAgIHRoaXMuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgICAgdGhpcy51bmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgIHRoaXMuaWZyYW1lTWFuYWdlci5hZGRJZnJhbWUoY3VycmVudE4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFN0eWxlc2hlZXQoY3VycmVudE4sIHRoaXMubWlycm9yKSkge1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLnRyYWNrTGlua0VsZW1lbnQoXG4gICAgICAgICAgICAgICAgY3VycmVudE5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4yKSkge1xuICAgICAgICAgICAgICB0aGlzLnNoYWRvd0RvbU1hbmFnZXIuYWRkU2hhZG93Um9vdChuMi5zaGFkb3dSb290LCB0aGlzLmRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbklmcmFtZUxvYWQ6IChpZnJhbWUsIGNoaWxkU24pID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQoXG4gICAgICAgICAgICAgIGlmcmFtZSxcbiAgICAgICAgICAgICAgdGhpcy5ibG9ja0NsYXNzLFxuICAgICAgICAgICAgICB0aGlzLmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICAgIHRoaXMudW5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlmcmFtZU1hbmFnZXIuYXR0YWNoSWZyYW1lKGlmcmFtZSwgY2hpbGRTbik7XG4gICAgICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmFkZFdpbmRvdyhpZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNoYWRvd0RvbU1hbmFnZXIub2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25TdHlsZXNoZWV0TG9hZDogKGxpbmssIGNoaWxkU24pID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuYXR0YWNoTGlua0VsZW1lbnQobGluaywgY2hpbGRTbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNuKSB7XG4gICAgICAgICAgYWRkcy5wdXNoKHtcbiAgICAgICAgICAgIHBhcmVudElkLFxuICAgICAgICAgICAgbmV4dElkLFxuICAgICAgICAgICAgbm9kZTogc25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhZGRlZElkcy5hZGQoc24uaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2hpbGUgKHRoaXMubWFwUmVtb3Zlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5taXJyb3IucmVtb3ZlTm9kZUZyb21NYXAodGhpcy5tYXBSZW1vdmVzLnNoaWZ0KCkpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBuMiBvZiB0aGlzLm1vdmVkU2V0KSB7XG4gICAgICAgIGlmIChpc1BhcmVudFJlbW92ZWQodGhpcy5yZW1vdmVzLCBuMiwgdGhpcy5taXJyb3IpICYmICF0aGlzLm1vdmVkU2V0LmhhcyhuMi5wYXJlbnROb2RlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2hBZGQobjIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBuMiBvZiB0aGlzLmFkZGVkU2V0KSB7XG4gICAgICAgIGlmICghaXNBbmNlc3RvckluU2V0KHRoaXMuZHJvcHBlZFNldCwgbjIpICYmICFpc1BhcmVudFJlbW92ZWQodGhpcy5yZW1vdmVzLCBuMiwgdGhpcy5taXJyb3IpKSB7XG4gICAgICAgICAgcHVzaEFkZChuMik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBbmNlc3RvckluU2V0KHRoaXMubW92ZWRTZXQsIG4yKSkge1xuICAgICAgICAgIHB1c2hBZGQobjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZHJvcHBlZFNldC5hZGQobjIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgY2FuZGlkYXRlID0gbnVsbDtcbiAgICAgIHdoaWxlIChhZGRMaXN0Lmxlbmd0aCkge1xuICAgICAgICBsZXQgbm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMubWlycm9yLmdldElkKGNhbmRpZGF0ZS52YWx1ZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBjb25zdCBuZXh0SWQgPSBnZXROZXh0SWQoY2FuZGlkYXRlLnZhbHVlKTtcbiAgICAgICAgICBpZiAocGFyZW50SWQgIT09IC0xICYmIG5leHRJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIGxldCB0YWlsTm9kZSA9IGFkZExpc3QudGFpbDtcbiAgICAgICAgICB3aGlsZSAodGFpbE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IF9ub2RlID0gdGFpbE5vZGU7XG4gICAgICAgICAgICB0YWlsTm9kZSA9IHRhaWxOb2RlLnByZXZpb3VzO1xuICAgICAgICAgICAgaWYgKF9ub2RlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gdGhpcy5taXJyb3IuZ2V0SWQoX25vZGUudmFsdWUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRJZCA9IGdldE5leHRJZChfbm9kZS52YWx1ZSk7XG4gICAgICAgICAgICAgIGlmIChuZXh0SWQgPT09IC0xKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50SWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IF9ub2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuaGFuZGxlZE5vZGUgPSBfbm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodW5oYW5kbGVkTm9kZS5wYXJlbnROb2RlICYmIHVuaGFuZGxlZE5vZGUucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBzaGFkb3dIb3N0ID0gdW5oYW5kbGVkTm9kZS5wYXJlbnROb2RlLmhvc3Q7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZDIgPSB0aGlzLm1pcnJvci5nZXRJZChzaGFkb3dIb3N0KTtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZDIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHdoaWxlIChhZGRMaXN0LmhlYWQpIHtcbiAgICAgICAgICAgIGFkZExpc3QucmVtb3ZlTm9kZShhZGRMaXN0LmhlYWQudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYW5kaWRhdGUgPSBub2RlLnByZXZpb3VzO1xuICAgICAgICBhZGRMaXN0LnJlbW92ZU5vZGUobm9kZS52YWx1ZSk7XG4gICAgICAgIHB1c2hBZGQobm9kZS52YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0ZXh0czogdGhpcy50ZXh0cy5tYXAoKHRleHQpID0+ICh7XG4gICAgICAgICAgaWQ6IHRoaXMubWlycm9yLmdldElkKHRleHQubm9kZSksXG4gICAgICAgICAgdmFsdWU6IHRleHQudmFsdWVcbiAgICAgICAgfSkpLmZpbHRlcigodGV4dCkgPT4gIWFkZGVkSWRzLmhhcyh0ZXh0LmlkKSkuZmlsdGVyKCh0ZXh0KSA9PiB0aGlzLm1pcnJvci5oYXModGV4dC5pZCkpLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLmF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGF0dHJpYnV0ZXMgfSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMuc3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmZBc1N0ciA9IEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZS5zdHlsZURpZmYpO1xuICAgICAgICAgICAgY29uc3QgdW5jaGFuZ2VkQXNTdHIgPSBKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGUuX3VuY2hhbmdlZFN0eWxlcyk7XG4gICAgICAgICAgICBpZiAoZGlmZkFzU3RyLmxlbmd0aCA8IGF0dHJpYnV0ZXMuc3R5bGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmICgoZGlmZkFzU3RyICsgdW5jaGFuZ2VkQXNTdHIpLnNwbGl0KFwidmFyKFwiKS5sZW5ndGggPT09IGF0dHJpYnV0ZXMuc3R5bGUuc3BsaXQoXCJ2YXIoXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSBhdHRyaWJ1dGUuc3R5bGVEaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5taXJyb3IuZ2V0SWQoYXR0cmlidXRlLm5vZGUpLFxuICAgICAgICAgICAgYXR0cmlidXRlc1xuICAgICAgICAgIH07XG4gICAgICAgIH0pLmZpbHRlcigoYXR0cmlidXRlKSA9PiAhYWRkZWRJZHMuaGFzKGF0dHJpYnV0ZS5pZCkpLmZpbHRlcigoYXR0cmlidXRlKSA9PiB0aGlzLm1pcnJvci5oYXMoYXR0cmlidXRlLmlkKSksXG4gICAgICAgIHJlbW92ZXM6IHRoaXMucmVtb3ZlcyxcbiAgICAgICAgYWRkc1xuICAgICAgfTtcbiAgICAgIGlmICghcGF5bG9hZC50ZXh0cy5sZW5ndGggJiYgIXBheWxvYWQuYXR0cmlidXRlcy5sZW5ndGggJiYgIXBheWxvYWQucmVtb3Zlcy5sZW5ndGggJiYgIXBheWxvYWQuYWRkcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXh0cyA9IFtdO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gW107XG4gICAgICB0aGlzLmF0dHJpYnV0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgdGhpcy5yZW1vdmVzID0gW107XG4gICAgICB0aGlzLmFkZGVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMubW92ZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgdGhpcy5kcm9wcGVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMubW92ZWRNYXAgPSB7fTtcbiAgICAgIHRoaXMubXV0YXRpb25DYihwYXlsb2FkKTtcbiAgICB9O1xuICAgIHRoaXMucHJvY2Vzc011dGF0aW9uID0gKG0pID0+IHtcbiAgICAgIGlmIChpc0lnbm9yZWQobS50YXJnZXQsIHRoaXMubWlycm9yKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG0udHlwZSkge1xuICAgICAgICBjYXNlIFwiY2hhcmFjdGVyRGF0YVwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBtLnRhcmdldC50ZXh0Q29udGVudDtcbiAgICAgICAgICBpZiAoIWlzQmxvY2tlZChcbiAgICAgICAgICAgIG0udGFyZ2V0LFxuICAgICAgICAgICAgdGhpcy5ibG9ja0NsYXNzLFxuICAgICAgICAgICAgdGhpcy5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy51bmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICkgJiYgdmFsdWUgIT09IG0ub2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHMucHVzaCh7XG4gICAgICAgICAgICAgIHZhbHVlOiBuZWVkTWFza2luZ1RleHQoXG4gICAgICAgICAgICAgICAgbS50YXJnZXQsXG4gICAgICAgICAgICAgICAgdGhpcy5tYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgICAgIHRoaXMubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgICAgICB0aGlzLnVubWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgICAgICB0aGlzLnVubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgICAgICB0aGlzLm1hc2tBbGxUZXh0XG4gICAgICAgICAgICAgICkgJiYgdmFsdWUgPyB0aGlzLm1hc2tUZXh0Rm4gPyB0aGlzLm1hc2tUZXh0Rm4odmFsdWUsIGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG0udGFyZ2V0KSkgOiB2YWx1ZS5yZXBsYWNlKC9bXFxTXS9nLCBcIipcIikgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgbm9kZTogbS50YXJnZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYXR0cmlidXRlc1wiOiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gbS50YXJnZXQ7XG4gICAgICAgICAgbGV0IGF0dHJpYnV0ZU5hbWUgPSBtLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgbGV0IHZhbHVlID0gbS50YXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBnZXRJbnB1dFR5cGUodGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSB0YXJnZXQudGFnTmFtZTtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0SW5wdXRWYWx1ZSh0YXJnZXQsIHRhZ05hbWUsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgaXNJbnB1dE1hc2tlZCA9IHNob3VsZE1hc2tJbnB1dCh7XG4gICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IHRoaXMubWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgICAgdGFnTmFtZSxcbiAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmb3JjZU1hc2sgPSBuZWVkTWFza2luZ1RleHQoXG4gICAgICAgICAgICAgIG0udGFyZ2V0LFxuICAgICAgICAgICAgICB0aGlzLm1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICAgIHRoaXMubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgICAgdGhpcy51bm1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICAgIHRoaXMudW5tYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgICBpc0lucHV0TWFza2VkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFsdWUgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICAgICAgICAgIGlzTWFza2VkOiBmb3JjZU1hc2ssXG4gICAgICAgICAgICAgIGVsZW1lbnQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiB0aGlzLm1hc2tJbnB1dEZuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQmxvY2tlZChcbiAgICAgICAgICAgIG0udGFyZ2V0LFxuICAgICAgICAgICAgdGhpcy5ibG9ja0NsYXNzLFxuICAgICAgICAgICAgdGhpcy5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy51bmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICkgfHwgdmFsdWUgPT09IG0ub2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmF0dHJpYnV0ZU1hcC5nZXQobS50YXJnZXQpO1xuICAgICAgICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gXCJJRlJBTUVcIiAmJiBhdHRyaWJ1dGVOYW1lID09PSBcInNyY1wiICYmICF0aGlzLmtlZXBJZnJhbWVTcmNGbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlmcmFtZURvYyA9IGdldElGcmFtZUNvbnRlbnREb2N1bWVudChcbiAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFpZnJhbWVEb2MpIHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IFwicnJfc3JjXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgICAgbm9kZTogbS50YXJnZXQsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgICAgICBzdHlsZURpZmY6IHt9LFxuICAgICAgICAgICAgICBfdW5jaGFuZ2VkU3R5bGVzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVNYXAuc2V0KG0udGFyZ2V0LCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwidHlwZVwiICYmIHRhcmdldC50YWdOYW1lID09PSBcIklOUFVUXCIgJiYgKG0ub2xkVmFsdWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJwYXNzd29yZFwiKSB7XG4gICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1yci1pcy1wYXNzd29yZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaWdub3JlQXR0cmlidXRlKHRhcmdldC50YWdOYW1lLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgaXRlbS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gdHJhbnNmb3JtQXR0cmlidXRlKFxuICAgICAgICAgICAgICB0aGlzLmRvYyxcbiAgICAgICAgICAgICAgdG9Mb3dlckNhc2UodGFyZ2V0LnRhZ05hbWUpLFxuICAgICAgICAgICAgICB0b0xvd2VyQ2FzZShhdHRyaWJ1dGVOYW1lKSxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgdGhpcy5tYXNrQXR0cmlidXRlRm5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy51bmF0dGFjaGVkRG9jKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudW5hdHRhY2hlZERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnVuYXR0YWNoZWREb2MgPSB0aGlzLmRvYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3Qgb2xkID0gdGhpcy51bmF0dGFjaGVkRG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICBpZiAobS5vbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG9sZC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBtLm9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBuYW1lIG9mIEFycmF5LmZyb20odGFyZ2V0LnN0eWxlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ByaW9yaXR5ID0gdGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpIHx8IG5ld1ByaW9yaXR5ICE9PSBvbGQuc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdQcmlvcml0eSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGVEaWZmW3BuYW1lXSA9IFtuZXdWYWx1ZSwgbmV3UHJpb3JpdHldO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpdGVtLl91bmNoYW5nZWRTdHlsZXNbcG5hbWVdID0gW25ld1ZhbHVlLCBuZXdQcmlvcml0eV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcG5hbWUgb2YgQXJyYXkuZnJvbShvbGQuc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJjaGlsZExpc3RcIjoge1xuICAgICAgICAgIGlmIChpc0Jsb2NrZWQoXG4gICAgICAgICAgICBtLnRhcmdldCxcbiAgICAgICAgICAgIHRoaXMuYmxvY2tDbGFzcyxcbiAgICAgICAgICAgIHRoaXMuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgIHRoaXMudW5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbS5hZGRlZE5vZGVzLmZvckVhY2goKG4yKSA9PiB0aGlzLmdlbkFkZHMobjIsIG0udGFyZ2V0KSk7XG4gICAgICAgICAgbS5yZW1vdmVkTm9kZXMuZm9yRWFjaCgobjIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVJZCA9IHRoaXMubWlycm9yLmdldElkKG4yKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gaXNTaGFkb3dSb290KG0udGFyZ2V0KSA/IHRoaXMubWlycm9yLmdldElkKG0udGFyZ2V0Lmhvc3QpIDogdGhpcy5taXJyb3IuZ2V0SWQobS50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2tlZChcbiAgICAgICAgICAgICAgbS50YXJnZXQsXG4gICAgICAgICAgICAgIHRoaXMuYmxvY2tDbGFzcyxcbiAgICAgICAgICAgICAgdGhpcy5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgICB0aGlzLnVuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICkgfHwgaXNJZ25vcmVkKG4yLCB0aGlzLm1pcnJvcikgfHwgIWlzU2VyaWFsaXplZChuMiwgdGhpcy5taXJyb3IpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFkZGVkU2V0LmhhcyhuMikpIHtcbiAgICAgICAgICAgICAgZGVlcERlbGV0ZSh0aGlzLmFkZGVkU2V0LCBuMik7XG4gICAgICAgICAgICAgIHRoaXMuZHJvcHBlZFNldC5hZGQobjIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFkZGVkU2V0LmhhcyhtLnRhcmdldCkgJiYgbm9kZUlkID09PSAtMSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNBbmNlc3RvclJlbW92ZWQobS50YXJnZXQsIHRoaXMubWlycm9yKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tb3ZlZFNldC5oYXMobjIpICYmIHRoaXMubW92ZWRNYXBbbW92ZUtleShub2RlSWQsIHBhcmVudElkKV0pIHtcbiAgICAgICAgICAgICAgZGVlcERlbGV0ZSh0aGlzLm1vdmVkU2V0LCBuMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcGFyZW50SWQsXG4gICAgICAgICAgICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgICAgICAgICAgICBpc1NoYWRvdzogaXNTaGFkb3dSb290KG0udGFyZ2V0KSAmJiBpc05hdGl2ZVNoYWRvd0RvbShtLnRhcmdldCkgPyB0cnVlIDogdm9pZCAwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXBSZW1vdmVzLnB1c2gobjIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdlbkFkZHMgPSAobjIsIHRhcmdldCkgPT4ge1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkTm9kZU1hbmFnZXIuaW5PdGhlckJ1ZmZlcihuMiwgdGhpcykpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmFkZGVkU2V0LmhhcyhuMikgfHwgdGhpcy5tb3ZlZFNldC5oYXMobjIpKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5taXJyb3IuaGFzTm9kZShuMikpIHtcbiAgICAgICAgaWYgKGlzSWdub3JlZChuMiwgdGhpcy5taXJyb3IpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZWRTZXQuYWRkKG4yKTtcbiAgICAgICAgbGV0IHRhcmdldElkID0gbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldCAmJiB0aGlzLm1pcnJvci5oYXNOb2RlKHRhcmdldCkpIHtcbiAgICAgICAgICB0YXJnZXRJZCA9IHRoaXMubWlycm9yLmdldElkKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldElkICYmIHRhcmdldElkICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMubW92ZWRNYXBbbW92ZUtleSh0aGlzLm1pcnJvci5nZXRJZChuMiksIHRhcmdldElkKV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZGVkU2V0LmFkZChuMik7XG4gICAgICAgIHRoaXMuZHJvcHBlZFNldC5kZWxldGUobjIpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0Jsb2NrZWQoXG4gICAgICAgIG4yLFxuICAgICAgICB0aGlzLmJsb2NrQ2xhc3MsXG4gICAgICAgIHRoaXMuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgdGhpcy51bmJsb2NrU2VsZWN0b3IsXG4gICAgICAgIGZhbHNlXG4gICAgICApKSB7XG4gICAgICAgIG4yLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROKSA9PiB0aGlzLmdlbkFkZHMoY2hpbGROKSk7XG4gICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4yKSkge1xuICAgICAgICAgIG4yLnNoYWRvd1Jvb3QuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE4pID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkTm9kZU1hbmFnZXIuYWRkKGNoaWxkTiwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmdlbkFkZHMoY2hpbGROLCBuMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIFtcbiAgICAgIFwibXV0YXRpb25DYlwiLFxuICAgICAgXCJibG9ja0NsYXNzXCIsXG4gICAgICBcImJsb2NrU2VsZWN0b3JcIixcbiAgICAgIFwidW5ibG9ja1NlbGVjdG9yXCIsXG4gICAgICBcIm1hc2tBbGxUZXh0XCIsXG4gICAgICBcIm1hc2tUZXh0Q2xhc3NcIixcbiAgICAgIFwidW5tYXNrVGV4dENsYXNzXCIsXG4gICAgICBcIm1hc2tUZXh0U2VsZWN0b3JcIixcbiAgICAgIFwidW5tYXNrVGV4dFNlbGVjdG9yXCIsXG4gICAgICBcImlubGluZVN0eWxlc2hlZXRcIixcbiAgICAgIFwibWFza0lucHV0T3B0aW9uc1wiLFxuICAgICAgXCJtYXNrQXR0cmlidXRlRm5cIixcbiAgICAgIFwibWFza1RleHRGblwiLFxuICAgICAgXCJtYXNrSW5wdXRGblwiLFxuICAgICAgXCJrZWVwSWZyYW1lU3JjRm5cIixcbiAgICAgIFwicmVjb3JkQ2FudmFzXCIsXG4gICAgICBcImlubGluZUltYWdlc1wiLFxuICAgICAgXCJzbGltRE9NT3B0aW9uc1wiLFxuICAgICAgXCJkYXRhVVJMT3B0aW9uc1wiLFxuICAgICAgXCJkb2NcIixcbiAgICAgIFwibWlycm9yXCIsXG4gICAgICBcImlmcmFtZU1hbmFnZXJcIixcbiAgICAgIFwic3R5bGVzaGVldE1hbmFnZXJcIixcbiAgICAgIFwic2hhZG93RG9tTWFuYWdlclwiLFxuICAgICAgXCJjYW52YXNNYW5hZ2VyXCIsXG4gICAgICBcInByb2Nlc3NlZE5vZGVNYW5hZ2VyXCJcbiAgICBdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH0pO1xuICB9XG4gIGZyZWV6ZSgpIHtcbiAgICB0aGlzLmZyb3plbiA9IHRydWU7XG4gICAgdGhpcy5jYW52YXNNYW5hZ2VyLmZyZWV6ZSgpO1xuICB9XG4gIHVuZnJlZXplKCkge1xuICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XG4gICAgdGhpcy5jYW52YXNNYW5hZ2VyLnVuZnJlZXplKCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgaXNGcm96ZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvemVuO1xuICB9XG4gIGxvY2soKSB7XG4gICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuICAgIHRoaXMuY2FudmFzTWFuYWdlci5sb2NrKCk7XG4gIH1cbiAgdW5sb2NrKCkge1xuICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy5jYW52YXNNYW5hZ2VyLnVubG9jaygpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuc2hhZG93RG9tTWFuYWdlci5yZXNldCgpO1xuICAgIHRoaXMuY2FudmFzTWFuYWdlci5yZXNldCgpO1xuICB9XG59XG5mdW5jdGlvbiBkZWVwRGVsZXRlKGFkZHNTZXQsIG4yKSB7XG4gIGFkZHNTZXQuZGVsZXRlKG4yKTtcbiAgbjIuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE4pID0+IGRlZXBEZWxldGUoYWRkc1NldCwgY2hpbGROKSk7XG59XG5mdW5jdGlvbiBpc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbjIsIG1pcnJvcjIpIHtcbiAgaWYgKHJlbW92ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBfaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIG4yLCBtaXJyb3IyKTtcbn1cbmZ1bmN0aW9uIF9pc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbjIsIG1pcnJvcjIpIHtcbiAgbGV0IG5vZGUgPSBuMi5wYXJlbnROb2RlO1xuICB3aGlsZSAobm9kZSkge1xuICAgIGNvbnN0IHBhcmVudElkID0gbWlycm9yMi5nZXRJZChub2RlKTtcbiAgICBpZiAocmVtb3Zlcy5zb21lKChyMikgPT4gcjIuaWQgPT09IHBhcmVudElkKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNBbmNlc3RvckluU2V0KHNldCwgbjIpIHtcbiAgaWYgKHNldC5zaXplID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBfaXNBbmNlc3RvckluU2V0KHNldCwgbjIpO1xufVxuZnVuY3Rpb24gX2lzQW5jZXN0b3JJblNldChzZXQsIG4yKSB7XG4gIGNvbnN0IHsgcGFyZW50Tm9kZSB9ID0gbjI7XG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc2V0LmhhcyhwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBfaXNBbmNlc3RvckluU2V0KHNldCwgcGFyZW50Tm9kZSk7XG59XG5sZXQgZXJyb3JIYW5kbGVyO1xuZnVuY3Rpb24gcmVnaXN0ZXJFcnJvckhhbmRsZXIoaGFuZGxlcikge1xuICBlcnJvckhhbmRsZXIgPSBoYW5kbGVyO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckVycm9ySGFuZGxlcigpIHtcbiAgZXJyb3JIYW5kbGVyID0gdm9pZCAwO1xufVxuY29uc3QgY2FsbGJhY2tXcmFwcGVyID0gKGNiKSA9PiB7XG4gIGlmICghZXJyb3JIYW5kbGVyKSB7XG4gICAgcmV0dXJuIGNiO1xuICB9XG4gIGNvbnN0IHJyd2ViV3JhcHBlZCA9ICguLi5yZXN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYiguLi5yZXN0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9ySGFuZGxlciAmJiBlcnJvckhhbmRsZXIoZXJyb3IpID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIHJldHVybiBycndlYldyYXBwZWQ7XG59O1xuY29uc3QgbXV0YXRpb25CdWZmZXJzID0gW107XG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChldmVudCkge1xuICB0cnkge1xuICAgIGlmIChcImNvbXBvc2VkUGF0aFwiIGluIGV2ZW50KSB7XG4gICAgICBjb25zdCBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcInBhdGhcIiBpbiBldmVudCAmJiBldmVudC5wYXRoLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGV2ZW50LnBhdGhbMF07XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gZXZlbnQgJiYgZXZlbnQudGFyZ2V0O1xufVxuZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIob3B0aW9ucywgcm9vdEVsKSB7XG4gIGNvbnN0IG11dGF0aW9uQnVmZmVyID0gbmV3IE11dGF0aW9uQnVmZmVyKCk7XG4gIG11dGF0aW9uQnVmZmVycy5wdXNoKG11dGF0aW9uQnVmZmVyKTtcbiAgbXV0YXRpb25CdWZmZXIuaW5pdChvcHRpb25zKTtcbiAgbGV0IG11dGF0aW9uT2JzZXJ2ZXJDdG9yID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgLyoqXG4gICogU29tZSB3ZWJzaXRlcyBtYXkgZGlzYWJsZSBNdXRhdGlvbk9ic2VydmVyIGJ5IHJlbW92aW5nIGl0IGZyb20gdGhlIHdpbmRvdyBvYmplY3QuXG4gICogSWYgc29tZW9uZSBpcyB1c2luZyBycndlYiB0byBidWlsZCBhIGJyb3dzZXIgZXh0ZW50aW9uIG9yIHRoaW5ncyBsaWtlIGl0LCB0aGV5XG4gICogY291bGQgbm90IGNoYW5nZSB0aGUgd2Vic2l0ZSdzIGNvZGUgYnV0IGNhbiBoYXZlIGFuIG9wcG9ydHVuaXR5IHRvIGluamVjdCBzb21lXG4gICogY29kZSBiZWZvcmUgdGhlIHdlYnNpdGUgZXhlY3V0aW5nIGl0cyBKUyBsb2dpYy5cbiAgKiBUaGVuIHRoZXkgY2FuIGRvIHRoaXMgdG8gc3RvcmUgdGhlIG5hdGl2ZSBNdXRhdGlvbk9ic2VydmVyOlxuICAqIHdpbmRvdy5fX3JyTXV0YXRpb25PYnNlcnZlciA9IE11dGF0aW9uT2JzZXJ2ZXJcbiAgKi9cbiAgd2luZG93Ll9fcnJNdXRhdGlvbk9ic2VydmVyO1xuICBjb25zdCBhbmd1bGFyWm9uZVN5bWJvbCA9IHdpbmRvdz8uWm9uZT8uX19zeW1ib2xfXz8uKFwiTXV0YXRpb25PYnNlcnZlclwiKTtcbiAgaWYgKGFuZ3VsYXJab25lU3ltYm9sICYmIHdpbmRvd1thbmd1bGFyWm9uZVN5bWJvbF0pIHtcbiAgICBtdXRhdGlvbk9ic2VydmVyQ3RvciA9IHdpbmRvd1thbmd1bGFyWm9uZVN5bWJvbF07XG4gIH1cbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgbXV0YXRpb25PYnNlcnZlckN0b3IoXG4gICAgY2FsbGJhY2tXcmFwcGVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLm9uTXV0YXRpb24gJiYgb3B0aW9ucy5vbk11dGF0aW9uKG11dGF0aW9ucykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG11dGF0aW9uQnVmZmVyLnByb2Nlc3NNdXRhdGlvbnMuYmluZChtdXRhdGlvbkJ1ZmZlcikobXV0YXRpb25zKTtcbiAgICB9KVxuICApO1xuICBvYnNlcnZlci5vYnNlcnZlKHJvb3RFbCwge1xuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWUsXG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGluaXRNb3ZlT2JzZXJ2ZXIoe1xuICBtb3VzZW1vdmVDYixcbiAgc2FtcGxpbmcsXG4gIGRvYyxcbiAgbWlycm9yOiBtaXJyb3IyXG59KSB7XG4gIGlmIChzYW1wbGluZy5tb3VzZW1vdmUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IHRocmVzaG9sZCA9IHR5cGVvZiBzYW1wbGluZy5tb3VzZW1vdmUgPT09IFwibnVtYmVyXCIgPyBzYW1wbGluZy5tb3VzZW1vdmUgOiA1MDtcbiAgY29uc3QgY2FsbGJhY2tUaHJlc2hvbGQgPSB0eXBlb2Ygc2FtcGxpbmcubW91c2Vtb3ZlQ2FsbGJhY2sgPT09IFwibnVtYmVyXCIgPyBzYW1wbGluZy5tb3VzZW1vdmVDYWxsYmFjayA6IDUwMDtcbiAgbGV0IHBvc2l0aW9ucyA9IFtdO1xuICBsZXQgdGltZUJhc2VsaW5lO1xuICBjb25zdCB3cmFwcGVkQ2IgPSB0aHJvdHRsZSQxKFxuICAgIGNhbGxiYWNrV3JhcHBlcihcbiAgICAgIChzb3VyY2UpID0+IHtcbiAgICAgICAgY29uc3QgdG90YWxPZmZzZXQgPSBEYXRlLm5vdygpIC0gdGltZUJhc2VsaW5lO1xuICAgICAgICBtb3VzZW1vdmVDYihcbiAgICAgICAgICBwb3NpdGlvbnMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICBwLnRpbWVPZmZzZXQgLT0gdG90YWxPZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzb3VyY2VcbiAgICAgICAgKTtcbiAgICAgICAgcG9zaXRpb25zID0gW107XG4gICAgICAgIHRpbWVCYXNlbGluZSA9IG51bGw7XG4gICAgICB9XG4gICAgKSxcbiAgICBjYWxsYmFja1RocmVzaG9sZFxuICApO1xuICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcihcbiAgICB0aHJvdHRsZSQxKFxuICAgICAgY2FsbGJhY2tXcmFwcGVyKChldnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZ0KTtcbiAgICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2dCkgPyBldnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldnQ7XG4gICAgICAgIGlmICghdGltZUJhc2VsaW5lKSB7XG4gICAgICAgICAgdGltZUJhc2VsaW5lID0gbm93VGltZXN0YW1wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb25zLnB1c2goe1xuICAgICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgICAgeTogY2xpZW50WSxcbiAgICAgICAgICBpZDogbWlycm9yMi5nZXRJZCh0YXJnZXQpLFxuICAgICAgICAgIHRpbWVPZmZzZXQ6IG5vd1RpbWVzdGFtcCgpIC0gdGltZUJhc2VsaW5lXG4gICAgICAgIH0pO1xuICAgICAgICB3cmFwcGVkQ2IoXG4gICAgICAgICAgdHlwZW9mIERyYWdFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBldnQgaW5zdGFuY2VvZiBEcmFnRXZlbnQgPyBJbmNyZW1lbnRhbFNvdXJjZS5EcmFnIDogZXZ0IGluc3RhbmNlb2YgTW91c2VFdmVudCA/IEluY3JlbWVudGFsU291cmNlLk1vdXNlTW92ZSA6IEluY3JlbWVudGFsU291cmNlLlRvdWNoTW92ZVxuICAgICAgICApO1xuICAgICAgfSksXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICB7XG4gICAgICAgIHRyYWlsaW5nOiBmYWxzZVxuICAgICAgfVxuICAgIClcbiAgKTtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXG4gICAgb24oXCJtb3VzZW1vdmVcIiwgdXBkYXRlUG9zaXRpb24sIGRvYyksXG4gICAgb24oXCJ0b3VjaG1vdmVcIiwgdXBkYXRlUG9zaXRpb24sIGRvYyksXG4gICAgb24oXCJkcmFnXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpXG4gIF07XG4gIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdE1vdXNlSW50ZXJhY3Rpb25PYnNlcnZlcih7XG4gIG1vdXNlSW50ZXJhY3Rpb25DYixcbiAgZG9jLFxuICBtaXJyb3I6IG1pcnJvcjIsXG4gIGJsb2NrQ2xhc3MsXG4gIGJsb2NrU2VsZWN0b3IsXG4gIHVuYmxvY2tTZWxlY3RvcixcbiAgc2FtcGxpbmdcbn0pIHtcbiAgaWYgKHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGRpc2FibGVNYXAgPSBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSB0cnVlIHx8IHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IHZvaWQgMCA/IHt9IDogc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbjtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgbGV0IGN1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gIGNvbnN0IGdldEhhbmRsZXIgPSAoZXZlbnRLZXkpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICBpZiAoaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdW5ibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgcG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgbGV0IHRoaXNFdmVudEtleSA9IGV2ZW50S2V5O1xuICAgICAgaWYgKFwicG9pbnRlclR5cGVcIiBpbiBldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnBvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm1vdXNlXCI6XG4gICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5Nb3VzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0b3VjaFwiOlxuICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicGVuXCI6XG4gICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5QZW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Ub3VjaCkge1xuICAgICAgICAgIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlRG93bikge1xuICAgICAgICAgICAgdGhpc0V2ZW50S2V5ID0gXCJUb3VjaFN0YXJ0XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlVXApIHtcbiAgICAgICAgICAgIHRoaXNFdmVudEtleSA9IFwiVG91Y2hFbmRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5QZW4pIDtcbiAgICAgIH0gZWxzZSBpZiAobGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XG4gICAgICB9XG4gICAgICBpZiAocG9pbnRlclR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudFBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XG4gICAgICAgIGlmICh0aGlzRXZlbnRLZXkuc3RhcnRzV2l0aChcIlRvdWNoXCIpICYmIHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuVG91Y2ggfHwgdGhpc0V2ZW50S2V5LnN0YXJ0c1dpdGgoXCJNb3VzZVwiKSAmJiBwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLk1vdXNlKSB7XG4gICAgICAgICAgcG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuQ2xpY2spIHtcbiAgICAgICAgcG9pbnRlclR5cGUgPSBjdXJyZW50UG9pbnRlclR5cGU7XG4gICAgICAgIGN1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBlMiA9IGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZlbnQpID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudDtcbiAgICAgIGlmICghZTIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGUyO1xuICAgICAgY2FsbGJhY2tXcmFwcGVyKG1vdXNlSW50ZXJhY3Rpb25DYikoe1xuICAgICAgICB0eXBlOiBNb3VzZUludGVyYWN0aW9uc1t0aGlzRXZlbnRLZXldLFxuICAgICAgICBpZCxcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WSxcbiAgICAgICAgLi4ucG9pbnRlclR5cGUgIT09IG51bGwgJiYgeyBwb2ludGVyVHlwZSB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3Qua2V5cyhNb3VzZUludGVyYWN0aW9ucykuZmlsdGVyKFxuICAgIChrZXkpID0+IE51bWJlci5pc05hTihOdW1iZXIoa2V5KSkgJiYgIWtleS5lbmRzV2l0aChcIl9EZXBhcnRlZFwiKSAmJiBkaXNhYmxlTWFwW2tleV0gIT09IGZhbHNlXG4gICkuZm9yRWFjaCgoZXZlbnRLZXkpID0+IHtcbiAgICBsZXQgZXZlbnROYW1lID0gdG9Mb3dlckNhc2UoZXZlbnRLZXkpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBnZXRIYW5kbGVyKGV2ZW50S2V5KTtcbiAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgc3dpdGNoIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0pIHtcbiAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZURvd246XG4gICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuTW91c2VVcDpcbiAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUucmVwbGFjZShcbiAgICAgICAgICAgIFwibW91c2VcIixcbiAgICAgICAgICAgIFwicG9pbnRlclwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Ub3VjaFN0YXJ0OlxuICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoRW5kOlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlcnMucHVzaChvbihldmVudE5hbWUsIGhhbmRsZXIsIGRvYykpO1xuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0U2Nyb2xsT2JzZXJ2ZXIoe1xuICBzY3JvbGxDYixcbiAgZG9jLFxuICBtaXJyb3I6IG1pcnJvcjIsXG4gIGJsb2NrQ2xhc3MsXG4gIGJsb2NrU2VsZWN0b3IsXG4gIHVuYmxvY2tTZWxlY3RvcixcbiAgc2FtcGxpbmdcbn0pIHtcbiAgY29uc3QgdXBkYXRlUG9zaXRpb24gPSBjYWxsYmFja1dyYXBwZXIoXG4gICAgdGhyb3R0bGUkMShcbiAgICAgIGNhbGxiYWNrV3JhcHBlcigoZXZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XG4gICAgICAgIGlmICghdGFyZ2V0IHx8IGlzQmxvY2tlZChcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICB0cnVlXG4gICAgICAgICkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXcpIHtcbiAgICAgICAgICBjb25zdCBzY3JvbGxMZWZ0VG9wID0gZ2V0V2luZG93U2Nyb2xsKGRvYy5kZWZhdWx0Vmlldyk7XG4gICAgICAgICAgc2Nyb2xsQ2Ioe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB4OiBzY3JvbGxMZWZ0VG9wLmxlZnQsXG4gICAgICAgICAgICB5OiBzY3JvbGxMZWZ0VG9wLnRvcFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbENiKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgeDogdGFyZ2V0LnNjcm9sbExlZnQsXG4gICAgICAgICAgICB5OiB0YXJnZXQuc2Nyb2xsVG9wXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgc2FtcGxpbmcuc2Nyb2xsIHx8IDEwMFxuICAgIClcbiAgKTtcbiAgcmV0dXJuIG9uKFwic2Nyb2xsXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpO1xufVxuZnVuY3Rpb24gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIoeyB2aWV3cG9ydFJlc2l6ZUNiIH0sIHsgd2luIH0pIHtcbiAgbGV0IGxhc3RIID0gLTE7XG4gIGxldCBsYXN0VyA9IC0xO1xuICBjb25zdCB1cGRhdGVEaW1lbnNpb24gPSBjYWxsYmFja1dyYXBwZXIoXG4gICAgdGhyb3R0bGUkMShcbiAgICAgIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGdldFdpbmRvd0hlaWdodCgpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldFdpbmRvd1dpZHRoKCk7XG4gICAgICAgIGlmIChsYXN0SCAhPT0gaGVpZ2h0IHx8IGxhc3RXICE9PSB3aWR0aCkge1xuICAgICAgICAgIHZpZXdwb3J0UmVzaXplQ2Ioe1xuICAgICAgICAgICAgd2lkdGg6IE51bWJlcih3aWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6IE51bWJlcihoZWlnaHQpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGFzdEggPSBoZWlnaHQ7XG4gICAgICAgICAgbGFzdFcgPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICAyMDBcbiAgICApXG4gICk7XG4gIHJldHVybiBvbihcInJlc2l6ZVwiLCB1cGRhdGVEaW1lbnNpb24sIHdpbik7XG59XG5jb25zdCBJTlBVVF9UQUdTID0gW1wiSU5QVVRcIiwgXCJURVhUQVJFQVwiLCBcIlNFTEVDVFwiXTtcbmNvbnN0IGxhc3RJbnB1dFZhbHVlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBpbml0SW5wdXRPYnNlcnZlcih7XG4gIGlucHV0Q2IsXG4gIGRvYyxcbiAgbWlycm9yOiBtaXJyb3IyLFxuICBibG9ja0NsYXNzLFxuICBibG9ja1NlbGVjdG9yLFxuICB1bmJsb2NrU2VsZWN0b3IsXG4gIGlnbm9yZUNsYXNzLFxuICBpZ25vcmVTZWxlY3RvcixcbiAgbWFza0lucHV0T3B0aW9ucyxcbiAgbWFza0lucHV0Rm4sXG4gIHNhbXBsaW5nLFxuICB1c2VyVHJpZ2dlcmVkT25JbnB1dCxcbiAgbWFza1RleHRDbGFzcyxcbiAgdW5tYXNrVGV4dENsYXNzLFxuICBtYXNrVGV4dFNlbGVjdG9yLFxuICB1bm1hc2tUZXh0U2VsZWN0b3Jcbn0pIHtcbiAgZnVuY3Rpb24gZXZlbnRIYW5kbGVyKGV2ZW50KSB7XG4gICAgbGV0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBjb25zdCB1c2VyVHJpZ2dlcmVkID0gZXZlbnQuaXNUcnVzdGVkO1xuICAgIGNvbnN0IHRhZ05hbWUgPSB0YXJnZXQgJiYgdG9VcHBlckNhc2UodGFyZ2V0LnRhZ05hbWUpO1xuICAgIGlmICh0YWdOYW1lID09PSBcIk9QVElPTlwiKSB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICBpZiAoIXRhcmdldCB8fCAhdGFnTmFtZSB8fCBJTlBVVF9UQUdTLmluZGV4T2YodGFnTmFtZSkgPCAwIHx8IGlzQmxvY2tlZChcbiAgICAgIHRhcmdldCxcbiAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgICAgdHJ1ZVxuICAgICkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWwgPSB0YXJnZXQ7XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhpZ25vcmVDbGFzcykgfHwgaWdub3JlU2VsZWN0b3IgJiYgZWwubWF0Y2hlcyhpZ25vcmVTZWxlY3RvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IGdldElucHV0VHlwZSh0YXJnZXQpO1xuICAgIGxldCB0ZXh0ID0gZ2V0SW5wdXRWYWx1ZShlbCwgdGFnTmFtZSwgdHlwZSk7XG4gICAgbGV0IGlzQ2hlY2tlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGlzSW5wdXRNYXNrZWQgPSBzaG91bGRNYXNrSW5wdXQoe1xuICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgIHRhZ05hbWUsXG4gICAgICB0eXBlXG4gICAgfSk7XG4gICAgY29uc3QgZm9yY2VNYXNrID0gbmVlZE1hc2tpbmdUZXh0KFxuICAgICAgdGFyZ2V0LFxuICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICB1bm1hc2tUZXh0Q2xhc3MsXG4gICAgICB1bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICBpc0lucHV0TWFza2VkXG4gICAgKTtcbiAgICBpZiAodHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgaXNDaGVja2VkID0gdGFyZ2V0LmNoZWNrZWQ7XG4gICAgfVxuICAgIHRleHQgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICBpc01hc2tlZDogZm9yY2VNYXNrLFxuICAgICAgZWxlbWVudDogdGFyZ2V0LFxuICAgICAgdmFsdWU6IHRleHQsXG4gICAgICBtYXNrSW5wdXRGblxuICAgIH0pO1xuICAgIGNiV2l0aERlZHVwKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdXNlclRyaWdnZXJlZE9uSW5wdXQgPyB7IHRleHQsIGlzQ2hlY2tlZCwgdXNlclRyaWdnZXJlZCB9IDogeyB0ZXh0LCBpc0NoZWNrZWQgfVxuICAgICk7XG4gICAgY29uc3QgbmFtZSA9IHRhcmdldC5uYW1lO1xuICAgIGlmICh0eXBlID09PSBcInJhZGlvXCIgJiYgbmFtZSAmJiBpc0NoZWNrZWQpIHtcbiAgICAgIGRvYy5xdWVyeVNlbGVjdG9yQWxsKGBpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIiR7bmFtZX1cIl1gKS5mb3JFYWNoKChlbDIpID0+IHtcbiAgICAgICAgaWYgKGVsMiAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3QgdGV4dDIgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICAgICAgICAvLyBzaGFyZSBtYXNrIGJlaGF2aW9yIG9mIGB0YXJnZXRgXG4gICAgICAgICAgICBpc01hc2tlZDogZm9yY2VNYXNrLFxuICAgICAgICAgICAgZWxlbWVudDogZWwyLFxuICAgICAgICAgICAgdmFsdWU6IGdldElucHV0VmFsdWUoZWwyLCB0YWdOYW1lLCB0eXBlKSxcbiAgICAgICAgICAgIG1hc2tJbnB1dEZuXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2JXaXRoRGVkdXAoXG4gICAgICAgICAgICBlbDIsXG4gICAgICAgICAgICB1c2VyVHJpZ2dlcmVkT25JbnB1dCA/IHsgdGV4dDogdGV4dDIsIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZCwgdXNlclRyaWdnZXJlZDogZmFsc2UgfSA6IHsgdGV4dDogdGV4dDIsIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNiV2l0aERlZHVwKHRhcmdldCwgdjIpIHtcbiAgICBjb25zdCBsYXN0SW5wdXRWYWx1ZSA9IGxhc3RJbnB1dFZhbHVlTWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghbGFzdElucHV0VmFsdWUgfHwgbGFzdElucHV0VmFsdWUudGV4dCAhPT0gdjIudGV4dCB8fCBsYXN0SW5wdXRWYWx1ZS5pc0NoZWNrZWQgIT09IHYyLmlzQ2hlY2tlZCkge1xuICAgICAgbGFzdElucHV0VmFsdWVNYXAuc2V0KHRhcmdldCwgdjIpO1xuICAgICAgY29uc3QgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICBjYWxsYmFja1dyYXBwZXIoaW5wdXRDYikoe1xuICAgICAgICAuLi52MixcbiAgICAgICAgaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBldmVudHMgPSBzYW1wbGluZy5pbnB1dCA9PT0gXCJsYXN0XCIgPyBbXCJjaGFuZ2VcIl0gOiBbXCJpbnB1dFwiLCBcImNoYW5nZVwiXTtcbiAgY29uc3QgaGFuZGxlcnMgPSBldmVudHMubWFwKFxuICAgIChldmVudE5hbWUpID0+IG9uKGV2ZW50TmFtZSwgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlciksIGRvYylcbiAgKTtcbiAgY29uc3QgY3VycmVudFdpbmRvdyA9IGRvYy5kZWZhdWx0VmlldztcbiAgaWYgKCFjdXJyZW50V2luZG93KSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBwcm9wZXJ0eURlc2NyaXB0b3IgPSBjdXJyZW50V2luZG93Lk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSxcbiAgICBcInZhbHVlXCJcbiAgKTtcbiAgY29uc3QgaG9va1Byb3BlcnRpZXMgPSBbXG4gICAgW2N1cnJlbnRXaW5kb3cuSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGUsIFwidmFsdWVcIl0sXG4gICAgW2N1cnJlbnRXaW5kb3cuSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGUsIFwiY2hlY2tlZFwiXSxcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsIFwidmFsdWVcIl0sXG4gICAgW2N1cnJlbnRXaW5kb3cuSFRNTFRleHRBcmVhRWxlbWVudC5wcm90b3R5cGUsIFwidmFsdWVcIl0sXG4gICAgLy8gU29tZSBVSSBsaWJyYXJ5IHVzZSBzZWxlY3RlZEluZGV4IHRvIHNldCBzZWxlY3QgdmFsdWVcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiXSxcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MT3B0aW9uRWxlbWVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIl1cbiAgXTtcbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvciAmJiBwcm9wZXJ0eURlc2NyaXB0b3Iuc2V0KSB7XG4gICAgaGFuZGxlcnMucHVzaChcbiAgICAgIC4uLmhvb2tQcm9wZXJ0aWVzLm1hcChcbiAgICAgICAgKHApID0+IGhvb2tTZXR0ZXIoXG4gICAgICAgICAgcFswXSxcbiAgICAgICAgICBwWzFdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlcikoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICBpc1RydXN0ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgLy8gdXNlclRyaWdnZXJlZCB0byBmYWxzZSBhcyB0aGlzIGNvdWxkIHdlbGwgYmUgcHJvZ3JhbW1hdGljXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgY3VycmVudFdpbmRvd1xuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnMocnVsZSkge1xuICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgZnVuY3Rpb24gcmVjdXJzZShjaGlsZFJ1bGUsIHBvcykge1xuICAgIGlmIChoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTR3JvdXBpbmdSdWxlXCIpICYmIGNoaWxkUnVsZS5wYXJlbnRSdWxlIGluc3RhbmNlb2YgQ1NTR3JvdXBpbmdSdWxlIHx8IGhhc05lc3RlZENTU1J1bGUoXCJDU1NNZWRpYVJ1bGVcIikgJiYgY2hpbGRSdWxlLnBhcmVudFJ1bGUgaW5zdGFuY2VvZiBDU1NNZWRpYVJ1bGUgfHwgaGFzTmVzdGVkQ1NTUnVsZShcIkNTU1N1cHBvcnRzUnVsZVwiKSAmJiBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU1N1cHBvcnRzUnVsZSB8fCBoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTQ29uZGl0aW9uUnVsZVwiKSAmJiBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU0NvbmRpdGlvblJ1bGUpIHtcbiAgICAgIGNvbnN0IHJ1bGVzMiA9IEFycmF5LmZyb20oXG4gICAgICAgIGNoaWxkUnVsZS5wYXJlbnRSdWxlLmNzc1J1bGVzXG4gICAgICApO1xuICAgICAgY29uc3QgaW5kZXggPSBydWxlczIuaW5kZXhPZihjaGlsZFJ1bGUpO1xuICAgICAgcG9zLnVuc2hpZnQoaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQpIHtcbiAgICAgIGNvbnN0IHJ1bGVzMiA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQuY3NzUnVsZXMpO1xuICAgICAgY29uc3QgaW5kZXggPSBydWxlczIuaW5kZXhPZihjaGlsZFJ1bGUpO1xuICAgICAgcG9zLnVuc2hpZnQoaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xuICB9XG4gIHJldHVybiByZWN1cnNlKHJ1bGUsIHBvc2l0aW9ucyk7XG59XG5mdW5jdGlvbiBnZXRJZEFuZFN0eWxlSWQoc2hlZXQsIG1pcnJvcjIsIHN0eWxlTWlycm9yKSB7XG4gIGxldCBpZCwgc3R5bGVJZDtcbiAgaWYgKCFzaGVldCkgcmV0dXJuIHt9O1xuICBpZiAoc2hlZXQub3duZXJOb2RlKSBpZCA9IG1pcnJvcjIuZ2V0SWQoc2hlZXQub3duZXJOb2RlKTtcbiAgZWxzZSBzdHlsZUlkID0gc3R5bGVNaXJyb3IuZ2V0SWQoc2hlZXQpO1xuICByZXR1cm4ge1xuICAgIHN0eWxlSWQsXG4gICAgaWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGluaXRTdHlsZVNoZWV0T2JzZXJ2ZXIoeyBzdHlsZVNoZWV0UnVsZUNiLCBtaXJyb3I6IG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyIH0sIHsgd2luIH0pIHtcbiAgaWYgKCF3aW4uQ1NTU3R5bGVTaGVldCB8fCAhd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGluc2VydFJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZTtcbiAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGUgPSBuZXcgUHJveHkoaW5zZXJ0UnVsZSwge1xuICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoXG4gICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgIGNvbnN0IFtydWxlLCBpbmRleF0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgYWRkczogW3sgcnVsZSwgaW5kZXggfV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgfVxuICAgIClcbiAgfSk7XG4gIGNvbnN0IGRlbGV0ZVJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZTtcbiAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBuZXcgUHJveHkoZGVsZXRlUnVsZSwge1xuICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoXG4gICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgIGNvbnN0IFtpbmRleF0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgcmVtb3ZlczogW3sgaW5kZXggfV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgfVxuICAgIClcbiAgfSk7XG4gIGxldCByZXBsYWNlO1xuICBpZiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UpIHtcbiAgICByZXBsYWNlID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2U7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UgPSBuZXcgUHJveHkocmVwbGFjZSwge1xuICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICAgKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IFt0ZXh0XSA9IGFyZ3VtZW50c0xpc3Q7XG4gICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICAgIG1pcnJvcjIsXG4gICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICAgIHJlcGxhY2U6IHRleHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgfSk7XG4gIH1cbiAgbGV0IHJlcGxhY2VTeW5jO1xuICBpZiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jKSB7XG4gICAgcmVwbGFjZVN5bmMgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmM7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jID0gbmV3IFByb3h5KHJlcGxhY2VTeW5jLCB7XG4gICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKFxuICAgICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgW3RleHRdID0gYXJndW1lbnRzTGlzdDtcbiAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoXG4gICAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgICAgbWlycm9yMixcbiAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgc3R5bGVJZCxcbiAgICAgICAgICAgICAgcmVwbGFjZVN5bmM6IHRleHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzID0ge307XG4gIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoXCJDU1NHcm91cGluZ1J1bGVcIikpIHtcbiAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTR3JvdXBpbmdSdWxlID0gd2luLkNTU0dyb3VwaW5nUnVsZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTTWVkaWFSdWxlXCIpKSB7XG4gICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTTWVkaWFSdWxlID0gd2luLkNTU01lZGlhUnVsZTtcbiAgICB9XG4gICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShcIkNTU0NvbmRpdGlvblJ1bGVcIikpIHtcbiAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NDb25kaXRpb25SdWxlID0gd2luLkNTU0NvbmRpdGlvblJ1bGU7XG4gICAgfVxuICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoXCJDU1NTdXBwb3J0c1J1bGVcIikpIHtcbiAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NTdXBwb3J0c1J1bGUgPSB3aW4uQ1NTU3VwcG9ydHNSdWxlO1xuICAgIH1cbiAgfVxuICBjb25zdCB1bm1vZGlmaWVkRnVuY3Rpb25zID0ge307XG4gIE9iamVjdC5lbnRyaWVzKHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcykuZm9yRWFjaCgoW3R5cGVLZXksIHR5cGVdKSA9PiB7XG4gICAgdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XSA9IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgIGluc2VydFJ1bGU6IHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICBkZWxldGVSdWxlOiB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlXG4gICAgfTtcbiAgICB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlID0gbmV3IFByb3h5KFxuICAgICAgdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5pbnNlcnRSdWxlLFxuICAgICAge1xuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKFxuICAgICAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtydWxlLCBpbmRleF0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgICAgICB0aGlzQXJnLnBhcmVudFN0eWxlU2hlZXQsXG4gICAgICAgICAgICAgIG1pcnJvcjIsXG4gICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgYWRkczogW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogW1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZyksXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXggfHwgMFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHRzIHRvIDBcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgICk7XG4gICAgdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IG5ldyBQcm94eShcbiAgICAgIHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uZGVsZXRlUnVsZSxcbiAgICAgIHtcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbaW5kZXhdID0gYXJndW1lbnRzTGlzdDtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZChcbiAgICAgICAgICAgICAgdGhpc0FyZy5wYXJlbnRTdHlsZVNoZWV0LFxuICAgICAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICAgIHJlbW92ZXM6IFtcbiAgICAgICAgICAgICAgICAgIHsgaW5kZXg6IFsuLi5nZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcpLCBpbmRleF0gfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgICk7XG4gIH0pO1xuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IGluc2VydFJ1bGU7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBkZWxldGVSdWxlO1xuICAgIHJlcGxhY2UgJiYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlID0gcmVwbGFjZSk7XG4gICAgcmVwbGFjZVN5bmMgJiYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYyA9IHJlcGxhY2VTeW5jKTtcbiAgICBPYmplY3QuZW50cmllcyhzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMpLmZvckVhY2goKFt0eXBlS2V5LCB0eXBlXSkgPT4ge1xuICAgICAgdHlwZS5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uaW5zZXJ0UnVsZTtcbiAgICAgIHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmRlbGV0ZVJ1bGU7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoe1xuICBtaXJyb3I6IG1pcnJvcjIsXG4gIHN0eWxlc2hlZXRNYW5hZ2VyXG59LCBob3N0KSB7XG4gIGxldCBob3N0SWQgPSBudWxsO1xuICBpZiAoaG9zdC5ub2RlTmFtZSA9PT0gXCIjZG9jdW1lbnRcIikgaG9zdElkID0gbWlycm9yMi5nZXRJZChob3N0KTtcbiAgZWxzZSBob3N0SWQgPSBtaXJyb3IyLmdldElkKGhvc3QuaG9zdCk7XG4gIGNvbnN0IHBhdGNoVGFyZ2V0ID0gaG9zdC5ub2RlTmFtZSA9PT0gXCIjZG9jdW1lbnRcIiA/IGhvc3QuZGVmYXVsdFZpZXc/LkRvY3VtZW50IDogaG9zdC5vd25lckRvY3VtZW50Py5kZWZhdWx0Vmlldz8uU2hhZG93Um9vdDtcbiAgY29uc3Qgb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IgPSBwYXRjaFRhcmdldD8ucHJvdG90eXBlID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICBwYXRjaFRhcmdldD8ucHJvdG90eXBlLFxuICAgIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCJcbiAgKSA6IHZvaWQgMDtcbiAgaWYgKGhvc3RJZCA9PT0gbnVsbCB8fCBob3N0SWQgPT09IC0xIHx8ICFwYXRjaFRhcmdldCB8fCAhb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdCwgXCJhZG9wdGVkU3R5bGVTaGVldHNcIiwge1xuICAgIGNvbmZpZ3VyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgIGVudW1lcmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmdldD8uY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldChzaGVldHMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLnNldD8uY2FsbCh0aGlzLCBzaGVldHMpO1xuICAgICAgaWYgKGhvc3RJZCAhPT0gbnVsbCAmJiBob3N0SWQgIT09IC0xKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhzaGVldHMsIGhvc3RJZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3QsIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgZW51bWVyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgIGdldDogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZ2V0LFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgc2V0OiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5zZXRcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0U3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKHtcbiAgc3R5bGVEZWNsYXJhdGlvbkNiLFxuICBtaXJyb3I6IG1pcnJvcjIsXG4gIGlnbm9yZUNTU0F0dHJpYnV0ZXMsXG4gIHN0eWxlc2hlZXRNYW5hZ2VyXG59LCB7IHdpbiB9KSB7XG4gIGNvbnN0IHNldFByb3BlcnR5ID0gd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5O1xuICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBuZXcgUHJveHkoc2V0UHJvcGVydHksIHtcbiAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKFxuICAgICAgKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xuICAgICAgICBjb25zdCBbcHJvcGVydHksIHZhbHVlLCBwcmlvcml0eV0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFByb3BlcnR5LmFwcGx5KHRoaXNBcmcsIFtwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5XSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgIHRoaXNBcmcucGFyZW50UnVsZT8ucGFyZW50U3R5bGVTaGVldCxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICBzZXQ6IHtcbiAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBwcmlvcml0eVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBpbmRleDogZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnLnBhcmVudFJ1bGUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgIH1cbiAgICApXG4gIH0pO1xuICBjb25zdCByZW1vdmVQcm9wZXJ0eSA9IHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eTtcbiAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5ID0gbmV3IFByb3h5KHJlbW92ZVByb3BlcnR5LCB7XG4gICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgY29uc3QgW3Byb3BlcnR5XSA9IGFyZ3VtZW50c0xpc3Q7XG4gICAgICAgIGlmIChpZ25vcmVDU1NBdHRyaWJ1dGVzLmhhcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVtb3ZlUHJvcGVydHkuYXBwbHkodGhpc0FyZywgW3Byb3BlcnR5XSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgIHRoaXNBcmcucGFyZW50UnVsZT8ucGFyZW50U3R5bGVTaGVldCxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICByZW1vdmU6IHtcbiAgICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgaW5kZXg6IGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZy5wYXJlbnRSdWxlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICB9XG4gICAgKVxuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XG4gICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5ID0gcmVtb3ZlUHJvcGVydHk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdE1lZGlhSW50ZXJhY3Rpb25PYnNlcnZlcih7XG4gIG1lZGlhSW50ZXJhY3Rpb25DYixcbiAgYmxvY2tDbGFzcyxcbiAgYmxvY2tTZWxlY3RvcixcbiAgdW5ibG9ja1NlbGVjdG9yLFxuICBtaXJyb3I6IG1pcnJvcjIsXG4gIHNhbXBsaW5nLFxuICBkb2Ncbn0pIHtcbiAgY29uc3QgaGFuZGxlciA9IGNhbGxiYWNrV3JhcHBlcihcbiAgICAodHlwZSkgPT4gdGhyb3R0bGUkMShcbiAgICAgIGNhbGxiYWNrV3JhcHBlcigoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgICAgICBpZiAoIXRhcmdldCB8fCBpc0Jsb2NrZWQoXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFRpbWUsIHZvbHVtZSwgbXV0ZWQsIHBsYXliYWNrUmF0ZSB9ID0gdGFyZ2V0O1xuICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2Ioe1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgaWQ6IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KSxcbiAgICAgICAgICBjdXJyZW50VGltZSxcbiAgICAgICAgICB2b2x1bWUsXG4gICAgICAgICAgbXV0ZWQsXG4gICAgICAgICAgcGxheWJhY2tSYXRlXG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBzYW1wbGluZy5tZWRpYSB8fCA1MDBcbiAgICApXG4gICk7XG4gIGNvbnN0IGhhbmRsZXJzID0gW1xuICAgIG9uKFwicGxheVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlBsYXkpLCBkb2MpLFxuICAgIG9uKFwicGF1c2VcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5QYXVzZSksIGRvYyksXG4gICAgb24oXCJzZWVrZWRcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5TZWVrZWQpLCBkb2MpLFxuICAgIG9uKFwidm9sdW1lY2hhbmdlXCIsIGhhbmRsZXIoTWVkaWFJbnRlcmFjdGlvbnMuVm9sdW1lQ2hhbmdlKSwgZG9jKSxcbiAgICBvbihcInJhdGVjaGFuZ2VcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5SYXRlQ2hhbmdlKSwgZG9jKVxuICBdO1xuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRGb250T2JzZXJ2ZXIoeyBmb250Q2IsIGRvYyB9KSB7XG4gIGNvbnN0IHdpbiA9IGRvYy5kZWZhdWx0VmlldztcbiAgaWYgKCF3aW4pIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgY29uc3QgZm9udE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBvcmlnaW5hbEZvbnRGYWNlID0gd2luLkZvbnRGYWNlO1xuICB3aW4uRm9udEZhY2UgPSBmdW5jdGlvbiBGb250RmFjZTIoZmFtaWx5LCBzb3VyY2UsIGRlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgZm9udEZhY2UgPSBuZXcgb3JpZ2luYWxGb250RmFjZShmYW1pbHksIHNvdXJjZSwgZGVzY3JpcHRvcnMpO1xuICAgIGZvbnRNYXAuc2V0KGZvbnRGYWNlLCB7XG4gICAgICBmYW1pbHksXG4gICAgICBidWZmZXI6IHR5cGVvZiBzb3VyY2UgIT09IFwic3RyaW5nXCIsXG4gICAgICBkZXNjcmlwdG9ycyxcbiAgICAgIGZvbnRTb3VyY2U6IHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIgPyBzb3VyY2UgOiBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KHNvdXJjZSkpKVxuICAgIH0pO1xuICAgIHJldHVybiBmb250RmFjZTtcbiAgfTtcbiAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChcbiAgICBkb2MuZm9udHMsXG4gICAgXCJhZGRcIixcbiAgICBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZvbnRGYWNlKSB7XG4gICAgICAgIHNldFRpbWVvdXQkMShcbiAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcCA9IGZvbnRNYXAuZ2V0KGZvbnRGYWNlKTtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgIGZvbnRDYihwKTtcbiAgICAgICAgICAgICAgZm9udE1hcC5kZWxldGUoZm9udEZhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtmb250RmFjZV0pO1xuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGhhbmRsZXJzLnB1c2goKCkgPT4ge1xuICAgIHdpbi5Gb250RmFjZSA9IG9yaWdpbmFsRm9udEZhY2U7XG4gIH0pO1xuICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0U2VsZWN0aW9uT2JzZXJ2ZXIocGFyYW0pIHtcbiAgY29uc3Qge1xuICAgIGRvYyxcbiAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgYmxvY2tDbGFzcyxcbiAgICBibG9ja1NlbGVjdG9yLFxuICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICBzZWxlY3Rpb25DYlxuICB9ID0gcGFyYW07XG4gIGxldCBjb2xsYXBzZWQgPSB0cnVlO1xuICBjb25zdCB1cGRhdGVTZWxlY3Rpb24gPSBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvYy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCBjb2xsYXBzZWQgJiYgc2VsZWN0aW9uPy5pc0NvbGxhcHNlZCkgcmV0dXJuO1xuICAgIGNvbGxhcHNlZCA9IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCB8fCBmYWxzZTtcbiAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICBjb25zdCBjb3VudCA9IHNlbGVjdGlvbi5yYW5nZUNvdW50IHx8IDA7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGNvdW50OyBpMisrKSB7XG4gICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KGkyKTtcbiAgICAgIGNvbnN0IHsgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCB9ID0gcmFuZ2U7XG4gICAgICBjb25zdCBibG9ja2VkID0gaXNCbG9ja2VkKFxuICAgICAgICBzdGFydENvbnRhaW5lcixcbiAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgICAgICB0cnVlXG4gICAgICApIHx8IGlzQmxvY2tlZChcbiAgICAgICAgZW5kQ29udGFpbmVyLFxuICAgICAgICBibG9ja0NsYXNzLFxuICAgICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgICBpZiAoYmxvY2tlZCkgY29udGludWU7XG4gICAgICByYW5nZXMucHVzaCh7XG4gICAgICAgIHN0YXJ0OiBtaXJyb3IyLmdldElkKHN0YXJ0Q29udGFpbmVyKSxcbiAgICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZDogbWlycm9yMi5nZXRJZChlbmRDb250YWluZXIpLFxuICAgICAgICBlbmRPZmZzZXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZWxlY3Rpb25DYih7IHJhbmdlcyB9KTtcbiAgfSk7XG4gIHVwZGF0ZVNlbGVjdGlvbigpO1xuICByZXR1cm4gb24oXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdXBkYXRlU2VsZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGluaXRDdXN0b21FbGVtZW50T2JzZXJ2ZXIoe1xuICBkb2MsXG4gIGN1c3RvbUVsZW1lbnRDYlxufSkge1xuICBjb25zdCB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG4gIGlmICghd2luIHx8ICF3aW4uY3VzdG9tRWxlbWVudHMpIHJldHVybiAoKSA9PiB7XG4gIH07XG4gIGNvbnN0IHJlc3RvcmVIYW5kbGVyID0gcGF0Y2goXG4gICAgd2luLmN1c3RvbUVsZW1lbnRzLFxuICAgIFwiZGVmaW5lXCIsXG4gICAgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBjb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYih7XG4gICAgICAgICAgICBkZWZpbmU6IHtcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbbmFtZSwgY29uc3RydWN0b3IsIG9wdGlvbnNdKTtcbiAgICAgIH07XG4gICAgfVxuICApO1xuICByZXR1cm4gcmVzdG9yZUhhbmRsZXI7XG59XG5mdW5jdGlvbiBpbml0T2JzZXJ2ZXJzKG8yLCBfaG9va3MgPSB7fSkge1xuICBjb25zdCBjdXJyZW50V2luZG93ID0gbzIuZG9jLmRlZmF1bHRWaWV3O1xuICBpZiAoIWN1cnJlbnRXaW5kb3cpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgbGV0IG11dGF0aW9uT2JzZXJ2ZXI7XG4gIGlmIChvMi5yZWNvcmRET00pIHtcbiAgICBtdXRhdGlvbk9ic2VydmVyID0gaW5pdE11dGF0aW9uT2JzZXJ2ZXIobzIsIG8yLmRvYyk7XG4gIH1cbiAgY29uc3QgbW91c2Vtb3ZlSGFuZGxlciA9IGluaXRNb3ZlT2JzZXJ2ZXIobzIpO1xuICBjb25zdCBtb3VzZUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIobzIpO1xuICBjb25zdCBzY3JvbGxIYW5kbGVyID0gaW5pdFNjcm9sbE9ic2VydmVyKG8yKTtcbiAgY29uc3Qgdmlld3BvcnRSZXNpemVIYW5kbGVyID0gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIobzIsIHtcbiAgICB3aW46IGN1cnJlbnRXaW5kb3dcbiAgfSk7XG4gIGNvbnN0IGlucHV0SGFuZGxlciA9IGluaXRJbnB1dE9ic2VydmVyKG8yKTtcbiAgY29uc3QgbWVkaWFJbnRlcmFjdGlvbkhhbmRsZXIgPSBpbml0TWVkaWFJbnRlcmFjdGlvbk9ic2VydmVyKG8yKTtcbiAgbGV0IHN0eWxlU2hlZXRPYnNlcnZlciA9ICgpID0+IHtcbiAgfTtcbiAgbGV0IGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBmb250T2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIH07XG4gIGlmIChvMi5yZWNvcmRET00pIHtcbiAgICBzdHlsZVNoZWV0T2JzZXJ2ZXIgPSBpbml0U3R5bGVTaGVldE9ic2VydmVyKG8yLCB7IHdpbjogY3VycmVudFdpbmRvdyB9KTtcbiAgICBhZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyID0gaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIobzIsIG8yLmRvYyk7XG4gICAgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyID0gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcihvMiwge1xuICAgICAgd2luOiBjdXJyZW50V2luZG93XG4gICAgfSk7XG4gICAgaWYgKG8yLmNvbGxlY3RGb250cykge1xuICAgICAgZm9udE9ic2VydmVyID0gaW5pdEZvbnRPYnNlcnZlcihvMik7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGVjdGlvbk9ic2VydmVyID0gaW5pdFNlbGVjdGlvbk9ic2VydmVyKG8yKTtcbiAgY29uc3QgY3VzdG9tRWxlbWVudE9ic2VydmVyID0gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcihvMik7XG4gIGNvbnN0IHBsdWdpbkhhbmRsZXJzID0gW107XG4gIGZvciAoY29uc3QgcGx1Z2luIG9mIG8yLnBsdWdpbnMpIHtcbiAgICBwbHVnaW5IYW5kbGVycy5wdXNoKFxuICAgICAgcGx1Z2luLm9ic2VydmVyKHBsdWdpbi5jYWxsYmFjaywgY3VycmVudFdpbmRvdywgcGx1Z2luLm9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYikgPT4gYi5yZXNldCgpKTtcbiAgICBtdXRhdGlvbk9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgbW91c2Vtb3ZlSGFuZGxlcigpO1xuICAgIG1vdXNlSW50ZXJhY3Rpb25IYW5kbGVyKCk7XG4gICAgc2Nyb2xsSGFuZGxlcigpO1xuICAgIHZpZXdwb3J0UmVzaXplSGFuZGxlcigpO1xuICAgIGlucHV0SGFuZGxlcigpO1xuICAgIG1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyKCk7XG4gICAgc3R5bGVTaGVldE9ic2VydmVyKCk7XG4gICAgYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcigpO1xuICAgIHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcigpO1xuICAgIGZvbnRPYnNlcnZlcigpO1xuICAgIHNlbGVjdGlvbk9ic2VydmVyKCk7XG4gICAgY3VzdG9tRWxlbWVudE9ic2VydmVyKCk7XG4gICAgcGx1Z2luSGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYXNOZXN0ZWRDU1NSdWxlKHByb3ApIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3dbcHJvcF0gIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUocHJvcCkge1xuICByZXR1cm4gQm9vbGVhbihcbiAgICB0eXBlb2Ygd2luZG93W3Byb3BdICE9PSBcInVuZGVmaW5lZFwiICYmIC8vIE5vdGU6IEdlbmVyYWxseSwgdGhpcyBjaGVjayBfc2hvdWxkbid0XyBiZSBuZWNlc3NhcnlcbiAgICAvLyBIb3dldmVyLCBpbiBzb21lIHNjZW5hcmlvcyAoZS5nLiBqc2RvbSkgdGhpcyBjYW4gc29tZXRpbWVzIGZhaWwsIHNvIHdlIGNoZWNrIGZvciBpdCBoZXJlXG4gICAgd2luZG93W3Byb3BdLnByb3RvdHlwZSAmJiBcImluc2VydFJ1bGVcIiBpbiB3aW5kb3dbcHJvcF0ucHJvdG90eXBlICYmIFwiZGVsZXRlUnVsZVwiIGluIHdpbmRvd1twcm9wXS5wcm90b3R5cGVcbiAgKTtcbn1cbmNsYXNzIENyb3NzT3JpZ2luSWZyYW1lTWlycm9yIHtcbiAgY29uc3RydWN0b3IoZ2VuZXJhdGVJZEZuKSB7XG4gICAgdGhpcy5nZW5lcmF0ZUlkRm4gPSBnZW5lcmF0ZUlkRm47XG4gICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB9XG4gIGdldElkKGlmcmFtZSwgcmVtb3RlSWQsIGlkVG9SZW1vdGVNYXAsIHJlbW90ZVRvSWRNYXApIHtcbiAgICBjb25zdCBpZFRvUmVtb3RlSWRNYXAgPSBpZFRvUmVtb3RlTWFwIHx8IHRoaXMuZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSk7XG4gICAgY29uc3QgcmVtb3RlSWRUb0lkTWFwID0gcmVtb3RlVG9JZE1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgIGxldCBpZCA9IGlkVG9SZW1vdGVJZE1hcC5nZXQocmVtb3RlSWQpO1xuICAgIGlmICghaWQpIHtcbiAgICAgIGlkID0gdGhpcy5nZW5lcmF0ZUlkRm4oKTtcbiAgICAgIGlkVG9SZW1vdGVJZE1hcC5zZXQocmVtb3RlSWQsIGlkKTtcbiAgICAgIHJlbW90ZUlkVG9JZE1hcC5zZXQoaWQsIHJlbW90ZUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIGdldElkcyhpZnJhbWUsIHJlbW90ZUlkKSB7XG4gICAgY29uc3QgaWRUb1JlbW90ZUlkTWFwID0gdGhpcy5nZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKTtcbiAgICBjb25zdCByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgIHJldHVybiByZW1vdGVJZC5tYXAoXG4gICAgICAoaWQpID0+IHRoaXMuZ2V0SWQoaWZyYW1lLCBpZCwgaWRUb1JlbW90ZUlkTWFwLCByZW1vdGVJZFRvSWRNYXApXG4gICAgKTtcbiAgfVxuICBnZXRSZW1vdGVJZChpZnJhbWUsIGlkLCBtYXApIHtcbiAgICBjb25zdCByZW1vdGVJZFRvSWRNYXAgPSBtYXAgfHwgdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcbiAgICBpZiAodHlwZW9mIGlkICE9PSBcIm51bWJlclwiKSByZXR1cm4gaWQ7XG4gICAgY29uc3QgcmVtb3RlSWQgPSByZW1vdGVJZFRvSWRNYXAuZ2V0KGlkKTtcbiAgICBpZiAoIXJlbW90ZUlkKSByZXR1cm4gLTE7XG4gICAgcmV0dXJuIHJlbW90ZUlkO1xuICB9XG4gIGdldFJlbW90ZUlkcyhpZnJhbWUsIGlkcykge1xuICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XG4gICAgcmV0dXJuIGlkcy5tYXAoKGlkKSA9PiB0aGlzLmdldFJlbW90ZUlkKGlmcmFtZSwgaWQsIHJlbW90ZUlkVG9JZE1hcCkpO1xuICB9XG4gIHJlc2V0KGlmcmFtZSkge1xuICAgIGlmICghaWZyYW1lKSB7XG4gICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuZGVsZXRlKGlmcmFtZSk7XG4gICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAuZGVsZXRlKGlmcmFtZSk7XG4gIH1cbiAgZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSkge1xuICAgIGxldCBpZFRvUmVtb3RlSWRNYXAgPSB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5nZXQoaWZyYW1lKTtcbiAgICBpZiAoIWlkVG9SZW1vdGVJZE1hcCkge1xuICAgICAgaWRUb1JlbW90ZUlkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwLnNldChpZnJhbWUsIGlkVG9SZW1vdGVJZE1hcCk7XG4gICAgfVxuICAgIHJldHVybiBpZFRvUmVtb3RlSWRNYXA7XG4gIH1cbiAgZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSkge1xuICAgIGxldCByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5nZXQoaWZyYW1lKTtcbiAgICBpZiAoIXJlbW90ZUlkVG9JZE1hcCkge1xuICAgICAgcmVtb3RlSWRUb0lkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLnNldChpZnJhbWUsIHJlbW90ZUlkVG9JZE1hcCk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVJZFRvSWRNYXA7XG4gIH1cbn1cbmNsYXNzIElmcmFtZU1hbmFnZXJOb29wIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZU1pcnJvciA9IG5ldyBDcm9zc09yaWdpbklmcmFtZU1pcnJvcihnZW5JZCk7XG4gICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB9XG4gIGFkZElmcmFtZSgpIHtcbiAgfVxuICBhZGRMb2FkTGlzdGVuZXIoKSB7XG4gIH1cbiAgYXR0YWNoSWZyYW1lKCkge1xuICB9XG59XG5jbGFzcyBJZnJhbWVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuaWZyYW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yID0gbmV3IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yKGdlbklkKTtcbiAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xuICAgIHRoaXMud3JhcHBlZEVtaXQgPSBvcHRpb25zLndyYXBwZWRFbWl0O1xuICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIgPSBvcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyO1xuICAgIHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzID0gb3B0aW9ucy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXM7XG4gICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yID0gbmV3IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yKFxuICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvci5nZW5lcmF0ZUlkLmJpbmQoXG4gICAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3JcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XG4gICAgaWYgKHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuICBhZGRJZnJhbWUoaWZyYW1lRWwpIHtcbiAgICB0aGlzLmlmcmFtZXMuc2V0KGlmcmFtZUVsLCB0cnVlKTtcbiAgICBpZiAoaWZyYW1lRWwuY29udGVudFdpbmRvdylcbiAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNYXAuc2V0KGlmcmFtZUVsLmNvbnRlbnRXaW5kb3csIGlmcmFtZUVsKTtcbiAgfVxuICBhZGRMb2FkTGlzdGVuZXIoY2IpIHtcbiAgICB0aGlzLmxvYWRMaXN0ZW5lciA9IGNiO1xuICB9XG4gIGF0dGFjaElmcmFtZShpZnJhbWVFbCwgY2hpbGRTbikge1xuICAgIHRoaXMubXV0YXRpb25DYih7XG4gICAgICBhZGRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwYXJlbnRJZDogdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwpLFxuICAgICAgICAgIG5leHRJZDogbnVsbCxcbiAgICAgICAgICBub2RlOiBjaGlsZFNuXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICByZW1vdmVzOiBbXSxcbiAgICAgIHRleHRzOiBbXSxcbiAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgaXNBdHRhY2hJZnJhbWU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAodGhpcy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMpXG4gICAgICBpZnJhbWVFbC5jb250ZW50V2luZG93Py5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQodGhpcylcbiAgICAgICk7XG4gICAgdGhpcy5sb2FkTGlzdGVuZXI/LihpZnJhbWVFbCk7XG4gICAgY29uc3QgaWZyYW1lRG9jID0gZ2V0SUZyYW1lQ29udGVudERvY3VtZW50KGlmcmFtZUVsKTtcbiAgICBpZiAoaWZyYW1lRG9jICYmIGlmcmFtZURvYy5hZG9wdGVkU3R5bGVTaGVldHMgJiYgaWZyYW1lRG9jLmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKVxuICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKFxuICAgICAgICBpZnJhbWVEb2MuYWRvcHRlZFN0eWxlU2hlZXRzLFxuICAgICAgICB0aGlzLm1pcnJvci5nZXRJZChpZnJhbWVEb2MpXG4gICAgICApO1xuICB9XG4gIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50ID0gbWVzc2FnZTtcbiAgICBpZiAoY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS50eXBlICE9PSBcInJyd2ViXCIgfHwgLy8gVG8gZmlsdGVyIG91dCB0aGUgcnJ3ZWIgbWVzc2FnZXMgd2hpY2ggYXJlIGZvcndhcmRlZCBieSBzb21lIHNpdGVzLlxuICAgIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50Lm9yaWdpbiAhPT0gY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS5vcmlnaW4pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaWZyYW1lU291cmNlV2luZG93ID0gbWVzc2FnZS5zb3VyY2U7XG4gICAgaWYgKCFpZnJhbWVTb3VyY2VXaW5kb3cpIHJldHVybjtcbiAgICBjb25zdCBpZnJhbWVFbCA9IHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNYXAuZ2V0KG1lc3NhZ2Uuc291cmNlKTtcbiAgICBpZiAoIWlmcmFtZUVsKSByZXR1cm47XG4gICAgY29uc3QgdHJhbnNmb3JtZWRFdmVudCA9IHRoaXMudHJhbnNmb3JtQ3Jvc3NPcmlnaW5FdmVudChcbiAgICAgIGlmcmFtZUVsLFxuICAgICAgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS5ldmVudFxuICAgICk7XG4gICAgaWYgKHRyYW5zZm9ybWVkRXZlbnQpXG4gICAgICB0aGlzLndyYXBwZWRFbWl0KFxuICAgICAgICB0cmFuc2Zvcm1lZEV2ZW50LFxuICAgICAgICBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLmlzQ2hlY2tvdXRcbiAgICAgICk7XG4gIH1cbiAgdHJhbnNmb3JtQ3Jvc3NPcmlnaW5FdmVudChpZnJhbWVFbCwgZTIpIHtcbiAgICBzd2l0Y2ggKGUyLnR5cGUpIHtcbiAgICAgIGNhc2UgRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdDoge1xuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcbiAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUoZTIuZGF0YS5ub2RlLCBpZnJhbWVFbCk7XG4gICAgICAgIGNvbnN0IHJvb3RJZCA9IGUyLmRhdGEubm9kZS5pZDtcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcC5zZXQoaWZyYW1lRWwsIHJvb3RJZCk7XG4gICAgICAgIHRoaXMucGF0Y2hSb290SWRPbk5vZGUoZTIuZGF0YS5ub2RlLCByb290SWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRpbWVzdGFtcDogZTIudGltZXN0YW1wLFxuICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24sXG4gICAgICAgICAgICBhZGRzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJZDogdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwpLFxuICAgICAgICAgICAgICAgIG5leHRJZDogbnVsbCxcbiAgICAgICAgICAgICAgICBub2RlOiBlMi5kYXRhLm5vZGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHJlbW92ZXM6IFtdLFxuICAgICAgICAgICAgdGV4dHM6IFtdLFxuICAgICAgICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICAgICAgICBpc0F0dGFjaElmcmFtZTogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgRXZlbnRUeXBlLk1ldGE6XG4gICAgICBjYXNlIEV2ZW50VHlwZS5Mb2FkOlxuICAgICAgY2FzZSBFdmVudFR5cGUuRG9tQ29udGVudExvYWRlZDoge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjYXNlIEV2ZW50VHlwZS5QbHVnaW46IHtcbiAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgfVxuICAgICAgY2FzZSBFdmVudFR5cGUuQ3VzdG9tOiB7XG4gICAgICAgIHRoaXMucmVwbGFjZUlkcyhcbiAgICAgICAgICBlMi5kYXRhLnBheWxvYWQsXG4gICAgICAgICAgaWZyYW1lRWwsXG4gICAgICAgICAgW1wiaWRcIiwgXCJwYXJlbnRJZFwiLCBcInByZXZpb3VzSWRcIiwgXCJuZXh0SWRcIl1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgfVxuICAgICAgY2FzZSBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdDoge1xuICAgICAgICBzd2l0Y2ggKGUyLmRhdGEuc291cmNlKSB7XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5NdXRhdGlvbjoge1xuICAgICAgICAgICAgZTIuZGF0YS5hZGRzLmZvckVhY2goKG4yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICBcInBhcmVudElkXCIsXG4gICAgICAgICAgICAgICAgXCJuZXh0SWRcIixcbiAgICAgICAgICAgICAgICBcInByZXZpb3VzSWRcIlxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUobjIubm9kZSwgaWZyYW1lRWwpO1xuICAgICAgICAgICAgICBjb25zdCByb290SWQgPSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwLmdldChpZnJhbWVFbCk7XG4gICAgICAgICAgICAgIHJvb3RJZCAmJiB0aGlzLnBhdGNoUm9vdElkT25Ob2RlKG4yLm5vZGUsIHJvb3RJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUyLmRhdGEucmVtb3Zlcy5mb3JFYWNoKChuMikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXCJwYXJlbnRJZFwiLCBcImlkXCJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZTIuZGF0YS5hdHRyaWJ1dGVzLmZvckVhY2goKG4yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcImlkXCJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZTIuZGF0YS50ZXh0cy5mb3JFYWNoKChuMikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXCJpZFwiXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5EcmFnOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuVG91Y2hNb3ZlOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VNb3ZlOiB7XG4gICAgICAgICAgICBlMi5kYXRhLnBvc2l0aW9ucy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhwLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuVmlld3BvcnRSZXNpemU6IHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5NZWRpYUludGVyYWN0aW9uOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvbjpcbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlNjcm9sbDpcbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLkNhbnZhc011dGF0aW9uOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQ6IHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlN0eWxlU2hlZXRSdWxlOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVEZWNsYXJhdGlvbjoge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUyLmRhdGEsIGlmcmFtZUVsLCBbXCJpZFwiXSk7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1wic3R5bGVJZFwiXSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuRm9udDoge1xuICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlNlbGVjdGlvbjoge1xuICAgICAgICAgICAgZTIuZGF0YS5yYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKHJhbmdlLCBpZnJhbWVFbCwgW1wic3RhcnRcIiwgXCJlbmRcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuQWRvcHRlZFN0eWxlU2hlZXQ6IHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3R5bGVJZHMoZTIuZGF0YSwgaWZyYW1lRWwsIFtcInN0eWxlSWRzXCJdKTtcbiAgICAgICAgICAgIGUyLmRhdGEuc3R5bGVzPy5mb3JFYWNoKChzdHlsZSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhzdHlsZSwgaWZyYW1lRWwsIFtcInN0eWxlSWRcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXBsYWNlKGlmcmFtZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmpba2V5XSkgJiYgdHlwZW9mIG9ialtrZXldICE9PSBcIm51bWJlclwiKSBjb250aW51ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xuICAgICAgICBvYmpba2V5XSA9IGlmcmFtZU1pcnJvci5nZXRJZHMoXG4gICAgICAgICAgaWZyYW1lRWwsXG4gICAgICAgICAgb2JqW2tleV1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gaWZyYW1lTWlycm9yLmdldElkKGlmcmFtZUVsLCBvYmpba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgcmVwbGFjZUlkcyhvYmosIGlmcmFtZUVsLCBrZXlzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKTtcbiAgfVxuICByZXBsYWNlU3R5bGVJZHMob2JqLCBpZnJhbWVFbCwga2V5cykge1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2UodGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKTtcbiAgfVxuICByZXBsYWNlSWRPbk5vZGUobm9kZSwgaWZyYW1lRWwpIHtcbiAgICB0aGlzLnJlcGxhY2VJZHMobm9kZSwgaWZyYW1lRWwsIFtcImlkXCIsIFwicm9vdElkXCJdKTtcbiAgICBpZiAoXCJjaGlsZE5vZGVzXCIgaW4gbm9kZSkge1xuICAgICAgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIHRoaXMucmVwbGFjZUlkT25Ob2RlKGNoaWxkLCBpZnJhbWVFbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcGF0Y2hSb290SWRPbk5vZGUobm9kZSwgcm9vdElkKSB7XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gTm9kZVR5cGUkMi5Eb2N1bWVudCAmJiAhbm9kZS5yb290SWQpIG5vZGUucm9vdElkID0gcm9vdElkO1xuICAgIGlmIChcImNoaWxkTm9kZXNcIiBpbiBub2RlKSB7XG4gICAgICBub2RlLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShjaGlsZCwgcm9vdElkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgU2hhZG93RG9tTWFuYWdlck5vb3Age1xuICBpbml0KCkge1xuICB9XG4gIGFkZFNoYWRvd1Jvb3QoKSB7XG4gIH1cbiAgb2JzZXJ2ZUF0dGFjaFNoYWRvdygpIHtcbiAgfVxuICByZXNldCgpIHtcbiAgfVxufVxuY2xhc3MgU2hhZG93RG9tTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNoYWRvd0RvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICB0aGlzLnJlc3RvcmVIYW5kbGVycyA9IFtdO1xuICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcbiAgICB0aGlzLnNjcm9sbENiID0gb3B0aW9ucy5zY3JvbGxDYjtcbiAgICB0aGlzLmJ5cGFzc09wdGlvbnMgPSBvcHRpb25zLmJ5cGFzc09wdGlvbnM7XG4gICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLnBhdGNoQXR0YWNoU2hhZG93KEVsZW1lbnQsIGRvY3VtZW50KTtcbiAgfVxuICBhZGRTaGFkb3dSb290KHNoYWRvd1Jvb3QsIGRvYykge1xuICAgIGlmICghaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdCkpIHJldHVybjtcbiAgICBpZiAodGhpcy5zaGFkb3dEb21zLmhhcyhzaGFkb3dSb290KSkgcmV0dXJuO1xuICAgIHRoaXMuc2hhZG93RG9tcy5hZGQoc2hhZG93Um9vdCk7XG4gICAgdGhpcy5ieXBhc3NPcHRpb25zLmNhbnZhc01hbmFnZXIuYWRkU2hhZG93Um9vdChzaGFkb3dSb290KTtcbiAgICBjb25zdCBvYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKFxuICAgICAge1xuICAgICAgICAuLi50aGlzLmJ5cGFzc09wdGlvbnMsXG4gICAgICAgIGRvYyxcbiAgICAgICAgbXV0YXRpb25DYjogdGhpcy5tdXRhdGlvbkNiLFxuICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxuICAgICAgICBzaGFkb3dEb21NYW5hZ2VyOiB0aGlzXG4gICAgICB9LFxuICAgICAgc2hhZG93Um9vdFxuICAgICk7XG4gICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaCgoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCkpO1xuICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goXG4gICAgICBpbml0U2Nyb2xsT2JzZXJ2ZXIoe1xuICAgICAgICAuLi50aGlzLmJ5cGFzc09wdGlvbnMsXG4gICAgICAgIHNjcm9sbENiOiB0aGlzLnNjcm9sbENiLFxuICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wcmF2ZWVucHVnbGlhLzA4MzJkYTY4N2VkNWE1ZDdhMDkwNzA0NmM5ZWYxODEzXG4gICAgICAgIC8vIHNjcm9sbCBpcyBub3QgYWxsb3dlZCB0byBwYXNzIHRoZSBib3VuZGFyeSwgc28gd2UgbmVlZCB0byBsaXN0ZW4gdGhlIHNoYWRvdyBkb2N1bWVudFxuICAgICAgICBkb2M6IHNoYWRvd1Jvb3QsXG4gICAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcbiAgICAgIH0pXG4gICAgKTtcbiAgICBzZXRUaW1lb3V0JDEoKCkgPT4ge1xuICAgICAgaWYgKHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzICYmIHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzLmxlbmd0aCA+IDApXG4gICAgICAgIHRoaXMuYnlwYXNzT3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKFxuICAgICAgICAgIHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzLFxuICAgICAgICAgIHRoaXMubWlycm9yLmdldElkKHNoYWRvd1Jvb3QuaG9zdClcbiAgICAgICAgKTtcbiAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goXG4gICAgICAgIGluaXRBZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXG4gICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcjogdGhpcy5ieXBhc3NPcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaGFkb3dSb290XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vbmtleSBwYXRjaCAnYXR0YWNoU2hhZG93JyBvZiBhbiBJRnJhbWVFbGVtZW50IHRvIG9ic2VydmUgbmV3bHkgYWRkZWQgc2hhZG93IGRvbXMuXG4gICAqL1xuICBvYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZUVsZW1lbnQpIHtcbiAgICBjb25zdCBpZnJhbWVEb2MgPSBnZXRJRnJhbWVDb250ZW50RG9jdW1lbnQoaWZyYW1lRWxlbWVudCk7XG4gICAgY29uc3QgaWZyYW1lV2luZG93ID0gZ2V0SUZyYW1lQ29udGVudFdpbmRvdyhpZnJhbWVFbGVtZW50KTtcbiAgICBpZiAoIWlmcmFtZURvYyB8fCAhaWZyYW1lV2luZG93KSByZXR1cm47XG4gICAgdGhpcy5wYXRjaEF0dGFjaFNoYWRvdyhcbiAgICAgIGlmcmFtZVdpbmRvdy5FbGVtZW50LFxuICAgICAgaWZyYW1lRG9jXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUGF0Y2ggJ2F0dGFjaFNoYWRvdycgdG8gb2JzZXJ2ZSBuZXdseSBhZGRlZCBzaGFkb3cgZG9tcy5cbiAgICovXG4gIHBhdGNoQXR0YWNoU2hhZG93KGVsZW1lbnQsIGRvYykge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB0aGlzO1xuICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goXG4gICAgICBwYXRjaChcbiAgICAgICAgZWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgIFwiYXR0YWNoU2hhZG93XCIsXG4gICAgICAgIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IG9yaWdpbmFsLmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QgJiYgaW5Eb20odGhpcykpXG4gICAgICAgICAgICAgIG1hbmFnZXIuYWRkU2hhZG93Um9vdCh0aGlzLnNoYWRvd1Jvb3QsIGRvYyk7XG4gICAgICAgICAgICByZXR1cm4gc2hhZG93Um9vdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyKCk7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzID0gW107XG4gICAgdGhpcy5zaGFkb3dEb21zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy5ieXBhc3NPcHRpb25zLmNhbnZhc01hbmFnZXIucmVzZXRTaGFkb3dSb290cygpO1xuICB9XG59XG52YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbnZhciBsb29rdXAgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoYXJzLmxlbmd0aDsgaSQxKyspIHtcbiAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSQxKV0gPSBpJDE7XG59XG5jbGFzcyBDYW52YXNNYW5hZ2VyTm9vcCB7XG4gIHJlc2V0KCkge1xuICB9XG4gIGZyZWV6ZSgpIHtcbiAgfVxuICB1bmZyZWV6ZSgpIHtcbiAgfVxuICBsb2NrKCkge1xuICB9XG4gIHVubG9jaygpIHtcbiAgfVxuICBzbmFwc2hvdCgpIHtcbiAgfVxuICBhZGRXaW5kb3coKSB7XG4gIH1cbiAgYWRkU2hhZG93Um9vdCgpIHtcbiAgfVxuICByZXNldFNoYWRvd1Jvb3RzKCkge1xuICB9XG59XG5jbGFzcyBTdHlsZXNoZWV0TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICB0aGlzLnN0eWxlTWlycm9yID0gbmV3IFN0eWxlU2hlZXRNaXJyb3IoKTtcbiAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XG4gICAgdGhpcy5hZG9wdGVkU3R5bGVTaGVldENiID0gb3B0aW9ucy5hZG9wdGVkU3R5bGVTaGVldENiO1xuICB9XG4gIGF0dGFjaExpbmtFbGVtZW50KGxpbmtFbCwgY2hpbGRTbikge1xuICAgIGlmIChcIl9jc3NUZXh0XCIgaW4gY2hpbGRTbi5hdHRyaWJ1dGVzKVxuICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcbiAgICAgICAgYWRkczogW10sXG4gICAgICAgIHJlbW92ZXM6IFtdLFxuICAgICAgICB0ZXh0czogW10sXG4gICAgICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogY2hpbGRTbi5pZCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGNoaWxkU24uYXR0cmlidXRlc1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgdGhpcy50cmFja0xpbmtFbGVtZW50KGxpbmtFbCk7XG4gIH1cbiAgdHJhY2tMaW5rRWxlbWVudChsaW5rRWwpIHtcbiAgICBpZiAodGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmhhcyhsaW5rRWwpKSByZXR1cm47XG4gICAgdGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmFkZChsaW5rRWwpO1xuICAgIHRoaXMudHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChsaW5rRWwpO1xuICB9XG4gIGFkb3B0U3R5bGVTaGVldHMoc2hlZXRzLCBob3N0SWQpIHtcbiAgICBpZiAoc2hlZXRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IGFkb3B0ZWRTdHlsZVNoZWV0RGF0YSA9IHtcbiAgICAgIGlkOiBob3N0SWQsXG4gICAgICBzdHlsZUlkczogW11cbiAgICB9O1xuICAgIGNvbnN0IHN0eWxlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2hlZXQgb2Ygc2hlZXRzKSB7XG4gICAgICBsZXQgc3R5bGVJZDtcbiAgICAgIGlmICghdGhpcy5zdHlsZU1pcnJvci5oYXMoc2hlZXQpKSB7XG4gICAgICAgIHN0eWxlSWQgPSB0aGlzLnN0eWxlTWlycm9yLmFkZChzaGVldCk7XG4gICAgICAgIHN0eWxlcy5wdXNoKHtcbiAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgIHJ1bGVzOiBBcnJheS5mcm9tKHNoZWV0LnJ1bGVzIHx8IENTU1J1bGUsIChyMiwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICBydWxlOiBzdHJpbmdpZnlSdWxlKHIyKSxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHN0eWxlSWQgPSB0aGlzLnN0eWxlTWlycm9yLmdldElkKHNoZWV0KTtcbiAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0RGF0YS5zdHlsZUlkcy5wdXNoKHN0eWxlSWQpO1xuICAgIH1cbiAgICBpZiAoc3R5bGVzLmxlbmd0aCA+IDApIGFkb3B0ZWRTdHlsZVNoZWV0RGF0YS5zdHlsZXMgPSBzdHlsZXM7XG4gICAgdGhpcy5hZG9wdGVkU3R5bGVTaGVldENiKGFkb3B0ZWRTdHlsZVNoZWV0RGF0YSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdHlsZU1pcnJvci5yZXNldCgpO1xuICAgIHRoaXMudHJhY2tlZExpbmtFbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICB9XG4gIC8vIFRPRE86IHRha2Ugc25hcHNob3Qgb24gc3R5bGVzaGVldCByZWxvYWQgYnkgYXBwbHlpbmcgZXZlbnQgbGlzdGVuZXJcbiAgdHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChfbGlua0VsKSB7XG4gIH1cbn1cbmNsYXNzIFByb2Nlc3NlZE5vZGVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ub2RlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxuICBpbk90aGVyQnVmZmVyKG5vZGUsIHRoaXNCdWZmZXIpIHtcbiAgICBjb25zdCBidWZmZXJzID0gdGhpcy5ub2RlTWFwLmdldChub2RlKTtcbiAgICByZXR1cm4gYnVmZmVycyAmJiBBcnJheS5mcm9tKGJ1ZmZlcnMpLnNvbWUoKGJ1ZmZlcikgPT4gYnVmZmVyICE9PSB0aGlzQnVmZmVyKTtcbiAgfVxuICBhZGQobm9kZSwgYnVmZmVyKSB7XG4gICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLm5vZGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLm5vZGVNYXAuc2V0KG5vZGUsICh0aGlzLm5vZGVNYXAuZ2V0KG5vZGUpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLmFkZChidWZmZXIpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICB9XG59XG5sZXQgd3JhcHBlZEVtaXQ7XG5sZXQgX3Rha2VGdWxsU25hcHNob3Q7XG50cnkge1xuICBpZiAoQXJyYXkuZnJvbShbMV0sICh4KSA9PiB4ICogMilbMF0gIT09IDIpIHtcbiAgICBjb25zdCBjbGVhbkZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNsZWFuRnJhbWUpO1xuICAgIEFycmF5LmZyb20gPSBjbGVhbkZyYW1lLmNvbnRlbnRXaW5kb3c/LkFycmF5LmZyb20gfHwgQXJyYXkuZnJvbTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNsZWFuRnJhbWUpO1xuICB9XG59IGNhdGNoIChlcnIpIHtcbiAgY29uc29sZS5kZWJ1ZyhcIlVuYWJsZSB0byBvdmVycmlkZSBBcnJheS5mcm9tXCIsIGVycik7XG59XG5jb25zdCBtaXJyb3IgPSBjcmVhdGVNaXJyb3IkMigpO1xuZnVuY3Rpb24gcmVjb3JkKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZW1pdCxcbiAgICBjaGVja291dEV2ZXJ5Tm1zLFxuICAgIGNoZWNrb3V0RXZlcnlOdGgsXG4gICAgYmxvY2tDbGFzcyA9IFwicnItYmxvY2tcIixcbiAgICBibG9ja1NlbGVjdG9yID0gbnVsbCxcbiAgICB1bmJsb2NrU2VsZWN0b3IgPSBudWxsLFxuICAgIGlnbm9yZUNsYXNzID0gXCJyci1pZ25vcmVcIixcbiAgICBpZ25vcmVTZWxlY3RvciA9IG51bGwsXG4gICAgbWFza0FsbFRleHQgPSBmYWxzZSxcbiAgICBtYXNrVGV4dENsYXNzID0gXCJyci1tYXNrXCIsXG4gICAgdW5tYXNrVGV4dENsYXNzID0gbnVsbCxcbiAgICBtYXNrVGV4dFNlbGVjdG9yID0gbnVsbCxcbiAgICB1bm1hc2tUZXh0U2VsZWN0b3IgPSBudWxsLFxuICAgIGlubGluZVN0eWxlc2hlZXQgPSB0cnVlLFxuICAgIG1hc2tBbGxJbnB1dHMsXG4gICAgbWFza0lucHV0T3B0aW9uczogX21hc2tJbnB1dE9wdGlvbnMsXG4gICAgc2xpbURPTU9wdGlvbnM6IF9zbGltRE9NT3B0aW9ucyxcbiAgICBtYXNrQXR0cmlidXRlRm4sXG4gICAgbWFza0lucHV0Rm4sXG4gICAgbWFza1RleHRGbixcbiAgICBtYXhDYW52YXNTaXplID0gbnVsbCxcbiAgICBwYWNrRm4sXG4gICAgc2FtcGxpbmcgPSB7fSxcbiAgICBkYXRhVVJMT3B0aW9ucyA9IHt9LFxuICAgIG1vdXNlbW92ZVdhaXQsXG4gICAgcmVjb3JkRE9NID0gdHJ1ZSxcbiAgICByZWNvcmRDYW52YXMgPSBmYWxzZSxcbiAgICByZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPSBmYWxzZSxcbiAgICByZWNvcmRBZnRlciA9IG9wdGlvbnMucmVjb3JkQWZ0ZXIgPT09IFwiRE9NQ29udGVudExvYWRlZFwiID8gb3B0aW9ucy5yZWNvcmRBZnRlciA6IFwibG9hZFwiLFxuICAgIHVzZXJUcmlnZ2VyZWRPbklucHV0ID0gZmFsc2UsXG4gICAgY29sbGVjdEZvbnRzID0gZmFsc2UsXG4gICAgaW5saW5lSW1hZ2VzID0gZmFsc2UsXG4gICAgcGx1Z2lucyxcbiAgICBrZWVwSWZyYW1lU3JjRm4gPSAoKSA9PiBmYWxzZSxcbiAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW10pLFxuICAgIGVycm9ySGFuZGxlcjogZXJyb3JIYW5kbGVyMixcbiAgICBvbk11dGF0aW9uLFxuICAgIGdldENhbnZhc01hbmFnZXJcbiAgfSA9IG9wdGlvbnM7XG4gIHJlZ2lzdGVyRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlcjIpO1xuICBjb25zdCBpbkVtaXR0aW5nRnJhbWUgPSByZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPyB3aW5kb3cucGFyZW50ID09PSB3aW5kb3cgOiB0cnVlO1xuICBsZXQgcGFzc0VtaXRzVG9QYXJlbnQgPSBmYWxzZTtcbiAgaWYgKCFpbkVtaXR0aW5nRnJhbWUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQpIHtcbiAgICAgICAgcGFzc0VtaXRzVG9QYXJlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlMikge1xuICAgICAgcGFzc0VtaXRzVG9QYXJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoaW5FbWl0dGluZ0ZyYW1lICYmICFlbWl0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZW1pdCBmdW5jdGlvbiBpcyByZXF1aXJlZFwiKTtcbiAgfVxuICBpZiAoIWluRW1pdHRpbmdGcmFtZSAmJiAhcGFzc0VtaXRzVG9QYXJlbnQpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgaWYgKG1vdXNlbW92ZVdhaXQgIT09IHZvaWQgMCAmJiBzYW1wbGluZy5tb3VzZW1vdmUgPT09IHZvaWQgMCkge1xuICAgIHNhbXBsaW5nLm1vdXNlbW92ZSA9IG1vdXNlbW92ZVdhaXQ7XG4gIH1cbiAgbWlycm9yLnJlc2V0KCk7XG4gIGNvbnN0IG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlID8ge1xuICAgIGNvbG9yOiB0cnVlLFxuICAgIGRhdGU6IHRydWUsXG4gICAgXCJkYXRldGltZS1sb2NhbFwiOiB0cnVlLFxuICAgIGVtYWlsOiB0cnVlLFxuICAgIG1vbnRoOiB0cnVlLFxuICAgIG51bWJlcjogdHJ1ZSxcbiAgICByYW5nZTogdHJ1ZSxcbiAgICBzZWFyY2g6IHRydWUsXG4gICAgdGVsOiB0cnVlLFxuICAgIHRleHQ6IHRydWUsXG4gICAgdGltZTogdHJ1ZSxcbiAgICB1cmw6IHRydWUsXG4gICAgd2VlazogdHJ1ZSxcbiAgICB0ZXh0YXJlYTogdHJ1ZSxcbiAgICBzZWxlY3Q6IHRydWUsXG4gICAgcmFkaW86IHRydWUsXG4gICAgY2hlY2tib3g6IHRydWVcbiAgfSA6IF9tYXNrSW5wdXRPcHRpb25zICE9PSB2b2lkIDAgPyBfbWFza0lucHV0T3B0aW9ucyA6IHt9O1xuICBjb25zdCBzbGltRE9NT3B0aW9ucyA9IF9zbGltRE9NT3B0aW9ucyA9PT0gdHJ1ZSB8fCBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCIgPyB7XG4gICAgc2NyaXB0OiB0cnVlLFxuICAgIGNvbW1lbnQ6IHRydWUsXG4gICAgaGVhZEZhdmljb246IHRydWUsXG4gICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsXG4gICAgaGVhZE1ldGFTb2NpYWw6IHRydWUsXG4gICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXG4gICAgaGVhZE1ldGFIdHRwRXF1aXY6IHRydWUsXG4gICAgaGVhZE1ldGFWZXJpZmljYXRpb246IHRydWUsXG4gICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgb2ZmIGZvciBzbGltRE9NT3B0aW9ucyA9PT0gdHJ1ZSxcbiAgICAvLyBhcyB0aGV5IGRlc3Ryb3kgc29tZSAoaGlkZGVuKSBpbmZvOlxuICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogX3NsaW1ET01PcHRpb25zID09PSBcImFsbFwiLFxuICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCJcbiAgfSA6IF9zbGltRE9NT3B0aW9ucyA/IF9zbGltRE9NT3B0aW9ucyA6IHt9O1xuICBwb2x5ZmlsbCQxKCk7XG4gIGxldCBsYXN0RnVsbFNuYXBzaG90RXZlbnQ7XG4gIGxldCBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xuICBjb25zdCBldmVudFByb2Nlc3NvciA9IChlMikgPT4ge1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMgfHwgW10pIHtcbiAgICAgIGlmIChwbHVnaW4uZXZlbnRQcm9jZXNzb3IpIHtcbiAgICAgICAgZTIgPSBwbHVnaW4uZXZlbnRQcm9jZXNzb3IoZTIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFja0ZuICYmIC8vIERpc2FibGUgcGFja2luZyBldmVudHMgd2hpY2ggd2lsbCBiZSBlbWl0dGVkIHRvIHBhcmVudCBmcmFtZXMuXG4gICAgIXBhc3NFbWl0c1RvUGFyZW50KSB7XG4gICAgICBlMiA9IHBhY2tGbihlMik7XG4gICAgfVxuICAgIHJldHVybiBlMjtcbiAgfTtcbiAgd3JhcHBlZEVtaXQgPSAocjIsIGlzQ2hlY2tvdXQpID0+IHtcbiAgICBjb25zdCBlMiA9IHIyO1xuICAgIGUyLnRpbWVzdGFtcCA9IG5vd1RpbWVzdGFtcCgpO1xuICAgIGlmIChtdXRhdGlvbkJ1ZmZlcnNbMF0/LmlzRnJvemVuKCkgJiYgZTIudHlwZSAhPT0gRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdCAmJiAhKGUyLnR5cGUgPT09IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90ICYmIGUyLmRhdGEuc291cmNlID09PSBJbmNyZW1lbnRhbFNvdXJjZS5NdXRhdGlvbikpIHtcbiAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChidWYpID0+IGJ1Zi51bmZyZWV6ZSgpKTtcbiAgICB9XG4gICAgaWYgKGluRW1pdHRpbmdGcmFtZSkge1xuICAgICAgZW1pdD8uKGV2ZW50UHJvY2Vzc29yKGUyKSwgaXNDaGVja291dCk7XG4gICAgfSBlbHNlIGlmIChwYXNzRW1pdHNUb1BhcmVudCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogXCJycndlYlwiLFxuICAgICAgICBldmVudDogZXZlbnRQcm9jZXNzb3IoZTIpLFxuICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgIGlzQ2hlY2tvdXRcbiAgICAgIH07XG4gICAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFwiKlwiKTtcbiAgICB9XG4gICAgaWYgKGUyLnR5cGUgPT09IEV2ZW50VHlwZS5GdWxsU25hcHNob3QpIHtcbiAgICAgIGxhc3RGdWxsU25hcHNob3RFdmVudCA9IGUyO1xuICAgICAgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID0gMDtcbiAgICB9IGVsc2UgaWYgKGUyLnR5cGUgPT09IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90KSB7XG4gICAgICBpZiAoZTIuZGF0YS5zb3VyY2UgPT09IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uICYmIGUyLmRhdGEuaXNBdHRhY2hJZnJhbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50Kys7XG4gICAgICBjb25zdCBleGNlZWRDb3VudCA9IGNoZWNrb3V0RXZlcnlOdGggJiYgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID49IGNoZWNrb3V0RXZlcnlOdGg7XG4gICAgICBjb25zdCBleGNlZWRUaW1lID0gY2hlY2tvdXRFdmVyeU5tcyAmJiBsYXN0RnVsbFNuYXBzaG90RXZlbnQgJiYgZTIudGltZXN0YW1wIC0gbGFzdEZ1bGxTbmFwc2hvdEV2ZW50LnRpbWVzdGFtcCA+IGNoZWNrb3V0RXZlcnlObXM7XG4gICAgICBpZiAoZXhjZWVkQ291bnQgfHwgZXhjZWVkVGltZSkge1xuICAgICAgICB0YWtlRnVsbFNuYXBzaG90Mih0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHdyYXBwZWRNdXRhdGlvbkVtaXQgPSAobSkgPT4ge1xuICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgZGF0YToge1xuICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uLFxuICAgICAgICAuLi5tXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHdyYXBwZWRTY3JvbGxFbWl0ID0gKHApID0+IHdyYXBwZWRFbWl0KHtcbiAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICBkYXRhOiB7XG4gICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlNjcm9sbCxcbiAgICAgIC4uLnBcbiAgICB9XG4gIH0pO1xuICBjb25zdCB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0ID0gKHApID0+IHdyYXBwZWRFbWl0KHtcbiAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICBkYXRhOiB7XG4gICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLkNhbnZhc011dGF0aW9uLFxuICAgICAgLi4ucFxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHdyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXQgPSAoYTIpID0+IHdyYXBwZWRFbWl0KHtcbiAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICBkYXRhOiB7XG4gICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLkFkb3B0ZWRTdHlsZVNoZWV0LFxuICAgICAgLi4uYTJcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzdHlsZXNoZWV0TWFuYWdlciA9IG5ldyBTdHlsZXNoZWV0TWFuYWdlcih7XG4gICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcbiAgICBhZG9wdGVkU3R5bGVTaGVldENiOiB3cmFwcGVkQWRvcHRlZFN0eWxlU2hlZXRFbWl0XG4gIH0pO1xuICBjb25zdCBpZnJhbWVNYW5hZ2VyID0gdHlwZW9mIF9fUlJXRUJfRVhDTFVERV9JRlJBTUVfXyA9PT0gXCJib29sZWFuXCIgJiYgX19SUldFQl9FWENMVURFX0lGUkFNRV9fID8gbmV3IElmcmFtZU1hbmFnZXJOb29wKCkgOiBuZXcgSWZyYW1lTWFuYWdlcih7XG4gICAgbWlycm9yLFxuICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXG4gICAgc3R5bGVzaGVldE1hbmFnZXIsXG4gICAgcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzLFxuICAgIHdyYXBwZWRFbWl0XG4gIH0pO1xuICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zIHx8IFtdKSB7XG4gICAgaWYgKHBsdWdpbi5nZXRNaXJyb3IpXG4gICAgICBwbHVnaW4uZ2V0TWlycm9yKHtcbiAgICAgICAgbm9kZU1pcnJvcjogbWlycm9yLFxuICAgICAgICBjcm9zc09yaWdpbklmcmFtZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZU1pcnJvcixcbiAgICAgICAgY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yXG4gICAgICB9KTtcbiAgfVxuICBjb25zdCBwcm9jZXNzZWROb2RlTWFuYWdlciA9IG5ldyBQcm9jZXNzZWROb2RlTWFuYWdlcigpO1xuICBjb25zdCBjYW52YXNNYW5hZ2VyID0gX2dldENhbnZhc01hbmFnZXIoXG4gICAgZ2V0Q2FudmFzTWFuYWdlcixcbiAgICB7XG4gICAgICBtaXJyb3IsXG4gICAgICB3aW46IHdpbmRvdyxcbiAgICAgIG11dGF0aW9uQ2I6IChwKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5DYW52YXNNdXRhdGlvbixcbiAgICAgICAgICAuLi5wXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgYmxvY2tDbGFzcyxcbiAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgICBtYXhDYW52YXNTaXplLFxuICAgICAgc2FtcGxpbmc6IHNhbXBsaW5nW1wiY2FudmFzXCJdLFxuICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICBlcnJvckhhbmRsZXI6IGVycm9ySGFuZGxlcjJcbiAgICB9XG4gICk7XG4gIGNvbnN0IHNoYWRvd0RvbU1hbmFnZXIgPSB0eXBlb2YgX19SUldFQl9FWENMVURFX1NIQURPV19ET01fXyA9PT0gXCJib29sZWFuXCIgJiYgX19SUldFQl9FWENMVURFX1NIQURPV19ET01fXyA/IG5ldyBTaGFkb3dEb21NYW5hZ2VyTm9vcCgpIDogbmV3IFNoYWRvd0RvbU1hbmFnZXIoe1xuICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXG4gICAgc2Nyb2xsQ2I6IHdyYXBwZWRTY3JvbGxFbWl0LFxuICAgIGJ5cGFzc09wdGlvbnM6IHtcbiAgICAgIG9uTXV0YXRpb24sXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICAgIG1hc2tBbGxUZXh0LFxuICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgIHVubWFza1RleHRDbGFzcyxcbiAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICB1bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgIGRhdGFVUkxPcHRpb25zLFxuICAgICAgbWFza0F0dHJpYnV0ZUZuLFxuICAgICAgbWFza1RleHRGbixcbiAgICAgIG1hc2tJbnB1dEZuLFxuICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgc2FtcGxpbmcsXG4gICAgICBzbGltRE9NT3B0aW9ucyxcbiAgICAgIGlmcmFtZU1hbmFnZXIsXG4gICAgICBzdHlsZXNoZWV0TWFuYWdlcixcbiAgICAgIGNhbnZhc01hbmFnZXIsXG4gICAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICBwcm9jZXNzZWROb2RlTWFuYWdlclxuICAgIH0sXG4gICAgbWlycm9yXG4gIH0pO1xuICBjb25zdCB0YWtlRnVsbFNuYXBzaG90MiA9IChpc0NoZWNrb3V0ID0gZmFsc2UpID0+IHtcbiAgICBpZiAoIXJlY29yZERPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3cmFwcGVkRW1pdChcbiAgICAgIHtcbiAgICAgICAgdHlwZTogRXZlbnRUeXBlLk1ldGEsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBocmVmOiB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICAgICAgICB3aWR0aDogZ2V0V2luZG93V2lkdGgoKSxcbiAgICAgICAgICBoZWlnaHQ6IGdldFdpbmRvd0hlaWdodCgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc0NoZWNrb3V0XG4gICAgKTtcbiAgICBzdHlsZXNoZWV0TWFuYWdlci5yZXNldCgpO1xuICAgIHNoYWRvd0RvbU1hbmFnZXIuaW5pdCgpO1xuICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChidWYpID0+IGJ1Zi5sb2NrKCkpO1xuICAgIGNvbnN0IG5vZGUgPSBzbmFwc2hvdChkb2N1bWVudCwge1xuICAgICAgbWlycm9yLFxuICAgICAgYmxvY2tDbGFzcyxcbiAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgICBtYXNrQWxsVGV4dCxcbiAgICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgICB1bm1hc2tUZXh0Q2xhc3MsXG4gICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgdW5tYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICAgIG1hc2tBbGxJbnB1dHM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICBtYXNrQXR0cmlidXRlRm4sXG4gICAgICBtYXNrSW5wdXRGbixcbiAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICBzbGltRE9NOiBzbGltRE9NT3B0aW9ucyxcbiAgICAgIGRhdGFVUkxPcHRpb25zLFxuICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgb25TZXJpYWxpemU6IChuMikgPT4ge1xuICAgICAgICBpZiAoaXNTZXJpYWxpemVkSWZyYW1lKG4yLCBtaXJyb3IpKSB7XG4gICAgICAgICAgaWZyYW1lTWFuYWdlci5hZGRJZnJhbWUobjIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KG4yLCBtaXJyb3IpKSB7XG4gICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIudHJhY2tMaW5rRWxlbWVudChuMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1NoYWRvd1Jvb3QobjIpKSB7XG4gICAgICAgICAgc2hhZG93RG9tTWFuYWdlci5hZGRTaGFkb3dSb290KG4yLnNoYWRvd1Jvb3QsIGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uSWZyYW1lTG9hZDogKGlmcmFtZSwgY2hpbGRTbikgPT4ge1xuICAgICAgICBpZnJhbWVNYW5hZ2VyLmF0dGFjaElmcmFtZShpZnJhbWUsIGNoaWxkU24pO1xuICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICBjYW52YXNNYW5hZ2VyLmFkZFdpbmRvdyhpZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgICAgIH1cbiAgICAgICAgc2hhZG93RG9tTWFuYWdlci5vYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZSk7XG4gICAgICB9LFxuICAgICAgb25TdHlsZXNoZWV0TG9hZDogKGxpbmtFbCwgY2hpbGRTbikgPT4ge1xuICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5hdHRhY2hMaW5rRWxlbWVudChsaW5rRWwsIGNoaWxkU24pO1xuICAgICAgfSxcbiAgICAgIGtlZXBJZnJhbWVTcmNGblxuICAgIH0pO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBzbmFwc2hvdCB0aGUgZG9jdW1lbnRcIik7XG4gICAgfVxuICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgIHR5cGU6IEV2ZW50VHlwZS5GdWxsU25hcHNob3QsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGluaXRpYWxPZmZzZXQ6IGdldFdpbmRvd1Njcm9sbCh3aW5kb3cpXG4gICAgICB9XG4gICAgfSk7XG4gICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLnVubG9jaygpKTtcbiAgICBpZiAoZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmIGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKVxuICAgICAgc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhcbiAgICAgICAgZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLFxuICAgICAgICBtaXJyb3IuZ2V0SWQoZG9jdW1lbnQpXG4gICAgICApO1xuICB9O1xuICBfdGFrZUZ1bGxTbmFwc2hvdCA9IHRha2VGdWxsU25hcHNob3QyO1xuICB0cnkge1xuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XG4gICAgY29uc3Qgb2JzZXJ2ZSA9IChkb2MpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoaW5pdE9ic2VydmVycykoXG4gICAgICAgIHtcbiAgICAgICAgICBvbk11dGF0aW9uLFxuICAgICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXG4gICAgICAgICAgbW91c2Vtb3ZlQ2I6IChwb3NpdGlvbnMsIHNvdXJjZSkgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgcG9zaXRpb25zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbW91c2VJbnRlcmFjdGlvbkNiOiAoZCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvbixcbiAgICAgICAgICAgICAgLi4uZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHNjcm9sbENiOiB3cmFwcGVkU2Nyb2xsRW1pdCxcbiAgICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiOiAoZCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuVmlld3BvcnRSZXNpemUsXG4gICAgICAgICAgICAgIC4uLmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBpbnB1dENiOiAodjIpID0+IHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLklucHV0LFxuICAgICAgICAgICAgICAuLi52MlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG1lZGlhSW50ZXJhY3Rpb25DYjogKHApID0+IHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLk1lZGlhSW50ZXJhY3Rpb24sXG4gICAgICAgICAgICAgIC4uLnBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiOiAocjIpID0+IHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlN0eWxlU2hlZXRSdWxlLFxuICAgICAgICAgICAgICAuLi5yMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYjogKHIyKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5TdHlsZURlY2xhcmF0aW9uLFxuICAgICAgICAgICAgICAuLi5yMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNhbnZhc011dGF0aW9uQ2I6IHdyYXBwZWRDYW52YXNNdXRhdGlvbkVtaXQsXG4gICAgICAgICAgZm9udENiOiAocCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuRm9udCxcbiAgICAgICAgICAgICAgLi4ucFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHNlbGVjdGlvbkNiOiAocCkgPT4ge1xuICAgICAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIC4uLnBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXN0b21FbGVtZW50Q2I6IChjMikgPT4ge1xuICAgICAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuQ3VzdG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAuLi5jMlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICAgICAgaWdub3JlQ2xhc3MsXG4gICAgICAgICAgaWdub3JlU2VsZWN0b3IsXG4gICAgICAgICAgbWFza0FsbFRleHQsXG4gICAgICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgICAgICB1bm1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICB1bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgIHNhbXBsaW5nLFxuICAgICAgICAgIHJlY29yZERPTSxcbiAgICAgICAgICByZWNvcmRDYW52YXMsXG4gICAgICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgICAgIHVzZXJUcmlnZ2VyZWRPbklucHV0LFxuICAgICAgICAgIGNvbGxlY3RGb250cyxcbiAgICAgICAgICBkb2MsXG4gICAgICAgICAgbWFza0F0dHJpYnV0ZUZuLFxuICAgICAgICAgIG1hc2tJbnB1dEZuLFxuICAgICAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxuICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgIG1pcnJvcixcbiAgICAgICAgICBpZnJhbWVNYW5hZ2VyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLFxuICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIsXG4gICAgICAgICAgcHJvY2Vzc2VkTm9kZU1hbmFnZXIsXG4gICAgICAgICAgY2FudmFzTWFuYWdlcixcbiAgICAgICAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzLFxuICAgICAgICAgIHBsdWdpbnM6IHBsdWdpbnM/LmZpbHRlcigocCkgPT4gcC5vYnNlcnZlcik/Lm1hcCgocCkgPT4gKHtcbiAgICAgICAgICAgIG9ic2VydmVyOiBwLm9ic2VydmVyLFxuICAgICAgICAgICAgb3B0aW9uczogcC5vcHRpb25zLFxuICAgICAgICAgICAgY2FsbGJhY2s6IChwYXlsb2FkKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5QbHVnaW4sXG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBwbHVnaW46IHAubmFtZSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSkpIHx8IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHt9XG4gICAgICApO1xuICAgIH07XG4gICAgaWZyYW1lTWFuYWdlci5hZGRMb2FkTGlzdGVuZXIoKGlmcmFtZUVsKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVycy5wdXNoKG9ic2VydmUoaWZyYW1lRWwuY29udGVudERvY3VtZW50KSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGluaXQgPSAoKSA9PiB7XG4gICAgICB0YWtlRnVsbFNuYXBzaG90MigpO1xuICAgICAgaGFuZGxlcnMucHVzaChvYnNlcnZlKGRvY3VtZW50KSk7XG4gICAgfTtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJpbnRlcmFjdGl2ZVwiIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgaW5pdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5wdXNoKFxuICAgICAgICBvbihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICAgICAgICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5Eb21Db250ZW50TG9hZGVkLFxuICAgICAgICAgICAgZGF0YToge31cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocmVjb3JkQWZ0ZXIgPT09IFwiRE9NQ29udGVudExvYWRlZFwiKSBpbml0KCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgaGFuZGxlcnMucHVzaChcbiAgICAgICAgb24oXG4gICAgICAgICAgXCJsb2FkXCIsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuTG9hZCxcbiAgICAgICAgICAgICAgZGF0YToge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlY29yZEFmdGVyID09PSBcImxvYWRcIikgaW5pdCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd2luZG93XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xuICAgICAgcHJvY2Vzc2VkTm9kZU1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgX3Rha2VGdWxsU25hcHNob3QgPSB2b2lkIDA7XG4gICAgICB1bnJlZ2lzdGVyRXJyb3JIYW5kbGVyKCk7XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiB0YWtlRnVsbFNuYXBzaG90KGlzQ2hlY2tvdXQpIHtcbiAgaWYgKCFfdGFrZUZ1bGxTbmFwc2hvdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInBsZWFzZSB0YWtlIGZ1bGwgc25hcHNob3QgYWZ0ZXIgc3RhcnQgcmVjb3JkaW5nXCIpO1xuICB9XG4gIF90YWtlRnVsbFNuYXBzaG90KGlzQ2hlY2tvdXQpO1xufVxucmVjb3JkLm1pcnJvciA9IG1pcnJvcjtcbnJlY29yZC50YWtlRnVsbFNuYXBzaG90ID0gdGFrZUZ1bGxTbmFwc2hvdDtcbmZ1bmN0aW9uIF9nZXRDYW52YXNNYW5hZ2VyKGdldENhbnZhc01hbmFnZXJGbiwgb3B0aW9ucykge1xuICB0cnkge1xuICAgIHJldHVybiBnZXRDYW52YXNNYW5hZ2VyRm4gPyBnZXRDYW52YXNNYW5hZ2VyRm4ob3B0aW9ucykgOiBuZXcgQ2FudmFzTWFuYWdlck5vb3AoKTtcbiAgfSBjYXRjaCB7XG4gICAgY29uc29sZS53YXJuKFwiVW5hYmxlIHRvIGluaXRpYWxpemUgQ2FudmFzTWFuYWdlclwiKTtcbiAgICByZXR1cm4gbmV3IENhbnZhc01hbmFnZXJOb29wKCk7XG4gIH1cbn1cbnZhciBuO1xuIWZ1bmN0aW9uKHQyKSB7XG4gIHQyW3QyLk5vdFN0YXJ0ZWQgPSAwXSA9IFwiTm90U3RhcnRlZFwiLCB0Mlt0Mi5SdW5uaW5nID0gMV0gPSBcIlJ1bm5pbmdcIiwgdDJbdDIuU3RvcHBlZCA9IDJdID0gXCJTdG9wcGVkXCI7XG59KG4gfHwgKG4gPSB7fSkpO1xuXG5jb25zdCBSZXBsYXlFdmVudFR5cGVJbmNyZW1lbnRhbFNuYXBzaG90ID0gMztcbmNvbnN0IFJlcGxheUV2ZW50VHlwZUN1c3RvbSA9IDU7XG5cbi8qKlxuICogQ29udmVydHMgYSB0aW1lc3RhbXAgdG8gbXMsIGlmIGl0IHdhcyBpbiBzLCBvciBrZWVwcyBpdCBhcyBtcy5cbiAqL1xuZnVuY3Rpb24gdGltZXN0YW1wVG9Ncyh0aW1lc3RhbXApIHtcbiAgY29uc3QgaXNNcyA9IHRpbWVzdGFtcCA+IDk5OTk5OTk5OTk7XG4gIHJldHVybiBpc01zID8gdGltZXN0YW1wIDogdGltZXN0YW1wICogMTAwMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHRpbWVzdGFtcCB0byBzLCBpZiBpdCB3YXMgaW4gbXMsIG9yIGtlZXBzIGl0IGFzIHMuXG4gKi9cbmZ1bmN0aW9uIHRpbWVzdGFtcFRvUyh0aW1lc3RhbXApIHtcbiAgY29uc3QgaXNNcyA9IHRpbWVzdGFtcCA+IDk5OTk5OTk5OTk7XG4gIHJldHVybiBpc01zID8gdGltZXN0YW1wIC8gMTAwMCA6IHRpbWVzdGFtcDtcbn1cblxuLyoqXG4gKiBBZGQgYSBicmVhZGNydW1iIGV2ZW50IHRvIHJlcGxheS5cbiAqL1xuZnVuY3Rpb24gYWRkQnJlYWRjcnVtYkV2ZW50KHJlcGxheSwgYnJlYWRjcnVtYikge1xuICBpZiAoYnJlYWRjcnVtYi5jYXRlZ29yeSA9PT0gJ3NlbnRyeS50cmFuc2FjdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoWyd1aS5jbGljaycsICd1aS5pbnB1dCddLmluY2x1ZGVzKGJyZWFkY3J1bWIuY2F0ZWdvcnkgKSkge1xuICAgIHJlcGxheS50cmlnZ2VyVXNlckFjdGl2aXR5KCk7XG4gIH0gZWxzZSB7XG4gICAgcmVwbGF5LmNoZWNrQW5kSGFuZGxlRXhwaXJlZFNlc3Npb24oKTtcbiAgfVxuXG4gIHJlcGxheS5hZGRVcGRhdGUoKCkgPT4ge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIHJlamVjdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICByZXBsYXkudGhyb3R0bGVkQWRkRXZlbnQoe1xuICAgICAgdHlwZTogRXZlbnRUeXBlLkN1c3RvbSxcbiAgICAgIC8vIFRPRE86IFdlIHdlcmUgY29udmVydGluZyBmcm9tIG1zIHRvIHNlY29uZHMgZm9yIGJyZWFkY3J1bWJzLCBzcGFucyxcbiAgICAgIC8vIGJ1dCBtYXliZSB3ZSBzaG91bGQganVzdCBrZWVwIHRoZW0gYXMgbWlsbGlzZWNvbmRzXG4gICAgICB0aW1lc3RhbXA6IChicmVhZGNydW1iLnRpbWVzdGFtcCB8fCAwKSAqIDEwMDAsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRhZzogJ2JyZWFkY3J1bWInLFxuICAgICAgICAvLyBub3JtYWxpemUgdG8gbWF4LiAxMCBkZXB0aCBhbmQgMV8wMDAgcHJvcGVydGllcyBwZXIgb2JqZWN0XG4gICAgICAgIHBheWxvYWQ6IG5vcm1hbGl6ZShicmVhZGNydW1iLCAxMCwgMTAwMCksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gRG8gbm90IGZsdXNoIGFmdGVyIGNvbnNvbGUgbG9nIG1lc3NhZ2VzXG4gICAgcmV0dXJuIGJyZWFkY3J1bWIuY2F0ZWdvcnkgPT09ICdjb25zb2xlJztcbiAgfSk7XG59XG5cbmNvbnN0IElOVEVSQUNUSVZFX1NFTEVDVE9SID0gJ2J1dHRvbixhJztcblxuLyoqIEdldCB0aGUgY2xvc2VzdCBpbnRlcmFjdGl2ZSBwYXJlbnQgZWxlbWVudCwgb3IgZWxzZSByZXR1cm4gdGhlIGdpdmVuIGVsZW1lbnQuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW50ZXJhY3RpdmUoZWxlbWVudCkge1xuICBjb25zdCBjbG9zZXN0SW50ZXJhY3RpdmUgPSBlbGVtZW50LmNsb3Nlc3QoSU5URVJBQ1RJVkVfU0VMRUNUT1IpO1xuICByZXR1cm4gY2xvc2VzdEludGVyYWN0aXZlIHx8IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRm9yIGNsaWNrcywgd2UgY2hlY2sgaWYgdGhlIHRhcmdldCBpcyBpbnNpZGUgb2YgYSBidXR0b24gb3IgbGlua1xuICogSWYgc28sIHdlIHVzZSB0aGlzIGFzIHRoZSB0YXJnZXQgaW5zdGVhZFxuICogVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBpZiB5b3UgY2xpY2sgb24gdGhlIGltYWdlIGluIDxidXR0b24+PGltZz48L2J1dHRvbj4sXG4gKiBUaGUgdGFyZ2V0IHdpbGwgYmUgdGhlIGltYWdlLCBub3QgdGhlIGJ1dHRvbiwgd2hpY2ggd2UgZG9uJ3Qgd2FudCBoZXJlXG4gKi9cbmZ1bmN0aW9uIGdldENsaWNrVGFyZ2V0Tm9kZShldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXROb2RlKGV2ZW50KTtcblxuICBpZiAoIXRhcmdldCB8fCAhKHRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBnZXRDbG9zZXN0SW50ZXJhY3RpdmUodGFyZ2V0KTtcbn1cblxuLyoqIEdldCB0aGUgZXZlbnQgdGFyZ2V0IG5vZGUuICovXG5mdW5jdGlvbiBnZXRUYXJnZXROb2RlKGV2ZW50KSB7XG4gIGlmIChpc0V2ZW50V2l0aFRhcmdldChldmVudCkpIHtcbiAgICByZXR1cm4gZXZlbnQudGFyZ2V0IDtcbiAgfVxuXG4gIHJldHVybiBldmVudDtcbn1cblxuZnVuY3Rpb24gaXNFdmVudFdpdGhUYXJnZXQoZXZlbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBldmVudCA9PT0gJ29iamVjdCcgJiYgISFldmVudCAmJiAndGFyZ2V0JyBpbiBldmVudDtcbn1cblxubGV0IGhhbmRsZXJzO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgaGFuZGxlciB0byBiZSBjYWxsZWQgd2hlbiBgd2luZG93Lm9wZW4oKWAgaXMgY2FsbGVkLlxuICogUmV0dXJucyBhIGNsZWFudXAgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG9uV2luZG93T3BlbihjYikge1xuICAvLyBFbnN1cmUgdG8gb25seSByZWdpc3RlciB0aGlzIG9uY2VcbiAgaWYgKCFoYW5kbGVycykge1xuICAgIGhhbmRsZXJzID0gW107XG4gICAgbW9ua2V5UGF0Y2hXaW5kb3dPcGVuKCk7XG4gIH1cblxuICBoYW5kbGVycy5wdXNoKGNiKTtcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IHBvcyA9IGhhbmRsZXJzID8gaGFuZGxlcnMuaW5kZXhPZihjYikgOiAtMTtcbiAgICBpZiAocG9zID4gLTEpIHtcbiAgICAgIChoYW5kbGVycyApLnNwbGljZShwb3MsIDEpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW9ua2V5UGF0Y2hXaW5kb3dPcGVuKCkge1xuICBmaWxsKFdJTkRPVywgJ29wZW4nLCBmdW5jdGlvbiAob3JpZ2luYWxXaW5kb3dPcGVuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcigpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlnbm9yZSBlcnJvcnMgaW4gaGVyZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcmlnaW5hbFdpbmRvd09wZW4uYXBwbHkoV0lORE9XLCBhcmdzKTtcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqIEFueSBJbmNyZW1lbnRhbFNvdXJjZSBmb3IgcnJ3ZWIgdGhhdCB3ZSBpbnRlcnByZXQgYXMgYSBraW5kIG9mIG11dGF0aW9uLiAqL1xuY29uc3QgSW5jcmVtZW50YWxNdXRhdGlvblNvdXJjZXMgPSBuZXcgU2V0KFtcbiAgSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24sXG4gIEluY3JlbWVudGFsU291cmNlLlN0eWxlU2hlZXRSdWxlLFxuICBJbmNyZW1lbnRhbFNvdXJjZS5TdHlsZURlY2xhcmF0aW9uLFxuICBJbmNyZW1lbnRhbFNvdXJjZS5BZG9wdGVkU3R5bGVTaGVldCxcbiAgSW5jcmVtZW50YWxTb3VyY2UuQ2FudmFzTXV0YXRpb24sXG4gIEluY3JlbWVudGFsU291cmNlLlNlbGVjdGlvbixcbiAgSW5jcmVtZW50YWxTb3VyY2UuTWVkaWFJbnRlcmFjdGlvbixcbl0pO1xuXG4vKiogSGFuZGxlIGEgY2xpY2suICovXG5mdW5jdGlvbiBoYW5kbGVDbGljayhjbGlja0RldGVjdG9yLCBjbGlja0JyZWFkY3J1bWIsIG5vZGUpIHtcbiAgY2xpY2tEZXRlY3Rvci5oYW5kbGVDbGljayhjbGlja0JyZWFkY3J1bWIsIG5vZGUpO1xufVxuXG4vKiogQSBjbGljayBkZXRlY3RvciBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGRldGVjdCBzbG93IG9yIHJhZ2UgY2xpY2tzIG9uIGVsZW1lbnRzLiAqL1xuY2xhc3MgQ2xpY2tEZXRlY3RvciAge1xuICAvLyBwcm90ZWN0ZWQgZm9yIHRlc3RpbmdcblxuICAgY29uc3RydWN0b3IoXG4gICAgcmVwbGF5LFxuICAgIHNsb3dDbGlja0NvbmZpZyxcbiAgICAvLyBKdXN0IGZvciBlYXNpZXIgdGVzdGluZ1xuICAgIF9hZGRCcmVhZGNydW1iRXZlbnQgPSBhZGRCcmVhZGNydW1iRXZlbnQsXG4gICkge1xuICAgIHRoaXMuX2xhc3RNdXRhdGlvbiA9IDA7XG4gICAgdGhpcy5fbGFzdFNjcm9sbCA9IDA7XG4gICAgdGhpcy5fY2xpY2tzID0gW107XG5cbiAgICAvLyBXZSB3YW50IGV2ZXJ5dGhpbmcgaW4gcywgYnV0IG9wdGlvbnMgYXJlIGluIG1zXG4gICAgdGhpcy5fdGltZW91dCA9IHNsb3dDbGlja0NvbmZpZy50aW1lb3V0IC8gMTAwMDtcbiAgICB0aGlzLl90aHJlc2hvbGQgPSBzbG93Q2xpY2tDb25maWcudGhyZXNob2xkIC8gMTAwMDtcbiAgICB0aGlzLl9zY3JvbGxUaW1lb3V0ID0gc2xvd0NsaWNrQ29uZmlnLnNjcm9sbFRpbWVvdXQgLyAxMDAwO1xuICAgIHRoaXMuX3JlcGxheSA9IHJlcGxheTtcbiAgICB0aGlzLl9pZ25vcmVTZWxlY3RvciA9IHNsb3dDbGlja0NvbmZpZy5pZ25vcmVTZWxlY3RvcjtcbiAgICB0aGlzLl9hZGRCcmVhZGNydW1iRXZlbnQgPSBfYWRkQnJlYWRjcnVtYkV2ZW50O1xuICB9XG5cbiAgLyoqIFJlZ2lzdGVyIGNsaWNrIGRldGVjdGlvbiBoYW5kbGVycyBvbiBtdXRhdGlvbiBvciBzY3JvbGwuICovXG4gICBhZGRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgY2xlYW51cFdpbmRvd09wZW4gPSBvbldpbmRvd09wZW4oKCkgPT4ge1xuICAgICAgLy8gVHJlYXQgd2luZG93Lm9wZW4gYXMgbXV0YXRpb25cbiAgICAgIHRoaXMuX2xhc3RNdXRhdGlvbiA9IG5vd0luU2Vjb25kcygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fdGVhcmRvd24gPSAoKSA9PiB7XG4gICAgICBjbGVhbnVwV2luZG93T3BlbigpO1xuXG4gICAgICB0aGlzLl9jbGlja3MgPSBbXTtcbiAgICAgIHRoaXMuX2xhc3RNdXRhdGlvbiA9IDA7XG4gICAgICB0aGlzLl9sYXN0U2Nyb2xsID0gMDtcbiAgICB9O1xuICB9XG5cbiAgLyoqIENsZWFuIHVwIGxpc3RlbmVycy4gKi9cbiAgIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5fdGVhcmRvd24pIHtcbiAgICAgIHRoaXMuX3RlYXJkb3duKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NoZWNrQ2xpY2tUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fY2hlY2tDbGlja1RpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgaGFuZGxlQ2xpY2soYnJlYWRjcnVtYiwgbm9kZSkge1xuICAgIGlmIChpZ25vcmVFbGVtZW50KG5vZGUsIHRoaXMuX2lnbm9yZVNlbGVjdG9yKSB8fCAhaXNDbGlja0JyZWFkY3J1bWIoYnJlYWRjcnVtYikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdDbGljayA9IHtcbiAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wVG9TKGJyZWFkY3J1bWIudGltZXN0YW1wKSxcbiAgICAgIGNsaWNrQnJlYWRjcnVtYjogYnJlYWRjcnVtYixcbiAgICAgIC8vIFNldCB0aGlzIHRvIDAgc28gd2Uga25vdyBpdCBvcmlnaW5hdGVzIGZyb20gdGhlIGNsaWNrIGJyZWFkY3J1bWJcbiAgICAgIGNsaWNrQ291bnQ6IDAsXG4gICAgICBub2RlLFxuICAgIH07XG5cbiAgICAvLyBJZiB0aGVyZSB3YXMgYSBjbGljayBpbiB0aGUgbGFzdCAxcyBvbiB0aGUgc2FtZSBlbGVtZW50LCBpZ25vcmUgaXQgLSBvbmx5IGtlZXAgYSBzaW5nbGUgcmVmZXJlbmNlIHBlciBzZWNvbmRcbiAgICBpZiAoXG4gICAgICB0aGlzLl9jbGlja3Muc29tZShjbGljayA9PiBjbGljay5ub2RlID09PSBuZXdDbGljay5ub2RlICYmIE1hdGguYWJzKGNsaWNrLnRpbWVzdGFtcCAtIG5ld0NsaWNrLnRpbWVzdGFtcCkgPCAxKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2NsaWNrcy5wdXNoKG5ld0NsaWNrKTtcblxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IG5ldyBjbGljaywgc2V0IGEgdGltZW91dCB0byBjaGVjayBmb3IgbXVsdGkgY2xpY2tzXG4gICAgaWYgKHRoaXMuX2NsaWNrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlQ2hlY2tDbGlja3MoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgIHJlZ2lzdGVyTXV0YXRpb24odGltZXN0YW1wID0gRGF0ZS5ub3coKSkge1xuICAgIHRoaXMuX2xhc3RNdXRhdGlvbiA9IHRpbWVzdGFtcFRvUyh0aW1lc3RhbXApO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gICByZWdpc3RlclNjcm9sbCh0aW1lc3RhbXAgPSBEYXRlLm5vdygpKSB7XG4gICAgdGhpcy5fbGFzdFNjcm9sbCA9IHRpbWVzdGFtcFRvUyh0aW1lc3RhbXApO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gICByZWdpc3RlckNsaWNrKGVsZW1lbnQpIHtcbiAgICBjb25zdCBub2RlID0gZ2V0Q2xvc2VzdEludGVyYWN0aXZlKGVsZW1lbnQpO1xuICAgIHRoaXMuX2hhbmRsZU11bHRpQ2xpY2sobm9kZSApO1xuICB9XG5cbiAgLyoqIENvdW50IG11bHRpcGxlIGNsaWNrcyBvbiBlbGVtZW50cy4gKi9cbiAgIF9oYW5kbGVNdWx0aUNsaWNrKG5vZGUpIHtcbiAgICB0aGlzLl9nZXRDbGlja3Mobm9kZSkuZm9yRWFjaChjbGljayA9PiB7XG4gICAgICBjbGljay5jbGlja0NvdW50Kys7XG4gICAgfSk7XG4gIH1cblxuICAvKiogR2V0IGFsbCBwZW5kaW5nIGNsaWNrcyBmb3IgYSBnaXZlbiBub2RlLiAqL1xuICAgX2dldENsaWNrcyhub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWNrcy5maWx0ZXIoY2xpY2sgPT4gY2xpY2subm9kZSA9PT0gbm9kZSk7XG4gIH1cblxuICAvKiogQ2hlY2sgdGhlIGNsaWNrcyB0aGF0IGhhcHBlbmVkLiAqL1xuICAgX2NoZWNrQ2xpY2tzKCkge1xuICAgIGNvbnN0IHRpbWVkT3V0Q2xpY2tzID0gW107XG5cbiAgICBjb25zdCBub3cgPSBub3dJblNlY29uZHMoKTtcblxuICAgIHRoaXMuX2NsaWNrcy5mb3JFYWNoKGNsaWNrID0+IHtcbiAgICAgIGlmICghY2xpY2subXV0YXRpb25BZnRlciAmJiB0aGlzLl9sYXN0TXV0YXRpb24pIHtcbiAgICAgICAgY2xpY2subXV0YXRpb25BZnRlciA9IGNsaWNrLnRpbWVzdGFtcCA8PSB0aGlzLl9sYXN0TXV0YXRpb24gPyB0aGlzLl9sYXN0TXV0YXRpb24gLSBjbGljay50aW1lc3RhbXAgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWNsaWNrLnNjcm9sbEFmdGVyICYmIHRoaXMuX2xhc3RTY3JvbGwpIHtcbiAgICAgICAgY2xpY2suc2Nyb2xsQWZ0ZXIgPSBjbGljay50aW1lc3RhbXAgPD0gdGhpcy5fbGFzdFNjcm9sbCA/IHRoaXMuX2xhc3RTY3JvbGwgLSBjbGljay50aW1lc3RhbXAgOiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbCBvZiB0aGVzZSBhcmUgaW4gc2Vjb25kcyFcbiAgICAgIGlmIChjbGljay50aW1lc3RhbXAgKyB0aGlzLl90aW1lb3V0IDw9IG5vdykge1xuICAgICAgICB0aW1lZE91dENsaWNrcy5wdXNoKGNsaWNrKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlbW92ZSBcIm9sZFwiIGNsaWNrc1xuICAgIGZvciAoY29uc3QgY2xpY2sgb2YgdGltZWRPdXRDbGlja3MpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX2NsaWNrcy5pbmRleE9mKGNsaWNrKTtcblxuICAgICAgaWYgKHBvcyA+IC0xKSB7XG4gICAgICAgIHRoaXMuX2dlbmVyYXRlQnJlYWRjcnVtYnMoY2xpY2spO1xuICAgICAgICB0aGlzLl9jbGlja3Muc3BsaWNlKHBvcywgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlciBuZXcgY2hlY2ssIHVubGVzcyBubyBjbGlja3MgbGVmdFxuICAgIGlmICh0aGlzLl9jbGlja3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZUNoZWNrQ2xpY2tzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEdlbmVyYXRlIG1hdGNoaW5nIGJyZWFkY3J1bWIocykgZm9yIHRoZSBjbGljay4gKi9cbiAgIF9nZW5lcmF0ZUJyZWFkY3J1bWJzKGNsaWNrKSB7XG4gICAgY29uc3QgcmVwbGF5ID0gdGhpcy5fcmVwbGF5O1xuICAgIGNvbnN0IGhhZFNjcm9sbCA9IGNsaWNrLnNjcm9sbEFmdGVyICYmIGNsaWNrLnNjcm9sbEFmdGVyIDw9IHRoaXMuX3Njcm9sbFRpbWVvdXQ7XG4gICAgY29uc3QgaGFkTXV0YXRpb24gPSBjbGljay5tdXRhdGlvbkFmdGVyICYmIGNsaWNrLm11dGF0aW9uQWZ0ZXIgPD0gdGhpcy5fdGhyZXNob2xkO1xuXG4gICAgY29uc3QgaXNTbG93Q2xpY2sgPSAhaGFkU2Nyb2xsICYmICFoYWRNdXRhdGlvbjtcbiAgICBjb25zdCB7IGNsaWNrQ291bnQsIGNsaWNrQnJlYWRjcnVtYiB9ID0gY2xpY2s7XG5cbiAgICAvLyBTbG93IGNsaWNrXG4gICAgaWYgKGlzU2xvd0NsaWNrKSB7XG4gICAgICAvLyBJZiBgbXV0YXRpb25BZnRlcmAgaXMgc2V0LCBpdCBtZWFucyBhIG11dGF0aW9uIGhhcHBlbmVkIGFmdGVyIHRoZSB0aHJlc2hvbGQsIGJ1dCBiZWZvcmUgdGhlIHRpbWVvdXRcbiAgICAgIC8vIElmIG5vdCwgaXQgbWVhbnMgd2UganVzdCB0aW1lZCBvdXQgd2l0aG91dCBzY3JvbGwgJiBtdXRhdGlvblxuICAgICAgY29uc3QgdGltZUFmdGVyQ2xpY2tNcyA9IE1hdGgubWluKGNsaWNrLm11dGF0aW9uQWZ0ZXIgfHwgdGhpcy5fdGltZW91dCwgdGhpcy5fdGltZW91dCkgKiAxMDAwO1xuICAgICAgY29uc3QgZW5kUmVhc29uID0gdGltZUFmdGVyQ2xpY2tNcyA8IHRoaXMuX3RpbWVvdXQgKiAxMDAwID8gJ211dGF0aW9uJyA6ICd0aW1lb3V0JztcblxuICAgICAgY29uc3QgYnJlYWRjcnVtYiA9IHtcbiAgICAgICAgdHlwZTogJ2RlZmF1bHQnLFxuICAgICAgICBtZXNzYWdlOiBjbGlja0JyZWFkY3J1bWIubWVzc2FnZSxcbiAgICAgICAgdGltZXN0YW1wOiBjbGlja0JyZWFkY3J1bWIudGltZXN0YW1wLFxuICAgICAgICBjYXRlZ29yeTogJ3VpLnNsb3dDbGlja0RldGVjdGVkJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIC4uLmNsaWNrQnJlYWRjcnVtYi5kYXRhLFxuICAgICAgICAgIHVybDogV0lORE9XLmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgcm91dGU6IHJlcGxheS5nZXRDdXJyZW50Um91dGUoKSxcbiAgICAgICAgICB0aW1lQWZ0ZXJDbGlja01zLFxuICAgICAgICAgIGVuZFJlYXNvbixcbiAgICAgICAgICAvLyBJZiBjbGlja0NvdW50ID09PSAwLCBpdCBtZWFucyBtdWx0aUNsaWNrIHdhcyBub3QgY29ycmVjdGx5IGNhcHR1cmVkIGhlcmVcbiAgICAgICAgICAvLyAtIHdlIHN0aWxsIHdhbnQgdG8gc2VuZCAxIGluIHRoaXMgY2FzZVxuICAgICAgICAgIGNsaWNrQ291bnQ6IGNsaWNrQ291bnQgfHwgMSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2FkZEJyZWFkY3J1bWJFdmVudChyZXBsYXksIGJyZWFkY3J1bWIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE11bHRpIGNsaWNrXG4gICAgaWYgKGNsaWNrQ291bnQgPiAxKSB7XG4gICAgICBjb25zdCBicmVhZGNydW1iID0ge1xuICAgICAgICB0eXBlOiAnZGVmYXVsdCcsXG4gICAgICAgIG1lc3NhZ2U6IGNsaWNrQnJlYWRjcnVtYi5tZXNzYWdlLFxuICAgICAgICB0aW1lc3RhbXA6IGNsaWNrQnJlYWRjcnVtYi50aW1lc3RhbXAsXG4gICAgICAgIGNhdGVnb3J5OiAndWkubXVsdGlDbGljaycsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAuLi5jbGlja0JyZWFkY3J1bWIuZGF0YSxcbiAgICAgICAgICB1cmw6IFdJTkRPVy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgIHJvdXRlOiByZXBsYXkuZ2V0Q3VycmVudFJvdXRlKCksXG4gICAgICAgICAgY2xpY2tDb3VudCxcbiAgICAgICAgICBtZXRyaWM6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9hZGRCcmVhZGNydW1iRXZlbnQocmVwbGF5LCBicmVhZGNydW1iKTtcbiAgICB9XG4gIH1cblxuICAvKiogU2NoZWR1bGUgdG8gY2hlY2sgY3VycmVudCBjbGlja3MuICovXG4gICBfc2NoZWR1bGVDaGVja0NsaWNrcygpIHtcbiAgICBpZiAodGhpcy5fY2hlY2tDbGlja1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jaGVja0NsaWNrVGltZW91dCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2hlY2tDbGlja1RpbWVvdXQgPSBzZXRUaW1lb3V0JDMoKCkgPT4gdGhpcy5fY2hlY2tDbGlja3MoKSwgMTAwMCk7XG4gIH1cbn1cblxuY29uc3QgU0xPV19DTElDS19UQUdTID0gWydBJywgJ0JVVFRPTicsICdJTlBVVCddO1xuXG4vKiogZXhwb3J0ZWQgZm9yIHRlc3RzIG9ubHkgKi9cbmZ1bmN0aW9uIGlnbm9yZUVsZW1lbnQobm9kZSwgaWdub3JlU2VsZWN0b3IpIHtcbiAgaWYgKCFTTE9XX0NMSUNLX1RBR1MuaW5jbHVkZXMobm9kZS50YWdOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSWYgPGlucHV0PiB0YWcsIHdlIG9ubHkgd2FudCB0byBjb25zaWRlciBpbnB1dFt0eXBlPSdzdWJtaXQnXSAmIGlucHV0W3R5cGU9J2J1dHRvbiddXG4gIGlmIChub2RlLnRhZ05hbWUgPT09ICdJTlBVVCcgJiYgIVsnc3VibWl0JywgJ2J1dHRvbiddLmluY2x1ZGVzKG5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJykgfHwgJycpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJZiA8YT4gdGFnLCBkZXRlY3Qgc3BlY2lhbCB2YXJpYW50cyB0aGF0IG1heSBub3QgbGVhZCB0byBhbiBhY3Rpb25cbiAgLy8gSWYgdGFyZ2V0ICE9PSBfc2VsZiwgd2UgbWF5IG9wZW4gdGhlIGxpbmsgc29tZXdoZXJlIGVsc2UsIHdoaWNoIHdvdWxkIGxlYWQgdG8gbm8gYWN0aW9uXG4gIC8vIEFsc28sIHdoZW4gZG93bmxvYWRpbmcgYSBmaWxlLCB3ZSBtYXkgbm90IGxlYXZlIHRoZSBwYWdlLCBidXQgc3RpbGwgbm90IHRyaWdnZXIgYW4gYWN0aW9uXG4gIGlmIChcbiAgICBub2RlLnRhZ05hbWUgPT09ICdBJyAmJlxuICAgIChub2RlLmhhc0F0dHJpYnV0ZSgnZG93bmxvYWQnKSB8fCAobm9kZS5oYXNBdHRyaWJ1dGUoJ3RhcmdldCcpICYmIG5vZGUuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSAhPT0gJ19zZWxmJykpXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlnbm9yZVNlbGVjdG9yICYmIG5vZGUubWF0Y2hlcyhpZ25vcmVTZWxlY3RvcikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDbGlja0JyZWFkY3J1bWIoYnJlYWRjcnVtYikge1xuICByZXR1cm4gISEoYnJlYWRjcnVtYi5kYXRhICYmIHR5cGVvZiBicmVhZGNydW1iLmRhdGEubm9kZUlkID09PSAnbnVtYmVyJyAmJiBicmVhZGNydW1iLnRpbWVzdGFtcCk7XG59XG5cbi8vIFRoaXMgaXMgZ29vZCBlbm91Z2ggZm9yIHVzLCBhbmQgaXMgZWFzaWVyIHRvIHRlc3QvbW9jayB0aGFuIGB0aW1lc3RhbXBJblNlY29uZHNgXG5mdW5jdGlvbiBub3dJblNlY29uZHMoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpIC8gMTAwMDtcbn1cblxuLyoqIFVwZGF0ZSB0aGUgY2xpY2sgZGV0ZWN0b3IgYmFzZWQgb24gYSByZWNvcmRpbmcgZXZlbnQgb2YgcnJ3ZWIuICovXG5mdW5jdGlvbiB1cGRhdGVDbGlja0RldGVjdG9yRm9yUmVjb3JkaW5nRXZlbnQoY2xpY2tEZXRlY3RvciwgZXZlbnQpIHtcbiAgdHJ5IHtcbiAgICAvLyBub3RlOiBXZSBvbmx5IGNvbnNpZGVyIGluY3JlbWVudGFsIHNuYXBzaG90cyBoZXJlXG4gICAgLy8gVGhpcyBtZWFucyB0aGF0IGFueSBmdWxsIHNuYXBzaG90IGlzIGlnbm9yZWQgZm9yIG11dGF0aW9uIGRldGVjdGlvbiAtIHRoZSByZWFzb24gaXMgdGhhdCB3ZSBzaW1wbHkgY2Fubm90IGtub3cgaWYgYSBtdXRhdGlvbiBoYXBwZW5lZCBoZXJlLlxuICAgIC8vIEUuZy4gdGhpbmsgdGhhdCB3ZSBhcmUgYnVmZmVyaW5nLCBhbiBlcnJvciBoYXBwZW5zIGFuZCB3ZSB0YWtlIGEgZnVsbCBzbmFwc2hvdCBiZWNhdXNlIHdlIHN3aXRjaGVkIHRvIHNlc3Npb24gbW9kZSAtXG4gICAgLy8gaW4gdGhpcyBzY2VuYXJpbywgd2Ugd291bGQgbm90IGtub3cgaWYgYSBkZWFkIGNsaWNrIGhhcHBlbmVkIGJlY2F1c2Ugb2YgdGhlIGVycm9yLCB3aGljaCBpcyBhIGtleSBkZWFkIGNsaWNrIHNjZW5hcmlvLlxuICAgIC8vIEluc3RlYWQsIGJ5IGlnbm9yaW5nIGZ1bGwgc25hcHNob3RzLCB3ZSBoYXZlIHRoZSByaXNrIHRoYXQgd2UgZ2VuZXJhdGUgYSBmYWxzZSBwb3NpdGl2ZVxuICAgIC8vIChpZiBhIG11dGF0aW9uIF9kaWRfIGhhcHBlbiBidXQgd2FzIFwic3dhbGxvd2VkXCIgYnkgdGhlIGZ1bGwgc25hcHNob3QpXG4gICAgLy8gQnV0IHRoaXMgc2hvdWxkIGJlIG1vcmUgdW5saWtlbHkgYXMgd2UnZCBnZW5lcmFsbHkgY2FwdHVyZSB0aGUgaW5jcmVtZW50YWwgc25hcHNob3QgcmlnaHQgYXdheVxuXG4gICAgaWYgKCFpc0luY3JlbWVudGFsRXZlbnQoZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBzb3VyY2UgfSA9IGV2ZW50LmRhdGE7XG4gICAgaWYgKEluY3JlbWVudGFsTXV0YXRpb25Tb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICBjbGlja0RldGVjdG9yLnJlZ2lzdGVyTXV0YXRpb24oZXZlbnQudGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlID09PSBJbmNyZW1lbnRhbFNvdXJjZS5TY3JvbGwpIHtcbiAgICAgIGNsaWNrRGV0ZWN0b3IucmVnaXN0ZXJTY3JvbGwoZXZlbnQudGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICBpZiAoaXNJbmNyZW1lbnRhbE1vdXNlSW50ZXJhY3Rpb24oZXZlbnQpKSB7XG4gICAgICBjb25zdCB7IHR5cGUsIGlkIH0gPSBldmVudC5kYXRhO1xuICAgICAgY29uc3Qgbm9kZSA9IHJlY29yZC5taXJyb3IuZ2V0Tm9kZShpZCk7XG5cbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdHlwZSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuQ2xpY2spIHtcbiAgICAgICAgY2xpY2tEZXRlY3Rvci5yZWdpc3RlckNsaWNrKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gaWdub3JlIGVycm9ycyBoZXJlLCBlLmcuIGlmIGFjY2Vzc2luZyBzb21ldGhpbmcgdGhhdCBkb2VzIG5vdCBleGlzdFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5jcmVtZW50YWxFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gUmVwbGF5RXZlbnRUeXBlSW5jcmVtZW50YWxTbmFwc2hvdDtcbn1cblxuZnVuY3Rpb24gaXNJbmNyZW1lbnRhbE1vdXNlSW50ZXJhY3Rpb24oXG4gIGV2ZW50LFxuKSB7XG4gIHJldHVybiBldmVudC5kYXRhLnNvdXJjZSA9PT0gSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvbjtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBicmVhZGNydW1iIGZvciBhIHJlcGxheS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnJlYWRjcnVtYihcbiAgYnJlYWRjcnVtYixcbikge1xuICByZXR1cm4ge1xuICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSAvIDEwMDAsXG4gICAgdHlwZTogJ2RlZmF1bHQnLFxuICAgIC4uLmJyZWFkY3J1bWIsXG4gIH07XG59XG5cbnZhciBOb2RlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5vZGVUeXBlMikgPT4ge1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRG9jdW1lbnRcIl0gPSAwXSA9IFwiRG9jdW1lbnRcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50VHlwZVwiXSA9IDFdID0gXCJEb2N1bWVudFR5cGVcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkVsZW1lbnRcIl0gPSAyXSA9IFwiRWxlbWVudFwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiVGV4dFwiXSA9IDNdID0gXCJUZXh0XCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDREFUQVwiXSA9IDRdID0gXCJDREFUQVwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ29tbWVudFwiXSA9IDVdID0gXCJDb21tZW50XCI7XG4gIHJldHVybiBOb2RlVHlwZTI7XG59KShOb2RlVHlwZSB8fCB7fSk7XG5cbi8vIE5vdGUgdGhhdCB0aGVzZSBhcmUgdGhlIHNlcmlhbGl6ZWQgYXR0cmlidXRlcyBhbmQgbm90IGF0dHJpYnV0ZXMgZGlyZWN0bHkgb25cbi8vIHRoZSBET00gTm9kZS4gQXR0cmlidXRlcyB3ZSBhcmUgaW50ZXJlc3RlZCBpbjpcbmNvbnN0IEFUVFJJQlVURVNfVE9fUkVDT1JEID0gbmV3IFNldChbXG4gICdpZCcsXG4gICdjbGFzcycsXG4gICdhcmlhLWxhYmVsJyxcbiAgJ3JvbGUnLFxuICAnbmFtZScsXG4gICdhbHQnLFxuICAndGl0bGUnLFxuICAnZGF0YS10ZXN0LWlkJyxcbiAgJ2RhdGEtdGVzdGlkJyxcbiAgJ2Rpc2FibGVkJyxcbiAgJ2FyaWEtZGlzYWJsZWQnLFxuICAnZGF0YS1zZW50cnktY29tcG9uZW50Jyxcbl0pO1xuXG4vKipcbiAqIEluY2x1c2lvbiBsaXN0IG9mIGF0dHJpYnV0ZXMgdGhhdCB3ZSB3YW50IHRvIHJlY29yZCBmcm9tIHRoZSBET00gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzVG9SZWNvcmQoYXR0cmlidXRlcykge1xuICBjb25zdCBvYmogPSB7fTtcbiAgaWYgKCFhdHRyaWJ1dGVzWydkYXRhLXNlbnRyeS1jb21wb25lbnQnXSAmJiBhdHRyaWJ1dGVzWydkYXRhLXNlbnRyeS1lbGVtZW50J10pIHtcbiAgICBhdHRyaWJ1dGVzWydkYXRhLXNlbnRyeS1jb21wb25lbnQnXSA9IGF0dHJpYnV0ZXNbJ2RhdGEtc2VudHJ5LWVsZW1lbnQnXTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKEFUVFJJQlVURVNfVE9fUkVDT1JELmhhcyhrZXkpKSB7XG4gICAgICBsZXQgbm9ybWFsaXplZEtleSA9IGtleTtcblxuICAgICAgaWYgKGtleSA9PT0gJ2RhdGEtdGVzdGlkJyB8fCBrZXkgPT09ICdkYXRhLXRlc3QtaWQnKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkgPSAndGVzdElkJztcbiAgICAgIH1cblxuICAgICAgb2JqW25vcm1hbGl6ZWRLZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmNvbnN0IGhhbmRsZURvbUxpc3RlbmVyID0gKFxuICByZXBsYXksXG4pID0+IHtcbiAgcmV0dXJuIChoYW5kbGVyRGF0YSkgPT4ge1xuICAgIGlmICghcmVwbGF5LmlzRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gaGFuZGxlRG9tKGhhbmRsZXJEYXRhKTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaXNDbGljayA9IGhhbmRsZXJEYXRhLm5hbWUgPT09ICdjbGljayc7XG4gICAgY29uc3QgZXZlbnQgPSBpc0NsaWNrID8gKGhhbmRsZXJEYXRhLmV2ZW50ICkgOiB1bmRlZmluZWQ7XG4gICAgLy8gSWdub3JlIGNsaWNrcyBpZiBjdHJsL2FsdC9tZXRhL3NoaWZ0IGtleXMgYXJlIGhlbGQgZG93biBhcyB0aGV5IGFsdGVyIGJlaGF2aW9yIG9mIGNsaWNrcyAoZS5nLiBvcGVuIGluIG5ldyB0YWIpXG4gICAgaWYgKFxuICAgICAgaXNDbGljayAmJlxuICAgICAgcmVwbGF5LmNsaWNrRGV0ZWN0b3IgJiZcbiAgICAgIGV2ZW50ICYmXG4gICAgICBldmVudC50YXJnZXQgJiZcbiAgICAgICFldmVudC5hbHRLZXkgJiZcbiAgICAgICFldmVudC5tZXRhS2V5ICYmXG4gICAgICAhZXZlbnQuY3RybEtleSAmJlxuICAgICAgIWV2ZW50LnNoaWZ0S2V5XG4gICAgKSB7XG4gICAgICBoYW5kbGVDbGljayhcbiAgICAgICAgcmVwbGF5LmNsaWNrRGV0ZWN0b3IsXG4gICAgICAgIHJlc3VsdCAsXG4gICAgICAgIGdldENsaWNrVGFyZ2V0Tm9kZShoYW5kbGVyRGF0YS5ldmVudCApICxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgYWRkQnJlYWRjcnVtYkV2ZW50KHJlcGxheSwgcmVzdWx0KTtcbiAgfTtcbn07XG5cbi8qKiBHZXQgdGhlIGJhc2UgRE9NIGJyZWFkY3J1bWIuICovXG5mdW5jdGlvbiBnZXRCYXNlRG9tQnJlYWRjcnVtYih0YXJnZXQsIG1lc3NhZ2UpIHtcbiAgY29uc3Qgbm9kZUlkID0gcmVjb3JkLm1pcnJvci5nZXRJZCh0YXJnZXQpO1xuICBjb25zdCBub2RlID0gbm9kZUlkICYmIHJlY29yZC5taXJyb3IuZ2V0Tm9kZShub2RlSWQpO1xuICBjb25zdCBtZXRhID0gbm9kZSAmJiByZWNvcmQubWlycm9yLmdldE1ldGEobm9kZSk7XG4gIGNvbnN0IGVsZW1lbnQgPSBtZXRhICYmIGlzRWxlbWVudChtZXRhKSA/IG1ldGEgOiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgbWVzc2FnZSxcbiAgICBkYXRhOiBlbGVtZW50XG4gICAgICA/IHtcbiAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgICAgICAgIHRhZ05hbWU6IGVsZW1lbnQudGFnTmFtZSxcbiAgICAgICAgICAgIHRleHRDb250ZW50OiBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2RlcylcbiAgICAgICAgICAgICAgLm1hcCgobm9kZSkgPT4gbm9kZS50eXBlID09PSBOb2RlVHlwZS5UZXh0ICYmIG5vZGUudGV4dENvbnRlbnQpXG4gICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbikgLy8gZmlsdGVyIG91dCBlbXB0eSB2YWx1ZXNcbiAgICAgICAgICAgICAgLm1hcCh0ZXh0ID0+ICh0ZXh0ICkudHJpbSgpKVxuICAgICAgICAgICAgICAuam9pbignJyksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBnZXRBdHRyaWJ1dGVzVG9SZWNvcmQoZWxlbWVudC5hdHRyaWJ1dGVzKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICA6IHt9LFxuICB9O1xufVxuXG4vKipcbiAqIEFuIGV2ZW50IGhhbmRsZXIgdG8gcmVhY3QgdG8gRE9NIGV2ZW50cy5cbiAqIEV4cG9ydGVkIGZvciB0ZXN0cy5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRG9tKGhhbmRsZXJEYXRhKSB7XG4gIGNvbnN0IHsgdGFyZ2V0LCBtZXNzYWdlIH0gPSBnZXREb21UYXJnZXQoaGFuZGxlckRhdGEpO1xuXG4gIHJldHVybiBjcmVhdGVCcmVhZGNydW1iKHtcbiAgICBjYXRlZ29yeTogYHVpLiR7aGFuZGxlckRhdGEubmFtZX1gLFxuICAgIC4uLmdldEJhc2VEb21CcmVhZGNydW1iKHRhcmdldCwgbWVzc2FnZSksXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXREb21UYXJnZXQoaGFuZGxlckRhdGEpIHtcbiAgY29uc3QgaXNDbGljayA9IGhhbmRsZXJEYXRhLm5hbWUgPT09ICdjbGljayc7XG5cbiAgbGV0IG1lc3NhZ2U7XG4gIGxldCB0YXJnZXQgPSBudWxsO1xuXG4gIC8vIEFjY2Vzc2luZyBldmVudC50YXJnZXQgY2FuIHRocm93IChzZWUgZ2V0c2VudHJ5L3JhdmVuLWpzIzgzOCwgIzc2OClcbiAgdHJ5IHtcbiAgICB0YXJnZXQgPSBpc0NsaWNrID8gZ2V0Q2xpY2tUYXJnZXROb2RlKGhhbmRsZXJEYXRhLmV2ZW50ICkgOiBnZXRUYXJnZXROb2RlKGhhbmRsZXJEYXRhLmV2ZW50ICk7XG4gICAgbWVzc2FnZSA9IGh0bWxUcmVlQXNTdHJpbmcodGFyZ2V0LCB7IG1heFN0cmluZ0xlbmd0aDogMjAwIH0pIHx8ICc8dW5rbm93bj4nO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbWVzc2FnZSA9ICc8dW5rbm93bj4nO1xuICB9XG5cbiAgcmV0dXJuIHsgdGFyZ2V0LCBtZXNzYWdlIH07XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQ7XG59XG5cbi8qKiBIYW5kbGUga2V5Ym9hcmQgZXZlbnRzICYgY3JlYXRlIGJyZWFkY3J1bWJzLiAqL1xuZnVuY3Rpb24gaGFuZGxlS2V5Ym9hcmRFdmVudChyZXBsYXksIGV2ZW50KSB7XG4gIGlmICghcmVwbGF5LmlzRW5hYmxlZCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVXBkYXRlIHVzZXIgYWN0aXZpdHksIGJ1dCBkbyBub3QgcmVzdGFydCByZWNvcmRpbmcgYXMgaXQgY2FuIGNyZWF0ZVxuICAvLyBub2lzeS9sb3ctdmFsdWUgcmVwbGF5cyAoZS5nLiB1c2VyIGNvbWVzIGJhY2sgZnJvbSBpZGxlLCBoaXRzIGFsdC10YWIsIG5ld1xuICAvLyBzZXNzaW9uIHdpdGggYSBzaW5nbGUgXCJrZXlkb3duXCIgYnJlYWRjcnVtYiBpcyBjcmVhdGVkKVxuICByZXBsYXkudXBkYXRlVXNlckFjdGl2aXR5KCk7XG5cbiAgY29uc3QgYnJlYWRjcnVtYiA9IGdldEtleWJvYXJkQnJlYWRjcnVtYihldmVudCk7XG5cbiAgaWYgKCFicmVhZGNydW1iKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYWRkQnJlYWRjcnVtYkV2ZW50KHJlcGxheSwgYnJlYWRjcnVtYik7XG59XG5cbi8qKiBleHBvcnRlZCBvbmx5IGZvciB0ZXN0cyAqL1xuZnVuY3Rpb24gZ2V0S2V5Ym9hcmRCcmVhZGNydW1iKGV2ZW50KSB7XG4gIGNvbnN0IHsgbWV0YUtleSwgc2hpZnRLZXksIGN0cmxLZXksIGFsdEtleSwga2V5LCB0YXJnZXQgfSA9IGV2ZW50O1xuXG4gIC8vIG5ldmVyIGNhcHR1cmUgZm9yIGlucHV0IGZpZWxkc1xuICBpZiAoIXRhcmdldCB8fCBpc0lucHV0RWxlbWVudCh0YXJnZXQgKSB8fCAha2V5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOb3RlOiBXZSBkbyBub3QgY29uc2lkZXIgc2hpZnQgaGVyZSwgYXMgdGhhdCBtZWFucyBcInVwcGVyY2FzZVwiXG4gIGNvbnN0IGhhc01vZGlmaWVyS2V5ID0gbWV0YUtleSB8fCBjdHJsS2V5IHx8IGFsdEtleTtcbiAgY29uc3QgaXNDaGFyYWN0ZXJLZXkgPSBrZXkubGVuZ3RoID09PSAxOyAvLyBvdGhlciBrZXlzIGxpa2UgRXNjYXBlLCBUYWIsIGV0YyBoYXZlIGEgbG9uZ2VyIGxlbmd0aFxuXG4gIC8vIERvIG5vdCBjYXB0dXJlIGJyZWFkY3J1bWIgaWYgb25seSBhIHdvcmQga2V5IGlzIHByZXNzZWRcbiAgLy8gVGhpcyBjb3VsZCBsZWFrIGUuZy4gdXNlciBpbnB1dFxuICBpZiAoIWhhc01vZGlmaWVyS2V5ICYmIGlzQ2hhcmFjdGVyS2V5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBtZXNzYWdlID0gaHRtbFRyZWVBc1N0cmluZyh0YXJnZXQsIHsgbWF4U3RyaW5nTGVuZ3RoOiAyMDAgfSkgfHwgJzx1bmtub3duPic7XG4gIGNvbnN0IGJhc2VCcmVhZGNydW1iID0gZ2V0QmFzZURvbUJyZWFkY3J1bWIodGFyZ2V0ICwgbWVzc2FnZSk7XG5cbiAgcmV0dXJuIGNyZWF0ZUJyZWFkY3J1bWIoe1xuICAgIGNhdGVnb3J5OiAndWkua2V5RG93bicsXG4gICAgbWVzc2FnZSxcbiAgICBkYXRhOiB7XG4gICAgICAuLi5iYXNlQnJlYWRjcnVtYi5kYXRhLFxuICAgICAgbWV0YUtleSxcbiAgICAgIHNoaWZ0S2V5LFxuICAgICAgY3RybEtleSxcbiAgICAgIGFsdEtleSxcbiAgICAgIGtleSxcbiAgICB9LFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCB0YXJnZXQudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fCB0YXJnZXQuaXNDb250ZW50RWRpdGFibGU7XG59XG5cbi8vIE1hcCBlbnRyeVR5cGUgLT4gZnVuY3Rpb24gdG8gbm9ybWFsaXplIGRhdGEgZm9yIGV2ZW50XG5jb25zdCBFTlRSWV9UWVBFU1xuXG4gPSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZW50cnkgdHlwZSBkb2VzIG5vdCBmaXQgdGhlIGNyZWF0ZSogZnVuY3Rpb25zIGVudHJ5IHR5cGVcbiAgcmVzb3VyY2U6IGNyZWF0ZVJlc291cmNlRW50cnksXG4gIHBhaW50OiBjcmVhdGVQYWludEVudHJ5LFxuICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IGVudHJ5IHR5cGUgZG9lcyBub3QgZml0IHRoZSBjcmVhdGUqIGZ1bmN0aW9ucyBlbnRyeSB0eXBlXG4gIG5hdmlnYXRpb246IGNyZWF0ZU5hdmlnYXRpb25FbnRyeSxcbn07XG5cbi8qKlxuICogSGFuZGxlciBjcmVhdGVyIGZvciB3ZWIgdml0YWxzXG4gKi9cbmZ1bmN0aW9uIHdlYlZpdGFsSGFuZGxlcihcbiAgZ2V0dGVyLFxuICByZXBsYXksXG4pIHtcbiAgcmV0dXJuICh7IG1ldHJpYyB9KSA9PiB2b2lkIHJlcGxheS5yZXBsYXlQZXJmb3JtYW5jZUVudHJpZXMucHVzaChnZXR0ZXIobWV0cmljKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIHJlcGxheSBwZXJmb3JtYW5jZSBlbnRyaWVzIGZyb20gdGhlIGJyb3dzZXIgcGVyZm9ybWFuY2UgZW50cmllcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGVyZm9ybWFuY2VFbnRyaWVzKFxuICBlbnRyaWVzLFxuKSB7XG4gIHJldHVybiBlbnRyaWVzLm1hcChjcmVhdGVQZXJmb3JtYW5jZUVudHJ5KS5maWx0ZXIoQm9vbGVhbikgO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQZXJmb3JtYW5jZUVudHJ5KGVudHJ5KSB7XG4gIGNvbnN0IGVudHJ5VHlwZSA9IEVOVFJZX1RZUEVTW2VudHJ5LmVudHJ5VHlwZV07XG4gIGlmICghZW50cnlUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZW50cnlUeXBlKGVudHJ5KTtcbn1cblxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVUaW1lKHRpbWUpIHtcbiAgLy8gYnJvd3NlclBlcmZvcm1hbmNlVGltZU9yaWdpbiBjYW4gYmUgdW5kZWZpbmVkIGlmIGBwZXJmb3JtYW5jZWAgb3JcbiAgLy8gYHBlcmZvcm1hbmNlLm5vd2AgZG9lc24ndCBleGlzdCwgYnV0IHRoaXMgaXMgYWxyZWFkeSBjaGVja2VkIGJ5IHRoaXMgaW50ZWdyYXRpb25cbiAgcmV0dXJuICgoYnJvd3NlclBlcmZvcm1hbmNlVGltZU9yaWdpbigpIHx8IFdJTkRPVy5wZXJmb3JtYW5jZS50aW1lT3JpZ2luKSArIHRpbWUpIC8gMTAwMDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGFpbnRFbnRyeShlbnRyeSkge1xuICBjb25zdCB7IGR1cmF0aW9uLCBlbnRyeVR5cGUsIG5hbWUsIHN0YXJ0VGltZSB9ID0gZW50cnk7XG5cbiAgY29uc3Qgc3RhcnQgPSBnZXRBYnNvbHV0ZVRpbWUoc3RhcnRUaW1lKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBlbnRyeVR5cGUsXG4gICAgbmFtZSxcbiAgICBzdGFydCxcbiAgICBlbmQ6IHN0YXJ0ICsgZHVyYXRpb24sXG4gICAgZGF0YTogdW5kZWZpbmVkLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOYXZpZ2F0aW9uRW50cnkoZW50cnkpIHtcbiAgY29uc3Qge1xuICAgIGVudHJ5VHlwZSxcbiAgICBuYW1lLFxuICAgIGRlY29kZWRCb2R5U2l6ZSxcbiAgICBkdXJhdGlvbixcbiAgICBkb21Db21wbGV0ZSxcbiAgICBlbmNvZGVkQm9keVNpemUsXG4gICAgZG9tQ29udGVudExvYWRlZEV2ZW50U3RhcnQsXG4gICAgZG9tQ29udGVudExvYWRlZEV2ZW50RW5kLFxuICAgIGRvbUludGVyYWN0aXZlLFxuICAgIGxvYWRFdmVudFN0YXJ0LFxuICAgIGxvYWRFdmVudEVuZCxcbiAgICByZWRpcmVjdENvdW50LFxuICAgIHN0YXJ0VGltZSxcbiAgICB0cmFuc2ZlclNpemUsXG4gICAgdHlwZSxcbiAgfSA9IGVudHJ5O1xuXG4gIC8vIElnbm9yZSBlbnRyaWVzIHdpdGggbm8gZHVyYXRpb24sIHRoZXkgZG8gbm90IHNlZW0gdG8gYmUgdXNlZnVsIGFuZCBjYXVzZSBkdXBlc1xuICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogYCR7ZW50cnlUeXBlfS4ke3R5cGV9YCxcbiAgICBzdGFydDogZ2V0QWJzb2x1dGVUaW1lKHN0YXJ0VGltZSksXG4gICAgZW5kOiBnZXRBYnNvbHV0ZVRpbWUoZG9tQ29tcGxldGUpLFxuICAgIG5hbWUsXG4gICAgZGF0YToge1xuICAgICAgc2l6ZTogdHJhbnNmZXJTaXplLFxuICAgICAgZGVjb2RlZEJvZHlTaXplLFxuICAgICAgZW5jb2RlZEJvZHlTaXplLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBkb21JbnRlcmFjdGl2ZSxcbiAgICAgIGRvbUNvbnRlbnRMb2FkZWRFdmVudFN0YXJ0LFxuICAgICAgZG9tQ29udGVudExvYWRlZEV2ZW50RW5kLFxuICAgICAgbG9hZEV2ZW50U3RhcnQsXG4gICAgICBsb2FkRXZlbnRFbmQsXG4gICAgICBkb21Db21wbGV0ZSxcbiAgICAgIHJlZGlyZWN0Q291bnQsXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVzb3VyY2VFbnRyeShcbiAgZW50cnksXG4pIHtcbiAgY29uc3Qge1xuICAgIGVudHJ5VHlwZSxcbiAgICBpbml0aWF0b3JUeXBlLFxuICAgIG5hbWUsXG4gICAgcmVzcG9uc2VFbmQsXG4gICAgc3RhcnRUaW1lLFxuICAgIGRlY29kZWRCb2R5U2l6ZSxcbiAgICBlbmNvZGVkQm9keVNpemUsXG4gICAgcmVzcG9uc2VTdGF0dXMsXG4gICAgdHJhbnNmZXJTaXplLFxuICB9ID0gZW50cnk7XG5cbiAgLy8gQ29yZSBTREsgaGFuZGxlcyB0aGVzZVxuICBpZiAoWydmZXRjaCcsICd4bWxodHRwcmVxdWVzdCddLmluY2x1ZGVzKGluaXRpYXRvclR5cGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IGAke2VudHJ5VHlwZX0uJHtpbml0aWF0b3JUeXBlfWAsXG4gICAgc3RhcnQ6IGdldEFic29sdXRlVGltZShzdGFydFRpbWUpLFxuICAgIGVuZDogZ2V0QWJzb2x1dGVUaW1lKHJlc3BvbnNlRW5kKSxcbiAgICBuYW1lLFxuICAgIGRhdGE6IHtcbiAgICAgIHNpemU6IHRyYW5zZmVyU2l6ZSxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlU3RhdHVzLFxuICAgICAgZGVjb2RlZEJvZHlTaXplLFxuICAgICAgZW5jb2RlZEJvZHlTaXplLFxuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogQWRkIGEgTENQIGV2ZW50IHRvIHRoZSByZXBsYXkgYmFzZWQgb24gYSBMQ1AgbWV0cmljLlxuICovXG5mdW5jdGlvbiBnZXRMYXJnZXN0Q29udGVudGZ1bFBhaW50KG1ldHJpYykge1xuICBjb25zdCBsYXN0RW50cnkgPSBtZXRyaWMuZW50cmllc1ttZXRyaWMuZW50cmllcy5sZW5ndGggLSAxXSA7XG4gIGNvbnN0IG5vZGUgPSBsYXN0RW50cnk/LmVsZW1lbnQgPyBbbGFzdEVudHJ5LmVsZW1lbnRdIDogdW5kZWZpbmVkO1xuICByZXR1cm4gZ2V0V2ViVml0YWwobWV0cmljLCAnbGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50Jywgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIGlzTGF5b3V0U2hpZnQoZW50cnkpIHtcbiAgcmV0dXJuIChlbnRyeSApLnNvdXJjZXMgIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBZGQgYSBDTFMgZXZlbnQgdG8gdGhlIHJlcGxheSBiYXNlZCBvbiBhIENMUyBtZXRyaWMuXG4gKi9cbmZ1bmN0aW9uIGdldEN1bXVsYXRpdmVMYXlvdXRTaGlmdChtZXRyaWMpIHtcbiAgY29uc3QgbGF5b3V0U2hpZnRzID0gW107XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGZvciAoY29uc3QgZW50cnkgb2YgbWV0cmljLmVudHJpZXMpIHtcbiAgICBpZiAoaXNMYXlvdXRTaGlmdChlbnRyeSkpIHtcbiAgICAgIGNvbnN0IG5vZGVJZHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIGVudHJ5LnNvdXJjZXMpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5ub2RlKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChzb3VyY2Uubm9kZSk7XG4gICAgICAgICAgY29uc3Qgbm9kZUlkID0gcmVjb3JkLm1pcnJvci5nZXRJZChzb3VyY2Uubm9kZSk7XG4gICAgICAgICAgaWYgKG5vZGVJZCkge1xuICAgICAgICAgICAgbm9kZUlkcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXlvdXRTaGlmdHMucHVzaCh7IHZhbHVlOiBlbnRyeS52YWx1ZSwgbm9kZUlkczogbm9kZUlkcy5sZW5ndGggPyBub2RlSWRzIDogdW5kZWZpbmVkIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRXZWJWaXRhbChtZXRyaWMsICdjdW11bGF0aXZlLWxheW91dC1zaGlmdCcsIG5vZGVzLCBsYXlvdXRTaGlmdHMpO1xufVxuXG4vKipcbiAqIEFkZCBhIEZJRCBldmVudCB0byB0aGUgcmVwbGF5IGJhc2VkIG9uIGEgRklEIG1ldHJpYy5cbiAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RJbnB1dERlbGF5KG1ldHJpYykge1xuICBjb25zdCBsYXN0RW50cnkgPSBtZXRyaWMuZW50cmllc1ttZXRyaWMuZW50cmllcy5sZW5ndGggLSAxXSA7XG4gIGNvbnN0IG5vZGUgPSBsYXN0RW50cnk/LnRhcmdldCA/IFtsYXN0RW50cnkudGFyZ2V0XSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGdldFdlYlZpdGFsKG1ldHJpYywgJ2ZpcnN0LWlucHV0LWRlbGF5Jywgbm9kZSk7XG59XG5cbi8qKlxuICogQWRkIGFuIElOUCBldmVudCB0byB0aGUgcmVwbGF5IGJhc2VkIG9uIGFuIElOUCBtZXRyaWMuXG4gKi9cbmZ1bmN0aW9uIGdldEludGVyYWN0aW9uVG9OZXh0UGFpbnQobWV0cmljKSB7XG4gIGNvbnN0IGxhc3RFbnRyeSA9IG1ldHJpYy5lbnRyaWVzW21ldHJpYy5lbnRyaWVzLmxlbmd0aCAtIDFdIDtcbiAgY29uc3Qgbm9kZSA9IGxhc3RFbnRyeT8udGFyZ2V0ID8gW2xhc3RFbnRyeS50YXJnZXRdIDogdW5kZWZpbmVkO1xuICByZXR1cm4gZ2V0V2ViVml0YWwobWV0cmljLCAnaW50ZXJhY3Rpb24tdG8tbmV4dC1wYWludCcsIG5vZGUpO1xufVxuXG4vKipcbiAqIEFkZCBhbiB3ZWIgdml0YWwgZXZlbnQgdG8gdGhlIHJlcGxheSBiYXNlZCBvbiB0aGUgd2ViIHZpdGFsIG1ldHJpYy5cbiAqL1xuZnVuY3Rpb24gZ2V0V2ViVml0YWwoXG4gIG1ldHJpYyxcbiAgbmFtZSxcbiAgbm9kZXMsXG4gIGF0dHJpYnV0aW9ucyxcbikge1xuICBjb25zdCB2YWx1ZSA9IG1ldHJpYy52YWx1ZTtcbiAgY29uc3QgcmF0aW5nID0gbWV0cmljLnJhdGluZztcblxuICBjb25zdCBlbmQgPSBnZXRBYnNvbHV0ZVRpbWUodmFsdWUpO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3dlYi12aXRhbCcsXG4gICAgbmFtZSxcbiAgICBzdGFydDogZW5kLFxuICAgIGVuZCxcbiAgICBkYXRhOiB7XG4gICAgICB2YWx1ZSxcbiAgICAgIHNpemU6IHZhbHVlLFxuICAgICAgcmF0aW5nLFxuICAgICAgbm9kZUlkczogbm9kZXMgPyBub2Rlcy5tYXAobm9kZSA9PiByZWNvcmQubWlycm9yLmdldElkKG5vZGUpKSA6IHVuZGVmaW5lZCxcbiAgICAgIGF0dHJpYnV0aW9ucyxcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIFNldHMgdXAgYSBQZXJmb3JtYW5jZU9ic2VydmVyIHRvIGxpc3RlbiB0byBhbGwgcGVyZm9ybWFuY2UgZW50cnkgdHlwZXMuXG4gKiBSZXR1cm5zIGEgY2FsbGJhY2sgdG8gc3RvcCBvYnNlcnZpbmcuXG4gKi9cbmZ1bmN0aW9uIHNldHVwUGVyZm9ybWFuY2VPYnNlcnZlcihyZXBsYXkpIHtcbiAgZnVuY3Rpb24gYWRkUGVyZm9ybWFuY2VFbnRyeShlbnRyeSkge1xuICAgIC8vIEl0IGlzIHBvc3NpYmxlIGZvciBlbnRyaWVzIHRvIGNvbWUgdXAgbXVsdGlwbGUgdGltZXNcbiAgICBpZiAoIXJlcGxheS5wZXJmb3JtYW5jZUVudHJpZXMuaW5jbHVkZXMoZW50cnkpKSB7XG4gICAgICByZXBsYXkucGVyZm9ybWFuY2VFbnRyaWVzLnB1c2goZW50cnkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW50cmllcyh7IGVudHJpZXMgfSkge1xuICAgIGVudHJpZXMuZm9yRWFjaChhZGRQZXJmb3JtYW5jZUVudHJ5KTtcbiAgfVxuXG4gIGNvbnN0IGNsZWFyQ2FsbGJhY2tzID0gW107XG5cbiAgKFsnbmF2aWdhdGlvbicsICdwYWludCcsICdyZXNvdXJjZSddICkuZm9yRWFjaCh0eXBlID0+IHtcbiAgICBjbGVhckNhbGxiYWNrcy5wdXNoKGFkZFBlcmZvcm1hbmNlSW5zdHJ1bWVudGF0aW9uSGFuZGxlcih0eXBlLCBvbkVudHJpZXMpKTtcbiAgfSk7XG5cbiAgY2xlYXJDYWxsYmFja3MucHVzaChcbiAgICBhZGRMY3BJbnN0cnVtZW50YXRpb25IYW5kbGVyKHdlYlZpdGFsSGFuZGxlcihnZXRMYXJnZXN0Q29udGVudGZ1bFBhaW50LCByZXBsYXkpKSxcbiAgICBhZGRDbHNJbnN0cnVtZW50YXRpb25IYW5kbGVyKHdlYlZpdGFsSGFuZGxlcihnZXRDdW11bGF0aXZlTGF5b3V0U2hpZnQsIHJlcGxheSkpLFxuICAgIGFkZEZpZEluc3RydW1lbnRhdGlvbkhhbmRsZXIod2ViVml0YWxIYW5kbGVyKGdldEZpcnN0SW5wdXREZWxheSwgcmVwbGF5KSksXG4gICAgYWRkSW5wSW5zdHJ1bWVudGF0aW9uSGFuZGxlcih3ZWJWaXRhbEhhbmRsZXIoZ2V0SW50ZXJhY3Rpb25Ub05leHRQYWludCwgcmVwbGF5KSksXG4gICk7XG5cbiAgLy8gQSBjYWxsYmFjayB0byBjbGVhbnVwIGFsbCBoYW5kbGVyc1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNsZWFyQ2FsbGJhY2tzLmZvckVhY2goY2xlYXJDYWxsYmFjayA9PiBjbGVhckNhbGxiYWNrKCkpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgc2VydmVzIGFzIGEgYnVpbGQgdGltZSBmbGFnIHRoYXQgd2lsbCBiZSB0cnVlIGJ5IGRlZmF1bHQsIGJ1dCBmYWxzZSBpbiBub24tZGVidWcgYnVpbGRzIG9yIGlmIHVzZXJzIHJlcGxhY2UgYF9fU0VOVFJZX0RFQlVHX19gIGluIHRoZWlyIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEFUVEVOVElPTjogVGhpcyBjb25zdGFudCBtdXN0IG5ldmVyIGNyb3NzIHBhY2thZ2UgYm91bmRhcmllcyAoaS5lLiBiZSBleHBvcnRlZCkgdG8gZ3VhcmFudGVlIHRoYXQgaXQgY2FuIGJlIHVzZWQgZm9yIHRyZWUgc2hha2luZy5cbiAqL1xuY29uc3QgREVCVUdfQlVJTEQgPSAodHlwZW9mIF9fU0VOVFJZX0RFQlVHX18gPT09ICd1bmRlZmluZWQnIHx8IF9fU0VOVFJZX0RFQlVHX18pO1xuXG5jb25zdCByID0gYHZhciB0PVVpbnQ4QXJyYXksbj1VaW50MTZBcnJheSxyPUludDMyQXJyYXksZT1uZXcgdChbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwLDAsMCwwXSksaT1uZXcgdChbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxMywwLDBdKSxzPW5ldyB0KFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSksYT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgaT1uZXcgbigzMSkscz0wO3M8MzE7KytzKWlbc109ZSs9MTw8dFtzLTFdO3ZhciBhPW5ldyByKGlbMzBdKTtmb3Iocz0xO3M8MzA7KytzKWZvcih2YXIgbz1pW3NdO288aVtzKzFdOysrbylhW29dPW8taVtzXTw8NXxzO3JldHVybntiOmkscjphfX0sbz1hKGUsMiksaD1vLmIsZj1vLnI7aFsyOF09MjU4LGZbMjU4XT0yODtmb3IodmFyIGw9YShpLDApLnIsdT1uZXcgbigzMjc2OCksYz0wO2M8MzI3Njg7KytjKXt2YXIgdj0oNDM2OTAmYyk+PjF8KDIxODQ1JmMpPDwxO3Y9KDYxNjgwJih2PSg1MjQyOCZ2KT4+MnwoMTMxMDcmdik8PDIpKT4+NHwoMzg1NSZ2KTw8NCx1W2NdPSgoNjUyODAmdik+Pjh8KDI1NSZ2KTw8OCk+PjF9dmFyIGQ9ZnVuY3Rpb24odCxyLGUpe2Zvcih2YXIgaT10Lmxlbmd0aCxzPTAsYT1uZXcgbihyKTtzPGk7KytzKXRbc10mJisrYVt0W3NdLTFdO3ZhciBvLGg9bmV3IG4ocik7Zm9yKHM9MTtzPHI7KytzKWhbc109aFtzLTFdK2Fbcy0xXTw8MTtpZihlKXtvPW5ldyBuKDE8PHIpO3ZhciBmPTE1LXI7Zm9yKHM9MDtzPGk7KytzKWlmKHRbc10pZm9yKHZhciBsPXM8PDR8dFtzXSxjPXItdFtzXSx2PWhbdFtzXS0xXSsrPDxjLGQ9dnwoMTw8YyktMTt2PD1kOysrdilvW3Vbdl0+PmZdPWx9ZWxzZSBmb3Iobz1uZXcgbihpKSxzPTA7czxpOysrcyl0W3NdJiYob1tzXT11W2hbdFtzXS0xXSsrXT4+MTUtdFtzXSk7cmV0dXJuIG99LHA9bmV3IHQoMjg4KTtmb3IoYz0wO2M8MTQ0OysrYylwW2NdPTg7Zm9yKGM9MTQ0O2M8MjU2OysrYylwW2NdPTk7Zm9yKGM9MjU2O2M8MjgwOysrYylwW2NdPTc7Zm9yKGM9MjgwO2M8Mjg4OysrYylwW2NdPTg7dmFyIGc9bmV3IHQoMzIpO2ZvcihjPTA7YzwzMjsrK2MpZ1tjXT01O3ZhciB3PWQocCw5LDApLHk9ZChnLDUsMCksbT1mdW5jdGlvbih0KXtyZXR1cm4odCs3KS84fDB9LGI9ZnVuY3Rpb24obixyLGUpe3JldHVybihudWxsPT1lfHxlPm4ubGVuZ3RoKSYmKGU9bi5sZW5ndGgpLG5ldyB0KG4uc3ViYXJyYXkocixlKSl9LE09W1widW5leHBlY3RlZCBFT0ZcIixcImludmFsaWQgYmxvY2sgdHlwZVwiLFwiaW52YWxpZCBsZW5ndGgvbGl0ZXJhbFwiLFwiaW52YWxpZCBkaXN0YW5jZVwiLFwic3RyZWFtIGZpbmlzaGVkXCIsXCJubyBzdHJlYW0gaGFuZGxlclwiLCxcIm5vIGNhbGxiYWNrXCIsXCJpbnZhbGlkIFVURi04IGRhdGFcIixcImV4dHJhIGZpZWxkIHRvbyBsb25nXCIsXCJkYXRlIG5vdCBpbiByYW5nZSAxOTgwLTIwOTlcIixcImZpbGVuYW1lIHRvbyBsb25nXCIsXCJzdHJlYW0gZmluaXNoaW5nXCIsXCJpbnZhbGlkIHppcCBkYXRhXCJdLEU9ZnVuY3Rpb24odCxuLHIpe3ZhciBlPW5ldyBFcnJvcihufHxNW3RdKTtpZihlLmNvZGU9dCxFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSYmRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZSxFKSwhcil0aHJvdyBlO3JldHVybiBlfSx6PWZ1bmN0aW9uKHQsbixyKXtyPDw9NyZuO3ZhciBlPW4vOHwwO3RbZV18PXIsdFtlKzFdfD1yPj44fSxfPWZ1bmN0aW9uKHQsbixyKXtyPDw9NyZuO3ZhciBlPW4vOHwwO3RbZV18PXIsdFtlKzFdfD1yPj44LHRbZSsyXXw9cj4+MTZ9LHg9ZnVuY3Rpb24ocixlKXtmb3IodmFyIGk9W10scz0wO3M8ci5sZW5ndGg7KytzKXJbc10mJmkucHVzaCh7czpzLGY6cltzXX0pO3ZhciBhPWkubGVuZ3RoLG89aS5zbGljZSgpO2lmKCFhKXJldHVybnt0OkYsbDowfTtpZigxPT1hKXt2YXIgaD1uZXcgdChpWzBdLnMrMSk7cmV0dXJuIGhbaVswXS5zXT0xLHt0OmgsbDoxfX1pLnNvcnQoKGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQuZi1uLmZ9KSksaS5wdXNoKHtzOi0xLGY6MjUwMDF9KTt2YXIgZj1pWzBdLGw9aVsxXSx1PTAsYz0xLHY9Mjtmb3IoaVswXT17czotMSxmOmYuZitsLmYsbDpmLHI6bH07YyE9YS0xOylmPWlbaVt1XS5mPGlbdl0uZj91Kys6disrXSxsPWlbdSE9YyYmaVt1XS5mPGlbdl0uZj91Kys6disrXSxpW2MrK109e3M6LTEsZjpmLmYrbC5mLGw6ZixyOmx9O3ZhciBkPW9bMF0ucztmb3Iocz0xO3M8YTsrK3Mpb1tzXS5zPmQmJihkPW9bc10ucyk7dmFyIHA9bmV3IG4oZCsxKSxnPUEoaVtjLTFdLHAsMCk7aWYoZz5lKXtzPTA7dmFyIHc9MCx5PWctZSxtPTE8PHk7Zm9yKG8uc29ydCgoZnVuY3Rpb24odCxuKXtyZXR1cm4gcFtuLnNdLXBbdC5zXXx8dC5mLW4uZn0pKTtzPGE7KytzKXt2YXIgYj1vW3NdLnM7aWYoIShwW2JdPmUpKWJyZWFrO3crPW0tKDE8PGctcFtiXSkscFtiXT1lfWZvcih3Pj49eTt3PjA7KXt2YXIgTT1vW3NdLnM7cFtNXTxlP3ctPTE8PGUtcFtNXSsrLTE6KytzfWZvcig7cz49MCYmdzstLXMpe3ZhciBFPW9bc10ucztwW0VdPT1lJiYoLS1wW0VdLCsrdyl9Zz1lfXJldHVybnt0Om5ldyB0KHApLGw6Z319LEE9ZnVuY3Rpb24odCxuLHIpe3JldHVybi0xPT10LnM/TWF0aC5tYXgoQSh0LmwsbixyKzEpLEEodC5yLG4scisxKSk6blt0LnNdPXJ9LEQ9ZnVuY3Rpb24odCl7Zm9yKHZhciByPXQubGVuZ3RoO3ImJiF0Wy0tcl07KTtmb3IodmFyIGU9bmV3IG4oKytyKSxpPTAscz10WzBdLGE9MSxvPWZ1bmN0aW9uKHQpe2VbaSsrXT10fSxoPTE7aDw9cjsrK2gpaWYodFtoXT09cyYmaCE9cikrK2E7ZWxzZXtpZighcyYmYT4yKXtmb3IoO2E+MTM4O2EtPTEzOClvKDMyNzU0KTthPjImJihvKGE+MTA/YS0xMTw8NXwyODY5MDphLTM8PDV8MTIzMDUpLGE9MCl9ZWxzZSBpZihhPjMpe2ZvcihvKHMpLC0tYTthPjY7YS09NilvKDgzMDQpO2E+MiYmKG8oYS0zPDw1fDgyMDgpLGE9MCl9Zm9yKDthLS07KW8ocyk7YT0xLHM9dFtoXX1yZXR1cm57YzplLnN1YmFycmF5KDAsaSksbjpyfX0sVD1mdW5jdGlvbih0LG4pe2Zvcih2YXIgcj0wLGU9MDtlPG4ubGVuZ3RoOysrZSlyKz10W2VdKm5bZV07cmV0dXJuIHJ9LGs9ZnVuY3Rpb24odCxuLHIpe3ZhciBlPXIubGVuZ3RoLGk9bShuKzIpO3RbaV09MjU1JmUsdFtpKzFdPWU+PjgsdFtpKzJdPTI1NV50W2ldLHRbaSszXT0yNTVedFtpKzFdO2Zvcih2YXIgcz0wO3M8ZTsrK3MpdFtpK3MrNF09cltzXTtyZXR1cm4gOCooaSs0K2UpfSxVPWZ1bmN0aW9uKHQscixhLG8saCxmLGwsdSxjLHYsbSl7eihyLG0rKyxhKSwrK2hbMjU2XTtmb3IodmFyIGI9eChoLDE1KSxNPWIudCxFPWIubCxBPXgoZiwxNSksVT1BLnQsQz1BLmwsRj1EKE0pLEk9Ri5jLFM9Ri5uLEw9RChVKSxPPUwuYyxqPUwubixxPW5ldyBuKDE5KSxCPTA7QjxJLmxlbmd0aDsrK0IpKytxWzMxJklbQl1dO2ZvcihCPTA7QjxPLmxlbmd0aDsrK0IpKytxWzMxJk9bQl1dO2Zvcih2YXIgRz14KHEsNyksSD1HLnQsSj1HLmwsSz0xOTtLPjQmJiFIW3NbSy0xXV07LS1LKTt2YXIgTixQLFEsUixWPXYrNTw8MyxXPVQoaCxwKStUKGYsZykrbCxYPVQoaCxNKStUKGYsVSkrbCsxNCszKksrVChxLEgpKzIqcVsxNl0rMypxWzE3XSs3KnFbMThdO2lmKGM+PTAmJlY8PVcmJlY8PVgpcmV0dXJuIGsocixtLHQuc3ViYXJyYXkoYyxjK3YpKTtpZih6KHIsbSwxKyhYPFcpKSxtKz0yLFg8Vyl7Tj1kKE0sRSwwKSxQPU0sUT1kKFUsQywwKSxSPVU7dmFyIFk9ZChILEosMCk7eihyLG0sUy0yNTcpLHoocixtKzUsai0xKSx6KHIsbSsxMCxLLTQpLG0rPTE0O2ZvcihCPTA7QjxLOysrQil6KHIsbSszKkIsSFtzW0JdXSk7bSs9MypLO2Zvcih2YXIgWj1bSSxPXSwkPTA7JDwyOysrJCl7dmFyIHR0PVpbJF07Zm9yKEI9MDtCPHR0Lmxlbmd0aDsrK0Ipe3ZhciBudD0zMSZ0dFtCXTt6KHIsbSxZW250XSksbSs9SFtudF0sbnQ+MTUmJih6KHIsbSx0dFtCXT4+NSYxMjcpLG0rPXR0W0JdPj4xMil9fX1lbHNlIE49dyxQPXAsUT15LFI9Zztmb3IoQj0wO0I8dTsrK0Ipe3ZhciBydD1vW0JdO2lmKHJ0PjI1NSl7XyhyLG0sTlsobnQ9cnQ+PjE4JjMxKSsyNTddKSxtKz1QW250KzI1N10sbnQ+NyYmKHoocixtLHJ0Pj4yMyYzMSksbSs9ZVtudF0pO3ZhciBldD0zMSZydDtfKHIsbSxRW2V0XSksbSs9UltldF0sZXQ+MyYmKF8ocixtLHJ0Pj41JjgxOTEpLG0rPWlbZXRdKX1lbHNlIF8ocixtLE5bcnRdKSxtKz1QW3J0XX1yZXR1cm4gXyhyLG0sTlsyNTZdKSxtK1BbMjU2XX0sQz1uZXcgcihbNjU1NDAsMTMxMDgwLDEzMTA4OCwxMzExMDQsMjYyMTc2LDEwNDg3MDQsMTA0ODgzMiwyMTE0NTYwLDIxMTc2MzJdKSxGPW5ldyB0KDApLEk9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEludDMyQXJyYXkoMjU2KSxuPTA7bjwyNTY7KytuKXtmb3IodmFyIHI9bixlPTk7LS1lOylyPSgxJnImJi0zMDY2NzQ5MTIpXnI+Pj4xO3Rbbl09cn1yZXR1cm4gdH0oKSxTPWZ1bmN0aW9uKCl7dmFyIHQ9LTE7cmV0dXJue3A6ZnVuY3Rpb24obil7Zm9yKHZhciByPXQsZT0wO2U8bi5sZW5ndGg7KytlKXI9SVsyNTUmcl5uW2VdXV5yPj4+ODt0PXJ9LGQ6ZnVuY3Rpb24oKXtyZXR1cm5+dH19fSxMPWZ1bmN0aW9uKCl7dmFyIHQ9MSxuPTA7cmV0dXJue3A6ZnVuY3Rpb24ocil7Zm9yKHZhciBlPXQsaT1uLHM9MHxyLmxlbmd0aCxhPTA7YSE9czspe2Zvcih2YXIgbz1NYXRoLm1pbihhKzI2NTUscyk7YTxvOysrYSlpKz1lKz1yW2FdO2U9KDY1NTM1JmUpKzE1KihlPj4xNiksaT0oNjU1MzUmaSkrMTUqKGk+PjE2KX10PWUsbj1pfSxkOmZ1bmN0aW9uKCl7cmV0dXJuKDI1NSYodCU9NjU1MjEpKTw8MjR8KDY1MjgwJnQpPDw4fCgyNTUmKG4lPTY1NTIxKSk8PDh8bj4+OH19fSxPPWZ1bmN0aW9uKHMsYSxvLGgsdSl7aWYoIXUmJih1PXtsOjF9LGEuZGljdGlvbmFyeSkpe3ZhciBjPWEuZGljdGlvbmFyeS5zdWJhcnJheSgtMzI3NjgpLHY9bmV3IHQoYy5sZW5ndGgrcy5sZW5ndGgpO3Yuc2V0KGMpLHYuc2V0KHMsYy5sZW5ndGgpLHM9dix1Lnc9Yy5sZW5ndGh9cmV0dXJuIGZ1bmN0aW9uKHMsYSxvLGgsdSxjKXt2YXIgdj1jLnp8fHMubGVuZ3RoLGQ9bmV3IHQoaCt2KzUqKDErTWF0aC5jZWlsKHYvN2UzKSkrdSkscD1kLnN1YmFycmF5KGgsZC5sZW5ndGgtdSksZz1jLmwsdz03JihjLnJ8fDApO2lmKGEpe3cmJihwWzBdPWMucj4+Myk7Zm9yKHZhciB5PUNbYS0xXSxNPXk+PjEzLEU9ODE5MSZ5LHo9KDE8PG8pLTEsXz1jLnB8fG5ldyBuKDMyNzY4KSx4PWMuaHx8bmV3IG4oeisxKSxBPU1hdGguY2VpbChvLzMpLEQ9MipBLFQ9ZnVuY3Rpb24odCl7cmV0dXJuKHNbdF1ec1t0KzFdPDxBXnNbdCsyXTw8RCkmen0sRj1uZXcgcigyNWUzKSxJPW5ldyBuKDI4OCksUz1uZXcgbigzMiksTD0wLE89MCxqPWMuaXx8MCxxPTAsQj1jLnd8fDAsRz0wO2orMjx2Oysrail7dmFyIEg9VChqKSxKPTMyNzY3JmosSz14W0hdO2lmKF9bSl09Syx4W0hdPUosQjw9ail7dmFyIE49di1qO2lmKChMPjdlM3x8cT4yNDU3NikmJihOPjQyM3x8IWcpKXt3PVUocyxwLDAsRixJLFMsTyxxLEcsai1HLHcpLHE9TD1PPTAsRz1qO2Zvcih2YXIgUD0wO1A8Mjg2OysrUClJW1BdPTA7Zm9yKFA9MDtQPDMwOysrUClTW1BdPTB9dmFyIFE9MixSPTAsVj1FLFc9Si1LJjMyNzY3O2lmKE4+MiYmSD09VChqLVcpKWZvcih2YXIgWD1NYXRoLm1pbihNLE4pLTEsWT1NYXRoLm1pbigzMjc2NyxqKSxaPU1hdGgubWluKDI1OCxOKTtXPD1ZJiYtLVYmJkohPUs7KXtpZihzW2orUV09PXNbaitRLVddKXtmb3IodmFyICQ9MDskPFomJnNbaiskXT09c1tqKyQtV107KyskKTtpZigkPlEpe2lmKFE9JCxSPVcsJD5YKWJyZWFrO3ZhciB0dD1NYXRoLm1pbihXLCQtMiksbnQ9MDtmb3IoUD0wO1A8dHQ7KytQKXt2YXIgcnQ9ai1XK1AmMzI3NjcsZXQ9cnQtX1tydF0mMzI3Njc7ZXQ+bnQmJihudD1ldCxLPXJ0KX19fVcrPShKPUspLShLPV9bSl0pJjMyNzY3fWlmKFIpe0ZbcSsrXT0yNjg0MzU0NTZ8ZltRXTw8MTh8bFtSXTt2YXIgaXQ9MzEmZltRXSxzdD0zMSZsW1JdO08rPWVbaXRdK2lbc3RdLCsrSVsyNTcraXRdLCsrU1tzdF0sQj1qK1EsKytMfWVsc2UgRltxKytdPXNbal0sKytJW3Nbal1dfX1mb3Ioaj1NYXRoLm1heChqLEIpO2o8djsrK2opRltxKytdPXNbal0sKytJW3Nbal1dO3c9VShzLHAsZyxGLEksUyxPLHEsRyxqLUcsdyksZ3x8KGMucj03Jnd8cFt3Lzh8MF08PDMsdy09NyxjLmg9eCxjLnA9XyxjLmk9aixjLnc9Qil9ZWxzZXtmb3Ioaj1jLnd8fDA7ajx2K2c7ais9NjU1MzUpe3ZhciBhdD1qKzY1NTM1O2F0Pj12JiYocFt3Lzh8MF09ZyxhdD12KSx3PWsocCx3KzEscy5zdWJhcnJheShqLGF0KSl9Yy5pPXZ9cmV0dXJuIGIoZCwwLGgrbSh3KSt1KX0ocyxudWxsPT1hLmxldmVsPzY6YS5sZXZlbCxudWxsPT1hLm1lbT91Lmw/TWF0aC5jZWlsKDEuNSpNYXRoLm1heCg4LE1hdGgubWluKDEzLE1hdGgubG9nKHMubGVuZ3RoKSkpKToyMDoxMithLm1lbSxvLGgsdSl9LGo9ZnVuY3Rpb24odCxuLHIpe2Zvcig7cjsrK24pdFtuXT1yLHI+Pj49OH0scT1mdW5jdGlvbih0LG4pe3ZhciByPW4uZmlsZW5hbWU7aWYodFswXT0zMSx0WzFdPTEzOSx0WzJdPTgsdFs4XT1uLmxldmVsPDI/NDo5PT1uLmxldmVsPzI6MCx0WzldPTMsMCE9bi5tdGltZSYmaih0LDQsTWF0aC5mbG9vcihuZXcgRGF0ZShuLm10aW1lfHxEYXRlLm5vdygpKS8xZTMpKSxyKXt0WzNdPTg7Zm9yKHZhciBlPTA7ZTw9ci5sZW5ndGg7KytlKXRbZSsxMF09ci5jaGFyQ29kZUF0KGUpfX0sQj1mdW5jdGlvbih0KXtyZXR1cm4gMTArKHQuZmlsZW5hbWU/dC5maWxlbmFtZS5sZW5ndGgrMTowKX0sRz1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obixyKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiYocj1uLG49e30pLHRoaXMub25kYXRhPXIsdGhpcy5vPW58fHt9LHRoaXMucz17bDowLGk6MzI3NjgsdzozMjc2OCx6OjMyNzY4fSx0aGlzLmI9bmV3IHQoOTgzMDQpLHRoaXMuby5kaWN0aW9uYXJ5KXt2YXIgZT10aGlzLm8uZGljdGlvbmFyeS5zdWJhcnJheSgtMzI3NjgpO3RoaXMuYi5zZXQoZSwzMjc2OC1lLmxlbmd0aCksdGhpcy5zLmk9MzI3NjgtZS5sZW5ndGh9fXJldHVybiBuLnByb3RvdHlwZS5wPWZ1bmN0aW9uKHQsbil7dGhpcy5vbmRhdGEoTyh0LHRoaXMubywwLDAsdGhpcy5zKSxuKX0sbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihuLHIpe3RoaXMub25kYXRhfHxFKDUpLHRoaXMucy5sJiZFKDQpO3ZhciBlPW4ubGVuZ3RoK3RoaXMucy56O2lmKGU+dGhpcy5iLmxlbmd0aCl7aWYoZT4yKnRoaXMuYi5sZW5ndGgtMzI3Njgpe3ZhciBpPW5ldyB0KC0zMjc2OCZlKTtpLnNldCh0aGlzLmIuc3ViYXJyYXkoMCx0aGlzLnMueikpLHRoaXMuYj1pfXZhciBzPXRoaXMuYi5sZW5ndGgtdGhpcy5zLno7dGhpcy5iLnNldChuLnN1YmFycmF5KDAscyksdGhpcy5zLnopLHRoaXMucy56PXRoaXMuYi5sZW5ndGgsdGhpcy5wKHRoaXMuYiwhMSksdGhpcy5iLnNldCh0aGlzLmIuc3ViYXJyYXkoLTMyNzY4KSksdGhpcy5iLnNldChuLnN1YmFycmF5KHMpLDMyNzY4KSx0aGlzLnMuej1uLmxlbmd0aC1zKzMyNzY4LHRoaXMucy5pPTMyNzY2LHRoaXMucy53PTMyNzY4fWVsc2UgdGhpcy5iLnNldChuLHRoaXMucy56KSx0aGlzLnMueis9bi5sZW5ndGg7dGhpcy5zLmw9MSZyLCh0aGlzLnMuej50aGlzLnMudys4MTkxfHxyKSYmKHRoaXMucCh0aGlzLmIscnx8ITEpLHRoaXMucy53PXRoaXMucy5pLHRoaXMucy5pLT0yKX0sbi5wcm90b3R5cGUuZmx1c2g9ZnVuY3Rpb24oKXt0aGlzLm9uZGF0YXx8RSg1KSx0aGlzLnMubCYmRSg0KSx0aGlzLnAodGhpcy5iLCExKSx0aGlzLnMudz10aGlzLnMuaSx0aGlzLnMuaS09Mn0sbn0oKTt2YXIgSD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxuKXt0aGlzLmM9TCgpLHRoaXMudj0xLEcuY2FsbCh0aGlzLHQsbil9cmV0dXJuIHQucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24odCxuKXt0aGlzLmMucCh0KSxHLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcyx0LG4pfSx0LnByb3RvdHlwZS5wPWZ1bmN0aW9uKHQsbil7dmFyIHI9Tyh0LHRoaXMubyx0aGlzLnYmJih0aGlzLm8uZGljdGlvbmFyeT82OjIpLG4mJjQsdGhpcy5zKTt0aGlzLnYmJihmdW5jdGlvbih0LG4pe3ZhciByPW4ubGV2ZWwsZT0wPT1yPzA6cjw2PzE6OT09cj8zOjI7aWYodFswXT0xMjAsdFsxXT1lPDw2fChuLmRpY3Rpb25hcnkmJjMyKSx0WzFdfD0zMS0odFswXTw8OHx0WzFdKSUzMSxuLmRpY3Rpb25hcnkpe3ZhciBpPUwoKTtpLnAobi5kaWN0aW9uYXJ5KSxqKHQsMixpLmQoKSl9fShyLHRoaXMubyksdGhpcy52PTApLG4mJmoocixyLmxlbmd0aC00LHRoaXMuYy5kKCkpLHRoaXMub25kYXRhKHIsbil9LHQucHJvdG90eXBlLmZsdXNoPWZ1bmN0aW9uKCl7Ry5wcm90b3R5cGUuZmx1c2guY2FsbCh0aGlzKX0sdH0oKSxKPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RW5jb2RlciYmbmV3IFRleHRFbmNvZGVyLEs9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyJiZuZXcgVGV4dERlY29kZXI7dHJ5e0suZGVjb2RlKEYse3N0cmVhbTohMH0pfWNhdGNoKHQpe312YXIgTj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5vbmRhdGE9dH1yZXR1cm4gdC5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0LG4pe3RoaXMub25kYXRhfHxFKDUpLHRoaXMuZCYmRSg0KSx0aGlzLm9uZGF0YShQKHQpLHRoaXMuZD1ufHwhMSl9LHR9KCk7ZnVuY3Rpb24gUChuLHIpe2lmKEopcmV0dXJuIEouZW5jb2RlKG4pO2Zvcih2YXIgZT1uLmxlbmd0aCxpPW5ldyB0KG4ubGVuZ3RoKyhuLmxlbmd0aD4+MSkpLHM9MCxhPWZ1bmN0aW9uKHQpe2lbcysrXT10fSxvPTA7bzxlOysrbyl7aWYocys1PmkubGVuZ3RoKXt2YXIgaD1uZXcgdChzKzgrKGUtbzw8MSkpO2guc2V0KGkpLGk9aH12YXIgZj1uLmNoYXJDb2RlQXQobyk7ZjwxMjh8fHI/YShmKTpmPDIwNDg/KGEoMTkyfGY+PjYpLGEoMTI4fDYzJmYpKTpmPjU1Mjk1JiZmPDU3MzQ0PyhhKDI0MHwoZj02NTUzNisoMTA0NzU1MiZmKXwxMDIzJm4uY2hhckNvZGVBdCgrK28pKT4+MTgpLGEoMTI4fGY+PjEyJjYzKSxhKDEyOHxmPj42JjYzKSxhKDEyOHw2MyZmKSk6KGEoMjI0fGY+PjEyKSxhKDEyOHxmPj42JjYzKSxhKDEyOHw2MyZmKSl9cmV0dXJuIGIoaSwwLHMpfWZ1bmN0aW9uIFEodCl7cmV0dXJuIGZ1bmN0aW9uKHQsbil7bnx8KG49e30pO3ZhciByPVMoKSxlPXQubGVuZ3RoO3IucCh0KTt2YXIgaT1PKHQsbixCKG4pLDgpLHM9aS5sZW5ndGg7cmV0dXJuIHEoaSxuKSxqKGkscy04LHIuZCgpKSxqKGkscy00LGUpLGl9KFAodCkpfWNvbnN0IFI9bmV3IGNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5faW5pdCgpfWNsZWFyKCl7dGhpcy5faW5pdCgpfWFkZEV2ZW50KHQpe2lmKCF0KXRocm93IG5ldyBFcnJvcihcIkFkZGluZyBpbnZhbGlkIGV2ZW50XCIpO2NvbnN0IG49dGhpcy5faGFzRXZlbnRzP1wiLFwiOlwiXCI7dGhpcy5zdHJlYW0ucHVzaChuK3QpLHRoaXMuX2hhc0V2ZW50cz0hMH1maW5pc2goKXt0aGlzLnN0cmVhbS5wdXNoKFwiXVwiLCEwKTtjb25zdCB0PWZ1bmN0aW9uKHQpe2xldCBuPTA7Zm9yKGNvbnN0IHIgb2YgdCluKz1yLmxlbmd0aDtjb25zdCByPW5ldyBVaW50OEFycmF5KG4pO2ZvcihsZXQgbj0wLGU9MCxpPXQubGVuZ3RoO248aTtuKyspe2NvbnN0IGk9dFtuXTtyLnNldChpLGUpLGUrPWkubGVuZ3RofXJldHVybiByfSh0aGlzLl9kZWZsYXRlZERhdGEpO3JldHVybiB0aGlzLl9pbml0KCksdH1faW5pdCgpe3RoaXMuX2hhc0V2ZW50cz0hMSx0aGlzLl9kZWZsYXRlZERhdGE9W10sdGhpcy5kZWZsYXRlPW5ldyBILHRoaXMuZGVmbGF0ZS5vbmRhdGE9KHQsbik9Pnt0aGlzLl9kZWZsYXRlZERhdGEucHVzaCh0KX0sdGhpcy5zdHJlYW09bmV3IE4oKCh0LG4pPT57dGhpcy5kZWZsYXRlLnB1c2godCxuKX0pKSx0aGlzLnN0cmVhbS5wdXNoKFwiW1wiKX19LFY9e2NsZWFyOigpPT57Ui5jbGVhcigpfSxhZGRFdmVudDp0PT5SLmFkZEV2ZW50KHQpLGZpbmlzaDooKT0+Ui5maW5pc2goKSxjb21wcmVzczp0PT5RKHQpfTthZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLChmdW5jdGlvbih0KXtjb25zdCBuPXQuZGF0YS5tZXRob2Qscj10LmRhdGEuaWQsZT10LmRhdGEuYXJnO2lmKG4gaW4gViYmXCJmdW5jdGlvblwiPT10eXBlb2YgVltuXSl0cnl7Y29uc3QgdD1WW25dKGUpO3Bvc3RNZXNzYWdlKHtpZDpyLG1ldGhvZDpuLHN1Y2Nlc3M6ITAscmVzcG9uc2U6dH0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHtpZDpyLG1ldGhvZDpuLHN1Y2Nlc3M6ITEscmVzcG9uc2U6dC5tZXNzYWdlfSksY29uc29sZS5lcnJvcih0KX19KSkscG9zdE1lc3NhZ2Uoe2lkOnZvaWQgMCxtZXRob2Q6XCJpbml0XCIsc3VjY2VzczohMCxyZXNwb25zZTp2b2lkIDB9KTtgO1xuXG5mdW5jdGlvbiBlKCl7Y29uc3QgZT1uZXcgQmxvYihbcl0pO3JldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGUpfVxuXG5jb25zdCBDT05TT0xFX0xFVkVMUyA9IFsnaW5mbycsICd3YXJuJywgJ2Vycm9yJywgJ2xvZyddIDtcbmNvbnN0IFBSRUZJWCA9ICdbUmVwbGF5XSAnO1xuXG5mdW5jdGlvbiBfYWRkQnJlYWRjcnVtYihtZXNzYWdlLCBsZXZlbCA9ICdpbmZvJykge1xuICBhZGRCcmVhZGNydW1iKFxuICAgIHtcbiAgICAgIGNhdGVnb3J5OiAnY29uc29sZScsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGxvZ2dlcjogJ3JlcGxheScsXG4gICAgICB9LFxuICAgICAgbGV2ZWwsXG4gICAgICBtZXNzYWdlOiBgJHtQUkVGSVh9JHttZXNzYWdlfWAsXG4gICAgfSxcbiAgICB7IGxldmVsIH0sXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1ha2VSZXBsYXlMb2dnZXIoKSB7XG4gIGxldCBfY2FwdHVyZSA9IGZhbHNlO1xuICBsZXQgX3RyYWNlID0gZmFsc2U7XG5cbiAgY29uc3QgX2xvZ2dlciA9IHtcbiAgICBleGNlcHRpb246ICgpID0+IHVuZGVmaW5lZCxcbiAgICBpbmZvVGljazogKCkgPT4gdW5kZWZpbmVkLFxuICAgIHNldENvbmZpZzogKG9wdHMpID0+IHtcbiAgICAgIF9jYXB0dXJlID0gISFvcHRzLmNhcHR1cmVFeGNlcHRpb25zO1xuICAgICAgX3RyYWNlID0gISFvcHRzLnRyYWNlSW50ZXJuYWxzO1xuICAgIH0sXG4gIH07XG5cbiAgaWYgKERFQlVHX0JVSUxEKSB7XG4gICAgQ09OU09MRV9MRVZFTFMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIF9sb2dnZXJbbmFtZV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBsb2dnZXIkMVtuYW1lXShQUkVGSVgsIC4uLmFyZ3MpO1xuICAgICAgICBpZiAoX3RyYWNlKSB7XG4gICAgICAgICAgX2FkZEJyZWFkY3J1bWIoYXJncy5qb2luKCcnKSwgc2V2ZXJpdHlMZXZlbEZyb21TdHJpbmcobmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgX2xvZ2dlci5leGNlcHRpb24gPSAoZXJyb3IsIC4uLm1lc3NhZ2UpID0+IHtcbiAgICAgIGlmIChtZXNzYWdlLmxlbmd0aCAmJiBfbG9nZ2VyLmVycm9yKSB7XG4gICAgICAgIF9sb2dnZXIuZXJyb3IoLi4ubWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIGxvZ2dlciQxLmVycm9yKFBSRUZJWCwgZXJyb3IpO1xuXG4gICAgICBpZiAoX2NhcHR1cmUpIHtcbiAgICAgICAgY2FwdHVyZUV4Y2VwdGlvbihlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKF90cmFjZSkge1xuICAgICAgICAvLyBObyBuZWVkIGZvciBhIGJyZWFkY3J1bWIgaWYgYF9jYXB0dXJlYCBpcyBlbmFibGVkIHNpbmNlIGl0IHNob3VsZCBiZVxuICAgICAgICAvLyBjYXB0dXJlZCBhcyBhbiBleGNlcHRpb25cbiAgICAgICAgX2FkZEJyZWFkY3J1bWIoZXJyb3IsICdlcnJvcicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfbG9nZ2VyLmluZm9UaWNrID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGxvZ2dlciQxLmluZm8oUFJFRklYLCAuLi5hcmdzKTtcbiAgICAgIGlmIChfdHJhY2UpIHtcbiAgICAgICAgLy8gV2FpdCBhIHRpY2sgaGVyZSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgZm9yIHNvbWUgaW5pdGlhbCBsb2dzXG4gICAgICAgIC8vIHdoaWNoIG1heSBiZSBhZGRlZCBiZWZvcmUgcmVwbGF5IGlzIGluaXRpYWxpemVkXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gX2FkZEJyZWFkY3J1bWIoYXJnc1swXSksIDApO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQ09OU09MRV9MRVZFTFMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIF9sb2dnZXJbbmFtZV0gPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gX2xvZ2dlciA7XG59XG5cbmNvbnN0IGxvZ2dlciA9IG1ha2VSZXBsYXlMb2dnZXIoKTtcblxuLyoqIFRoaXMgZXJyb3IgaW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGJ1ZmZlciBzaXplIGV4Y2VlZGVkIHRoZSBsaW1pdC4uICovXG5jbGFzcyBFdmVudEJ1ZmZlclNpemVFeGNlZWRlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYEV2ZW50IGJ1ZmZlciBleGNlZWRlZCBtYXhpbXVtIHNpemUgb2YgJHtSRVBMQVlfTUFYX0VWRU5UX0JVRkZFUl9TSVpFfS5gKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgYmFzaWMgZXZlbnQgYnVmZmVyIHRoYXQgZG9lcyBub3QgZG8gYW55IGNvbXByZXNzaW9uLlxuICogVXNlZCBhcyBmYWxsYmFjayBpZiB0aGUgY29tcHJlc3Npb24gd29ya2VyIGNhbm5vdCBiZSBsb2FkZWQgb3IgaXMgZGlzYWJsZWQuXG4gKi9cbmNsYXNzIEV2ZW50QnVmZmVyQXJyYXkgIHtcbiAgLyoqIEFsbCB0aGUgZXZlbnRzIHRoYXQgYXJlIGJ1ZmZlcmVkIHRvIGJlIHNlbnQuICovXG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgdGhpcy5fdG90YWxTaXplID0gMDtcbiAgICB0aGlzLmhhc0NoZWNrb3V0ID0gZmFsc2U7XG4gICAgdGhpcy53YWl0Rm9yQ2hlY2tvdXQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgZ2V0IGhhc0V2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudHMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdzeW5jJztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBhc3luYyBhZGRFdmVudChldmVudCkge1xuICAgIGNvbnN0IGV2ZW50U2l6ZSA9IEpTT04uc3RyaW5naWZ5KGV2ZW50KS5sZW5ndGg7XG4gICAgdGhpcy5fdG90YWxTaXplICs9IGV2ZW50U2l6ZTtcbiAgICBpZiAodGhpcy5fdG90YWxTaXplID4gUkVQTEFZX01BWF9FVkVOVF9CVUZGRVJfU0laRSkge1xuICAgICAgdGhyb3cgbmV3IEV2ZW50QnVmZmVyU2l6ZUV4Y2VlZGVkRXJyb3IoKTtcbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgZmluaXNoKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIC8vIE1ha2UgYSBjb3B5IG9mIHRoZSBldmVudHMgYXJyYXkgcmVmZXJlbmNlIGFuZCBpbW1lZGlhdGVseSBjbGVhciB0aGVcbiAgICAgIC8vIGV2ZW50cyBtZW1iZXIgc28gdGhhdCB3ZSBkbyBub3QgbG9zZSBuZXcgZXZlbnRzIHdoaWxlIHVwbG9hZGluZ1xuICAgICAgLy8gYXR0YWNobWVudC5cbiAgICAgIGNvbnN0IGV2ZW50c1JldCA9IHRoaXMuZXZlbnRzO1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgcmVzb2x2ZShKU09OLnN0cmluZ2lmeShldmVudHNSZXQpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgY2xlYXIoKSB7XG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICB0aGlzLl90b3RhbFNpemUgPSAwO1xuICAgIHRoaXMuaGFzQ2hlY2tvdXQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgZ2V0RWFybGllc3RUaW1lc3RhbXAoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gdGhpcy5ldmVudHMubWFwKGV2ZW50ID0+IGV2ZW50LnRpbWVzdGFtcCkuc29ydCgpWzBdO1xuXG4gICAgaWYgKCF0aW1lc3RhbXApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aW1lc3RhbXBUb01zKHRpbWVzdGFtcCk7XG4gIH1cbn1cblxuLyoqXG4gKiBFdmVudCBidWZmZXIgdGhhdCB1c2VzIGEgd2ViIHdvcmtlciB0byBjb21wcmVzcyBldmVudHMuXG4gKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0aW5nLlxuICovXG5jbGFzcyBXb3JrZXJIYW5kbGVyIHtcblxuICAgY29uc3RydWN0b3Iod29ya2VyKSB7XG4gICAgdGhpcy5fd29ya2VyID0gd29ya2VyO1xuICAgIHRoaXMuX2lkID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgdGhlIHdvcmtlciBpcyByZWFkeSAob3Igbm90KS5cbiAgICogVGhpcyB3aWxsIGVpdGhlciByZXNvbHZlIHdoZW4gdGhlIHdvcmtlciBpcyByZWFkeSwgb3IgcmVqZWN0IGlmIGFuIGVycm9yIG9jY3VycmVkLlxuICAgKi9cbiAgIGVuc3VyZVJlYWR5KCkge1xuICAgIC8vIEVuc3VyZSB3ZSBvbmx5IGNoZWNrIG9uY2VcbiAgICBpZiAodGhpcy5fZW5zdXJlUmVhZHlQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5zdXJlUmVhZHlQcm9taXNlO1xuICAgIH1cblxuICAgIHRoaXMuX2Vuc3VyZVJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3dvcmtlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAnbWVzc2FnZScsXG4gICAgICAgICh7IGRhdGEgfSkgPT4ge1xuICAgICAgICAgIGlmICgoZGF0YSApLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX3dvcmtlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAnZXJyb3InLFxuICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgeyBvbmNlOiB0cnVlIH0sXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuX2Vuc3VyZVJlYWR5UHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSB3b3JrZXIuXG4gICAqL1xuICAgZGVzdHJveSgpIHtcbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIuaW5mbygnRGVzdHJveWluZyBjb21wcmVzc2lvbiB3b3JrZXInKTtcbiAgICB0aGlzLl93b3JrZXIudGVybWluYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUG9zdCBtZXNzYWdlIHRvIHdvcmtlciBhbmQgd2FpdCBmb3IgcmVzcG9uc2UgYmVmb3JlIHJlc29sdmluZyBwcm9taXNlLlxuICAgKi9cbiAgIHBvc3RNZXNzYWdlKG1ldGhvZCwgYXJnKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLl9nZXRBbmRJbmNyZW1lbnRJZCgpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZGF0YSA7XG4gICAgICAgIGlmIChyZXNwb25zZS5tZXRob2QgIT09IG1ldGhvZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIGNhbiBiZSBtdWx0aXBsZSBsaXN0ZW5lcnMgZm9yIGEgc2luZ2xlIG1ldGhvZCwgdGhlIGlkIGVuc3VyZXNcbiAgICAgICAgLy8gdGhhdCB0aGUgcmVzcG9uc2UgbWF0Y2hlcyB0aGUgY2FsbGVyLlxuICAgICAgICBpZiAocmVzcG9uc2UuaWQgIT09IGlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UnbGwgYWx3YXlzIHdhbnQgdG8gcmVtb3ZlIGxpc3RlbmVyIHJlZ2FyZGxlc3Mgb2YgcmVzdWx0IHN0YXR1c1xuICAgICAgICB0aGlzLl93b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAvLyBUT0RPOiBEbyBzb21lIGVycm9yIGhhbmRsaW5nLCBub3Qgc3VyZSB3aGF0XG4gICAgICAgICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmVycm9yKCdFcnJvciBpbiBjb21wcmVzc2lvbiB3b3JrZXI6ICcsIHJlc3BvbnNlLnJlc3BvbnNlKTtcblxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0Vycm9yIGluIGNvbXByZXNzaW9uIHdvcmtlcicpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnJlc3BvbnNlICk7XG4gICAgICB9O1xuXG4gICAgICAvLyBOb3RlOiB3ZSBjYW4ndCB1c2UgYG9uY2VgIG9wdGlvbiBiZWNhdXNlIGl0J3MgcG9zc2libGUgaXQgbmVlZHMgdG9cbiAgICAgIC8vIGxpc3RlbiB0byBtdWx0aXBsZSBtZXNzYWdlc1xuICAgICAgdGhpcy5fd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgICB0aGlzLl93b3JrZXIucG9zdE1lc3NhZ2UoeyBpZCwgbWV0aG9kLCBhcmcgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogR2V0IHRoZSBjdXJyZW50IElEIGFuZCBpbmNyZW1lbnQgaXQgZm9yIHRoZSBuZXh0IGNhbGwuICovXG4gICBfZ2V0QW5kSW5jcmVtZW50SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkKys7XG4gIH1cbn1cblxuLyoqXG4gKiBFdmVudCBidWZmZXIgdGhhdCB1c2VzIGEgd2ViIHdvcmtlciB0byBjb21wcmVzcyBldmVudHMuXG4gKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0aW5nLlxuICovXG5jbGFzcyBFdmVudEJ1ZmZlckNvbXByZXNzaW9uV29ya2VyICB7XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuXG4gICBjb25zdHJ1Y3Rvcih3b3JrZXIpIHtcbiAgICB0aGlzLl93b3JrZXIgPSBuZXcgV29ya2VySGFuZGxlcih3b3JrZXIpO1xuICAgIHRoaXMuX2VhcmxpZXN0VGltZXN0YW1wID0gbnVsbDtcbiAgICB0aGlzLl90b3RhbFNpemUgPSAwO1xuICAgIHRoaXMuaGFzQ2hlY2tvdXQgPSBmYWxzZTtcbiAgICB0aGlzLndhaXRGb3JDaGVja291dCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBnZXQgaGFzRXZlbnRzKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2VhcmxpZXN0VGltZXN0YW1wO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3dvcmtlcic7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIHRoZSB3b3JrZXIgaXMgcmVhZHkgKG9yIG5vdCkuXG4gICAqIFRoaXMgd2lsbCBlaXRoZXIgcmVzb2x2ZSB3aGVuIHRoZSB3b3JrZXIgaXMgcmVhZHksIG9yIHJlamVjdCBpZiBhbiBlcnJvciBvY2N1cnJlZC5cbiAgICovXG4gICBlbnN1cmVSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fd29ya2VyLmVuc3VyZVJlYWR5KCk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgZXZlbnQgYnVmZmVyLlxuICAgKi9cbiAgIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fd29ya2VyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgdG8gdGhlIGV2ZW50IGJ1ZmZlci5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcmVjZWl2ZWQgYW5kIHByb2Nlc3NlZCBieSB3b3JrZXIuXG4gICAqL1xuICAgYWRkRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lc3RhbXBUb01zKGV2ZW50LnRpbWVzdGFtcCk7XG4gICAgaWYgKCF0aGlzLl9lYXJsaWVzdFRpbWVzdGFtcCB8fCB0aW1lc3RhbXAgPCB0aGlzLl9lYXJsaWVzdFRpbWVzdGFtcCkge1xuICAgICAgdGhpcy5fZWFybGllc3RUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGV2ZW50KTtcbiAgICB0aGlzLl90b3RhbFNpemUgKz0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAodGhpcy5fdG90YWxTaXplID4gUkVQTEFZX01BWF9FVkVOVF9CVUZGRVJfU0laRSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFdmVudEJ1ZmZlclNpemVFeGNlZWRlZEVycm9yKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zZW5kRXZlbnRUb1dvcmtlcihkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5pc2ggdGhlIGV2ZW50IGJ1ZmZlciBhbmQgcmV0dXJuIHRoZSBjb21wcmVzc2VkIGRhdGEuXG4gICAqL1xuICAgZmluaXNoKCkge1xuICAgIHJldHVybiB0aGlzLl9maW5pc2hSZXF1ZXN0KCk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGNsZWFyKCkge1xuICAgIHRoaXMuX2VhcmxpZXN0VGltZXN0YW1wID0gbnVsbDtcbiAgICB0aGlzLl90b3RhbFNpemUgPSAwO1xuICAgIHRoaXMuaGFzQ2hlY2tvdXQgPSBmYWxzZTtcblxuICAgIC8vIFdlIGRvIG5vdCB3YWl0IG9uIHRoaXMsIGFzIHdlIGFzc3VtZSB0aGUgb3JkZXIgb2YgbWVzc2FnZXMgaXMgY29uc2lzdGVudCBmb3IgdGhlIHdvcmtlclxuICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZSgnY2xlYXInKS50aGVuKG51bGwsIGUgPT4ge1xuICAgICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmV4Y2VwdGlvbihlLCAnU2VuZGluZyBcImNsZWFyXCIgbWVzc2FnZSB0byB3b3JrZXIgZmFpbGVkJywgZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGdldEVhcmxpZXN0VGltZXN0YW1wKCkge1xuICAgIHJldHVybiB0aGlzLl9lYXJsaWVzdFRpbWVzdGFtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIHRoZSBldmVudCB0byB0aGUgd29ya2VyLlxuICAgKi9cbiAgIF9zZW5kRXZlbnRUb1dvcmtlcihkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZSgnYWRkRXZlbnQnLCBkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5pc2ggdGhlIHJlcXVlc3QgYW5kIHJldHVybiB0aGUgY29tcHJlc3NlZCBkYXRhIGZyb20gdGhlIHdvcmtlci5cbiAgICovXG4gICBhc3luYyBfZmluaXNoUmVxdWVzdCgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZSgnZmluaXNoJyk7XG5cbiAgICB0aGlzLl9lYXJsaWVzdFRpbWVzdGFtcCA9IG51bGw7XG4gICAgdGhpcy5fdG90YWxTaXplID0gMDtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcHJveHkgd2lsbCB0cnkgdG8gdXNlIHRoZSBjb21wcmVzc2lvbiB3b3JrZXIsIGFuZCBmYWxsIGJhY2sgdG8gdXNlIHRoZSBzaW1wbGUgYnVmZmVyIGlmIGFuIGVycm9yIG9jY3VycyB0aGVyZS5cbiAqIFRoaXMgY2FuIGhhcHBlbiBlLmcuIGlmIHRoZSB3b3JrZXIgY2Fubm90IGJlIGxvYWRlZC5cbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9cbmNsYXNzIEV2ZW50QnVmZmVyUHJveHkgIHtcblxuICAgY29uc3RydWN0b3Iod29ya2VyKSB7XG4gICAgdGhpcy5fZmFsbGJhY2sgPSBuZXcgRXZlbnRCdWZmZXJBcnJheSgpO1xuICAgIHRoaXMuX2NvbXByZXNzaW9uID0gbmV3IEV2ZW50QnVmZmVyQ29tcHJlc3Npb25Xb3JrZXIod29ya2VyKTtcbiAgICB0aGlzLl91c2VkID0gdGhpcy5fZmFsbGJhY2s7XG5cbiAgICB0aGlzLl9lbnN1cmVXb3JrZXJJc0xvYWRlZFByb21pc2UgPSB0aGlzLl9lbnN1cmVXb3JrZXJJc0xvYWRlZCgpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBnZXQgd2FpdEZvckNoZWNrb3V0KCkge1xuICAgIHJldHVybiB0aGlzLl91c2VkLndhaXRGb3JDaGVja291dDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZWQudHlwZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgZ2V0IGhhc0V2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlZC5oYXNFdmVudHM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGdldCBoYXNDaGVja291dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlZC5oYXNDaGVja291dDtcbiAgfVxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIHNldCBoYXNDaGVja291dCh2YWx1ZSkge1xuICAgIHRoaXMuX3VzZWQuaGFzQ2hlY2tvdXQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2FkamFjZW50LW92ZXJsb2FkLXNpZ25hdHVyZXNcbiAgIHNldCB3YWl0Rm9yQ2hlY2tvdXQodmFsdWUpIHtcbiAgICB0aGlzLl91c2VkLndhaXRGb3JDaGVja291dCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2ZhbGxiYWNrLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9jb21wcmVzc2lvbi5kZXN0cm95KCk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGNsZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VkLmNsZWFyKCk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGdldEVhcmxpZXN0VGltZXN0YW1wKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VkLmdldEVhcmxpZXN0VGltZXN0YW1wKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGV2ZW50IHRvIHRoZSBldmVudCBidWZmZXIuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IGFkZGVkLlxuICAgKi9cbiAgIGFkZEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZWQuYWRkRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gICBhc3luYyBmaW5pc2goKSB7XG4gICAgLy8gRW5zdXJlIHRoZSB3b3JrZXIgaXMgbG9hZGVkLCBzbyB0aGUgc2VudCBldmVudCBpcyBjb21wcmVzc2VkXG4gICAgYXdhaXQgdGhpcy5lbnN1cmVXb3JrZXJJc0xvYWRlZCgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3VzZWQuZmluaXNoKCk7XG4gIH1cblxuICAvKiogRW5zdXJlIHRoZSB3b3JrZXIgaGFzIGxvYWRlZC4gKi9cbiAgIGVuc3VyZVdvcmtlcklzTG9hZGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbnN1cmVXb3JrZXJJc0xvYWRlZFByb21pc2U7XG4gIH1cblxuICAvKiogQWN0dWFsbHkgY2hlY2sgaWYgdGhlIHdvcmtlciBoYXMgYmVlbiBsb2FkZWQuICovXG4gICBhc3luYyBfZW5zdXJlV29ya2VySXNMb2FkZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX2NvbXByZXNzaW9uLmVuc3VyZVJlYWR5KCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHRoZSB3b3JrZXIgZmFpbHMgdG8gbG9hZCwgd2UgZmFsbCBiYWNrIHRvIHRoZSBzaW1wbGUgYnVmZmVyLlxuICAgICAgLy8gTm90aGluZyBtb3JlIHRvIGRvIGZyb20gb3VyIHNpZGUgaGVyZVxuICAgICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmV4Y2VwdGlvbihlcnJvciwgJ0ZhaWxlZCB0byBsb2FkIHRoZSBjb21wcmVzc2lvbiB3b3JrZXIsIGZhbGxpbmcgYmFjayB0byBzaW1wbGUgYnVmZmVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIG5lZWQgdG8gc3dpdGNoIG92ZXIgdGhlIGFycmF5IGJ1ZmZlciB0byB0aGUgY29tcHJlc3Npb24gd29ya2VyXG4gICAgYXdhaXQgdGhpcy5fc3dpdGNoVG9Db21wcmVzc2lvbldvcmtlcigpO1xuICB9XG5cbiAgLyoqIFN3aXRjaCB0aGUgdXNlZCBidWZmZXIgdG8gdGhlIGNvbXByZXNzaW9uIHdvcmtlci4gKi9cbiAgIGFzeW5jIF9zd2l0Y2hUb0NvbXByZXNzaW9uV29ya2VyKCkge1xuICAgIGNvbnN0IHsgZXZlbnRzLCBoYXNDaGVja291dCwgd2FpdEZvckNoZWNrb3V0IH0gPSB0aGlzLl9mYWxsYmFjaztcblxuICAgIGNvbnN0IGFkZEV2ZW50UHJvbWlzZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgYWRkRXZlbnRQcm9taXNlcy5wdXNoKHRoaXMuX2NvbXByZXNzaW9uLmFkZEV2ZW50KGV2ZW50KSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY29tcHJlc3Npb24uaGFzQ2hlY2tvdXQgPSBoYXNDaGVja291dDtcbiAgICB0aGlzLl9jb21wcmVzc2lvbi53YWl0Rm9yQ2hlY2tvdXQgPSB3YWl0Rm9yQ2hlY2tvdXQ7XG5cbiAgICAvLyBXZSBzd2l0Y2ggb3ZlciB0byB0aGUgbmV3IGJ1ZmZlciBpbW1lZGlhdGVseSAtIGFueSBmdXJ0aGVyIGV2ZW50cyB3aWxsIGJlIGFkZGVkXG4gICAgLy8gYWZ0ZXIgdGhlIHByZXZpb3VzbHkgYnVmZmVyZWQgb25lc1xuICAgIHRoaXMuX3VzZWQgPSB0aGlzLl9jb21wcmVzc2lvbjtcblxuICAgIC8vIFdhaXQgZm9yIG9yaWdpbmFsIGV2ZW50cyB0byBiZSByZS1hZGRlZCBiZWZvcmUgcmVzb2x2aW5nXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGFkZEV2ZW50UHJvbWlzZXMpO1xuXG4gICAgICAvLyBDYW4gbm93IGNsZWFyIGZhbGxiYWNrIGJ1ZmZlciBhcyBpdCdzIG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgICAgIHRoaXMuX2ZhbGxiYWNrLmNsZWFyKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5leGNlcHRpb24oZXJyb3IsICdGYWlsZWQgdG8gYWRkIGV2ZW50cyB3aGVuIHN3aXRjaGluZyBidWZmZXJzLicpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBldmVudCBidWZmZXIgZm9yIHJlcGxheXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50QnVmZmVyKHtcbiAgdXNlQ29tcHJlc3Npb24sXG4gIHdvcmtlclVybDogY3VzdG9tV29ya2VyVXJsLFxufSkge1xuICBpZiAoXG4gICAgdXNlQ29tcHJlc3Npb24gJiZcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgd2luZG93LldvcmtlclxuICApIHtcbiAgICBjb25zdCB3b3JrZXIgPSBfbG9hZFdvcmtlcihjdXN0b21Xb3JrZXJVcmwpO1xuXG4gICAgaWYgKHdvcmtlcikge1xuICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9XG4gIH1cblxuICBERUJVR19CVUlMRCAmJiBsb2dnZXIuaW5mbygnVXNpbmcgc2ltcGxlIGJ1ZmZlcicpO1xuICByZXR1cm4gbmV3IEV2ZW50QnVmZmVyQXJyYXkoKTtcbn1cblxuZnVuY3Rpb24gX2xvYWRXb3JrZXIoY3VzdG9tV29ya2VyVXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgd29ya2VyVXJsID0gY3VzdG9tV29ya2VyVXJsIHx8IF9nZXRXb3JrZXJVcmwoKTtcblxuICAgIGlmICghd29ya2VyVXJsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmluZm8oYFVzaW5nIGNvbXByZXNzaW9uIHdvcmtlciR7Y3VzdG9tV29ya2VyVXJsID8gYCBmcm9tICR7Y3VzdG9tV29ya2VyVXJsfWAgOiAnJ31gKTtcbiAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVybCk7XG4gICAgcmV0dXJuIG5ldyBFdmVudEJ1ZmZlclByb3h5KHdvcmtlcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmV4Y2VwdGlvbihlcnJvciwgJ0ZhaWxlZCB0byBjcmVhdGUgY29tcHJlc3Npb24gd29ya2VyJyk7XG4gICAgLy8gRmFsbCBiYWNrIHRvIHVzZSBzaW1wbGUgZXZlbnQgYnVmZmVyIGFycmF5XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFdvcmtlclVybCgpIHtcbiAgaWYgKHR5cGVvZiBfX1NFTlRSWV9FWENMVURFX1JFUExBWV9XT1JLRVJfXyA9PT0gJ3VuZGVmaW5lZCcgfHwgIV9fU0VOVFJZX0VYQ0xVREVfUkVQTEFZX1dPUktFUl9fKSB7XG4gICAgcmV0dXJuIGUoKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLyoqIElmIHNlc3Npb25TdG9yYWdlIGlzIGF2YWlsYWJsZS4gKi9cbmZ1bmN0aW9uIGhhc1Nlc3Npb25TdG9yYWdlKCkge1xuICB0cnkge1xuICAgIC8vIFRoaXMgY2FuIHRocm93LCBlLmcuIHdoZW4gYmVpbmcgYWNjZXNzZWQgaW4gYSBzYW5kYm94ZWQgaWZyYW1lXG4gICAgcmV0dXJuICdzZXNzaW9uU3RvcmFnZScgaW4gV0lORE9XICYmICEhV0lORE9XLnNlc3Npb25TdG9yYWdlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBzZXNzaW9uIGZyb20gU2Vzc2lvbiBTdG9yYWdlIGFuZCB1bnNldHMgc2Vzc2lvbiBpbiByZXBsYXkgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gY2xlYXJTZXNzaW9uKHJlcGxheSkge1xuICBkZWxldGVTZXNzaW9uKCk7XG4gIHJlcGxheS5zZXNzaW9uID0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIERlbGV0ZXMgYSBzZXNzaW9uIGZyb20gc3RvcmFnZVxuICovXG5mdW5jdGlvbiBkZWxldGVTZXNzaW9uKCkge1xuICBpZiAoIWhhc1Nlc3Npb25TdG9yYWdlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIFdJTkRPVy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFJFUExBWV9TRVNTSU9OX0tFWSk7XG4gIH0gY2F0Y2gge1xuICAgIC8vIElnbm9yZSBwb3RlbnRpYWwgU2VjdXJpdHlFcnJvciBleGNlcHRpb25zXG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIHNhbXBsZSByYXRlLCByZXR1cm5zIHRydWUgaWYgcmVwbGF5IHNob3VsZCBiZSBzYW1wbGVkLlxuICpcbiAqIDEuMCA9IDEwMCUgc2FtcGxpbmdcbiAqIDAuMCA9IDAlIHNhbXBsaW5nXG4gKi9cbmZ1bmN0aW9uIGlzU2FtcGxlZChzYW1wbGVSYXRlKSB7XG4gIGlmIChzYW1wbGVSYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBNYXRoLnJhbmRvbSgpIHJldHVybnMgYSBudW1iZXIgaW4gcmFuZ2Ugb2YgMCB0byAxIChpbmNsdXNpdmUgb2YgMCwgYnV0IG5vdCAxKVxuICByZXR1cm4gTWF0aC5yYW5kb20oKSA8IHNhbXBsZVJhdGU7XG59XG5cbi8qKlxuICogU2F2ZSBhIHNlc3Npb24gdG8gc2Vzc2lvbiBzdG9yYWdlLlxuICovXG5mdW5jdGlvbiBzYXZlU2Vzc2lvbihzZXNzaW9uKSB7XG4gIGlmICghaGFzU2Vzc2lvblN0b3JhZ2UoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgV0lORE9XLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUkVQTEFZX1NFU1NJT05fS0VZLCBKU09OLnN0cmluZ2lmeShzZXNzaW9uKSk7XG4gIH0gY2F0Y2gge1xuICAgIC8vIElnbm9yZSBwb3RlbnRpYWwgU2VjdXJpdHlFcnJvciBleGNlcHRpb25zXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYSBzZXNzaW9uIHdpdGggZGVmYXVsdHMgJiBhcHBsaWVkIHNhbXBsaW5nLlxuICovXG5mdW5jdGlvbiBtYWtlU2Vzc2lvbihzZXNzaW9uKSB7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGNvbnN0IGlkID0gc2Vzc2lvbi5pZCB8fCB1dWlkNCgpO1xuICAvLyBOb3RlIHRoYXQgdGhpcyBtZWFucyB3ZSBjYW5ub3Qgc2V0IGEgc3RhcnRlZC9sYXN0QWN0aXZpdHkgb2YgYDBgLCBidXQgdGhpcyBzaG91bGQgbm90IGJlIHJlbGV2YW50IG91dHNpZGUgb2YgdGVzdHMuXG4gIGNvbnN0IHN0YXJ0ZWQgPSBzZXNzaW9uLnN0YXJ0ZWQgfHwgbm93O1xuICBjb25zdCBsYXN0QWN0aXZpdHkgPSBzZXNzaW9uLmxhc3RBY3Rpdml0eSB8fCBub3c7XG4gIGNvbnN0IHNlZ21lbnRJZCA9IHNlc3Npb24uc2VnbWVudElkIHx8IDA7XG4gIGNvbnN0IHNhbXBsZWQgPSBzZXNzaW9uLnNhbXBsZWQ7XG4gIGNvbnN0IHByZXZpb3VzU2Vzc2lvbklkID0gc2Vzc2lvbi5wcmV2aW91c1Nlc3Npb25JZDtcblxuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIHN0YXJ0ZWQsXG4gICAgbGFzdEFjdGl2aXR5LFxuICAgIHNlZ21lbnRJZCxcbiAgICBzYW1wbGVkLFxuICAgIHByZXZpb3VzU2Vzc2lvbklkLFxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2FtcGxlZCBzdGF0dXMgZm9yIGEgc2Vzc2lvbiBiYXNlZCBvbiBzYW1wbGUgcmF0ZXMgJiBjdXJyZW50IHNhbXBsZWQgc3RhdHVzLlxuICovXG5mdW5jdGlvbiBnZXRTZXNzaW9uU2FtcGxlVHlwZShzZXNzaW9uU2FtcGxlUmF0ZSwgYWxsb3dCdWZmZXJpbmcpIHtcbiAgcmV0dXJuIGlzU2FtcGxlZChzZXNzaW9uU2FtcGxlUmF0ZSkgPyAnc2Vzc2lvbicgOiBhbGxvd0J1ZmZlcmluZyA/ICdidWZmZXInIDogZmFsc2U7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHNlc3Npb24sIHdoaWNoIGluIGl0cyBjdXJyZW50IGltcGxlbWVudGF0aW9uIGlzIGEgU2VudHJ5IGV2ZW50XG4gKiB0aGF0IGFsbCByZXBsYXlzIHdpbGwgYmUgc2F2ZWQgdG8gYXMgYXR0YWNobWVudHMuIEN1cnJlbnRseSwgd2Ugb25seSBleHBlY3RcbiAqIG9uZSBvZiB0aGVzZSBTZW50cnkgZXZlbnRzIHBlciBcInJlcGxheSBzZXNzaW9uXCIuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNlc3Npb24oXG4gIHsgc2Vzc2lvblNhbXBsZVJhdGUsIGFsbG93QnVmZmVyaW5nLCBzdGlja3lTZXNzaW9uID0gZmFsc2UgfSxcbiAgeyBwcmV2aW91c1Nlc3Npb25JZCB9ID0ge30sXG4pIHtcbiAgY29uc3Qgc2FtcGxlZCA9IGdldFNlc3Npb25TYW1wbGVUeXBlKHNlc3Npb25TYW1wbGVSYXRlLCBhbGxvd0J1ZmZlcmluZyk7XG4gIGNvbnN0IHNlc3Npb24gPSBtYWtlU2Vzc2lvbih7XG4gICAgc2FtcGxlZCxcbiAgICBwcmV2aW91c1Nlc3Npb25JZCxcbiAgfSk7XG5cbiAgaWYgKHN0aWNreVNlc3Npb24pIHtcbiAgICBzYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgfVxuXG4gIHJldHVybiBzZXNzaW9uO1xufVxuXG4vKipcbiAqIEZldGNoZXMgYSBzZXNzaW9uIGZyb20gc3RvcmFnZVxuICovXG5mdW5jdGlvbiBmZXRjaFNlc3Npb24oKSB7XG4gIGlmICghaGFzU2Vzc2lvblN0b3JhZ2UoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGNhbiB0aHJvdyBpZiBjb29raWVzIGFyZSBkaXNhYmxlZFxuICAgIGNvbnN0IHNlc3Npb25TdHJpbmdGcm9tU3RvcmFnZSA9IFdJTkRPVy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFJFUExBWV9TRVNTSU9OX0tFWSk7XG5cbiAgICBpZiAoIXNlc3Npb25TdHJpbmdGcm9tU3RvcmFnZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Vzc2lvbk9iaiA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0cmluZ0Zyb21TdG9yYWdlKSA7XG5cbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIuaW5mb1RpY2soJ0xvYWRpbmcgZXhpc3Rpbmcgc2Vzc2lvbicpO1xuXG4gICAgcmV0dXJuIG1ha2VTZXNzaW9uKHNlc3Npb25PYmopO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGluaXRpYWwgdGltZXN0YW1wIGFuZCBhbiBleHBpcnkgZHVyYXRpb24sIGNoZWNrcyB0byBzZWUgaWYgY3VycmVudFxuICogdGltZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBleHBpcmVkLlxuICovXG5mdW5jdGlvbiBpc0V4cGlyZWQoXG4gIGluaXRpYWxUaW1lLFxuICBleHBpcnksXG4gIHRhcmdldFRpbWUgPSArbmV3IERhdGUoKSxcbikge1xuICAvLyBBbHdheXMgZXhwaXJlZCBpZiA8IDBcbiAgaWYgKGluaXRpYWxUaW1lID09PSBudWxsIHx8IGV4cGlyeSA9PT0gdW5kZWZpbmVkIHx8IGV4cGlyeSA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIE5ldmVyIGV4cGlyZXMgaWYgPT0gMFxuICBpZiAoZXhwaXJ5ID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGluaXRpYWxUaW1lICsgZXhwaXJ5IDw9IHRhcmdldFRpbWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiBzZXNzaW9uIGlzIGV4cGlyZWRcbiAqL1xuZnVuY3Rpb24gaXNTZXNzaW9uRXhwaXJlZChcbiAgc2Vzc2lvbixcbiAge1xuICAgIG1heFJlcGxheUR1cmF0aW9uLFxuICAgIHNlc3Npb25JZGxlRXhwaXJlLFxuICAgIHRhcmdldFRpbWUgPSBEYXRlLm5vdygpLFxuICB9LFxuKSB7XG4gIHJldHVybiAoXG4gICAgLy8gRmlyc3QsIGNoZWNrIHRoYXQgbWF4aW11bSBzZXNzaW9uIGxlbmd0aCBoYXMgbm90IGJlZW4gZXhjZWVkZWRcbiAgICBpc0V4cGlyZWQoc2Vzc2lvbi5zdGFydGVkLCBtYXhSZXBsYXlEdXJhdGlvbiwgdGFyZ2V0VGltZSkgfHxcbiAgICAvLyBjaGVjayB0aGF0IHRoZSBpZGxlIHRpbWVvdXQgaGFzIG5vdCBiZWVuIGV4Y2VlZGVkIChpLmUuIHVzZXIgaGFzXG4gICAgLy8gcGVyZm9ybWVkIGFuIGFjdGlvbiB3aXRoaW4gdGhlIGxhc3QgYHNlc3Npb25JZGxlRXhwaXJlYCBtcylcbiAgICBpc0V4cGlyZWQoc2Vzc2lvbi5sYXN0QWN0aXZpdHksIHNlc3Npb25JZGxlRXhwaXJlLCB0YXJnZXRUaW1lKVxuICApO1xufVxuXG4vKiogSWYgdGhlIHNlc3Npb24gc2hvdWxkIGJlIHJlZnJlc2hlZCBvciBub3QuICovXG5mdW5jdGlvbiBzaG91bGRSZWZyZXNoU2Vzc2lvbihcbiAgc2Vzc2lvbixcbiAgeyBzZXNzaW9uSWRsZUV4cGlyZSwgbWF4UmVwbGF5RHVyYXRpb24gfSxcbikge1xuICAvLyBJZiBub3QgZXhwaXJlZCwgYWxsIGdvb2QsIGp1c3Qga2VlcCB0aGUgc2Vzc2lvblxuICBpZiAoIWlzU2Vzc2lvbkV4cGlyZWQoc2Vzc2lvbiwgeyBzZXNzaW9uSWRsZUV4cGlyZSwgbWF4UmVwbGF5RHVyYXRpb24gfSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB3ZSBhcmUgYnVmZmVyaW5nICYgaGF2ZW4ndCBldmVyIGZsdXNoZWQgeWV0LCBhbHdheXMgY29udGludWVcbiAgaWYgKHNlc3Npb24uc2FtcGxlZCA9PT0gJ2J1ZmZlcicgJiYgc2Vzc2lvbi5zZWdtZW50SWQgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXQgb3IgY3JlYXRlIGEgc2Vzc2lvbiwgd2hlbiBpbml0aWFsaXppbmcgdGhlIHJlcGxheS5cbiAqIFJldHVybnMgYSBzZXNzaW9uIHRoYXQgbWF5IGJlIHVuc2FtcGxlZC5cbiAqL1xuZnVuY3Rpb24gbG9hZE9yQ3JlYXRlU2Vzc2lvbihcbiAge1xuICAgIHNlc3Npb25JZGxlRXhwaXJlLFxuICAgIG1heFJlcGxheUR1cmF0aW9uLFxuICAgIHByZXZpb3VzU2Vzc2lvbklkLFxuICB9XG5cbixcbiAgc2Vzc2lvbk9wdGlvbnMsXG4pIHtcbiAgY29uc3QgZXhpc3RpbmdTZXNzaW9uID0gc2Vzc2lvbk9wdGlvbnMuc3RpY2t5U2Vzc2lvbiAmJiBmZXRjaFNlc3Npb24oKTtcblxuICAvLyBObyBzZXNzaW9uIGV4aXN0cyB5ZXQsIGp1c3QgY3JlYXRlIGEgbmV3IG9uZVxuICBpZiAoIWV4aXN0aW5nU2Vzc2lvbikge1xuICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5pbmZvVGljaygnQ3JlYXRpbmcgbmV3IHNlc3Npb24nKTtcbiAgICByZXR1cm4gY3JlYXRlU2Vzc2lvbihzZXNzaW9uT3B0aW9ucywgeyBwcmV2aW91c1Nlc3Npb25JZCB9KTtcbiAgfVxuXG4gIGlmICghc2hvdWxkUmVmcmVzaFNlc3Npb24oZXhpc3RpbmdTZXNzaW9uLCB7IHNlc3Npb25JZGxlRXhwaXJlLCBtYXhSZXBsYXlEdXJhdGlvbiB9KSkge1xuICAgIHJldHVybiBleGlzdGluZ1Nlc3Npb247XG4gIH1cblxuICBERUJVR19CVUlMRCAmJiBsb2dnZXIuaW5mb1RpY2soJ1Nlc3Npb24gaW4gc2Vzc2lvblN0b3JhZ2UgaXMgZXhwaXJlZCwgY3JlYXRpbmcgbmV3IG9uZS4uLicpO1xuICByZXR1cm4gY3JlYXRlU2Vzc2lvbihzZXNzaW9uT3B0aW9ucywgeyBwcmV2aW91c1Nlc3Npb25JZDogZXhpc3RpbmdTZXNzaW9uLmlkIH0pO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSBFdmVudFR5cGUuQ3VzdG9tO1xufVxuXG4vKipcbiAqIEFkZCBhbiBldmVudCB0byB0aGUgZXZlbnQgYnVmZmVyLlxuICogSW4gY29udHJhc3QgdG8gYGFkZEV2ZW50YCwgdGhpcyBkb2VzIG5vdCByZXR1cm4gYSBwcm9taXNlICYgZG9lcyBub3Qgd2FpdCBmb3IgdGhlIGFkZGluZyBvZiB0aGUgZXZlbnQgdG8gc3VjY2VlZC9mYWlsLlxuICogSW5zdGVhZCB0aGlzIHJldHVybnMgYHRydWVgIGlmIHdlIHRyaWVkIHRvIGFkZCB0aGUgZXZlbnQsIGVsc2UgZmFsc2UuXG4gKiBJdCByZXR1cm5zIGBmYWxzZWAgZS5nLiBpZiB3ZSBhcmUgcGF1c2VkLCBkaXNhYmxlZCwgb3Igb3V0IG9mIHRoZSBtYXggcmVwbGF5IGR1cmF0aW9uLlxuICpcbiAqIGBpc0NoZWNrb3V0YCBpcyB0cnVlIGlmIHRoaXMgaXMgZWl0aGVyIHRoZSB2ZXJ5IGZpcnN0IGV2ZW50LCBvciBhbiBldmVudCB0cmlnZ2VyZWQgYnkgYGNoZWNrb3V0RXZlcnlObXNgLlxuICovXG5mdW5jdGlvbiBhZGRFdmVudFN5bmMocmVwbGF5LCBldmVudCwgaXNDaGVja291dCkge1xuICBpZiAoIXNob3VsZEFkZEV2ZW50KHJlcGxheSwgZXZlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgcmVqZWN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgX2FkZEV2ZW50KHJlcGxheSwgZXZlbnQsIGlzQ2hlY2tvdXQpO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEFkZCBhbiBldmVudCB0byB0aGUgZXZlbnQgYnVmZmVyLlxuICogUmVzb2x2ZXMgdG8gYG51bGxgIGlmIG5vIGV2ZW50IHdhcyBhZGRlZCwgZWxzZSB0byBgdm9pZGAuXG4gKlxuICogYGlzQ2hlY2tvdXRgIGlzIHRydWUgaWYgdGhpcyBpcyBlaXRoZXIgdGhlIHZlcnkgZmlyc3QgZXZlbnQsIG9yIGFuIGV2ZW50IHRyaWdnZXJlZCBieSBgY2hlY2tvdXRFdmVyeU5tc2AuXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50KFxuICByZXBsYXksXG4gIGV2ZW50LFxuICBpc0NoZWNrb3V0LFxuKSB7XG4gIGlmICghc2hvdWxkQWRkRXZlbnQocmVwbGF5LCBldmVudCkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICB9XG5cbiAgcmV0dXJuIF9hZGRFdmVudChyZXBsYXksIGV2ZW50LCBpc0NoZWNrb3V0KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gX2FkZEV2ZW50KFxuICByZXBsYXksXG4gIGV2ZW50LFxuICBpc0NoZWNrb3V0LFxuKSB7XG4gIGNvbnN0IHsgZXZlbnRCdWZmZXIgfSA9IHJlcGxheTtcblxuICBpZiAoIWV2ZW50QnVmZmVyIHx8IChldmVudEJ1ZmZlci53YWl0Rm9yQ2hlY2tvdXQgJiYgIWlzQ2hlY2tvdXQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBpc0J1ZmZlck1vZGUgPSByZXBsYXkucmVjb3JkaW5nTW9kZSA9PT0gJ2J1ZmZlcic7XG5cbiAgdHJ5IHtcbiAgICBpZiAoaXNDaGVja291dCAmJiBpc0J1ZmZlck1vZGUpIHtcbiAgICAgIGV2ZW50QnVmZmVyLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ2hlY2tvdXQpIHtcbiAgICAgIGV2ZW50QnVmZmVyLmhhc0NoZWNrb3V0ID0gdHJ1ZTtcbiAgICAgIGV2ZW50QnVmZmVyLndhaXRGb3JDaGVja291dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcGxheU9wdGlvbnMgPSByZXBsYXkuZ2V0T3B0aW9ucygpO1xuXG4gICAgY29uc3QgZXZlbnRBZnRlclBvc3NpYmxlQ2FsbGJhY2sgPSBtYXliZUFwcGx5Q2FsbGJhY2soZXZlbnQsIHJlcGxheU9wdGlvbnMuYmVmb3JlQWRkUmVjb3JkaW5nRXZlbnQpO1xuXG4gICAgaWYgKCFldmVudEFmdGVyUG9zc2libGVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBldmVudEJ1ZmZlci5hZGRFdmVudChldmVudEFmdGVyUG9zc2libGVDYWxsYmFjayk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgaXNFeGNlZWRlZCA9IGVycm9yICYmIGVycm9yIGluc3RhbmNlb2YgRXZlbnRCdWZmZXJTaXplRXhjZWVkZWRFcnJvcjtcbiAgICBjb25zdCByZWFzb24gPSBpc0V4Y2VlZGVkID8gJ2FkZEV2ZW50U2l6ZUV4Y2VlZGVkJyA6ICdhZGRFdmVudCc7XG5cbiAgICBpZiAoaXNFeGNlZWRlZCAmJiBpc0J1ZmZlck1vZGUpIHtcbiAgICAgIC8vIENsZWFyIGJ1ZmZlciBhbmQgd2FpdCBmb3IgbmV4dCBjaGVja291dFxuICAgICAgZXZlbnRCdWZmZXIuY2xlYXIoKTtcbiAgICAgIGV2ZW50QnVmZmVyLndhaXRGb3JDaGVja291dCA9IHRydWU7XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlcGxheS5oYW5kbGVFeGNlcHRpb24oZXJyb3IpO1xuXG4gICAgYXdhaXQgcmVwbGF5LnN0b3AoeyByZWFzb24gfSk7XG5cbiAgICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQoKTtcblxuICAgIGlmIChjbGllbnQpIHtcbiAgICAgIGNsaWVudC5yZWNvcmREcm9wcGVkRXZlbnQoJ2ludGVybmFsX3Nka19lcnJvcicsICdyZXBsYXknKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RzLiAqL1xuZnVuY3Rpb24gc2hvdWxkQWRkRXZlbnQocmVwbGF5LCBldmVudCkge1xuICBpZiAoIXJlcGxheS5ldmVudEJ1ZmZlciB8fCByZXBsYXkuaXNQYXVzZWQoKSB8fCAhcmVwbGF5LmlzRW5hYmxlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgdGltZXN0YW1wSW5NcyA9IHRpbWVzdGFtcFRvTXMoZXZlbnQudGltZXN0YW1wKTtcblxuICAvLyBUaHJvdyBvdXQgZXZlbnRzIHRoYXQgaGFwcGVuIG1vcmUgdGhhbiA1IG1pbnV0ZXMgYWdvLiBUaGlzIGNhbiBoYXBwZW4gaWZcbiAgLy8gcGFnZSBoYXMgYmVlbiBsZWZ0IG9wZW4gYW5kIGlkbGUgZm9yIGEgbG9uZyBwZXJpb2Qgb2YgdGltZSBhbmQgdXNlclxuICAvLyBjb21lcyBiYWNrIHRvIHRyaWdnZXIgYSBuZXcgc2Vzc2lvbi4gVGhlIHBlcmZvcm1hbmNlIGVudHJpZXMgcmVseSBvblxuICAvLyBgcGVyZm9ybWFuY2UudGltZU9yaWdpbmAsIHdoaWNoIGlzIHdoZW4gdGhlIHBhZ2UgZmlyc3Qgb3BlbmVkLlxuICBpZiAodGltZXN0YW1wSW5NcyArIHJlcGxheS50aW1lb3V0cy5zZXNzaW9uSWRsZVBhdXNlIDwgRGF0ZS5ub3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRocm93IG91dCBldmVudHMgdGhhdCBhcmUgKzYwbWluIGZyb20gdGhlIGluaXRpYWwgdGltZXN0YW1wXG4gIGlmICh0aW1lc3RhbXBJbk1zID4gcmVwbGF5LmdldENvbnRleHQoKS5pbml0aWFsVGltZXN0YW1wICsgcmVwbGF5LmdldE9wdGlvbnMoKS5tYXhSZXBsYXlEdXJhdGlvbikge1xuICAgIERFQlVHX0JVSUxEICYmXG4gICAgICBsb2dnZXIuaW5mb1RpY2soYFNraXBwaW5nIGV2ZW50IHdpdGggdGltZXN0YW1wICR7dGltZXN0YW1wSW5Nc30gYmVjYXVzZSBpdCBpcyBhZnRlciBtYXhSZXBsYXlEdXJhdGlvbmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXliZUFwcGx5Q2FsbGJhY2soXG4gIGV2ZW50LFxuICBjYWxsYmFjayxcbikge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgJiYgaXNDdXN0b21FdmVudChldmVudCkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhldmVudCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIERFQlVHX0JVSUxEICYmXG4gICAgICBsb2dnZXIuZXhjZXB0aW9uKGVycm9yLCAnQW4gZXJyb3Igb2NjdXJyZWQgaW4gdGhlIGBiZWZvcmVBZGRSZWNvcmRpbmdFdmVudGAgY2FsbGJhY2ssIHNraXBwaW5nIHRoZSBldmVudC4uLicpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKiogSWYgdGhlIGV2ZW50IGlzIGFuIGVycm9yIGV2ZW50ICovXG5mdW5jdGlvbiBpc0Vycm9yRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICFldmVudC50eXBlO1xufVxuXG4vKiogSWYgdGhlIGV2ZW50IGlzIGEgdHJhbnNhY3Rpb24gZXZlbnQgKi9cbmZ1bmN0aW9uIGlzVHJhbnNhY3Rpb25FdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ3RyYW5zYWN0aW9uJztcbn1cblxuLyoqIElmIHRoZSBldmVudCBpcyBhbiByZXBsYXkgZXZlbnQgKi9cbmZ1bmN0aW9uIGlzUmVwbGF5RXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUgPT09ICdyZXBsYXlfZXZlbnQnO1xufVxuXG4vKiogSWYgdGhlIGV2ZW50IGlzIGEgZmVlZGJhY2sgZXZlbnQgKi9cbmZ1bmN0aW9uIGlzRmVlZGJhY2tFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ2ZlZWRiYWNrJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdGVuZXIgdG8gYmUgYWRkZWQgdG8gYGNsaWVudC5vbignYWZ0ZXJTZW5kRXJyb3JFdmVudCwgbGlzdGVuZXIpYC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlQWZ0ZXJTZW5kRXZlbnQocmVwbGF5KSB7XG4gIHJldHVybiAoZXZlbnQsIHNlbmRSZXNwb25zZSkgPT4ge1xuICAgIGlmICghcmVwbGF5LmlzRW5hYmxlZCgpIHx8ICghaXNFcnJvckV2ZW50KGV2ZW50KSAmJiAhaXNUcmFuc2FjdGlvbkV2ZW50KGV2ZW50KSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0dXNDb2RlID0gc2VuZFJlc3BvbnNlPy5zdGF0dXNDb2RlO1xuXG4gICAgLy8gV2Ugb25seSB3YW50IHRvIGRvIHN0dWZmIG9uIHN1Y2Nlc3NmdWwgZXJyb3Igc2VuZGluZywgb3RoZXJ3aXNlIHlvdSBnZXQgZXJyb3IgcmVwbGF5cyB3aXRob3V0IGVycm9ycyBhdHRhY2hlZFxuICAgIC8vIElmIG5vdCB1c2luZyB0aGUgYmFzZSB0cmFuc3BvcnQsIHdlIGFsbG93IGB1bmRlZmluZWRgIHJlc3BvbnNlIChhcyBhIGN1c3RvbSB0cmFuc3BvcnQgbWF5IG5vdCBpbXBsZW1lbnQgdGhpcyBjb3JyZWN0bHkgeWV0KVxuICAgIC8vIElmIHdlIGRvIHVzZSB0aGUgYmFzZSB0cmFuc3BvcnQsIHdlIHNraXAgaWYgd2UgZW5jb3VudGVyZWQgYW4gbm9uLU9LIHN0YXR1cyBjb2RlXG4gICAgaWYgKCFzdGF0dXNDb2RlIHx8IHN0YXR1c0NvZGUgPCAyMDAgfHwgc3RhdHVzQ29kZSA+PSAzMDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNUcmFuc2FjdGlvbkV2ZW50KGV2ZW50KSkge1xuICAgICAgaGFuZGxlVHJhbnNhY3Rpb25FdmVudChyZXBsYXksIGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvckV2ZW50KHJlcGxheSwgZXZlbnQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVUcmFuc2FjdGlvbkV2ZW50KHJlcGxheSwgZXZlbnQpIHtcbiAgY29uc3QgcmVwbGF5Q29udGV4dCA9IHJlcGxheS5nZXRDb250ZXh0KCk7XG5cbiAgLy8gQ29sbGVjdCB0cmFjZUlkcyBpbiBfY29udGV4dCByZWdhcmRsZXNzIG9mIGByZWNvcmRpbmdNb2RlYFxuICAvLyBJbiBlcnJvciBtb2RlLCBfY29udGV4dCBnZXRzIGNsZWFyZWQgb24gZXZlcnkgY2hlY2tvdXRcbiAgLy8gV2UgbGltaXQgdG8gbWF4LiAxMDAgdHJhbnNhY3Rpb25zIGxpbmtlZFxuICBpZiAoZXZlbnQuY29udGV4dHM/LnRyYWNlPy50cmFjZV9pZCAmJiByZXBsYXlDb250ZXh0LnRyYWNlSWRzLnNpemUgPCAxMDApIHtcbiAgICByZXBsYXlDb250ZXh0LnRyYWNlSWRzLmFkZChldmVudC5jb250ZXh0cy50cmFjZS50cmFjZV9pZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3JFdmVudChyZXBsYXksIGV2ZW50KSB7XG4gIGNvbnN0IHJlcGxheUNvbnRleHQgPSByZXBsYXkuZ2V0Q29udGV4dCgpO1xuXG4gIC8vIEFkZCBlcnJvciB0byBsaXN0IG9mIGVycm9ySWRzIG9mIHJlcGxheS4gVGhpcyBpcyBvayB0byBkbyBldmVuIGlmIG5vdFxuICAvLyBzYW1wbGVkIGJlY2F1c2UgY29udGV4dCB3aWxsIGdldCByZXNldCBhdCBuZXh0IGNoZWNrb3V0LlxuICAvLyBYWFg6IFRoZXJlIGlzIGFsc28gYSByYWNlIGNvbmRpdGlvbiB3aGVyZSBpdCdzIHBvc3NpYmxlIHRvIGNhcHR1cmUgYW5cbiAgLy8gZXJyb3IgdG8gU2VudHJ5IGJlZm9yZSBSZXBsYXkgU0RLIGhhcyBsb2FkZWQsIGJ1dCByZXNwb25zZSByZXR1cm5zIGFmdGVyXG4gIC8vIGl0IHdhcyBsb2FkZWQsIGFuZCB0aGlzIGdldHMgY2FsbGVkLlxuICAvLyBXZSBsaW1pdCB0byBtYXguIDEwMCBlcnJvcnMgbGlua2VkXG4gIGlmIChldmVudC5ldmVudF9pZCAmJiByZXBsYXlDb250ZXh0LmVycm9ySWRzLnNpemUgPCAxMDApIHtcbiAgICByZXBsYXlDb250ZXh0LmVycm9ySWRzLmFkZChldmVudC5ldmVudF9pZCk7XG4gIH1cblxuICAvLyBJZiBlcnJvciBldmVudCBpcyB0YWdnZWQgd2l0aCByZXBsYXkgaWQgaXQgbWVhbnMgaXQgd2FzIHNhbXBsZWQgKHdoZW4gaW4gYnVmZmVyIG1vZGUpXG4gIC8vIE5lZWQgdG8gYmUgdmVyeSBjYXJlZnVsIHRoYXQgdGhpcyBkb2VzIG5vdCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wXG4gIGlmIChyZXBsYXkucmVjb3JkaW5nTW9kZSAhPT0gJ2J1ZmZlcicgfHwgIWV2ZW50LnRhZ3MgfHwgIWV2ZW50LnRhZ3MucmVwbGF5SWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7IGJlZm9yZUVycm9yU2FtcGxpbmcgfSA9IHJlcGxheS5nZXRPcHRpb25zKCk7XG4gIGlmICh0eXBlb2YgYmVmb3JlRXJyb3JTYW1wbGluZyA9PT0gJ2Z1bmN0aW9uJyAmJiAhYmVmb3JlRXJyb3JTYW1wbGluZyhldmVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzZXRUaW1lb3V0JDMoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDYXB0dXJlIGN1cnJlbnQgZXZlbnQgYnVmZmVyIGFzIG5ldyByZXBsYXlcbiAgICAgIGF3YWl0IHJlcGxheS5zZW5kQnVmZmVyZWRSZXBsYXlPckZsdXNoKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXBsYXkuaGFuZGxlRXhjZXB0aW9uKGVycik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdGVuZXIgdG8gYmUgYWRkZWQgdG8gYGNsaWVudC5vbignYWZ0ZXJTZW5kRXJyb3JFdmVudCwgbGlzdGVuZXIpYC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlQmVmb3JlU2VuZEV2ZW50KHJlcGxheSkge1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCFyZXBsYXkuaXNFbmFibGVkKCkgfHwgIWlzRXJyb3JFdmVudChldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYW5kbGVIeWRyYXRpb25FcnJvcihyZXBsYXksIGV2ZW50KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlSHlkcmF0aW9uRXJyb3IocmVwbGF5LCBldmVudCkge1xuICBjb25zdCBleGNlcHRpb25WYWx1ZSA9IGV2ZW50LmV4Y2VwdGlvbj8udmFsdWVzPy5bMF0/LnZhbHVlO1xuICBpZiAodHlwZW9mIGV4Y2VwdGlvblZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChcbiAgICAvLyBPbmx5IG1hdGNoZXMgZXJyb3JzIGluIHByb2R1Y3Rpb24gYnVpbGRzIG9mIHJlYWN0LWRvbVxuICAgIC8vIEV4YW1wbGUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9NDIzXG4gICAgLy8gV2l0aCBuZXdlciBSZWFjdCB2ZXJzaW9ucywgdGhlIG1lc3NhZ2VzIGNoYW5nZWQgdG8gYSBkaWZmZXJlbnQgd2Vic2l0ZSBodHRwczovL3JlYWN0LmRldi9lcnJvcnMvNDE4XG4gICAgZXhjZXB0aW9uVmFsdWUubWF0Y2goXG4gICAgICAvKHJlYWN0anNcXC5vcmdcXC9kb2NzXFwvZXJyb3ItZGVjb2RlclxcLmh0bWxcXD9pbnZhcmlhbnQ9fHJlYWN0XFwuZGV2XFwvZXJyb3JzXFwvKSg0MTh8NDE5fDQyMnw0MjN8NDI1KS8sXG4gICAgKSB8fFxuICAgIC8vIERldmVsb3BtZW50IGJ1aWxkcyBvZiByZWFjdC1kb21cbiAgICAvLyBFcnJvciAxOiBIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIGluaXRpYWwgVUkgZG9lcyBub3QgbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci5cbiAgICAvLyBFcnJvciAyOiBUZXh0IGNvbnRlbnQgZG9lcyBub3QgbWF0Y2ggc2VydmVyLXJlbmRlcmVkIEhUTUwuIFdhcm5pbmc6IFRleHQgY29udGVudCBkaWQgbm90IG1hdGNoLlxuICAgIGV4Y2VwdGlvblZhbHVlLm1hdGNoKC8oZG9lcyBub3QgbWF0Y2ggc2VydmVyLXJlbmRlcmVkIEhUTUx8SHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlKS9pKVxuICApIHtcbiAgICBjb25zdCBicmVhZGNydW1iID0gY3JlYXRlQnJlYWRjcnVtYih7XG4gICAgICBjYXRlZ29yeTogJ3JlcGxheS5oeWRyYXRlLWVycm9yJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdXJsOiBnZXRMb2NhdGlvbkhyZWYoKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgYWRkQnJlYWRjcnVtYkV2ZW50KHJlcGxheSwgYnJlYWRjcnVtYik7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgYnJlYWRjcnVtYnMgdGhhdCBTZW50cnkgY2FwdHVyZXMsIGFuZCBtYWtlIHN1cmUgdG8gY2FwdHVyZSByZWxldmFudCBicmVhZGNydW1icyB0byBSZXBsYXkgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlQnJlYWRjcnVtYnMocmVwbGF5KSB7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuXG4gIGlmICghY2xpZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY2xpZW50Lm9uKCdiZWZvcmVBZGRCcmVhZGNydW1iJywgYnJlYWRjcnVtYiA9PiBiZWZvcmVBZGRCcmVhZGNydW1iKHJlcGxheSwgYnJlYWRjcnVtYikpO1xufVxuXG5mdW5jdGlvbiBiZWZvcmVBZGRCcmVhZGNydW1iKHJlcGxheSwgYnJlYWRjcnVtYikge1xuICBpZiAoIXJlcGxheS5pc0VuYWJsZWQoKSB8fCAhaXNCcmVhZGNydW1iV2l0aENhdGVnb3J5KGJyZWFkY3J1bWIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gbm9ybWFsaXplQnJlYWRjcnVtYihicmVhZGNydW1iKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIGFkZEJyZWFkY3J1bWJFdmVudChyZXBsYXksIHJlc3VsdCk7XG4gIH1cbn1cblxuLyoqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RzLiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQnJlYWRjcnVtYihicmVhZGNydW1iKSB7XG4gIGlmIChcbiAgICAhaXNCcmVhZGNydW1iV2l0aENhdGVnb3J5KGJyZWFkY3J1bWIpIHx8XG4gICAgW1xuICAgICAgLy8gZmV0Y2ggJiB4aHIgYXJlIGhhbmRsZWQgc2VwYXJhdGVseSxpbiBoYW5kbGVOZXR3b3JrQnJlYWRjcnVtYnNcbiAgICAgICdmZXRjaCcsXG4gICAgICAneGhyJyxcbiAgICAgIC8vIFRoZXNlIHR3byBhcmUgYnJlYWRjcnVtYnMgZm9yIGVtaXR0ZWQgc2VudHJ5IGV2ZW50cywgd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGVtXG4gICAgICAnc2VudHJ5LmV2ZW50JyxcbiAgICAgICdzZW50cnkudHJhbnNhY3Rpb24nLFxuICAgIF0uaW5jbHVkZXMoYnJlYWRjcnVtYi5jYXRlZ29yeSkgfHxcbiAgICAvLyBXZSBjYXB0dXJlIFVJIGJyZWFkY3J1bWJzIHNlcGFyYXRlbHlcbiAgICBicmVhZGNydW1iLmNhdGVnb3J5LnN0YXJ0c1dpdGgoJ3VpLicpXG4gICkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGJyZWFkY3J1bWIuY2F0ZWdvcnkgPT09ICdjb25zb2xlJykge1xuICAgIHJldHVybiBub3JtYWxpemVDb25zb2xlQnJlYWRjcnVtYihicmVhZGNydW1iKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVCcmVhZGNydW1iKGJyZWFkY3J1bWIpO1xufVxuXG4vKiogZXhwb3J0ZWQgZm9yIHRlc3RzIG9ubHkgKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnNvbGVCcmVhZGNydW1iKFxuICBicmVhZGNydW1iLFxuKSB7XG4gIGNvbnN0IGFyZ3MgPSBicmVhZGNydW1iLmRhdGE/LmFyZ3VtZW50cztcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncykgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnJlYWRjcnVtYihicmVhZGNydW1iKTtcbiAgfVxuXG4gIGxldCBpc1RydW5jYXRlZCA9IGZhbHNlO1xuXG4gIC8vIEF2b2lkIGdpYW50IGFyZ3MgY2FwdHVyZXNcbiAgY29uc3Qgbm9ybWFsaXplZEFyZ3MgPSBhcmdzLm1hcChhcmcgPT4ge1xuICAgIGlmICghYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChhcmcubGVuZ3RoID4gQ09OU09MRV9BUkdfTUFYX1NJWkUpIHtcbiAgICAgICAgaXNUcnVuY2F0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYCR7YXJnLnNsaWNlKDAsIENPTlNPTEVfQVJHX01BWF9TSVpFKX3igKZgO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBcmcgPSBub3JtYWxpemUoYXJnLCA3KTtcbiAgICAgICAgY29uc3Qgc3RyaW5naWZpZWQgPSBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQXJnKTtcbiAgICAgICAgaWYgKHN0cmluZ2lmaWVkLmxlbmd0aCA+IENPTlNPTEVfQVJHX01BWF9TSVpFKSB7XG4gICAgICAgICAgaXNUcnVuY2F0ZWQgPSB0cnVlO1xuICAgICAgICAgIC8vIFdlIHVzZSB0aGUgcHJldHR5IHByaW50ZWQgSlNPTiBzdHJpbmcgaGVyZSBhcyBhIGJhc2VcbiAgICAgICAgICByZXR1cm4gYCR7SlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZEFyZywgbnVsbCwgMikuc2xpY2UoMCwgQ09OU09MRV9BUkdfTUFYX1NJWkUpfeKApmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBcmc7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGRlZmF1bHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJnO1xuICB9KTtcblxuICByZXR1cm4gY3JlYXRlQnJlYWRjcnVtYih7XG4gICAgLi4uYnJlYWRjcnVtYixcbiAgICBkYXRhOiB7XG4gICAgICAuLi5icmVhZGNydW1iLmRhdGEsXG4gICAgICBhcmd1bWVudHM6IG5vcm1hbGl6ZWRBcmdzLFxuICAgICAgLi4uKGlzVHJ1bmNhdGVkID8geyBfbWV0YTogeyB3YXJuaW5nczogWydDT05TT0xFX0FSR19UUlVOQ0FURUQnXSB9IH0gOiB7fSksXG4gICAgfSxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzQnJlYWRjcnVtYldpdGhDYXRlZ29yeShicmVhZGNydW1iKSB7XG4gIHJldHVybiAhIWJyZWFkY3J1bWIuY2F0ZWdvcnk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHdlIHRoaW5rIHRoZSBnaXZlbiBldmVudCBpcyBhbiBlcnJvciBvcmlnaW5hdGluZyBpbnNpZGUgb2YgcnJ3ZWIuXG4gKi9cbmZ1bmN0aW9uIGlzUnJ3ZWJFcnJvcihldmVudCwgaGludCkge1xuICBpZiAoZXZlbnQudHlwZSB8fCAhZXZlbnQuZXhjZXB0aW9uIHx8ICFldmVudC5leGNlcHRpb24udmFsdWVzIHx8ICFldmVudC5leGNlcHRpb24udmFsdWVzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBtYXkgYmUgc2V0IGJ5IHJyd2ViIHdoZW4gaXQgZmluZHMgZXJyb3JzXG4gIGlmIChoaW50Lm9yaWdpbmFsRXhjZXB0aW9uPy5fX3Jyd2ViX18pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXNldCB0aGUgYHJlcGxheV9pZGAgZmllbGQgb24gdGhlIERTQy5cbiAqL1xuZnVuY3Rpb24gcmVzZXRSZXBsYXlJZE9uRHluYW1pY1NhbXBsaW5nQ29udGV4dCgpIHtcbiAgLy8gUmVzZXQgRFNDIG9uIHRoZSBjdXJyZW50IHNjb3BlLCBpZiB0aGVyZSBpcyBvbmVcbiAgY29uc3QgZHNjID0gZ2V0Q3VycmVudFNjb3BlKCkuZ2V0UHJvcGFnYXRpb25Db250ZXh0KCkuZHNjO1xuICBpZiAoZHNjKSB7XG4gICAgZGVsZXRlIGRzYy5yZXBsYXlfaWQ7XG4gIH1cblxuICAvLyBDbGVhciBpdCBmcm9tIGZyb3plbiBEU0Mgb24gdGhlIGFjdGl2ZSBzcGFuXG4gIGNvbnN0IGFjdGl2ZVNwYW4gPSBnZXRBY3RpdmVTcGFuKCk7XG4gIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgY29uc3QgZHNjID0gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKGFjdGl2ZVNwYW4pO1xuICAgIGRlbGV0ZSAoZHNjICkucmVwbGF5X2lkO1xuICB9XG59XG5cbi8qKlxuICogQWRkIGEgZmVlZGJhY2sgYnJlYWRjcnVtYiBldmVudCB0byByZXBsYXkuXG4gKi9cbmZ1bmN0aW9uIGFkZEZlZWRiYWNrQnJlYWRjcnVtYihyZXBsYXksIGV2ZW50KSB7XG4gIHJlcGxheS50cmlnZ2VyVXNlckFjdGl2aXR5KCk7XG4gIHJlcGxheS5hZGRVcGRhdGUoKCkgPT4ge1xuICAgIGlmICghZXZlbnQudGltZXN0YW1wKSB7XG4gICAgICAvLyBJZ25vcmUgZXZlbnRzIHRoYXQgZG9uJ3QgaGF2ZSB0aW1lc3RhbXBzICh0aGlzIHNob3VsZG4ndCBoYXBwZW4sIG1vcmUgb2YgYSB0eXBpbmcgaXNzdWUpXG4gICAgICAvLyBSZXR1cm4gdHJ1ZSBoZXJlIHNvIHRoYXQgd2UgZG9uJ3QgZmx1c2hcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIHJlamVjdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICByZXBsYXkudGhyb3R0bGVkQWRkRXZlbnQoe1xuICAgICAgdHlwZTogRXZlbnRUeXBlLkN1c3RvbSxcbiAgICAgIHRpbWVzdGFtcDogZXZlbnQudGltZXN0YW1wICogMTAwMCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFnOiAnYnJlYWRjcnVtYicsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICB0aW1lc3RhbXA6IGV2ZW50LnRpbWVzdGFtcCxcbiAgICAgICAgICB0eXBlOiAnZGVmYXVsdCcsXG4gICAgICAgICAgY2F0ZWdvcnk6ICdzZW50cnkuZmVlZGJhY2snLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGZlZWRiYWNrSWQ6IGV2ZW50LmV2ZW50X2lkLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0gKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGV2ZW50IHNob3VsZCBiZSBzYW1wbGVkIChvbmx5IGFwcGxpZXMgaW4gYnVmZmVyIG1vZGUpLlxuICogV2hlbiBhbiBldmVudCBpcyBjYXB0dXJlZCBieSBgaGFuZGxlR2xvYmFsRXZlbnRgLCB3aGVuIGluIGJ1ZmZlciBtb2RlXG4gKiB3ZSBkZXRlcm1pbmUgaWYgd2Ugd2FudCB0byBzYW1wbGUgdGhlIGVycm9yIG9yIG5vdC5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkU2FtcGxlRm9yQnVmZmVyRXZlbnQocmVwbGF5LCBldmVudCkge1xuICBpZiAocmVwbGF5LnJlY29yZGluZ01vZGUgIT09ICdidWZmZXInKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaWdub3JlIHRoaXMgZXJyb3IgYmVjYXVzZSBvdGhlcndpc2Ugd2UgY291bGQgbG9vcCBpbmRlZmluaXRlbHkgd2l0aFxuICAvLyB0cnlpbmcgdG8gY2FwdHVyZSByZXBsYXkgYW5kIGZhaWxpbmdcbiAgaWYgKGV2ZW50Lm1lc3NhZ2UgPT09IFVOQUJMRV9UT19TRU5EX1JFUExBWSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFJlcXVpcmUgdGhlIGV2ZW50IHRvIGJlIGFuIGVycm9yIGV2ZW50ICYgdG8gaGF2ZSBhbiBleGNlcHRpb25cbiAgaWYgKCFldmVudC5leGNlcHRpb24gfHwgZXZlbnQudHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NhbXBsZWQocmVwbGF5LmdldE9wdGlvbnMoKS5lcnJvclNhbXBsZVJhdGUpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0ZW5lciB0byBiZSBhZGRlZCB0byBgYWRkRXZlbnRQcm9jZXNzb3IobGlzdGVuZXIpYC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlR2xvYmFsRXZlbnRMaXN0ZW5lcihyZXBsYXkpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgKGV2ZW50LCBoaW50KSA9PiB7XG4gICAgICAvLyBEbyBub3RoaW5nIGlmIHJlcGxheSBoYXMgYmVlbiBkaXNhYmxlZCBvciBwYXVzZWRcbiAgICAgIGlmICghcmVwbGF5LmlzRW5hYmxlZCgpIHx8IHJlcGxheS5pc1BhdXNlZCgpKSB7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUmVwbGF5RXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIC8vIFJlcGxheXMgaGF2ZSBzZXBhcmF0ZSBzZXQgb2YgYnJlYWRjcnVtYnMsIGRvIG5vdCBpbmNsdWRlIGJyZWFkY3J1bWJzXG4gICAgICAgIC8vIGZyb20gY29yZSBTREtcbiAgICAgICAgZGVsZXRlIGV2ZW50LmJyZWFkY3J1bWJzO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIG9ubHkgd2FudCB0byBoYW5kbGUgZXJyb3JzLCB0cmFuc2FjdGlvbnMsIGFuZCBmZWVkYmFja3MsIG5vdGhpbmcgZWxzZVxuICAgICAgaWYgKCFpc0Vycm9yRXZlbnQoZXZlbnQpICYmICFpc1RyYW5zYWN0aW9uRXZlbnQoZXZlbnQpICYmICFpc0ZlZWRiYWNrRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIHdlIGRvIG5vdCBhZGQgcmVwbGF5X2lkIGlmIHRoZSBzZXNzaW9uIGlzIGV4cGlyZWRcbiAgICAgIGNvbnN0IGlzU2Vzc2lvbkFjdGl2ZSA9IHJlcGxheS5jaGVja0FuZEhhbmRsZUV4cGlyZWRTZXNzaW9uKCk7XG4gICAgICBpZiAoIWlzU2Vzc2lvbkFjdGl2ZSkge1xuICAgICAgICAvLyBwcmV2ZW50IGV4Y2VlZGluZyByZXBsYXkgZHVyYXRpb25zIGJ5IHJlbW92aW5nIHRoZSBleHBpcmVkIHJlcGxheUlkIGZyb20gdGhlIERTQ1xuICAgICAgICByZXNldFJlcGxheUlkT25EeW5hbWljU2FtcGxpbmdDb250ZXh0KCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRmVlZGJhY2tFdmVudChldmVudCkpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgcmVqZWN0XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgcmVwbGF5LmZsdXNoKCk7XG4gICAgICAgIGV2ZW50LmNvbnRleHRzLmZlZWRiYWNrLnJlcGxheV9pZCA9IHJlcGxheS5nZXRTZXNzaW9uSWQoKTtcbiAgICAgICAgLy8gQWRkIGEgcmVwbGF5IGJyZWFkY3J1bWIgZm9yIHRoaXMgcGllY2Ugb2YgZmVlZGJhY2tcbiAgICAgICAgYWRkRmVlZGJhY2tCcmVhZGNydW1iKHJlcGxheSwgZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFVubGVzcyBgY2FwdHVyZUV4Y2VwdGlvbnNgIGlzIGVuYWJsZWQsIHdlIHdhbnQgdG8gaWdub3JlIGVycm9ycyBjb21pbmcgZnJvbSBycndlYlxuICAgICAgLy8gQXMgdGhlcmUgY2FuIGJlIGEgYnVuY2ggb2Ygc3R1ZmYgZ29pbmcgd3JvbmcgaW4gaW50ZXJuYWxzIHRoZXJlLCB0aGF0IHdlIGRvbid0IHdhbnQgdG8gYnViYmxlIHVwIHRvIHVzZXJzXG4gICAgICBpZiAoaXNScndlYkVycm9yKGV2ZW50LCBoaW50KSAmJiAhcmVwbGF5LmdldE9wdGlvbnMoKS5fZXhwZXJpbWVudHMuY2FwdHVyZUV4Y2VwdGlvbnMpIHtcbiAgICAgICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZygnSWdub3JpbmcgZXJyb3IgZnJvbSBycndlYiBpbnRlcm5hbHMnLCBldmVudCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGVuIGluIGJ1ZmZlciBtb2RlLCB3ZSBkZWNpZGUgdG8gc2FtcGxlIGhlcmUuXG4gICAgICAvLyBMYXRlciwgaW4gYGhhbmRsZUFmdGVyU2VuZEV2ZW50YCwgaWYgdGhlIHJlcGxheUlkIGlzIHNldCwgd2Uga25vdyB0aGF0IHdlIHNhbXBsZWRcbiAgICAgIC8vIEFuZCBjb252ZXJ0IHRoZSBidWZmZXIgc2Vzc2lvbiB0byBhIGZ1bGwgc2Vzc2lvblxuICAgICAgY29uc3QgaXNFcnJvckV2ZW50U2FtcGxlZCA9IHNob3VsZFNhbXBsZUZvckJ1ZmZlckV2ZW50KHJlcGxheSwgZXZlbnQpO1xuXG4gICAgICAvLyBUYWcgZXJyb3JzIGlmIGl0IGhhcyBiZWVuIHNhbXBsZWQgaW4gYnVmZmVyIG1vZGUsIG9yIGlmIGl0IGlzIHNlc3Npb24gbW9kZVxuICAgICAgLy8gT25seSB0YWcgdHJhbnNhY3Rpb25zIGlmIGluIHNlc3Npb24gbW9kZVxuICAgICAgY29uc3Qgc2hvdWxkVGFnUmVwbGF5SWQgPSBpc0Vycm9yRXZlbnRTYW1wbGVkIHx8IHJlcGxheS5yZWNvcmRpbmdNb2RlID09PSAnc2Vzc2lvbic7XG5cbiAgICAgIGlmIChzaG91bGRUYWdSZXBsYXlJZCkge1xuICAgICAgICBldmVudC50YWdzID0geyAuLi5ldmVudC50YWdzLCByZXBsYXlJZDogcmVwbGF5LmdldFNlc3Npb25JZCgpIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9LFxuICAgIHsgaWQ6ICdSZXBsYXknIH0sXG4gICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgXCJzcGFuXCIgZm9yIGVhY2ggcGVyZm9ybWFuY2UgZW50cnkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBlcmZvcm1hbmNlU3BhbnMoXG4gIHJlcGxheSxcbiAgZW50cmllcyxcbikge1xuICByZXR1cm4gZW50cmllcy5tYXAoKHsgdHlwZSwgc3RhcnQsIGVuZCwgbmFtZSwgZGF0YSB9KSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXBsYXkudGhyb3R0bGVkQWRkRXZlbnQoe1xuICAgICAgdHlwZTogRXZlbnRUeXBlLkN1c3RvbSxcbiAgICAgIHRpbWVzdGFtcDogc3RhcnQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRhZzogJ3BlcmZvcm1hbmNlU3BhbicsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBvcDogdHlwZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogbmFtZSxcbiAgICAgICAgICBzdGFydFRpbWVzdGFtcDogc3RhcnQsXG4gICAgICAgICAgZW5kVGltZXN0YW1wOiBlbmQsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBJZiByZXNwb25zZSBpcyBhIHN0cmluZywgaXQgbWVhbnMgaXRzIGVpdGhlciBUSFJPVFRMRUQgb3IgU0tJUFBFRFxuICAgIHJldHVybiB0eXBlb2YgcmVzcG9uc2UgPT09ICdzdHJpbmcnID8gUHJvbWlzZS5yZXNvbHZlKG51bGwpIDogcmVzcG9uc2U7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVIaXN0b3J5KGhhbmRsZXJEYXRhKSB7XG4gIGNvbnN0IHsgZnJvbSwgdG8gfSA9IGhhbmRsZXJEYXRhO1xuXG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCkgLyAxMDAwO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ25hdmlnYXRpb24ucHVzaCcsXG4gICAgc3RhcnQ6IG5vdyxcbiAgICBlbmQ6IG5vdyxcbiAgICBuYW1lOiB0byxcbiAgICBkYXRhOiB7XG4gICAgICBwcmV2aW91czogZnJvbSxcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0ZW5lciB0byBiZSBhZGRlZCB0byBgYWRkSGlzdG9yeUluc3RydW1lbnRhdGlvbkhhbmRsZXIobGlzdGVuZXIpYC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlSGlzdG9yeVNwYW5MaXN0ZW5lcihyZXBsYXkpIHtcbiAgcmV0dXJuIChoYW5kbGVyRGF0YSkgPT4ge1xuICAgIGlmICghcmVwbGF5LmlzRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gaGFuZGxlSGlzdG9yeShoYW5kbGVyRGF0YSk7XG5cbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTmVlZCB0byBjb2xsZWN0IHZpc2l0ZWQgVVJMc1xuICAgIHJlcGxheS5nZXRDb250ZXh0KCkudXJscy5wdXNoKHJlc3VsdC5uYW1lKTtcbiAgICByZXBsYXkudHJpZ2dlclVzZXJBY3Rpdml0eSgpO1xuXG4gICAgcmVwbGF5LmFkZFVwZGF0ZSgoKSA9PiB7XG4gICAgICBjcmVhdGVQZXJmb3JtYW5jZVNwYW5zKHJlcGxheSwgW3Jlc3VsdF0pO1xuICAgICAgLy8gUmV0dXJuaW5nIGZhbHNlIHRvIGZsdXNoXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIHJlcXVlc3QgVVJMIHNob3VsZCBiZSBmaWx0ZXJlZCBvdXQuIFRoaXMgaXMgc28gd2VcbiAqIGRvbid0IGxvZyBTZW50cnkgaW5nZXN0IHJlcXVlc3RzLlxuICovXG5mdW5jdGlvbiBzaG91bGRGaWx0ZXJSZXF1ZXN0KHJlcGxheSwgdXJsKSB7XG4gIC8vIElmIHdlIGVuYWJsZWQgdGhlIGB0cmFjZUludGVybmFsc2AgZXhwZXJpbWVudCwgd2Ugd2FudCB0byB0cmFjZSBldmVyeXRoaW5nXG4gIGlmIChERUJVR19CVUlMRCAmJiByZXBsYXkuZ2V0T3B0aW9ucygpLl9leHBlcmltZW50cy50cmFjZUludGVybmFscykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NlbnRyeVJlcXVlc3RVcmwodXJsLCBnZXRDbGllbnQoKSk7XG59XG5cbi8qKiBBZGQgYSBwZXJmb3JtYW5jZSBlbnRyeSBicmVhZGNydW1iICovXG5mdW5jdGlvbiBhZGROZXR3b3JrQnJlYWRjcnVtYihcbiAgcmVwbGF5LFxuICByZXN1bHQsXG4pIHtcbiAgaWYgKCFyZXBsYXkuaXNFbmFibGVkKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNob3VsZEZpbHRlclJlcXVlc3QocmVwbGF5LCByZXN1bHQubmFtZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXBsYXkuYWRkVXBkYXRlKCgpID0+IHtcbiAgICBjcmVhdGVQZXJmb3JtYW5jZVNwYW5zKHJlcGxheSwgW3Jlc3VsdF0pO1xuICAgIC8vIFJldHVybmluZyB0cnVlIHdpbGwgY2F1c2UgYGFkZFVwZGF0ZWAgdG8gbm90IGZsdXNoXG4gICAgLy8gV2UgZG8gbm90IHdhbnQgbmV0d29yayByZXF1ZXN0cyB0byBjYXVzZSBhIGZsdXNoLiBUaGlzIHdpbGwgcHJldmVudFxuICAgIC8vIHJlY3VycmluZy9wb2xsaW5nIHJlcXVlc3RzIGZyb20ga2VlcGluZyB0aGUgcmVwbGF5IHNlc3Npb24gYWxpdmUuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG4vKiogR2V0IHRoZSBzaXplIG9mIGEgYm9keS4gKi9cbmZ1bmN0aW9uIGdldEJvZHlTaXplKGJvZHkpIHtcbiAgaWYgKCFib2R5KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlKGJvZHkpLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgICAgcmV0dXJuIHRleHRFbmNvZGVyLmVuY29kZShib2R5LnRvU3RyaW5nKCkpLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICBjb25zdCBmb3JtRGF0YVN0ciA9IHNlcmlhbGl6ZUZvcm1EYXRhKGJvZHkpO1xuICAgICAgcmV0dXJuIHRleHRFbmNvZGVyLmVuY29kZShmb3JtRGF0YVN0cikubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChib2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgcmV0dXJuIGJvZHkuc2l6ZTtcbiAgICB9XG5cbiAgICBpZiAoYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gYm9keS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIEN1cnJlbnRseSB1bmhhbmRsZWQgdHlwZXM6IEFycmF5QnVmZmVyVmlldywgUmVhZGFibGVTdHJlYW1cbiAgfSBjYXRjaCB7XG4gICAgLy8ganVzdCByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKiogQ29udmVydCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciB0byBudW1iZXIvdW5kZWZpbmVkLiAgKi9cbmZ1bmN0aW9uIHBhcnNlQ29udGVudExlbmd0aEhlYWRlcihoZWFkZXIpIHtcbiAgaWYgKCFoZWFkZXIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KGhlYWRlciwgMTApO1xuICByZXR1cm4gaXNOYU4oc2l6ZSkgPyB1bmRlZmluZWQgOiBzaXplO1xufVxuXG4vKiogTWVyZ2UgYSB3YXJuaW5nIGludG8gYW4gZXhpc3RpbmcgbmV0d29yayByZXF1ZXN0L3Jlc3BvbnNlLiAqL1xuZnVuY3Rpb24gbWVyZ2VXYXJuaW5nKFxuICBpbmZvLFxuICB3YXJuaW5nLFxuKSB7XG4gIGlmICghaW5mbykge1xuICAgIHJldHVybiB7XG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIHNpemU6IHVuZGVmaW5lZCxcbiAgICAgIF9tZXRhOiB7XG4gICAgICAgIHdhcm5pbmdzOiBbd2FybmluZ10sXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBjb25zdCBuZXdNZXRhID0geyAuLi5pbmZvLl9tZXRhIH07XG4gIGNvbnN0IGV4aXN0aW5nV2FybmluZ3MgPSBuZXdNZXRhLndhcm5pbmdzIHx8IFtdO1xuICBuZXdNZXRhLndhcm5pbmdzID0gWy4uLmV4aXN0aW5nV2FybmluZ3MsIHdhcm5pbmddO1xuXG4gIGluZm8uX21ldGEgPSBuZXdNZXRhO1xuICByZXR1cm4gaW5mbztcbn1cblxuLyoqIENvbnZlcnQgUmVwbGF5TmV0d29ya1JlcXVlc3REYXRhIHRvIGEgUGVyZm9ybWFuY2VFbnRyeS4gKi9cbmZ1bmN0aW9uIG1ha2VOZXR3b3JrUmVwbGF5QnJlYWRjcnVtYihcbiAgdHlwZSxcbiAgZGF0YSxcbikge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHsgc3RhcnRUaW1lc3RhbXAsIGVuZFRpbWVzdGFtcCwgdXJsLCBtZXRob2QsIHN0YXR1c0NvZGUsIHJlcXVlc3QsIHJlc3BvbnNlIH0gPSBkYXRhO1xuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB0eXBlLFxuICAgIHN0YXJ0OiBzdGFydFRpbWVzdGFtcCAvIDEwMDAsXG4gICAgZW5kOiBlbmRUaW1lc3RhbXAgLyAxMDAwLFxuICAgIG5hbWU6IHVybCxcbiAgICBkYXRhOiB7XG4gICAgICBtZXRob2QsXG4gICAgICBzdGF0dXNDb2RlLFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlLFxuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIEJ1aWxkIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlIHBhcnQgb2YgYSByZXBsYXkgbmV0d29yayBicmVhZGNydW1iIHRoYXQgd2FzIHNraXBwZWQuICovXG5mdW5jdGlvbiBidWlsZFNraXBwZWROZXR3b3JrUmVxdWVzdE9yUmVzcG9uc2UoYm9keVNpemUpIHtcbiAgcmV0dXJuIHtcbiAgICBoZWFkZXJzOiB7fSxcbiAgICBzaXplOiBib2R5U2l6ZSxcbiAgICBfbWV0YToge1xuICAgICAgd2FybmluZ3M6IFsnVVJMX1NLSVBQRUQnXSxcbiAgICB9LFxuICB9O1xufVxuXG4vKiogQnVpbGQgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2UgcGFydCBvZiBhIHJlcGxheSBuZXR3b3JrIGJyZWFkY3J1bWIuICovXG5mdW5jdGlvbiBidWlsZE5ldHdvcmtSZXF1ZXN0T3JSZXNwb25zZShcbiAgaGVhZGVycyxcbiAgYm9keVNpemUsXG4gIGJvZHksXG4pIHtcbiAgaWYgKCFib2R5U2l6ZSAmJiBPYmplY3Qua2V5cyhoZWFkZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCFib2R5U2l6ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBoZWFkZXJzLFxuICAgIH07XG4gIH1cblxuICBpZiAoIWJvZHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGVhZGVycyxcbiAgICAgIHNpemU6IGJvZHlTaXplLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBpbmZvID0ge1xuICAgIGhlYWRlcnMsXG4gICAgc2l6ZTogYm9keVNpemUsXG4gIH07XG5cbiAgY29uc3QgeyBib2R5OiBub3JtYWxpemVkQm9keSwgd2FybmluZ3MgfSA9IG5vcm1hbGl6ZU5ldHdvcmtCb2R5KGJvZHkpO1xuICBpbmZvLmJvZHkgPSBub3JtYWxpemVkQm9keTtcbiAgaWYgKHdhcm5pbmdzPy5sZW5ndGgpIHtcbiAgICBpbmZvLl9tZXRhID0ge1xuICAgICAgd2FybmluZ3MsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuXG4vKiogRmlsdGVyIGEgc2V0IG9mIGhlYWRlcnMgKi9cbmZ1bmN0aW9uIGdldEFsbG93ZWRIZWFkZXJzKGhlYWRlcnMsIGFsbG93ZWRIZWFkZXJzKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhoZWFkZXJzKS5yZWR1Y2UoKGZpbHRlcmVkSGVhZGVycywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIEF2b2lkIHB1dHRpbmcgZW1wdHkgc3RyaW5ncyBpbnRvIHRoZSBoZWFkZXJzXG4gICAgaWYgKGFsbG93ZWRIZWFkZXJzLmluY2x1ZGVzKG5vcm1hbGl6ZWRLZXkpICYmIGhlYWRlcnNba2V5XSkge1xuICAgICAgZmlsdGVyZWRIZWFkZXJzW25vcm1hbGl6ZWRLZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZEhlYWRlcnM7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmV0d29ya0JvZHkoYm9keSlcblxuIHtcbiAgaWYgKCFib2R5IHx8IHR5cGVvZiBib2R5ICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICBib2R5LFxuICAgIH07XG4gIH1cblxuICBjb25zdCBleGNlZWRzU2l6ZUxpbWl0ID0gYm9keS5sZW5ndGggPiBORVRXT1JLX0JPRFlfTUFYX1NJWkU7XG4gIGNvbnN0IGlzUHJvYmFibHlKc29uID0gX3N0cklzUHJvYmFibHlKc29uKGJvZHkpO1xuXG4gIGlmIChleGNlZWRzU2l6ZUxpbWl0KSB7XG4gICAgY29uc3QgdHJ1bmNhdGVkQm9keSA9IGJvZHkuc2xpY2UoMCwgTkVUV09SS19CT0RZX01BWF9TSVpFKTtcblxuICAgIGlmIChpc1Byb2JhYmx5SnNvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYm9keTogdHJ1bmNhdGVkQm9keSxcbiAgICAgICAgd2FybmluZ3M6IFsnTUFZQkVfSlNPTl9UUlVOQ0FURUQnXSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJvZHk6IGAke3RydW5jYXRlZEJvZHl94oCmYCxcbiAgICAgIHdhcm5pbmdzOiBbJ1RFWFRfVFJVTkNBVEVEJ10sXG4gICAgfTtcbiAgfVxuXG4gIGlmIChpc1Byb2JhYmx5SnNvbikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBqc29uQm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBib2R5OiBqc29uQm9keSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBmYWxsIGJhY2sgdG8ganVzdCBzZW5kIHRoZSBib2R5IGFzIHN0cmluZ1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYm9keSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3N0cklzUHJvYmFibHlKc29uKHN0cikge1xuICBjb25zdCBmaXJzdCA9IHN0clswXTtcbiAgY29uc3QgbGFzdCA9IHN0cltzdHIubGVuZ3RoIC0gMV07XG5cbiAgLy8gU2ltcGxlIGNoZWNrOiBJZiB0aGlzIGRvZXMgbm90IHN0YXJ0ICYgZW5kIHdpdGgge30gb3IgW10sIGl0J3Mgbm90IEpTT05cbiAgcmV0dXJuIChmaXJzdCA9PT0gJ1snICYmIGxhc3QgPT09ICddJykgfHwgKGZpcnN0ID09PSAneycgJiYgbGFzdCA9PT0gJ30nKTtcbn1cblxuLyoqIE1hdGNoIGFuIFVSTCBhZ2FpbnN0IGEgbGlzdCBvZiBzdHJpbmdzL1JlZ2V4LiAqL1xuZnVuY3Rpb24gdXJsTWF0Y2hlcyh1cmwsIHVybHMpIHtcbiAgY29uc3QgZnVsbFVybCA9IGdldEZ1bGxVcmwodXJsKTtcblxuICByZXR1cm4gc3RyaW5nTWF0Y2hlc1NvbWVQYXR0ZXJuKGZ1bGxVcmwsIHVybHMpO1xufVxuXG4vKiogZXhwb3J0ZWQgZm9yIHRlc3RzICovXG5mdW5jdGlvbiBnZXRGdWxsVXJsKHVybCwgYmFzZVVSSSA9IFdJTkRPVy5kb2N1bWVudC5iYXNlVVJJKSB7XG4gIC8vIFNob3J0IGNpcmN1aXQgZm9yIGNvbW1vbiBjYXNlczpcbiAgaWYgKHVybC5zdGFydHNXaXRoKCdodHRwOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoV0lORE9XLmxvY2F0aW9uLm9yaWdpbikpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGNvbnN0IGZpeGVkVXJsID0gbmV3IFVSTCh1cmwsIGJhc2VVUkkpO1xuXG4gIC8vIElmIHRoZXNlIGRvIG5vdCBtYXRjaCwgd2UgYXJlIG5vdCBkZWFsaW5nIHdpdGggYSByZWxhdGl2ZSBVUkwsIHNvIGp1c3QgcmV0dXJuIGl0XG4gIGlmIChmaXhlZFVybC5vcmlnaW4gIT09IG5ldyBVUkwoYmFzZVVSSSkub3JpZ2luKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIGNvbnN0IGZ1bGxVcmwgPSBmaXhlZFVybC5ocmVmO1xuXG4gIC8vIFJlbW92ZSB0cmFpbGluZyBzbGFzaGVzLCBpZiB0aGV5IGRvbid0IG1hdGNoIHRoZSBvcmlnaW5hbCBVUkxcbiAgaWYgKCF1cmwuZW5kc1dpdGgoJy8nKSAmJiBmdWxsVXJsLmVuZHNXaXRoKCcvJykpIHtcbiAgICByZXR1cm4gZnVsbFVybC5zbGljZSgwLCAtMSk7XG4gIH1cblxuICByZXR1cm4gZnVsbFVybDtcbn1cblxuLyoqXG4gKiBDYXB0dXJlIGEgZmV0Y2ggYnJlYWRjcnVtYiB0byBhIHJlcGxheS5cbiAqIFRoaXMgYWRkcyBhZGRpdGlvbmFsIGRhdGEgKHdoZXJlIGFwcHJvcHJpYXRlKS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2FwdHVyZUZldGNoQnJlYWRjcnVtYlRvUmVwbGF5KFxuICBicmVhZGNydW1iLFxuICBoaW50LFxuICBvcHRpb25zXG5cbixcbikge1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBfcHJlcGFyZUZldGNoRGF0YShicmVhZGNydW1iLCBoaW50LCBvcHRpb25zKTtcblxuICAgIC8vIENyZWF0ZSBhIHJlcGxheSBwZXJmb3JtYW5jZSBlbnRyeSBmcm9tIHRoaXMgYnJlYWRjcnVtYlxuICAgIGNvbnN0IHJlc3VsdCA9IG1ha2VOZXR3b3JrUmVwbGF5QnJlYWRjcnVtYigncmVzb3VyY2UuZmV0Y2gnLCBkYXRhKTtcbiAgICBhZGROZXR3b3JrQnJlYWRjcnVtYihvcHRpb25zLnJlcGxheSwgcmVzdWx0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIuZXhjZXB0aW9uKGVycm9yLCAnRmFpbGVkIHRvIGNhcHR1cmUgZmV0Y2ggYnJlYWRjcnVtYicpO1xuICB9XG59XG5cbi8qKlxuICogRW5yaWNoIGEgYnJlYWRjcnVtYiB3aXRoIGFkZGl0aW9uYWwgZGF0YS5cbiAqIFRoaXMgaGFzIHRvIGJlIHN5bmMgJiBtdXRhdGUgdGhlIGdpdmVuIGJyZWFkY3J1bWIsXG4gKiBhcyB0aGUgYnJlYWRjcnVtYiBpcyBhZnRlcndhcmRzIGNvbnN1bWVkIGJ5IG90aGVyIGhhbmRsZXJzLlxuICovXG5mdW5jdGlvbiBlbnJpY2hGZXRjaEJyZWFkY3J1bWIoXG4gIGJyZWFkY3J1bWIsXG4gIGhpbnQsXG4pIHtcbiAgY29uc3QgeyBpbnB1dCwgcmVzcG9uc2UgfSA9IGhpbnQ7XG5cbiAgY29uc3QgYm9keSA9IGlucHV0ID8gZ2V0RmV0Y2hSZXF1ZXN0QXJnQm9keShpbnB1dCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHJlcVNpemUgPSBnZXRCb2R5U2l6ZShib2R5KTtcblxuICBjb25zdCByZXNTaXplID0gcmVzcG9uc2UgPyBwYXJzZUNvbnRlbnRMZW5ndGhIZWFkZXIocmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJykpIDogdW5kZWZpbmVkO1xuXG4gIGlmIChyZXFTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBicmVhZGNydW1iLmRhdGEucmVxdWVzdF9ib2R5X3NpemUgPSByZXFTaXplO1xuICB9XG4gIGlmIChyZXNTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBicmVhZGNydW1iLmRhdGEucmVzcG9uc2VfYm9keV9zaXplID0gcmVzU2l6ZTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfcHJlcGFyZUZldGNoRGF0YShcbiAgYnJlYWRjcnVtYixcbiAgaGludCxcbiAgb3B0aW9ucyxcbikge1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICBjb25zdCB7IHN0YXJ0VGltZXN0YW1wID0gbm93LCBlbmRUaW1lc3RhbXAgPSBub3cgfSA9IGhpbnQ7XG5cbiAgY29uc3Qge1xuICAgIHVybCxcbiAgICBtZXRob2QsXG4gICAgc3RhdHVzX2NvZGU6IHN0YXR1c0NvZGUgPSAwLFxuICAgIHJlcXVlc3RfYm9keV9zaXplOiByZXF1ZXN0Qm9keVNpemUsXG4gICAgcmVzcG9uc2VfYm9keV9zaXplOiByZXNwb25zZUJvZHlTaXplLFxuICB9ID0gYnJlYWRjcnVtYi5kYXRhO1xuXG4gIGNvbnN0IGNhcHR1cmVEZXRhaWxzID1cbiAgICB1cmxNYXRjaGVzKHVybCwgb3B0aW9ucy5uZXR3b3JrRGV0YWlsQWxsb3dVcmxzKSAmJiAhdXJsTWF0Y2hlcyh1cmwsIG9wdGlvbnMubmV0d29ya0RldGFpbERlbnlVcmxzKTtcblxuICBjb25zdCByZXF1ZXN0ID0gY2FwdHVyZURldGFpbHNcbiAgICA/IF9nZXRSZXF1ZXN0SW5mbyhvcHRpb25zLCBoaW50LmlucHV0LCByZXF1ZXN0Qm9keVNpemUpXG4gICAgOiBidWlsZFNraXBwZWROZXR3b3JrUmVxdWVzdE9yUmVzcG9uc2UocmVxdWVzdEJvZHlTaXplKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfZ2V0UmVzcG9uc2VJbmZvKGNhcHR1cmVEZXRhaWxzLCBvcHRpb25zLCBoaW50LnJlc3BvbnNlLCByZXNwb25zZUJvZHlTaXplKTtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0VGltZXN0YW1wLFxuICAgIGVuZFRpbWVzdGFtcCxcbiAgICB1cmwsXG4gICAgbWV0aG9kLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgcmVxdWVzdCxcbiAgICByZXNwb25zZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2dldFJlcXVlc3RJbmZvKFxuICB7IG5ldHdvcmtDYXB0dXJlQm9kaWVzLCBuZXR3b3JrUmVxdWVzdEhlYWRlcnMgfSxcbiAgaW5wdXQsXG4gIHJlcXVlc3RCb2R5U2l6ZSxcbikge1xuICBjb25zdCBoZWFkZXJzID0gaW5wdXQgPyBnZXRSZXF1ZXN0SGVhZGVycyhpbnB1dCwgbmV0d29ya1JlcXVlc3RIZWFkZXJzKSA6IHt9O1xuXG4gIGlmICghbmV0d29ya0NhcHR1cmVCb2RpZXMpIHtcbiAgICByZXR1cm4gYnVpbGROZXR3b3JrUmVxdWVzdE9yUmVzcG9uc2UoaGVhZGVycywgcmVxdWVzdEJvZHlTaXplLCB1bmRlZmluZWQpO1xuICB9XG5cbiAgLy8gV2Ugb25seSB3YW50IHRvIHRyYW5zbWl0IHN0cmluZyBvciBzdHJpbmctbGlrZSBib2RpZXNcbiAgY29uc3QgcmVxdWVzdEJvZHkgPSBnZXRGZXRjaFJlcXVlc3RBcmdCb2R5KGlucHV0KTtcbiAgY29uc3QgW2JvZHlTdHIsIHdhcm5pbmddID0gZ2V0Qm9keVN0cmluZyhyZXF1ZXN0Qm9keSwgbG9nZ2VyKTtcbiAgY29uc3QgZGF0YSA9IGJ1aWxkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKGhlYWRlcnMsIHJlcXVlc3RCb2R5U2l6ZSwgYm9keVN0cik7XG5cbiAgaWYgKHdhcm5pbmcpIHtcbiAgICByZXR1cm4gbWVyZ2VXYXJuaW5nKGRhdGEsIHdhcm5pbmcpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0cy4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9nZXRSZXNwb25zZUluZm8oXG4gIGNhcHR1cmVEZXRhaWxzLFxuICB7XG4gICAgbmV0d29ya0NhcHR1cmVCb2RpZXMsXG4gICAgbmV0d29ya1Jlc3BvbnNlSGVhZGVycyxcbiAgfSxcbiAgcmVzcG9uc2UsXG4gIHJlc3BvbnNlQm9keVNpemUsXG4pIHtcbiAgaWYgKCFjYXB0dXJlRGV0YWlscyAmJiByZXNwb25zZUJvZHlTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYnVpbGRTa2lwcGVkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKHJlc3BvbnNlQm9keVNpemUpO1xuICB9XG5cbiAgY29uc3QgaGVhZGVycyA9IHJlc3BvbnNlID8gZ2V0QWxsSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzLCBuZXR3b3JrUmVzcG9uc2VIZWFkZXJzKSA6IHt9O1xuXG4gIGlmICghcmVzcG9uc2UgfHwgKCFuZXR3b3JrQ2FwdHVyZUJvZGllcyAmJiByZXNwb25zZUJvZHlTaXplICE9PSB1bmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIGJ1aWxkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKGhlYWRlcnMsIHJlc3BvbnNlQm9keVNpemUsIHVuZGVmaW5lZCk7XG4gIH1cblxuICBjb25zdCBbYm9keVRleHQsIHdhcm5pbmddID0gYXdhaXQgX3BhcnNlRmV0Y2hSZXNwb25zZUJvZHkocmVzcG9uc2UpO1xuICBjb25zdCByZXN1bHQgPSBnZXRSZXNwb25zZURhdGEoYm9keVRleHQsIHtcbiAgICBuZXR3b3JrQ2FwdHVyZUJvZGllcyxcblxuICAgIHJlc3BvbnNlQm9keVNpemUsXG4gICAgY2FwdHVyZURldGFpbHMsXG4gICAgaGVhZGVycyxcbiAgfSk7XG5cbiAgaWYgKHdhcm5pbmcpIHtcbiAgICByZXR1cm4gbWVyZ2VXYXJuaW5nKHJlc3VsdCwgd2FybmluZyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZURhdGEoXG4gIGJvZHlUZXh0LFxuICB7XG4gICAgbmV0d29ya0NhcHR1cmVCb2RpZXMsXG4gICAgcmVzcG9uc2VCb2R5U2l6ZSxcbiAgICBjYXB0dXJlRGV0YWlscyxcbiAgICBoZWFkZXJzLFxuICB9XG5cbixcbikge1xuICB0cnkge1xuICAgIGNvbnN0IHNpemUgPSBib2R5VGV4dD8ubGVuZ3RoICYmIHJlc3BvbnNlQm9keVNpemUgPT09IHVuZGVmaW5lZCA/IGdldEJvZHlTaXplKGJvZHlUZXh0KSA6IHJlc3BvbnNlQm9keVNpemU7XG5cbiAgICBpZiAoIWNhcHR1cmVEZXRhaWxzKSB7XG4gICAgICByZXR1cm4gYnVpbGRTa2lwcGVkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKHNpemUpO1xuICAgIH1cblxuICAgIGlmIChuZXR3b3JrQ2FwdHVyZUJvZGllcykge1xuICAgICAgcmV0dXJuIGJ1aWxkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKGhlYWRlcnMsIHNpemUsIGJvZHlUZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVpbGROZXR3b3JrUmVxdWVzdE9yUmVzcG9uc2UoaGVhZGVycywgc2l6ZSwgdW5kZWZpbmVkKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIuZXhjZXB0aW9uKGVycm9yLCAnRmFpbGVkIHRvIHNlcmlhbGl6ZSByZXNwb25zZSBib2R5Jyk7XG4gICAgLy8gZmFsbGJhY2tcbiAgICByZXR1cm4gYnVpbGROZXR3b3JrUmVxdWVzdE9yUmVzcG9uc2UoaGVhZGVycywgcmVzcG9uc2VCb2R5U2l6ZSwgdW5kZWZpbmVkKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfcGFyc2VGZXRjaFJlc3BvbnNlQm9keShyZXNwb25zZSkge1xuICBjb25zdCByZXMgPSBfdHJ5Q2xvbmVSZXNwb25zZShyZXNwb25zZSk7XG5cbiAgaWYgKCFyZXMpIHtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgJ0JPRFlfUEFSU0VfRVJST1InXTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IF90cnlHZXRSZXNwb25zZVRleHQocmVzKTtcbiAgICByZXR1cm4gW3RleHRdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5kZXhPZignVGltZW91dCcpID4gLTEpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci53YXJuKCdQYXJzaW5nIHRleHQgYm9keSBmcm9tIHJlc3BvbnNlIHRpbWVkIG91dCcpO1xuICAgICAgcmV0dXJuIFt1bmRlZmluZWQsICdCT0RZX1BBUlNFX1RJTUVPVVQnXTtcbiAgICB9XG5cbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIuZXhjZXB0aW9uKGVycm9yLCAnRmFpbGVkIHRvIGdldCB0ZXh0IGJvZHkgZnJvbSByZXNwb25zZScpO1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCAnQk9EWV9QQVJTRV9FUlJPUiddO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFsbEhlYWRlcnMoaGVhZGVycywgYWxsb3dlZEhlYWRlcnMpIHtcbiAgY29uc3QgYWxsSGVhZGVycyA9IHt9O1xuXG4gIGFsbG93ZWRIZWFkZXJzLmZvckVhY2goaGVhZGVyID0+IHtcbiAgICBpZiAoaGVhZGVycy5nZXQoaGVhZGVyKSkge1xuICAgICAgYWxsSGVhZGVyc1toZWFkZXJdID0gaGVhZGVycy5nZXQoaGVhZGVyKSA7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYWxsSGVhZGVycztcbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWVzdEhlYWRlcnMoZmV0Y2hBcmdzLCBhbGxvd2VkSGVhZGVycykge1xuICBpZiAoZmV0Y2hBcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZmV0Y2hBcmdzWzBdICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBnZXRIZWFkZXJzRnJvbU9wdGlvbnMoZmV0Y2hBcmdzWzBdICwgYWxsb3dlZEhlYWRlcnMpO1xuICB9XG5cbiAgaWYgKGZldGNoQXJncy5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gZ2V0SGVhZGVyc0Zyb21PcHRpb25zKGZldGNoQXJnc1sxXSAsIGFsbG93ZWRIZWFkZXJzKTtcbiAgfVxuXG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZ2V0SGVhZGVyc0Zyb21PcHRpb25zKFxuICBpbnB1dCxcbiAgYWxsb3dlZEhlYWRlcnMsXG4pIHtcbiAgaWYgKCFpbnB1dCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IGhlYWRlcnMgPSBpbnB1dC5oZWFkZXJzO1xuXG4gIGlmICghaGVhZGVycykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgIHJldHVybiBnZXRBbGxIZWFkZXJzKGhlYWRlcnMsIGFsbG93ZWRIZWFkZXJzKTtcbiAgfVxuXG4gIC8vIFdlIGRvIG5vdCBzdXBwb3J0IHRoaXMsIGFzIGl0IGlzIG5vdCByZWFsbHkgZG9jdW1lbnRlZCAoYW55bW9yZT8pXG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcmV0dXJuIGdldEFsbG93ZWRIZWFkZXJzKGhlYWRlcnMsIGFsbG93ZWRIZWFkZXJzKTtcbn1cblxuZnVuY3Rpb24gX3RyeUNsb25lUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgdHJ5IHtcbiAgICAvLyBXZSBoYXZlIHRvIGNsb25lIHRoaXMsIGFzIHRoZSBib2R5IGNhbiBvbmx5IGJlIHJlYWQgb25jZVxuICAgIHJldHVybiByZXNwb25zZS5jbG9uZSgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIHRoaXMgY2FuIHRocm93IGlmIHRoZSByZXNwb25zZSB3YXMgYWxyZWFkeSBjb25zdW1lZCBiZWZvcmVcbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIuZXhjZXB0aW9uKGVycm9yLCAnRmFpbGVkIHRvIGNsb25lIHJlc3BvbnNlIGJvZHknKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgcmVzcG9uc2UgYm9keSBvZiBhIGZldGNoIHJlcXVlc3QsIG9yIHRpbWVvdXQgYWZ0ZXIgNTAwbXMuXG4gKiBGZXRjaCBjYW4gcmV0dXJuIGEgc3RyZWFtaW5nIGJvZHksIHRoYXQgbWF5IG5vdCByZXNvbHZlIChvciBub3QgZm9yIGEgbG9uZyB0aW1lKS5cbiAqIElmIHRoYXQgaGFwcGVucywgd2UgcmF0aGVyIGFib3J0IGFmdGVyIGEgc2hvcnQgdGltZSB0aGFuIGtlZXAgd2FpdGluZyBmb3IgdGhpcy5cbiAqL1xuZnVuY3Rpb24gX3RyeUdldFJlc3BvbnNlVGV4dChyZXNwb25zZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0JDMoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCB3aGlsZSB0cnlpbmcgdG8gcmVhZCByZXNwb25zZSBib2R5JykpLCA1MDApO1xuXG4gICAgX2dldFJlc3BvbnNlVGV4dChyZXNwb25zZSlcbiAgICAgIC50aGVuKFxuICAgICAgICB0eHQgPT4gcmVzb2x2ZSh0eHQpLFxuICAgICAgICByZWFzb24gPT4gcmVqZWN0KHJlYXNvbiksXG4gICAgICApXG4gICAgICAuZmluYWxseSgoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCkpO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gX2dldFJlc3BvbnNlVGV4dChyZXNwb25zZSkge1xuICAvLyBGb3JjZSB0aGlzIHRvIGJlIGEgcHJvbWlzZSwganVzdCB0byBiZSBzYWZlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXR1cm4tYXdhaXRcbiAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbn1cblxuLyoqXG4gKiBDYXB0dXJlIGFuIFhIUiBicmVhZGNydW1iIHRvIGEgcmVwbGF5LlxuICogVGhpcyBhZGRzIGFkZGl0aW9uYWwgZGF0YSAod2hlcmUgYXBwcm9wcmlhdGUpLlxuICovXG5hc3luYyBmdW5jdGlvbiBjYXB0dXJlWGhyQnJlYWRjcnVtYlRvUmVwbGF5KFxuICBicmVhZGNydW1iLFxuICBoaW50LFxuICBvcHRpb25zLFxuKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGF0YSA9IF9wcmVwYXJlWGhyRGF0YShicmVhZGNydW1iLCBoaW50LCBvcHRpb25zKTtcblxuICAgIC8vIENyZWF0ZSBhIHJlcGxheSBwZXJmb3JtYW5jZSBlbnRyeSBmcm9tIHRoaXMgYnJlYWRjcnVtYlxuICAgIGNvbnN0IHJlc3VsdCA9IG1ha2VOZXR3b3JrUmVwbGF5QnJlYWRjcnVtYigncmVzb3VyY2UueGhyJywgZGF0YSk7XG4gICAgYWRkTmV0d29ya0JyZWFkY3J1bWIob3B0aW9ucy5yZXBsYXksIHJlc3VsdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmV4Y2VwdGlvbihlcnJvciwgJ0ZhaWxlZCB0byBjYXB0dXJlIHhociBicmVhZGNydW1iJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnJpY2ggYSBicmVhZGNydW1iIHdpdGggYWRkaXRpb25hbCBkYXRhLlxuICogVGhpcyBoYXMgdG8gYmUgc3luYyAmIG11dGF0ZSB0aGUgZ2l2ZW4gYnJlYWRjcnVtYixcbiAqIGFzIHRoZSBicmVhZGNydW1iIGlzIGFmdGVyd2FyZHMgY29uc3VtZWQgYnkgb3RoZXIgaGFuZGxlcnMuXG4gKi9cbmZ1bmN0aW9uIGVucmljaFhockJyZWFkY3J1bWIoXG4gIGJyZWFkY3J1bWIsXG4gIGhpbnQsXG4pIHtcbiAgY29uc3QgeyB4aHIsIGlucHV0IH0gPSBoaW50O1xuXG4gIGlmICgheGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcmVxU2l6ZSA9IGdldEJvZHlTaXplKGlucHV0KTtcbiAgY29uc3QgcmVzU2l6ZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC1sZW5ndGgnKVxuICAgID8gcGFyc2VDb250ZW50TGVuZ3RoSGVhZGVyKHhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC1sZW5ndGgnKSlcbiAgICA6IF9nZXRCb2R5U2l6ZSh4aHIucmVzcG9uc2UsIHhoci5yZXNwb25zZVR5cGUpO1xuXG4gIGlmIChyZXFTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBicmVhZGNydW1iLmRhdGEucmVxdWVzdF9ib2R5X3NpemUgPSByZXFTaXplO1xuICB9XG4gIGlmIChyZXNTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBicmVhZGNydW1iLmRhdGEucmVzcG9uc2VfYm9keV9zaXplID0gcmVzU2l6ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfcHJlcGFyZVhockRhdGEoXG4gIGJyZWFkY3J1bWIsXG4gIGhpbnQsXG4gIG9wdGlvbnMsXG4pIHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgeyBzdGFydFRpbWVzdGFtcCA9IG5vdywgZW5kVGltZXN0YW1wID0gbm93LCBpbnB1dCwgeGhyIH0gPSBoaW50O1xuXG4gIGNvbnN0IHtcbiAgICB1cmwsXG4gICAgbWV0aG9kLFxuICAgIHN0YXR1c19jb2RlOiBzdGF0dXNDb2RlID0gMCxcbiAgICByZXF1ZXN0X2JvZHlfc2l6ZTogcmVxdWVzdEJvZHlTaXplLFxuICAgIHJlc3BvbnNlX2JvZHlfc2l6ZTogcmVzcG9uc2VCb2R5U2l6ZSxcbiAgfSA9IGJyZWFkY3J1bWIuZGF0YTtcblxuICBpZiAoIXVybCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCF4aHIgfHwgIXVybE1hdGNoZXModXJsLCBvcHRpb25zLm5ldHdvcmtEZXRhaWxBbGxvd1VybHMpIHx8IHVybE1hdGNoZXModXJsLCBvcHRpb25zLm5ldHdvcmtEZXRhaWxEZW55VXJscykpIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gYnVpbGRTa2lwcGVkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKHJlcXVlc3RCb2R5U2l6ZSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBidWlsZFNraXBwZWROZXR3b3JrUmVxdWVzdE9yUmVzcG9uc2UocmVzcG9uc2VCb2R5U2l6ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0VGltZXN0YW1wLFxuICAgICAgZW5kVGltZXN0YW1wLFxuICAgICAgdXJsLFxuICAgICAgbWV0aG9kLFxuICAgICAgc3RhdHVzQ29kZSxcbiAgICAgIHJlcXVlc3QsXG4gICAgICByZXNwb25zZSxcbiAgICB9O1xuICB9XG5cbiAgLy8gLS0tLSBUaGlzIGFkZGl0aW9uYWwgbmV0d29yayBkYXRhIGJlbG93IGlzIG9ubHkgY2FwdHVyZWQgZm9yIFVSTHMgZGVmaW5lZCBpbiBgbmV0d29ya0RldGFpbEFsbG93VXJsc2AgLS0tLVxuXG4gIGNvbnN0IHhockluZm8gPSB4aHJbU0VOVFJZX1hIUl9EQVRBX0tFWV07XG4gIGNvbnN0IG5ldHdvcmtSZXF1ZXN0SGVhZGVycyA9IHhockluZm9cbiAgICA/IGdldEFsbG93ZWRIZWFkZXJzKHhockluZm8ucmVxdWVzdF9oZWFkZXJzLCBvcHRpb25zLm5ldHdvcmtSZXF1ZXN0SGVhZGVycylcbiAgICA6IHt9O1xuICBjb25zdCBuZXR3b3JrUmVzcG9uc2VIZWFkZXJzID0gZ2V0QWxsb3dlZEhlYWRlcnMoZ2V0UmVzcG9uc2VIZWFkZXJzKHhociksIG9wdGlvbnMubmV0d29ya1Jlc3BvbnNlSGVhZGVycyk7XG5cbiAgY29uc3QgW3JlcXVlc3RCb2R5LCByZXF1ZXN0V2FybmluZ10gPSBvcHRpb25zLm5ldHdvcmtDYXB0dXJlQm9kaWVzID8gZ2V0Qm9keVN0cmluZyhpbnB1dCwgbG9nZ2VyKSA6IFt1bmRlZmluZWRdO1xuICBjb25zdCBbcmVzcG9uc2VCb2R5LCByZXNwb25zZVdhcm5pbmddID0gb3B0aW9ucy5uZXR3b3JrQ2FwdHVyZUJvZGllcyA/IF9nZXRYaHJSZXNwb25zZUJvZHkoeGhyKSA6IFt1bmRlZmluZWRdO1xuXG4gIGNvbnN0IHJlcXVlc3QgPSBidWlsZE5ldHdvcmtSZXF1ZXN0T3JSZXNwb25zZShuZXR3b3JrUmVxdWVzdEhlYWRlcnMsIHJlcXVlc3RCb2R5U2l6ZSwgcmVxdWVzdEJvZHkpO1xuICBjb25zdCByZXNwb25zZSA9IGJ1aWxkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKG5ldHdvcmtSZXNwb25zZUhlYWRlcnMsIHJlc3BvbnNlQm9keVNpemUsIHJlc3BvbnNlQm9keSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFRpbWVzdGFtcCxcbiAgICBlbmRUaW1lc3RhbXAsXG4gICAgdXJsLFxuICAgIG1ldGhvZCxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHJlcXVlc3Q6IHJlcXVlc3RXYXJuaW5nID8gbWVyZ2VXYXJuaW5nKHJlcXVlc3QsIHJlcXVlc3RXYXJuaW5nKSA6IHJlcXVlc3QsXG4gICAgcmVzcG9uc2U6IHJlc3BvbnNlV2FybmluZyA/IG1lcmdlV2FybmluZyhyZXNwb25zZSwgcmVzcG9uc2VXYXJuaW5nKSA6IHJlc3BvbnNlLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZUhlYWRlcnMoeGhyKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcmV0dXJuIGhlYWRlcnMuc3BsaXQoJ1xcclxcbicpLnJlZHVjZSgoYWNjLCBsaW5lKSA9PiB7XG4gICAgY29uc3QgW2tleSwgdmFsdWVdID0gbGluZS5zcGxpdCgnOiAnKSA7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBhY2Nba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gX2dldFhoclJlc3BvbnNlQm9keSh4aHIpIHtcbiAgLy8gV2UgY29sbGVjdCBlcnJvcnMgdGhhdCBoYXBwZW4sIGJ1dCBvbmx5IGxvZyB0aGVtIGlmIHdlIGNhbid0IGdldCBhbnkgcmVzcG9uc2UgYm9keVxuICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICB0cnkge1xuICAgIHJldHVybiBbeGhyLnJlc3BvbnNlVGV4dF07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvcnMucHVzaChlKTtcbiAgfVxuXG4gIC8vIFRyeSB0byBtYW51YWxseSBwYXJzZSB0aGUgcmVzcG9uc2UgYm9keSwgaWYgcmVzcG9uc2VUZXh0IGZhaWxzXG4gIHRyeSB7XG4gICAgcmV0dXJuIF9wYXJzZVhoclJlc3BvbnNlKHhoci5yZXNwb25zZSwgeGhyLnJlc3BvbnNlVHlwZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvcnMucHVzaChlKTtcbiAgfVxuXG4gIERFQlVHX0JVSUxEICYmIGxvZ2dlci53YXJuKCdGYWlsZWQgdG8gZ2V0IHhociByZXNwb25zZSBib2R5JywgLi4uZXJyb3JzKTtcblxuICByZXR1cm4gW3VuZGVmaW5lZF07XG59XG5cbi8qKlxuICogR2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFhIUiByZXNwb25zZS5cbiAqIEJhc2VkIG9uIE1ETiwgdGhlc2UgYXJlIHRoZSBwb3NzaWJsZSB0eXBlcyBvZiB0aGUgcmVzcG9uc2U6XG4gKiBzdHJpbmdcbiAqIEFycmF5QnVmZmVyXG4gKiBCbG9iXG4gKiBEb2N1bWVudFxuICogUE9KT1xuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RzLlxuICovXG5mdW5jdGlvbiBfcGFyc2VYaHJSZXNwb25zZShcbiAgYm9keSxcbiAgcmVzcG9uc2VUeXBlLFxuKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFtib2R5XTtcbiAgICB9XG5cbiAgICBpZiAoYm9keSBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICByZXR1cm4gW2JvZHkuYm9keS5vdXRlckhUTUxdO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZVR5cGUgPT09ICdqc29uJyAmJiBib2R5ICYmIHR5cGVvZiBib2R5ID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIFtKU09OLnN0cmluZ2lmeShib2R5KV07XG4gICAgfVxuXG4gICAgaWYgKCFib2R5KSB7XG4gICAgICByZXR1cm4gW3VuZGVmaW5lZF07XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5leGNlcHRpb24oZXJyb3IsICdGYWlsZWQgdG8gc2VyaWFsaXplIGJvZHknLCBib2R5KTtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgJ0JPRFlfUEFSU0VfRVJST1InXTtcbiAgfVxuXG4gIERFQlVHX0JVSUxEICYmIGxvZ2dlci5pbmZvKCdTa2lwcGluZyBuZXR3b3JrIGJvZHkgYmVjYXVzZSBvZiBib2R5IHR5cGUnLCBib2R5KTtcblxuICByZXR1cm4gW3VuZGVmaW5lZCwgJ1VOUEFSU0VBQkxFX0JPRFlfVFlQRSddO1xufVxuXG5mdW5jdGlvbiBfZ2V0Qm9keVNpemUoXG4gIGJvZHksXG4gIHJlc3BvbnNlVHlwZSxcbikge1xuICB0cnkge1xuICAgIGNvbnN0IGJvZHlTdHIgPSByZXNwb25zZVR5cGUgPT09ICdqc29uJyAmJiBib2R5ICYmIHR5cGVvZiBib2R5ID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KGJvZHkpIDogYm9keTtcbiAgICByZXR1cm4gZ2V0Qm9keVNpemUoYm9keVN0cik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkb2VzIHR3byB0aGluZ3M6XG4gKiAtIEl0IGVucmljaGVzIHRoZSByZWd1bGFyIFhIUi9mZXRjaCBicmVhZGNydW1icyB3aXRoIHJlcXVlc3QvcmVzcG9uc2Ugc2l6ZSBkYXRhXG4gKiAtIEl0IGNhcHR1cmVzIHRoZSBYSFIvZmV0Y2ggYnJlYWRjcnVtYnMgdG8gdGhlIHJlcGxheVxuICogICAoZW5yaWNoaW5nIGl0IHdpdGggZnVydGhlciBkYXRhIHRoYXQgaXMgX25vdF8gYWRkZWQgdG8gdGhlIHJlZ3VsYXIgYnJlYWRjcnVtYnMpXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU5ldHdvcmtCcmVhZGNydW1icyhyZXBsYXkpIHtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBuZXR3b3JrRGV0YWlsQWxsb3dVcmxzLFxuICAgICAgbmV0d29ya0RldGFpbERlbnlVcmxzLFxuICAgICAgbmV0d29ya0NhcHR1cmVCb2RpZXMsXG4gICAgICBuZXR3b3JrUmVxdWVzdEhlYWRlcnMsXG4gICAgICBuZXR3b3JrUmVzcG9uc2VIZWFkZXJzLFxuICAgIH0gPSByZXBsYXkuZ2V0T3B0aW9ucygpO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJlcGxheSxcbiAgICAgIG5ldHdvcmtEZXRhaWxBbGxvd1VybHMsXG4gICAgICBuZXR3b3JrRGV0YWlsRGVueVVybHMsXG4gICAgICBuZXR3b3JrQ2FwdHVyZUJvZGllcyxcbiAgICAgIG5ldHdvcmtSZXF1ZXN0SGVhZGVycyxcbiAgICAgIG5ldHdvcmtSZXNwb25zZUhlYWRlcnMsXG4gICAgfTtcblxuICAgIGlmIChjbGllbnQpIHtcbiAgICAgIGNsaWVudC5vbignYmVmb3JlQWRkQnJlYWRjcnVtYicsIChicmVhZGNydW1iLCBoaW50KSA9PiBiZWZvcmVBZGROZXR3b3JrQnJlYWRjcnVtYihvcHRpb25zLCBicmVhZGNydW1iLCBoaW50KSk7XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICAvLyBEbyBub3RoaW5nXG4gIH1cbn1cblxuLyoqIGp1c3QgZXhwb3J0ZWQgZm9yIHRlc3RzICovXG5mdW5jdGlvbiBiZWZvcmVBZGROZXR3b3JrQnJlYWRjcnVtYihcbiAgb3B0aW9ucyxcbiAgYnJlYWRjcnVtYixcbiAgaGludCxcbikge1xuICBpZiAoIWJyZWFkY3J1bWIuZGF0YSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKF9pc1hockJyZWFkY3J1bWIoYnJlYWRjcnVtYikgJiYgX2lzWGhySGludChoaW50KSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgc3luYywgYXMgd2UgbmVlZCB0byBlbnN1cmUgdGhlIGJyZWFkY3J1bWIgaXMgZW5yaWNoZWQgaW4gdGhlIHNhbWUgdGlja1xuICAgICAgLy8gQmVjYXVzZSB0aGUgaG9vayBydW5zIHN5bmNocm9ub3VzbHksIGFuZCB0aGUgYnJlYWRjcnVtYiBpcyBhZnRlcndhcmRzIHBhc3NlZCBvblxuICAgICAgLy8gU28gYW55IGFzeW5jIG11dGF0aW9ucyB0byBpdCB3aWxsIG5vdCBiZSByZWZsZWN0ZWQgaW4gdGhlIGZpbmFsIGJyZWFkY3J1bWJcbiAgICAgIGVucmljaFhockJyZWFkY3J1bWIoYnJlYWRjcnVtYiwgaGludCk7XG5cbiAgICAgIC8vIFRoaXMgY2FsbCBzaG91bGQgbm90IHJlamVjdFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgY2FwdHVyZVhockJyZWFkY3J1bWJUb1JlcGxheShicmVhZGNydW1iLCBoaW50LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoX2lzRmV0Y2hCcmVhZGNydW1iKGJyZWFkY3J1bWIpICYmIF9pc0ZldGNoSGludChoaW50KSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgc3luYywgYXMgd2UgbmVlZCB0byBlbnN1cmUgdGhlIGJyZWFkY3J1bWIgaXMgZW5yaWNoZWQgaW4gdGhlIHNhbWUgdGlja1xuICAgICAgLy8gQmVjYXVzZSB0aGUgaG9vayBydW5zIHN5bmNocm9ub3VzbHksIGFuZCB0aGUgYnJlYWRjcnVtYiBpcyBhZnRlcndhcmRzIHBhc3NlZCBvblxuICAgICAgLy8gU28gYW55IGFzeW5jIG11dGF0aW9ucyB0byBpdCB3aWxsIG5vdCBiZSByZWZsZWN0ZWQgaW4gdGhlIGZpbmFsIGJyZWFkY3J1bWJcbiAgICAgIGVucmljaEZldGNoQnJlYWRjcnVtYihicmVhZGNydW1iLCBoaW50KTtcblxuICAgICAgLy8gVGhpcyBjYWxsIHNob3VsZCBub3QgcmVqZWN0XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICBjYXB0dXJlRmV0Y2hCcmVhZGNydW1iVG9SZXBsYXkoYnJlYWRjcnVtYiwgaGludCwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmV4Y2VwdGlvbihlLCAnRXJyb3Igd2hlbiBlbnJpY2hpbmcgbmV0d29yayBicmVhZGNydW1iJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2lzWGhyQnJlYWRjcnVtYihicmVhZGNydW1iKSB7XG4gIHJldHVybiBicmVhZGNydW1iLmNhdGVnb3J5ID09PSAneGhyJztcbn1cblxuZnVuY3Rpb24gX2lzRmV0Y2hCcmVhZGNydW1iKGJyZWFkY3J1bWIpIHtcbiAgcmV0dXJuIGJyZWFkY3J1bWIuY2F0ZWdvcnkgPT09ICdmZXRjaCc7XG59XG5cbmZ1bmN0aW9uIF9pc1hockhpbnQoaGludCkge1xuICByZXR1cm4gaGludD8ueGhyO1xufVxuXG5mdW5jdGlvbiBfaXNGZXRjaEhpbnQoaGludCkge1xuICByZXR1cm4gaGludD8ucmVzcG9uc2U7XG59XG5cbi8qKlxuICogQWRkIGdsb2JhbCBsaXN0ZW5lcnMgdGhhdCBjYW5ub3QgYmUgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gYWRkR2xvYmFsTGlzdGVuZXJzKFxuICByZXBsYXksXG4gIHsgYXV0b0ZsdXNoT25GZWVkYmFjayB9LFxuKSB7XG4gIC8vIExpc3RlbmVycyBmcm9tIGNvcmUgU0RLIC8vXG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuXG4gIGFkZENsaWNrS2V5cHJlc3NJbnN0cnVtZW50YXRpb25IYW5kbGVyKGhhbmRsZURvbUxpc3RlbmVyKHJlcGxheSkpO1xuICBhZGRIaXN0b3J5SW5zdHJ1bWVudGF0aW9uSGFuZGxlcihoYW5kbGVIaXN0b3J5U3Bhbkxpc3RlbmVyKHJlcGxheSkpO1xuICBoYW5kbGVCcmVhZGNydW1icyhyZXBsYXkpO1xuICBoYW5kbGVOZXR3b3JrQnJlYWRjcnVtYnMocmVwbGF5KTtcblxuICAvLyBUYWcgYWxsIChub24gcmVwbGF5KSBldmVudHMgdGhhdCBnZXQgc2VudCB0byBTZW50cnkgd2l0aCB0aGUgY3VycmVudFxuICAvLyByZXBsYXkgSUQgc28gdGhhdCB3ZSBjYW4gcmVmZXJlbmNlIHRoZW0gbGF0ZXIgaW4gdGhlIFVJXG4gIGNvbnN0IGV2ZW50UHJvY2Vzc29yID0gaGFuZGxlR2xvYmFsRXZlbnRMaXN0ZW5lcihyZXBsYXkpO1xuICBhZGRFdmVudFByb2Nlc3NvcihldmVudFByb2Nlc3Nvcik7XG5cbiAgLy8gSWYgYSBjdXN0b20gY2xpZW50IGhhcyBubyBob29rcyB5ZXQsIHdlIGNvbnRpbnVlIHRvIHVzZSB0aGUgXCJvbGRcIiBpbXBsZW1lbnRhdGlvblxuICBpZiAoY2xpZW50KSB7XG4gICAgY2xpZW50Lm9uKCdiZWZvcmVTZW5kRXZlbnQnLCBoYW5kbGVCZWZvcmVTZW5kRXZlbnQocmVwbGF5KSk7XG4gICAgY2xpZW50Lm9uKCdhZnRlclNlbmRFdmVudCcsIGhhbmRsZUFmdGVyU2VuZEV2ZW50KHJlcGxheSkpO1xuICAgIGNsaWVudC5vbignY3JlYXRlRHNjJywgKGRzYykgPT4ge1xuICAgICAgY29uc3QgcmVwbGF5SWQgPSByZXBsYXkuZ2V0U2Vzc2lvbklkKCk7XG4gICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBzZXQgdGhlIERTQyB3aGVuIGluIGJ1ZmZlciBtb2RlLCBhcyB0aGF0IG1lYW5zIHRoZSByZXBsYXkgaGFzIG5vdCBiZWVuIHNlbnQgKHlldClcbiAgICAgIGlmIChyZXBsYXlJZCAmJiByZXBsYXkuaXNFbmFibGVkKCkgJiYgcmVwbGF5LnJlY29yZGluZ01vZGUgPT09ICdzZXNzaW9uJykge1xuICAgICAgICAvLyBFbnN1cmUgdG8gY2hlY2sgdGhhdCB0aGUgc2Vzc2lvbiBpcyBzdGlsbCBhY3RpdmUgLSBpdCBjb3VsZCBoYXZlIGV4cGlyZWQgaW4gdGhlIG1lYW53aGlsZVxuICAgICAgICBjb25zdCBpc1Nlc3Npb25BY3RpdmUgPSByZXBsYXkuY2hlY2tBbmRIYW5kbGVFeHBpcmVkU2Vzc2lvbigpO1xuICAgICAgICBpZiAoaXNTZXNzaW9uQWN0aXZlKSB7XG4gICAgICAgICAgZHNjLnJlcGxheV9pZCA9IHJlcGxheUlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjbGllbnQub24oJ3NwYW5TdGFydCcsIHNwYW4gPT4ge1xuICAgICAgcmVwbGF5Lmxhc3RBY3RpdmVTcGFuID0gc3BhbjtcbiAgICB9KTtcblxuICAgIC8vIFdlIG1heSBiZSBtaXNzaW5nIHRoZSBpbml0aWFsIHNwYW5TdGFydCBkdWUgdG8gdGltaW5nIGlzc3VlcyxcbiAgICAvLyBzbyB3ZSBjYXB0dXJlIGl0IG9uIGZpbmlzaCBhZ2Fpbi5cbiAgICBjbGllbnQub24oJ3NwYW5FbmQnLCBzcGFuID0+IHtcbiAgICAgIHJlcGxheS5sYXN0QWN0aXZlU3BhbiA9IHNwYW47XG4gICAgfSk7XG5cbiAgICAvLyBXZSB3YW50IHRvIGF0dGFjaCB0aGUgcmVwbGF5IGlkIHRvIHRoZSBmZWVkYmFjayBldmVudFxuICAgIGNsaWVudC5vbignYmVmb3JlU2VuZEZlZWRiYWNrJywgYXN5bmMgKGZlZWRiYWNrRXZlbnQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxheUlkID0gcmVwbGF5LmdldFNlc3Npb25JZCgpO1xuICAgICAgaWYgKG9wdGlvbnM/LmluY2x1ZGVSZXBsYXkgJiYgcmVwbGF5LmlzRW5hYmxlZCgpICYmIHJlcGxheUlkICYmIGZlZWRiYWNrRXZlbnQuY29udGV4dHM/LmZlZWRiYWNrKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIGZlZWRiYWNrIGlzIHNlbnQgdmlhIEFQSSBhbmQgbm90IHRocm91Z2ggb3VyIHdpZGdldCwgd2Ugd2FudCB0byBmbHVzaCByZXBsYXlcbiAgICAgICAgaWYgKGZlZWRiYWNrRXZlbnQuY29udGV4dHMuZmVlZGJhY2suc291cmNlID09PSAnYXBpJyAmJiBhdXRvRmx1c2hPbkZlZWRiYWNrKSB7XG4gICAgICAgICAgYXdhaXQgcmVwbGF5LmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmVlZGJhY2tFdmVudC5jb250ZXh0cy5mZWVkYmFjay5yZXBsYXlfaWQgPSByZXBsYXlJZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChhdXRvRmx1c2hPbkZlZWRiYWNrKSB7XG4gICAgICBjbGllbnQub24oJ29wZW5GZWVkYmFja1dpZGdldCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgcmVwbGF5LmZsdXNoKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBcInNwYW5cIiBmb3IgdGhlIHRvdGFsIGFtb3VudCBvZiBtZW1vcnkgYmVpbmcgdXNlZCBieSBKUyBvYmplY3RzXG4gKiAoaW5jbHVkaW5nIHY4IGludGVybmFsIG9iamVjdHMpLlxuICovXG5hc3luYyBmdW5jdGlvbiBhZGRNZW1vcnlFbnRyeShyZXBsYXkpIHtcbiAgLy8gd2luZG93LnBlcmZvcm1hbmNlLm1lbW9yeSBpcyBhIG5vbi1zdGFuZGFyZCBBUEkgYW5kIGRvZXNuJ3Qgd29yayBvbiBhbGwgYnJvd3NlcnMsIHNvIHdlIHRyeS1jYXRjaCB0aGlzXG4gIHRyeSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgY3JlYXRlUGVyZm9ybWFuY2VTcGFucyhyZXBsYXksIFtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBtZW1vcnkgZG9lc24ndCBleGlzdCBvbiB0eXBlIFBlcmZvcm1hbmNlIGFzIHRoZSBBUEkgaXMgbm9uLXN0YW5kYXJkICh3ZSBjaGVjayB0aGF0IGl0IGV4aXN0cyBhYm92ZSlcbiAgICAgICAgY3JlYXRlTWVtb3J5RW50cnkoV0lORE9XLnBlcmZvcm1hbmNlLm1lbW9yeSksXG4gICAgICBdKSxcbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIERvIG5vdGhpbmdcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5RW50cnkobWVtb3J5RW50cnkpIHtcbiAgY29uc3QgeyBqc0hlYXBTaXplTGltaXQsIHRvdGFsSlNIZWFwU2l6ZSwgdXNlZEpTSGVhcFNpemUgfSA9IG1lbW9yeUVudHJ5O1xuICAvLyB3ZSBkb24ndCB3YW50IHRvIHVzZSBgZ2V0QWJzb2x1dGVUaW1lYCBiZWNhdXNlIGl0IGFkZHMgdGhlIGV2ZW50IHRpbWUgdG8gdGhlXG4gIC8vIHRpbWUgb3JpZ2luLCBzbyB3ZSBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGluc3RlYWRcbiAgY29uc3QgdGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdtZW1vcnknLFxuICAgIG5hbWU6ICdtZW1vcnknLFxuICAgIHN0YXJ0OiB0aW1lLFxuICAgIGVuZDogdGltZSxcbiAgICBkYXRhOiB7XG4gICAgICBtZW1vcnk6IHtcbiAgICAgICAganNIZWFwU2l6ZUxpbWl0LFxuICAgICAgICB0b3RhbEpTSGVhcFNpemUsXG4gICAgICAgIHVzZWRKU0hlYXBTaXplLFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIEhlYXZpbHkgc2ltcGxpZmllZCBkZWJvdW5jZSBmdW5jdGlvbiBiYXNlZCBvbiBsb2Rhc2guZGVib3VuY2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIChAcGFyYW0gZnVuKSBhbmQgZGVsYXlzIGl0cyBpbnZvY2F0aW9uXG4gKiBieSBAcGFyYW0gd2FpdCBtaWxsaXNlY29uZHMuIE9wdGlvbmFsbHksIGEgbWF4V2FpdCBjYW4gYmUgc3BlY2lmaWVkIGluIEBwYXJhbSBvcHRpb25zLFxuICogd2hpY2ggZW5zdXJlcyB0aGF0IHRoZSBjYWxsYmFjayBpcyBpbnZva2VkIGF0IGxlYXN0IG9uY2UgYWZ0ZXIgdGhlIHNwZWNpZmllZCBtYXguIHdhaXQgdGltZS5cbiAqXG4gKiBAcGFyYW0gZnVuYyB0aGUgZnVuY3Rpb24gd2hvc2UgaW52b2NhdGlvbiBpcyB0byBiZSBkZWJvdW5jZWRcbiAqIEBwYXJhbSB3YWl0IHRoZSBtaW5pbXVtIHRpbWUgdW50aWwgdGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgYWZ0ZXIgaXQgd2FzIGNhbGxlZCBvbmNlXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvYmplY3QsIHdoaWNoIGNhbiBjb250YWluIHRoZSBgbWF4V2FpdGAgcHJvcGVydHlcbiAqXG4gKiBAcmV0dXJucyB0aGUgZGVib3VuY2VkIHZlcnNpb24gb2YgdGhlIGZ1bmN0aW9uLCB3aGljaCBuZWVkcyB0byBiZSBjYWxsZWQgYXQgbGVhc3Qgb25jZSB0byBzdGFydCB0aGVcbiAqICAgICAgICAgIGRlYm91bmNpbmcgcHJvY2Vzcy4gU3Vic2VxdWVudCBjYWxscyB3aWxsIHJlc2V0IHRoZSBkZWJvdW5jaW5nIHRpbWVyIGFuZCwgaW4gY2FzZSBAcGFyYW1mdW5jXG4gKiAgICAgICAgICB3YXMgYWxyZWFkeSBpbnZva2VkIGluIHRoZSBtZWFudGltZSwgcmV0dXJuIEBwYXJhbSBmdW5jJ3MgcmV0dXJuIHZhbHVlLlxuICogICAgICAgICAgVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBoYXMgdHdvIGFkZGl0aW9uYWwgcHJvcGVydGllczpcbiAqICAgICAgICAgIC0gYGZsdXNoYDogSW52b2tlcyB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIGltbWVkaWF0ZWx5IGFuZCByZXR1cm5zIGl0cyByZXR1cm4gdmFsdWVcbiAqICAgICAgICAgIC0gYGNhbmNlbGA6IENhbmNlbHMgdGhlIGRlYm91bmNpbmcgcHJvY2VzcyBhbmQgcmVzZXRzIHRoZSBkZWJvdW5jaW5nIHRpbWVyXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgbGV0IGNhbGxiYWNrUmV0dXJuVmFsdWU7XG5cbiAgbGV0IHRpbWVySWQ7XG4gIGxldCBtYXhUaW1lcklkO1xuXG4gIGNvbnN0IG1heFdhaXQgPSBvcHRpb25zPy5tYXhXYWl0ID8gTWF0aC5tYXgob3B0aW9ucy5tYXhXYWl0LCB3YWl0KSA6IDA7XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYygpIHtcbiAgICBjYW5jZWxUaW1lcnMoKTtcbiAgICBjYWxsYmFja1JldHVyblZhbHVlID0gZnVuYygpO1xuICAgIHJldHVybiBjYWxsYmFja1JldHVyblZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsVGltZXJzKCkge1xuICAgIHRpbWVySWQgIT09IHVuZGVmaW5lZCAmJiBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgbWF4VGltZXJJZCAhPT0gdW5kZWZpbmVkICYmIGNsZWFyVGltZW91dChtYXhUaW1lcklkKTtcbiAgICB0aW1lcklkID0gbWF4VGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQgfHwgbWF4VGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYygpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2tSZXR1cm5WYWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICBpZiAodGltZXJJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCQzKGludm9rZUZ1bmMsIHdhaXQpO1xuXG4gICAgaWYgKG1heFdhaXQgJiYgbWF4VGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtYXhUaW1lcklkID0gc2V0VGltZW91dCQzKGludm9rZUZ1bmMsIG1heFdhaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxsYmFja1JldHVyblZhbHVlO1xuICB9XG5cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbFRpbWVycztcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbmNvbnN0IE5BVklHQVRPUiA9IEdMT0JBTF9PQkoubmF2aWdhdG9yO1xuXG4vKipcbiAqICBEaXNhYmxlIHNhbXBsaW5nIG1vdXNlbW92ZSBldmVudHMgb24gaU9TIGJyb3dzZXJzIGFzIHRoaXMgY2FuIGNhdXNlIGJsb2NraW5nIHRoZSBtYWluIHRocmVhZFxuICogIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzE0NTM0XG4gKi9cbmZ1bmN0aW9uIGdldFJlY29yZGluZ1NhbXBsaW5nT3B0aW9ucygpIHtcbiAgaWYgKFxuICAgIC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChOQVZJR0FUT1I/LnVzZXJBZ2VudCA/PyAnJykgfHxcbiAgICAoL01hY2ludG9zaC9pLnRlc3QoTkFWSUdBVE9SPy51c2VyQWdlbnQgPz8gJycpICYmIE5BVklHQVRPUj8ubWF4VG91Y2hQb2ludHMgJiYgTkFWSUdBVE9SPy5tYXhUb3VjaFBvaW50cyA+IDEpXG4gICkge1xuICAgIHJldHVybiB7XG4gICAgICBzYW1wbGluZzoge1xuICAgICAgICBtb3VzZW1vdmU6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHt9O1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIHJlY29yZGluZyBldmVudHMuXG4gKlxuICogQWRkcyB0byBldmVudCBidWZmZXIsIGFuZCBoYXMgdmFyeWluZyBmbHVzaGluZyBiZWhhdmlvcnMgaWYgdGhlIGV2ZW50IHdhcyBhIGNoZWNrb3V0LlxuICovXG5mdW5jdGlvbiBnZXRIYW5kbGVSZWNvcmRpbmdFbWl0KHJlcGxheSkge1xuICBsZXQgaGFkRmlyc3RFdmVudCA9IGZhbHNlO1xuXG4gIHJldHVybiAoZXZlbnQsIF9pc0NoZWNrb3V0KSA9PiB7XG4gICAgLy8gSWYgdGhpcyBpcyBmYWxzZSwgaXQgbWVhbnMgc2Vzc2lvbiBpcyBleHBpcmVkLCBjcmVhdGUgYW5kIGEgbmV3IHNlc3Npb24gYW5kIHdhaXQgZm9yIGNoZWNrb3V0XG4gICAgaWYgKCFyZXBsYXkuY2hlY2tBbmRIYW5kbGVFeHBpcmVkU2Vzc2lvbigpKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIud2FybignUmVjZWl2ZWQgcmVwbGF5IGV2ZW50IGFmdGVyIHNlc3Npb24gZXhwaXJlZC4nKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGBfaXNDaGVja291dGAgaXMgb25seSBzZXQgd2hlbiB0aGUgY2hlY2tvdXQgaXMgZHVlIHRvIGBjaGVja291dEV2ZXJ5Tm1zYFxuICAgIC8vIFdlIGFsc28gd2FudCB0byB0cmVhdCB0aGUgZmlyc3QgZXZlbnQgYXMgYSBjaGVja291dCwgc28gd2UgaGFuZGxlIHRoaXMgc3BlY2lmaWNhbGx5IGhlcmVcbiAgICBjb25zdCBpc0NoZWNrb3V0ID0gX2lzQ2hlY2tvdXQgfHwgIWhhZEZpcnN0RXZlbnQ7XG4gICAgaGFkRmlyc3RFdmVudCA9IHRydWU7XG5cbiAgICBpZiAocmVwbGF5LmNsaWNrRGV0ZWN0b3IpIHtcbiAgICAgIHVwZGF0ZUNsaWNrRGV0ZWN0b3JGb3JSZWNvcmRpbmdFdmVudChyZXBsYXkuY2xpY2tEZXRlY3RvciwgZXZlbnQpO1xuICAgIH1cblxuICAgIC8vIFRoZSBoYW5kbGVyIHJldHVybnMgYHRydWVgIGlmIHdlIGRvIG5vdCB3YW50IHRvIHRyaWdnZXIgZGVib3VuY2VkIGZsdXNoLCBgZmFsc2VgIGlmIHdlIHdhbnQgdG8gZGVib3VuY2UgZmx1c2guXG4gICAgcmVwbGF5LmFkZFVwZGF0ZSgoKSA9PiB7XG4gICAgICAvLyBUaGUgc2Vzc2lvbiBpcyBhbHdheXMgc3RhcnRlZCBpbW1lZGlhdGVseSBvbiBwYWdlbG9hZC9pbml0LCBidXQgZm9yXG4gICAgICAvLyBlcnJvci1vbmx5IHJlcGxheXMsIGl0IHNob3VsZCByZWZsZWN0IHRoZSBtb3N0IHJlY2VudCBjaGVja291dFxuICAgICAgLy8gd2hlbiBhbiBlcnJvciBvY2N1cnMuIENsZWFyIGFueSBzdGF0ZSB0aGF0IGhhcHBlbnMgYmVmb3JlIHRoaXMgY3VycmVudFxuICAgICAgLy8gY2hlY2tvdXQuIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSBgYWRkRXZlbnQoKWAgd2hpY2ggdXBkYXRlcyBzdGF0ZVxuICAgICAgLy8gZGVwZW5kZW50IG9uIHRoaXMgcmVzZXQuXG4gICAgICBpZiAocmVwbGF5LnJlY29yZGluZ01vZGUgPT09ICdidWZmZXInICYmIGlzQ2hlY2tvdXQpIHtcbiAgICAgICAgcmVwbGF5LnNldEluaXRpYWxTdGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgbm90IGFkZGVkIChlLmcuIGR1ZSB0byBiZWluZyBwYXVzZWQsIGRpc2FibGVkLCBvciBvdXQgb2YgdGhlIG1heCByZXBsYXkgZHVyYXRpb24pLFxuICAgICAgLy8gU2tpcCBhbGwgZnVydGhlciBzdGVwc1xuICAgICAgaWYgKCFhZGRFdmVudFN5bmMocmVwbGF5LCBldmVudCwgaXNDaGVja291dCkpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRydWUgdG8gc2tpcCBzY2hlZHVsaW5nIGEgZGVib3VuY2VkIGZsdXNoXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBEaWZmZXJlbnQgYmVoYXZpb3IgZm9yIGZ1bGwgc25hcHNob3RzICh0eXBlPTIpLCBpZ25vcmUgb3RoZXIgZXZlbnQgdHlwZXNcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcnJ3ZWItaW8vcnJ3ZWIvYmxvYi9kOGY5MjkwY2E0OTY3MTJhYTFlN2Q0NzI1NDk0ODBjNGU3ODc2NTk0L3BhY2thZ2VzL3Jyd2ViL3NyYy90eXBlcy50cyNMMTZcbiAgICAgIGlmICghaXNDaGVja291dCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlc3Npb24gPSByZXBsYXkuc2Vzc2lvbjtcblxuICAgICAgLy8gQWRkaXRpb25hbGx5LCBjcmVhdGUgYSBtZXRhIGV2ZW50IHRoYXQgd2lsbCBjYXB0dXJlIGNlcnRhaW4gU0RLIHNldHRpbmdzLlxuICAgICAgLy8gSW4gb3JkZXIgdG8gaGFuZGxlIGJ1ZmZlciBtb2RlLCB0aGlzIG5lZWRzIHRvIGVpdGhlciBiZSBkb25lIHdoZW4gd2VcbiAgICAgIC8vIHJlY2VpdmUgY2hlY2tvdXQgZXZlbnRzIG9yIGF0IGZsdXNoIHRpbWUuIFdlIGhhdmUgYW4gZXhwZXJpbWVudGFsIG1vZGVcbiAgICAgIC8vIHRvIHBlcmZvcm0gbXVsdGlwbGUgY2hlY2tvdXRzIGEgc2Vzc2lvbiAodGhlIGlkZWEgaXMgdG8gaW1wcm92ZVxuICAgICAgLy8gc2Vla2luZyBkdXJpbmcgcGxheWJhY2spLCBzbyBhbHNvIG9ubHkgaW5jbHVkZSBpZiBzZWdtZW50SWQgaXMgMFxuICAgICAgLy8gKGhhbmRsZWQgaW4gYGFkZFNldHRpbmdzRXZlbnRgKS5cbiAgICAgIC8vXG4gICAgICAvLyBgaXNDaGVja291dGAgaXMgYWx3YXlzIHRydWUsIGJ1dCB3YW50IHRvIGJlIGV4cGxpY2l0IHRoYXQgaXQgc2hvdWxkXG4gICAgICAvLyBvbmx5IGJlIGFkZGVkIGZvciBjaGVja291dHNcbiAgICAgIGFkZFNldHRpbmdzRXZlbnQocmVwbGF5LCBpc0NoZWNrb3V0KTtcblxuICAgICAgLy8gV2hlbiBpbiBidWZmZXIgbW9kZSwgbWFrZSBzdXJlIHdlIGFkanVzdCB0aGUgc2Vzc2lvbiBzdGFydGVkIGRhdGUgdG8gdGhlIGN1cnJlbnQgZWFybGllc3QgZXZlbnQgb2YgdGhlIGJ1ZmZlclxuICAgICAgLy8gdGhpcyBzaG91bGQgdXN1YWxseSBiZSB0aGUgdGltZXN0YW1wIG9mIHRoZSBjaGVja291dCBldmVudCwgYnV0IHRvIGJlIHNhZmUuLi5cbiAgICAgIGlmIChyZXBsYXkucmVjb3JkaW5nTW9kZSA9PT0gJ2J1ZmZlcicgJiYgc2Vzc2lvbiAmJiByZXBsYXkuZXZlbnRCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgZWFybGllc3RFdmVudCA9IHJlcGxheS5ldmVudEJ1ZmZlci5nZXRFYXJsaWVzdFRpbWVzdGFtcCgpO1xuICAgICAgICBpZiAoZWFybGllc3RFdmVudCkge1xuICAgICAgICAgIERFQlVHX0JVSUxEICYmXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgVXBkYXRpbmcgc2Vzc2lvbiBzdGFydCB0aW1lIHRvIGVhcmxpZXN0IGV2ZW50IGluIGJ1ZmZlciB0byAke25ldyBEYXRlKGVhcmxpZXN0RXZlbnQpfWApO1xuXG4gICAgICAgICAgc2Vzc2lvbi5zdGFydGVkID0gZWFybGllc3RFdmVudDtcblxuICAgICAgICAgIGlmIChyZXBsYXkuZ2V0T3B0aW9ucygpLnN0aWNreVNlc3Npb24pIHtcbiAgICAgICAgICAgIHNhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHByZXZpb3VzU2Vzc2lvbklkIGFmdGVyIGEgZnVsbCBzbmFwc2hvdCBvY2N1cnMsIHRoZW5cbiAgICAgIC8vIHRoZSByZXBsYXkgc2Vzc2lvbiB3YXMgc3RhcnRlZCBkdWUgdG8gc2Vzc2lvbiBleHBpcmF0aW9uLiBUaGUgbmV3IHNlc3Npb25cbiAgICAgIC8vIGlzIHN0YXJ0ZWQgYmVmb3JlIHRyaWdnZXJpbmcgYSBuZXcgY2hlY2tvdXQgYW5kIGNvbnRhaW5zIHRoZSBpZFxuICAgICAgLy8gb2YgdGhlIHByZXZpb3VzIHNlc3Npb24uIERvIG5vdCBpbW1lZGlhdGVseSBmbHVzaCBpbiB0aGlzIGNhc2VcbiAgICAgIC8vIHRvIGF2b2lkIGNhcHR1cmluZyBvbmx5IHRoZSBjaGVja291dCBhbmQgaW5zdGVhZCB0aGUgcmVwbGF5IHdpbGxcbiAgICAgIC8vIGJlIGNhcHR1cmVkIGlmIHRoZXkgcGVyZm9ybSBhbnkgZm9sbG93LXVwIGFjdGlvbnMuXG4gICAgICBpZiAoc2Vzc2lvbj8ucHJldmlvdXNTZXNzaW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXBsYXkucmVjb3JkaW5nTW9kZSA9PT0gJ3Nlc3Npb24nKSB7XG4gICAgICAgIC8vIElmIHRoZSBmdWxsIHNuYXBzaG90IGlzIGR1ZSB0byBhbiBpbml0aWFsIGxvYWQsIHdlIHdpbGwgbm90IGhhdmVcbiAgICAgICAgLy8gYSBwcmV2aW91cyBzZXNzaW9uIElELiBJbiB0aGlzIGNhc2UsIHdlIHdhbnQgdG8gYnVmZmVyIGV2ZW50c1xuICAgICAgICAvLyBmb3IgYSBzZXQgYW1vdW50IG9mIHRpbWUgYmVmb3JlIGZsdXNoaW5nLiBUaGlzIGNhbiBoZWxwIGF2b2lkXG4gICAgICAgIC8vIGNhcHR1cmluZyByZXBsYXlzIG9mIHVzZXJzIHRoYXQgaW1tZWRpYXRlbHkgY2xvc2UgdGhlIHdpbmRvdy5cblxuICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciByZWplY3RcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICB2b2lkIHJlcGxheS5mbHVzaCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHBvcnRlZCBmb3IgdGVzdHNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9uc0V2ZW50KHJlcGxheSkge1xuICBjb25zdCBvcHRpb25zID0gcmVwbGF5LmdldE9wdGlvbnMoKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBFdmVudFR5cGUuQ3VzdG9tLFxuICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICBkYXRhOiB7XG4gICAgICB0YWc6ICdvcHRpb25zJyxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgc2hvdWxkUmVjb3JkQ2FudmFzOiByZXBsYXkuaXNSZWNvcmRpbmdDYW52YXMoKSxcbiAgICAgICAgc2Vzc2lvblNhbXBsZVJhdGU6IG9wdGlvbnMuc2Vzc2lvblNhbXBsZVJhdGUsXG4gICAgICAgIGVycm9yU2FtcGxlUmF0ZTogb3B0aW9ucy5lcnJvclNhbXBsZVJhdGUsXG4gICAgICAgIHVzZUNvbXByZXNzaW9uT3B0aW9uOiBvcHRpb25zLnVzZUNvbXByZXNzaW9uLFxuICAgICAgICBibG9ja0FsbE1lZGlhOiBvcHRpb25zLmJsb2NrQWxsTWVkaWEsXG4gICAgICAgIG1hc2tBbGxUZXh0OiBvcHRpb25zLm1hc2tBbGxUZXh0LFxuICAgICAgICBtYXNrQWxsSW5wdXRzOiBvcHRpb25zLm1hc2tBbGxJbnB1dHMsXG4gICAgICAgIHVzZUNvbXByZXNzaW9uOiByZXBsYXkuZXZlbnRCdWZmZXIgPyByZXBsYXkuZXZlbnRCdWZmZXIudHlwZSA9PT0gJ3dvcmtlcicgOiBmYWxzZSxcbiAgICAgICAgbmV0d29ya0RldGFpbEhhc1VybHM6IG9wdGlvbnMubmV0d29ya0RldGFpbEFsbG93VXJscy5sZW5ndGggPiAwLFxuICAgICAgICBuZXR3b3JrQ2FwdHVyZUJvZGllczogb3B0aW9ucy5uZXR3b3JrQ2FwdHVyZUJvZGllcyxcbiAgICAgICAgbmV0d29ya1JlcXVlc3RIYXNIZWFkZXJzOiBvcHRpb25zLm5ldHdvcmtSZXF1ZXN0SGVhZGVycy5sZW5ndGggPiAwLFxuICAgICAgICBuZXR3b3JrUmVzcG9uc2VIYXNIZWFkZXJzOiBvcHRpb25zLm5ldHdvcmtSZXNwb25zZUhlYWRlcnMubGVuZ3RoID4gMCxcbiAgICAgIH0sXG4gICAgfSxcbiAgfTtcbn1cblxuLyoqXG4gKiBBZGQgYSBcIm1ldGFcIiBldmVudCB0aGF0IGNvbnRhaW5zIGEgc2ltcGxpZmllZCB2aWV3IG9uIGN1cnJlbnQgY29uZmlndXJhdGlvblxuICogb3B0aW9ucy4gVGhpcyBzaG91bGQgb25seSBiZSBpbmNsdWRlZCBvbiB0aGUgZmlyc3Qgc2VnbWVudCBvZiBhIHJlY29yZGluZy5cbiAqL1xuZnVuY3Rpb24gYWRkU2V0dGluZ3NFdmVudChyZXBsYXksIGlzQ2hlY2tvdXQpIHtcbiAgLy8gT25seSBuZWVkIHRvIGFkZCB0aGlzIGV2ZW50IHdoZW4gc2VuZGluZyB0aGUgZmlyc3Qgc2VnbWVudFxuICBpZiAoIWlzQ2hlY2tvdXQgfHwgIXJlcGxheS5zZXNzaW9uIHx8IHJlcGxheS5zZXNzaW9uLnNlZ21lbnRJZCAhPT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFkZEV2ZW50U3luYyhyZXBsYXksIGNyZWF0ZU9wdGlvbnNFdmVudChyZXBsYXkpLCBmYWxzZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVwbGF5IGVudmVsb3BlIHJlYWR5IHRvIGJlIHNlbnQuXG4gKiBUaGlzIGluY2x1ZGVzIGJvdGggdGhlIHJlcGxheSBldmVudCwgYXMgd2VsbCBhcyB0aGUgcmVjb3JkaW5nIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlcGxheUVudmVsb3BlKFxuICByZXBsYXlFdmVudCxcbiAgcmVjb3JkaW5nRGF0YSxcbiAgZHNuLFxuICB0dW5uZWwsXG4pIHtcbiAgcmV0dXJuIGNyZWF0ZUVudmVsb3BlKFxuICAgIGNyZWF0ZUV2ZW50RW52ZWxvcGVIZWFkZXJzKHJlcGxheUV2ZW50LCBnZXRTZGtNZXRhZGF0YUZvckVudmVsb3BlSGVhZGVyKHJlcGxheUV2ZW50KSwgdHVubmVsLCBkc24pLFxuICAgIFtcbiAgICAgIFt7IHR5cGU6ICdyZXBsYXlfZXZlbnQnIH0sIHJlcGxheUV2ZW50XSxcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdyZXBsYXlfcmVjb3JkaW5nJyxcbiAgICAgICAgICAvLyBJZiBzdHJpbmcgdGhlbiB3ZSBuZWVkIHRvIGVuY29kZSB0byBVVEY4LCBvdGhlcndpc2Ugd2lsbCBoYXZlXG4gICAgICAgICAgLy8gd3Jvbmcgc2l6ZS4gVGV4dEVuY29kZXIgaGFzIHNpbWlsYXIgYnJvd3NlciBzdXBwb3J0IHRvXG4gICAgICAgICAgLy8gTXV0YXRpb25PYnNlcnZlciwgYWx0aG91Z2ggaXQgZG9lcyBub3QgYWNjZXB0IElFMTEuXG4gICAgICAgICAgbGVuZ3RoOlxuICAgICAgICAgICAgdHlwZW9mIHJlY29yZGluZ0RhdGEgPT09ICdzdHJpbmcnID8gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHJlY29yZGluZ0RhdGEpLmxlbmd0aCA6IHJlY29yZGluZ0RhdGEubGVuZ3RoLFxuICAgICAgICB9LFxuICAgICAgICByZWNvcmRpbmdEYXRhLFxuICAgICAgXSxcbiAgICBdLFxuICApO1xufVxuXG4vKipcbiAqIFByZXBhcmUgdGhlIHJlY29yZGluZyBkYXRhIHJlYWR5IHRvIGJlIHNlbnQuXG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVSZWNvcmRpbmdEYXRhKHtcbiAgcmVjb3JkaW5nRGF0YSxcbiAgaGVhZGVycyxcbn1cblxuKSB7XG4gIGxldCBwYXlsb2FkV2l0aFNlcXVlbmNlO1xuXG4gIC8vIFhYWDogbmV3bGluZSBpcyBuZWVkZWQgdG8gc2VwYXJhdGUgc2VxdWVuY2UgaWQgZnJvbSBldmVudHNcbiAgY29uc3QgcmVwbGF5SGVhZGVycyA9IGAke0pTT04uc3RyaW5naWZ5KGhlYWRlcnMpfVxuYDtcblxuICBpZiAodHlwZW9mIHJlY29yZGluZ0RhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcGF5bG9hZFdpdGhTZXF1ZW5jZSA9IGAke3JlcGxheUhlYWRlcnN9JHtyZWNvcmRpbmdEYXRhfWA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgLy8gWFhYOiBuZXdsaW5lIGlzIG5lZWRlZCB0byBzZXBhcmF0ZSBzZXF1ZW5jZSBpZCBmcm9tIGV2ZW50c1xuICAgIGNvbnN0IHNlcXVlbmNlID0gZW5jLmVuY29kZShyZXBsYXlIZWFkZXJzKTtcbiAgICAvLyBNZXJnZSB0aGUgdHdvIFVpbnQ4QXJyYXlzXG4gICAgcGF5bG9hZFdpdGhTZXF1ZW5jZSA9IG5ldyBVaW50OEFycmF5KHNlcXVlbmNlLmxlbmd0aCArIHJlY29yZGluZ0RhdGEubGVuZ3RoKTtcbiAgICBwYXlsb2FkV2l0aFNlcXVlbmNlLnNldChzZXF1ZW5jZSk7XG4gICAgcGF5bG9hZFdpdGhTZXF1ZW5jZS5zZXQocmVjb3JkaW5nRGF0YSwgc2VxdWVuY2UubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiBwYXlsb2FkV2l0aFNlcXVlbmNlO1xufVxuXG4vKipcbiAqIFByZXBhcmUgYSByZXBsYXkgZXZlbnQgJiBlbnJpY2ggaXQgd2l0aCB0aGUgU0RLIG1ldGFkYXRhLlxuICovXG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlUmVwbGF5RXZlbnQoe1xuICBjbGllbnQsXG4gIHNjb3BlLFxuICByZXBsYXlJZDogZXZlbnRfaWQsXG4gIGV2ZW50LFxufVxuXG4pIHtcbiAgY29uc3QgaW50ZWdyYXRpb25zID1cbiAgICB0eXBlb2YgY2xpZW50WydfaW50ZWdyYXRpb25zJ10gPT09ICdvYmplY3QnICYmXG4gICAgY2xpZW50WydfaW50ZWdyYXRpb25zJ10gIT09IG51bGwgJiZcbiAgICAhQXJyYXkuaXNBcnJheShjbGllbnRbJ19pbnRlZ3JhdGlvbnMnXSlcbiAgICAgID8gT2JqZWN0LmtleXMoY2xpZW50WydfaW50ZWdyYXRpb25zJ10pXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICBjb25zdCBldmVudEhpbnQgPSB7IGV2ZW50X2lkLCBpbnRlZ3JhdGlvbnMgfTtcblxuICBjbGllbnQuZW1pdCgncHJlcHJvY2Vzc0V2ZW50JywgZXZlbnQsIGV2ZW50SGludCk7XG5cbiAgY29uc3QgcHJlcGFyZWRFdmVudCA9IChhd2FpdCBwcmVwYXJlRXZlbnQoXG4gICAgY2xpZW50LmdldE9wdGlvbnMoKSxcbiAgICBldmVudCxcbiAgICBldmVudEhpbnQsXG4gICAgc2NvcGUsXG4gICAgY2xpZW50LFxuICAgIGdldElzb2xhdGlvblNjb3BlKCksXG4gICkpIDtcblxuICAvLyBJZiBlLmcuIGEgZ2xvYmFsIGV2ZW50IHByb2Nlc3NvciByZXR1cm5lZCBudWxsXG4gIGlmICghcHJlcGFyZWRFdmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY2xpZW50LmVtaXQoJ3Bvc3Rwcm9jZXNzRXZlbnQnLCBwcmVwYXJlZEV2ZW50LCBldmVudEhpbnQpO1xuXG4gIC8vIFRoaXMgbm9ybWFsbHkgaGFwcGVucyBpbiBicm93c2VyIGNsaWVudCBcIl9wcmVwYXJlRXZlbnRcIlxuICAvLyBidXQgc2luY2Ugd2UgZG8gbm90IHVzZSB0aGlzIHByaXZhdGUgbWV0aG9kIGZyb20gdGhlIGNsaWVudCwgYnV0IHJhdGhlciB0aGUgcGxhaW4gaW1wb3J0XG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBtYW51YWxseS5cbiAgcHJlcGFyZWRFdmVudC5wbGF0Zm9ybSA9IHByZXBhcmVkRXZlbnQucGxhdGZvcm0gfHwgJ2phdmFzY3JpcHQnO1xuXG4gIC8vIGV4dHJhY3QgdGhlIFNESyBuYW1lIGJlY2F1c2UgYGNsaWVudC5fcHJlcGFyZUV2ZW50YCBkb2Vzbid0IGFkZCBpdCB0byB0aGUgZXZlbnRcbiAgY29uc3QgbWV0YWRhdGEgPSBjbGllbnQuZ2V0U2RrTWV0YWRhdGEoKTtcbiAgY29uc3QgeyBuYW1lLCB2ZXJzaW9uIH0gPSBtZXRhZGF0YT8uc2RrIHx8IHt9O1xuXG4gIHByZXBhcmVkRXZlbnQuc2RrID0ge1xuICAgIC4uLnByZXBhcmVkRXZlbnQuc2RrLFxuICAgIG5hbWU6IG5hbWUgfHwgJ3NlbnRyeS5qYXZhc2NyaXB0LnVua25vd24nLFxuICAgIHZlcnNpb246IHZlcnNpb24gfHwgJzAuMC4wJyxcbiAgfTtcblxuICByZXR1cm4gcHJlcGFyZWRFdmVudDtcbn1cblxuLyoqXG4gKiBTZW5kIHJlcGxheSBhdHRhY2htZW50IHVzaW5nIGBmZXRjaCgpYFxuICovXG5hc3luYyBmdW5jdGlvbiBzZW5kUmVwbGF5UmVxdWVzdCh7XG4gIHJlY29yZGluZ0RhdGEsXG4gIHJlcGxheUlkLFxuICBzZWdtZW50SWQ6IHNlZ21lbnRfaWQsXG4gIGV2ZW50Q29udGV4dCxcbiAgdGltZXN0YW1wLFxuICBzZXNzaW9uLFxufSkge1xuICBjb25zdCBwcmVwYXJlZFJlY29yZGluZ0RhdGEgPSBwcmVwYXJlUmVjb3JkaW5nRGF0YSh7XG4gICAgcmVjb3JkaW5nRGF0YSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBzZWdtZW50X2lkLFxuICAgIH0sXG4gIH0pO1xuXG4gIGNvbnN0IHsgdXJscywgZXJyb3JJZHMsIHRyYWNlSWRzLCBpbml0aWFsVGltZXN0YW1wIH0gPSBldmVudENvbnRleHQ7XG5cbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG4gIGNvbnN0IHNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKCk7XG4gIGNvbnN0IHRyYW5zcG9ydCA9IGNsaWVudD8uZ2V0VHJhbnNwb3J0KCk7XG4gIGNvbnN0IGRzbiA9IGNsaWVudD8uZ2V0RHNuKCk7XG5cbiAgaWYgKCFjbGllbnQgfHwgIXRyYW5zcG9ydCB8fCAhZHNuIHx8ICFzZXNzaW9uLnNhbXBsZWQpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWRTeW5jUHJvbWlzZSh7fSk7XG4gIH1cblxuICBjb25zdCBiYXNlRXZlbnQgPSB7XG4gICAgdHlwZTogUkVQTEFZX0VWRU5UX05BTUUsXG4gICAgcmVwbGF5X3N0YXJ0X3RpbWVzdGFtcDogaW5pdGlhbFRpbWVzdGFtcCAvIDEwMDAsXG4gICAgdGltZXN0YW1wOiB0aW1lc3RhbXAgLyAxMDAwLFxuICAgIGVycm9yX2lkczogZXJyb3JJZHMsXG4gICAgdHJhY2VfaWRzOiB0cmFjZUlkcyxcbiAgICB1cmxzLFxuICAgIHJlcGxheV9pZDogcmVwbGF5SWQsXG4gICAgc2VnbWVudF9pZCxcbiAgICByZXBsYXlfdHlwZTogc2Vzc2lvbi5zYW1wbGVkLFxuICB9O1xuXG4gIGNvbnN0IHJlcGxheUV2ZW50ID0gYXdhaXQgcHJlcGFyZVJlcGxheUV2ZW50KHsgc2NvcGUsIGNsaWVudCwgcmVwbGF5SWQsIGV2ZW50OiBiYXNlRXZlbnQgfSk7XG5cbiAgaWYgKCFyZXBsYXlFdmVudCkge1xuICAgIC8vIFRha2VuIGZyb20gYmFzZWNsaWVudCdzIGBfcHJvY2Vzc0V2ZW50YCBtZXRob2QsIHdoZXJlIHRoaXMgaXMgaGFuZGxlZCBmb3IgZXJyb3JzL3RyYW5zYWN0aW9uc1xuICAgIGNsaWVudC5yZWNvcmREcm9wcGVkRXZlbnQoJ2V2ZW50X3Byb2Nlc3NvcicsICdyZXBsYXknKTtcbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIuaW5mbygnQW4gZXZlbnQgcHJvY2Vzc29yIHJldHVybmVkIGBudWxsYCwgd2lsbCBub3Qgc2VuZCBldmVudC4nKTtcbiAgICByZXR1cm4gcmVzb2x2ZWRTeW5jUHJvbWlzZSh7fSk7XG4gIH1cblxuICAvKlxuICBGb3IgcmVmZXJlbmNlLCB0aGUgZnVsbHkgYnVpbHQgZXZlbnQgbG9va3Mgc29tZXRoaW5nIGxpa2UgdGhpczpcbiAge1xuICAgICAgXCJ0eXBlXCI6IFwicmVwbGF5X2V2ZW50XCIsXG4gICAgICBcInRpbWVzdGFtcFwiOiAxNjcwODM3MDA4LjYzNCxcbiAgICAgIFwiZXJyb3JfaWRzXCI6IFtcbiAgICAgICAgICBcImVycm9ySWRcIlxuICAgICAgXSxcbiAgICAgIFwidHJhY2VfaWRzXCI6IFtcbiAgICAgICAgICBcInRyYWNlSWRcIlxuICAgICAgXSxcbiAgICAgIFwidXJsc1wiOiBbXG4gICAgICAgICAgXCJodHRwczovL2V4YW1wbGUuY29tXCJcbiAgICAgIF0sXG4gICAgICBcInJlcGxheV9pZFwiOiBcImV2ZW50SWRcIixcbiAgICAgIFwic2VnbWVudF9pZFwiOiAzLFxuICAgICAgXCJyZXBsYXlfdHlwZVwiOiBcImVycm9yXCIsXG4gICAgICBcInBsYXRmb3JtXCI6IFwiamF2YXNjcmlwdFwiLFxuICAgICAgXCJldmVudF9pZFwiOiBcImV2ZW50SWRcIixcbiAgICAgIFwiZW52aXJvbm1lbnRcIjogXCJwcm9kdWN0aW9uXCIsXG4gICAgICBcInNka1wiOiB7XG4gICAgICAgICAgXCJpbnRlZ3JhdGlvbnNcIjogW1xuICAgICAgICAgICAgICBcIkJyb3dzZXJUcmFjaW5nXCIsXG4gICAgICAgICAgICAgIFwiUmVwbGF5XCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcInNlbnRyeS5qYXZhc2NyaXB0LmJyb3dzZXJcIixcbiAgICAgICAgICBcInZlcnNpb25cIjogXCI3LjI1LjBcIlxuICAgICAgfSxcbiAgICAgIFwic2RrUHJvY2Vzc2luZ01ldGFkYXRhXCI6IHt9LFxuICAgICAgXCJjb250ZXh0c1wiOiB7XG4gICAgICB9LFxuICB9XG4gICovXG5cbiAgLy8gUHJldmVudCB0aGlzIGRhdGEgKHdoaWNoLCBpZiBpdCBleGlzdHMsIHdhcyB1c2VkIGluIGVhcmxpZXIgc3RlcHMgaW4gdGhlIHByb2Nlc3NpbmcgcGlwZWxpbmUpIGZyb20gYmVpbmcgc2VudCB0b1xuICAvLyBzZW50cnkuIChOb3RlOiBPdXIgdXNlIG9mIHRoaXMgcHJvcGVydHkgY29tZXMgYW5kIGdvZXMgd2l0aCB3aGF0ZXZlciB3ZSBtaWdodCBiZSBkZWJ1Z2dpbmcsIHdoYXRldmVyIGhhY2tzIHdlIG1heVxuICAvLyBoYXZlIHRlbXBvcmFyaWx5IGFkZGVkLCBldGMuIEV2ZW4gaWYgd2UgZG9uJ3QgaGFwcGVuIHRvIGJlIHVzaW5nIGl0IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZSwgbGV0J3Mgbm90IGdldCByaWRcbiAgLy8gb2YgdGhpcyBgZGVsZXRlYCwgbGVzdCB3ZSBtaXNzIHB1dHRpbmcgaXQgYmFjayBpbiB0aGUgbmV4dCB0aW1lIHRoZSBwcm9wZXJ0eSBpcyBpbiB1c2UuKVxuICBkZWxldGUgcmVwbGF5RXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhO1xuXG4gIGNvbnN0IGVudmVsb3BlID0gY3JlYXRlUmVwbGF5RW52ZWxvcGUocmVwbGF5RXZlbnQsIHByZXBhcmVkUmVjb3JkaW5nRGF0YSwgZHNuLCBjbGllbnQuZ2V0T3B0aW9ucygpLnR1bm5lbCk7XG5cbiAgbGV0IHJlc3BvbnNlO1xuXG4gIHRyeSB7XG4gICAgcmVzcG9uc2UgPSBhd2FpdCB0cmFuc3BvcnQuc2VuZChlbnZlbG9wZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFVOQUJMRV9UT19TRU5EX1JFUExBWSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gSW4gY2FzZSBicm93c2VycyBkb24ndCBhbGxvdyB0aGlzIHByb3BlcnR5IHRvIGJlIHdyaXRhYmxlXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRoaXMgbmVlZHMgbGliIGVzMjAyMiBhbmQgbmV3ZXJcbiAgICAgIGVycm9yLmNhdXNlID0gZXJyO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIElmIHRoZSBzdGF0dXMgY29kZSBpcyBpbnZhbGlkLCB3ZSB3YW50IHRvIGltbWVkaWF0ZWx5IHN0b3AgJiBub3QgcmV0cnlcbiAgaWYgKHR5cGVvZiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAnbnVtYmVyJyAmJiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXNDb2RlID49IDMwMCkpIHtcbiAgICB0aHJvdyBuZXcgVHJhbnNwb3J0U3RhdHVzQ29kZUVycm9yKHJlc3BvbnNlLnN0YXR1c0NvZGUpO1xuICB9XG5cbiAgY29uc3QgcmF0ZUxpbWl0cyA9IHVwZGF0ZVJhdGVMaW1pdHMoe30sIHJlc3BvbnNlKTtcbiAgaWYgKGlzUmF0ZUxpbWl0ZWQocmF0ZUxpbWl0cywgJ3JlcGxheScpKSB7XG4gICAgdGhyb3cgbmV3IFJhdGVMaW1pdEVycm9yKHJhdGVMaW1pdHMpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG4vKipcbiAqIFRoaXMgZXJyb3IgaW5kaWNhdGVzIHRoYXQgdGhlIHRyYW5zcG9ydCByZXR1cm5lZCBhbiBpbnZhbGlkIHN0YXR1cyBjb2RlLlxuICovXG5jbGFzcyBUcmFuc3BvcnRTdGF0dXNDb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlKSB7XG4gICAgc3VwZXIoYFRyYW5zcG9ydCByZXR1cm5lZCBzdGF0dXMgY29kZSAke3N0YXR1c0NvZGV9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGVycm9yIGluZGljYXRlcyB0aGF0IHdlIGhpdCBhIHJhdGUgbGltaXQgQVBJIGVycm9yLlxuICovXG5jbGFzcyBSYXRlTGltaXRFcnJvciBleHRlbmRzIEVycm9yIHtcblxuICAgY29uc3RydWN0b3IocmF0ZUxpbWl0cykge1xuICAgIHN1cGVyKCdSYXRlIGxpbWl0IGhpdCcpO1xuICAgIHRoaXMucmF0ZUxpbWl0cyA9IHJhdGVMaW1pdHM7XG4gIH1cbn1cblxuLyoqXG4gKiBGaW5hbGl6ZSBhbmQgc2VuZCB0aGUgY3VycmVudCByZXBsYXkgZXZlbnQgdG8gU2VudHJ5XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlbmRSZXBsYXkoXG4gIHJlcGxheURhdGEsXG4gIHJldHJ5Q29uZmlnID0ge1xuICAgIGNvdW50OiAwLFxuICAgIGludGVydmFsOiBSRVRSWV9CQVNFX0lOVEVSVkFMLFxuICB9LFxuKSB7XG4gIGNvbnN0IHsgcmVjb3JkaW5nRGF0YSwgb25FcnJvciB9ID0gcmVwbGF5RGF0YTtcblxuICAvLyBzaG9ydCBjaXJjdWl0IGlmIHRoZXJlJ3Mgbm8gZXZlbnRzIHRvIHVwbG9hZCAodGhpcyBzaG91bGRuJ3QgaGFwcGVuIGFzIF9ydW5GbHVzaCBtYWtlcyB0aGlzIGNoZWNrKVxuICBpZiAoIXJlY29yZGluZ0RhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBzZW5kUmVwbGF5UmVxdWVzdChyZXBsYXlEYXRhKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFRyYW5zcG9ydFN0YXR1c0NvZGVFcnJvciB8fCBlcnIgaW5zdGFuY2VvZiBSYXRlTGltaXRFcnJvcikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIC8vIENhcHR1cmUgZXJyb3IgZm9yIGV2ZXJ5IGZhaWxlZCByZXBsYXlcbiAgICBzZXRDb250ZXh0KCdSZXBsYXlzJywge1xuICAgICAgX3JldHJ5Q291bnQ6IHJldHJ5Q29uZmlnLmNvdW50LFxuICAgIH0pO1xuXG4gICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhbiBlcnJvciBoYXBwZW5lZCBoZXJlLCBpdCdzIGxpa2VseSB0aGF0IHVwbG9hZGluZyB0aGUgYXR0YWNobWVudFxuICAgIC8vIGZhaWxlZCwgd2UnbGwgY2FuIHJldHJ5IHdpdGggdGhlIHNhbWUgZXZlbnRzIHBheWxvYWRcbiAgICBpZiAocmV0cnlDb25maWcuY291bnQgPj0gUkVUUllfTUFYX0NPVU5UKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgJHtVTkFCTEVfVE9fU0VORF9SRVBMQVl9IC0gbWF4IHJldHJpZXMgZXhjZWVkZWRgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW4gY2FzZSBicm93c2VycyBkb24ndCBhbGxvdyB0aGlzIHByb3BlcnR5IHRvIGJlIHdyaXRhYmxlXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBuZWVkcyBsaWIgZXMyMDIyIGFuZCBuZXdlclxuICAgICAgICBlcnJvci5jYXVzZSA9IGVycjtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIHdpbGwgcmV0cnkgaW4gaW50ZXJ2YWxzIG9mIDUsIDEwLCAzMFxuICAgIHJldHJ5Q29uZmlnLmludGVydmFsICo9ICsrcmV0cnlDb25maWcuY291bnQ7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc2V0VGltZW91dCQzKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBzZW5kUmVwbGF5KHJlcGxheURhdGEsIHJldHJ5Q29uZmlnKTtcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmV0cnlDb25maWcuaW50ZXJ2YWwpO1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IFRIUk9UVExFRCA9ICdfX1RIUk9UVExFRCc7XG5jb25zdCBTS0lQUEVEID0gJ19fU0tJUFBFRCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIG9mZiBhIGdpdmVuIGZ1bmN0aW9uLlxuICogV2hlbiBjYWxsaW5nIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24sIGl0IHdpbGwgY2FsbCB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gb25seVxuICogaWYgaXQgaGFzbid0IGJlZW4gY2FsbGVkIG1vcmUgdGhhbiBgbWF4Q291bnRgIHRpbWVzIGluIHRoZSBsYXN0IGBkdXJhdGlvblNlY29uZHNgLlxuICpcbiAqIFJldHVybnMgYFRIUk9UVExFRGAgaWYgdGhyb3R0bGVkIGZvciB0aGUgZmlyc3QgdGltZSwgYWZ0ZXIgdGhhdCBgU0tJUFBFRGAsXG4gKiBvciBlbHNlIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdGhyb3R0bGUoXG4gIGZuLFxuICBtYXhDb3VudCxcbiAgZHVyYXRpb25TZWNvbmRzLFxuKSB7XG4gIGNvbnN0IGNvdW50ZXIgPSBuZXcgTWFwKCk7XG5cbiAgY29uc3QgX2NsZWFudXAgPSAobm93KSA9PiB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gbm93IC0gZHVyYXRpb25TZWNvbmRzO1xuICAgIGNvdW50ZXIuZm9yRWFjaCgoX3ZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmIChrZXkgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgY291bnRlci5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBfZ2V0VG90YWxDb3VudCA9ICgpID0+IHtcbiAgICByZXR1cm4gWy4uLmNvdW50ZXIudmFsdWVzKCldLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICB9O1xuXG4gIGxldCBpc1Rocm90dGxlZCA9IGZhbHNlO1xuXG4gIHJldHVybiAoLi4ucmVzdCkgPT4ge1xuICAgIC8vIERhdGUgaW4gc2Vjb25kLXByZWNpc2lvbiwgd2hpY2ggd2UgdXNlIGFzIGJhc2lzIGZvciB0aGUgdGhyb3R0bGluZ1xuICAgIGNvbnN0IG5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuXG4gICAgLy8gRmlyc3QsIG1ha2Ugc3VyZSB0byBkZWxldGUgYW55IG9sZCBlbnRyaWVzXG4gICAgX2NsZWFudXAobm93KTtcblxuICAgIC8vIElmIGFscmVhZHkgb3ZlciBsaW1pdCwgZG8gbm90aGluZ1xuICAgIGlmIChfZ2V0VG90YWxDb3VudCgpID49IG1heENvdW50KSB7XG4gICAgICBjb25zdCB3YXNUaHJvdHRsZWQgPSBpc1Rocm90dGxlZDtcbiAgICAgIGlzVGhyb3R0bGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB3YXNUaHJvdHRsZWQgPyBTS0lQUEVEIDogVEhST1RUTEVEO1xuICAgIH1cblxuICAgIGlzVGhyb3R0bGVkID0gZmFsc2U7XG4gICAgY29uc3QgY291bnQgPSBjb3VudGVyLmdldChub3cpIHx8IDA7XG4gICAgY291bnRlci5zZXQobm93LCBjb3VudCArIDEpO1xuXG4gICAgcmV0dXJuIGZuKC4uLnJlc3QpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBtYWluIHJlcGxheSBjb250YWluZXIgY2xhc3MsIHdoaWNoIGhvbGRzIGFsbCB0aGUgc3RhdGUgYW5kIG1ldGhvZHMgZm9yIHJlY29yZGluZyBhbmQgc2VuZGluZyByZXBsYXlzLlxuICovXG5jbGFzcyBSZXBsYXlDb250YWluZXIgIHtcblxuICAvKipcbiAgICogUmVjb3JkaW5nIGNhbiBoYXBwZW4gaW4gb25lIG9mIHR3byBtb2RlczpcbiAgICogICAtIHNlc3Npb246IFJlY29yZCB0aGUgd2hvbGUgc2Vzc2lvbiwgc2VuZGluZyBpdCBjb250aW51b3VzbHlcbiAgICogICAtIGJ1ZmZlcjogQWx3YXlzIGtlZXAgdGhlIGxhc3QgNjBzIG9mIHJlY29yZGluZywgcmVxdWlyZXM6XG4gICAqICAgICAtIGhhdmluZyByZXBsYXlzT25FcnJvclNhbXBsZVJhdGUgPiAwIHRvIGNhcHR1cmUgcmVwbGF5IHdoZW4gYW4gZXJyb3Igb2NjdXJzXG4gICAqICAgICAtIG9yIGNhbGxpbmcgYGZsdXNoKClgIHRvIHNlbmQgdGhlIHJlcGxheVxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgb3IgbGFzdCBhY3RpdmUgc3Bhbi5cbiAgICogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHBlcmZvcm1hbmNlIGlzIGVuYWJsZWQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgaGVyZSBzbyB3ZSBjYW4gb3ZlcndyaXRlIHRoZW0gaW4gdGVzdHMgZXRjLlxuICAgKiBAaGlkZGVuXG4gICAqL1xuXG4gIC8qKiBUaGUgcmVwbGF5IGhhcyB0byBiZSBtYW51YWxseSBzdGFydGVkLCBiZWNhdXNlIG5vIHNhbXBsZSByYXRlIChuZWl0aGVyIHNlc3Npb24gb3IgZXJyb3IpIHdhcyBwcm92aWRlZC4gKi9cblxuICAvKipcbiAgICogT3B0aW9ucyB0byBwYXNzIHRvIGBycndlYi5yZWNvcmQoKWBcbiAgICovXG5cbiAgLyoqXG4gICAqIFRpbWVzdGFtcCBvZiB0aGUgbGFzdCB1c2VyIGFjdGl2aXR5LiBUaGlzIGxpdmVzIGFjcm9zcyBzZXNzaW9ucy5cbiAgICovXG5cbiAgLyoqXG4gICAqIElzIHRoZSBpbnRlZ3JhdGlvbiBjdXJyZW50bHkgYWN0aXZlP1xuICAgKi9cblxuICAvKipcbiAgICogUGF1c2VkIGlzIGEgc3RhdGUgd2hlcmU6XG4gICAqIC0gRE9NIFJlY29yZGluZyBpcyBub3QgbGlzdGVuaW5nIGF0IGFsbFxuICAgKiAtIE5vdGhpbmcgd2lsbCBiZSBhZGRlZCB0byBldmVudCBidWZmZXIgKGUuZy4gY29yZSBTREsgZXZlbnRzKVxuICAgKi9cblxuICAvKipcbiAgICogSGF2ZSB3ZSBhdHRhY2hlZCBsaXN0ZW5lcnMgdG8gdGhlIGNvcmUgU0RLP1xuICAgKiBOb3RlIHdlIGhhdmUgdG8gdHJhY2sgdGhpcyBhcyB0aGVyZSBpcyBubyB3YXkgdG8gcmVtb3ZlIGluc3RydW1lbnRhdGlvbiBoYW5kbGVycy5cbiAgICovXG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRvIHN0b3AgcmVjb3JkaW5nXG4gICAqL1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCB1c2UgZm9yIGNhbnZhcyByZWNvcmRpbmcgb3B0aW9uc1xuICAgKi9cblxuICAvKipcbiAgICogSGFuZGxlIHdoZW4gdmlzaWJpbGl0eSBvZiB0aGUgcGFnZSBjb250ZW50IGNoYW5nZXMuIE9wZW5pbmcgYSBuZXcgdGFiIHdpbGxcbiAgICogY2F1c2UgdGhlIHN0YXRlIHRvIGNoYW5nZSB0byBoaWRkZW4gYmVjYXVzZSBvZiBjb250ZW50IG9mIGN1cnJlbnQgcGFnZSB3aWxsXG4gICAqIGJlIGhpZGRlbi4gTGlrZXdpc2UsIG1vdmluZyBhIGRpZmZlcmVudCB3aW5kb3cgdG8gY292ZXIgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgKiBwYWdlIHdpbGwgYWxzbyB0cmlnZ2VyIGEgY2hhbmdlIHRvIGEgaGlkZGVuIHN0YXRlLlxuICAgKi9cblxuICAvKipcbiAgICogSGFuZGxlIHdoZW4gcGFnZSBpcyBibHVycmVkXG4gICAqL1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgd2hlbiBwYWdlIGlzIGZvY3VzZWRcbiAgICovXG5cbiAgLyoqIEVuc3VyZSBwYWdlIHJlbWFpbnMgYWN0aXZlIHdoZW4gYSBrZXkgaXMgcHJlc3NlZC4gKi9cblxuICAgY29uc3RydWN0b3Ioe1xuICAgIG9wdGlvbnMsXG4gICAgcmVjb3JkaW5nT3B0aW9ucyxcbiAgfVxuXG4pIHtcbiAgICB0aGlzLmV2ZW50QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnBlcmZvcm1hbmNlRW50cmllcyA9IFtdO1xuICAgIHRoaXMucmVwbGF5UGVyZm9ybWFuY2VFbnRyaWVzID0gW107XG4gICAgdGhpcy5yZWNvcmRpbmdNb2RlID0gJ3Nlc3Npb24nO1xuICAgIHRoaXMudGltZW91dHMgPSB7XG4gICAgICBzZXNzaW9uSWRsZVBhdXNlOiBTRVNTSU9OX0lETEVfUEFVU0VfRFVSQVRJT04sXG4gICAgICBzZXNzaW9uSWRsZUV4cGlyZTogU0VTU0lPTl9JRExFX0VYUElSRV9EVVJBVElPTixcbiAgICB9IDtcbiAgICB0aGlzLl9sYXN0QWN0aXZpdHkgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVxdWlyZXNNYW51YWxTdGFydCA9IGZhbHNlO1xuICAgIHRoaXMuX2hhc0luaXRpYWxpemVkQ29yZUxpc3RlbmVycyA9IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRleHQgPSB7XG4gICAgICBlcnJvcklkczogbmV3IFNldCgpLFxuICAgICAgdHJhY2VJZHM6IG5ldyBTZXQoKSxcbiAgICAgIHVybHM6IFtdLFxuICAgICAgaW5pdGlhbFRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIGluaXRpYWxVcmw6ICcnLFxuICAgIH07XG5cbiAgICB0aGlzLl9yZWNvcmRpbmdPcHRpb25zID0gcmVjb3JkaW5nT3B0aW9ucztcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMuX2RlYm91bmNlZEZsdXNoID0gZGVib3VuY2UoKCkgPT4gdGhpcy5fZmx1c2goKSwgdGhpcy5fb3B0aW9ucy5mbHVzaE1pbkRlbGF5LCB7XG4gICAgICBtYXhXYWl0OiB0aGlzLl9vcHRpb25zLmZsdXNoTWF4RGVsYXksXG4gICAgfSk7XG5cbiAgICB0aGlzLl90aHJvdHRsZWRBZGRFdmVudCA9IHRocm90dGxlKFxuICAgICAgKGV2ZW50LCBpc0NoZWNrb3V0KSA9PiBhZGRFdmVudCh0aGlzLCBldmVudCwgaXNDaGVja291dCksXG4gICAgICAvLyBNYXggMzAwIGV2ZW50cy4uLlxuICAgICAgMzAwLFxuICAgICAgLy8gLi4uIHBlciA1c1xuICAgICAgNSxcbiAgICApO1xuXG4gICAgY29uc3QgeyBzbG93Q2xpY2tUaW1lb3V0LCBzbG93Q2xpY2tJZ25vcmVTZWxlY3RvcnMgfSA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuXG4gICAgY29uc3Qgc2xvd0NsaWNrQ29uZmlnID0gc2xvd0NsaWNrVGltZW91dFxuICAgICAgPyB7XG4gICAgICAgICAgdGhyZXNob2xkOiBNYXRoLm1pbihTTE9XX0NMSUNLX1RIUkVTSE9MRCwgc2xvd0NsaWNrVGltZW91dCksXG4gICAgICAgICAgdGltZW91dDogc2xvd0NsaWNrVGltZW91dCxcbiAgICAgICAgICBzY3JvbGxUaW1lb3V0OiBTTE9XX0NMSUNLX1NDUk9MTF9USU1FT1VULFxuICAgICAgICAgIGlnbm9yZVNlbGVjdG9yOiBzbG93Q2xpY2tJZ25vcmVTZWxlY3RvcnMgPyBzbG93Q2xpY2tJZ25vcmVTZWxlY3RvcnMuam9pbignLCcpIDogJycsXG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHNsb3dDbGlja0NvbmZpZykge1xuICAgICAgdGhpcy5jbGlja0RldGVjdG9yID0gbmV3IENsaWNrRGV0ZWN0b3IodGhpcywgc2xvd0NsaWNrQ29uZmlnKTtcbiAgICB9XG5cbiAgICAvLyBDb25maWd1cmUgcmVwbGF5IGxvZ2dlciB3LyBleHBlcmltZW50YWwgb3B0aW9uc1xuICAgIGlmIChERUJVR19CVUlMRCkge1xuICAgICAgY29uc3QgZXhwZXJpbWVudHMgPSBvcHRpb25zLl9leHBlcmltZW50cztcbiAgICAgIGxvZ2dlci5zZXRDb25maWcoe1xuICAgICAgICBjYXB0dXJlRXhjZXB0aW9uczogISFleHBlcmltZW50cy5jYXB0dXJlRXhjZXB0aW9ucyxcbiAgICAgICAgdHJhY2VJbnRlcm5hbHM6ICEhZXhwZXJpbWVudHMudHJhY2VJbnRlcm5hbHMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBXZSBzZXQgdGhlc2UgaGFuZGxlciBwcm9wZXJ0aWVzIGFzIGNsYXNzIHByb3BlcnRpZXMsIHRvIG1ha2UgYmluZGluZy91bmJpbmRpbmcgdGhlbSBlYXNpZXJcbiAgICB0aGlzLl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYgKFdJTkRPVy5kb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgICB0aGlzLl9kb0NoYW5nZVRvRm9yZWdyb3VuZFRhc2tzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kb0NoYW5nZVRvQmFja2dyb3VuZFRhc2tzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB3aGVuIHBhZ2UgaXMgYmx1cnJlZFxuICAgICAqL1xuICAgIHRoaXMuX2hhbmRsZVdpbmRvd0JsdXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBicmVhZGNydW1iID0gY3JlYXRlQnJlYWRjcnVtYih7XG4gICAgICAgIGNhdGVnb3J5OiAndWkuYmx1cicsXG4gICAgICB9KTtcblxuICAgICAgLy8gRG8gbm90IGNvdW50IGJsdXIgYXMgYSB1c2VyIGFjdGlvbiAtLSBpdCdzIHBhcnQgb2YgdGhlIHByb2Nlc3Mgb2YgdGhlbVxuICAgICAgLy8gbGVhdmluZyB0aGUgcGFnZVxuICAgICAgdGhpcy5fZG9DaGFuZ2VUb0JhY2tncm91bmRUYXNrcyhicmVhZGNydW1iKTtcbiAgICB9O1xuXG4gICAgdGhpcy5faGFuZGxlV2luZG93Rm9jdXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBicmVhZGNydW1iID0gY3JlYXRlQnJlYWRjcnVtYih7XG4gICAgICAgIGNhdGVnb3J5OiAndWkuZm9jdXMnLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIERvIG5vdCBjb3VudCBmb2N1cyBhcyBhIHVzZXIgYWN0aW9uIC0tIGluc3RlYWQgd2FpdCB1bnRpbCB0aGV5IGZvY3VzIGFuZFxuICAgICAgLy8gaW50ZXJhY3RpdmUgd2l0aCBwYWdlXG4gICAgICB0aGlzLl9kb0NoYW5nZVRvRm9yZWdyb3VuZFRhc2tzKGJyZWFkY3J1bWIpO1xuICAgIH07XG5cbiAgICAvKiogRW5zdXJlIHBhZ2UgcmVtYWlucyBhY3RpdmUgd2hlbiBhIGtleSBpcyBwcmVzc2VkLiAqL1xuICAgIHRoaXMuX2hhbmRsZUtleWJvYXJkRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICAgIGhhbmRsZUtleWJvYXJkRXZlbnQodGhpcywgZXZlbnQpO1xuICAgIH07XG4gIH1cblxuICAvKiogR2V0IHRoZSBldmVudCBjb250ZXh0LiAqL1xuICAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcbiAgfVxuXG4gIC8qKiBJZiByZWNvcmRpbmcgaXMgY3VycmVudGx5IGVuYWJsZWQuICovXG4gICBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzRW5hYmxlZDtcbiAgfVxuXG4gIC8qKiBJZiByZWNvcmRpbmcgaXMgY3VycmVudGx5IHBhdXNlZC4gKi9cbiAgIGlzUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1BhdXNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgY2FudmFzIHJlY29yZGluZyBpcyBlbmFibGVkXG4gICAqL1xuICAgaXNSZWNvcmRpbmdDYW52YXMoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fY2FudmFzKTtcbiAgfVxuXG4gIC8qKiBHZXQgdGhlIHJlcGxheSBpbnRlZ3JhdGlvbiBvcHRpb25zLiAqL1xuICAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIC8qKiBBIHdyYXBwZXIgdG8gY29uZGl0aW9uYWxseSBjYXB0dXJlIGV4Y2VwdGlvbnMuICovXG4gICBoYW5kbGVFeGNlcHRpb24oZXJyb3IpIHtcbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIuZXhjZXB0aW9uKGVycm9yKTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5vbkVycm9yKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLm9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luIGJhc2VkIG9uIHNhbXBsaW5nIGNvbmZpZ3VyYXRpb24uIFNob3VsZCBub3QgYmVcbiAgICogY2FsbGVkIG91dHNpZGUgb2YgY29uc3RydWN0b3IuXG4gICAqL1xuICAgaW5pdGlhbGl6ZVNhbXBsaW5nKHByZXZpb3VzU2Vzc2lvbklkKSB7XG4gICAgY29uc3QgeyBlcnJvclNhbXBsZVJhdGUsIHNlc3Npb25TYW1wbGVSYXRlIH0gPSB0aGlzLl9vcHRpb25zO1xuXG4gICAgLy8gSWYgbmVpdGhlciBzYW1wbGUgcmF0ZSBpcyA+IDAsIHRoZW4gZG8gbm90aGluZyAtIHVzZXIgd2lsbCBuZWVkIHRvIGNhbGwgb25lIG9mXG4gICAgLy8gYHN0YXJ0KClgIG9yIGBzdGFydEJ1ZmZlcmluZ2AgdGhlbXNlbHZlcy5cbiAgICBjb25zdCByZXF1aXJlc01hbnVhbFN0YXJ0ID0gZXJyb3JTYW1wbGVSYXRlIDw9IDAgJiYgc2Vzc2lvblNhbXBsZVJhdGUgPD0gMDtcblxuICAgIHRoaXMuX3JlcXVpcmVzTWFudWFsU3RhcnQgPSByZXF1aXJlc01hbnVhbFN0YXJ0O1xuXG4gICAgaWYgKHJlcXVpcmVzTWFudWFsU3RhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UgaWYgdGhlcmUgaXMgX2FueV8gc2FtcGxlIHJhdGUgc2V0LCB0cnkgdG8gbG9hZCBhbiBleGlzdGluZ1xuICAgIC8vIHNlc3Npb24sIG9yIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgdGhpcy5faW5pdGlhbGl6ZVNlc3Npb25Gb3JTYW1wbGluZyhwcmV2aW91c1Nlc3Npb25JZCk7XG5cbiAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgc29tZXRoaW5nIHdyb25nIGhhcyBvY2N1cnJlZFxuICAgICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmV4Y2VwdGlvbihuZXcgRXJyb3IoJ1VuYWJsZSB0byBpbml0aWFsaXplIGFuZCBjcmVhdGUgc2Vzc2lvbicpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZXNzaW9uLnNhbXBsZWQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBvbmx5IG9jY3VyIGlmIGBlcnJvclNhbXBsZVJhdGVgIGlzIDAgYW5kIHdhcyB1bnNhbXBsZWQgZm9yXG4gICAgICAvLyBzZXNzaW9uLWJhc2VkIHJlcGxheS4gSW4gdGhpcyBjYXNlIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8uXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgc2VnbWVudElkID4gMCwgaXQgbWVhbnMgd2UndmUgcHJldmlvdXNseSBhbHJlYWR5IGNhcHR1cmVkIHRoaXMgc2Vzc2lvblxuICAgIC8vIEluIHRoaXMgY2FzZSwgd2Ugc3RpbGwgd2FudCB0byBjb250aW51ZSBpbiBgc2Vzc2lvbmAgcmVjb3JkaW5nIG1vZGVcbiAgICB0aGlzLnJlY29yZGluZ01vZGUgPSB0aGlzLnNlc3Npb24uc2FtcGxlZCA9PT0gJ2J1ZmZlcicgJiYgdGhpcy5zZXNzaW9uLnNlZ21lbnRJZCA9PT0gMCA/ICdidWZmZXInIDogJ3Nlc3Npb24nO1xuXG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmluZm9UaWNrKGBTdGFydGluZyByZXBsYXkgaW4gJHt0aGlzLnJlY29yZGluZ01vZGV9IG1vZGVgKTtcblxuICAgIHRoaXMuX2luaXRpYWxpemVSZWNvcmRpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIHJlcGxheSByZWdhcmRsZXNzIG9mIHNhbXBsaW5nIHJhdGUuIENhbGxpbmcgdGhpcyB3aWxsIGFsd2F5c1xuICAgKiBjcmVhdGUgYSBuZXcgc2Vzc2lvbi4gV2lsbCBsb2cgYSBtZXNzYWdlIGlmIHJlcGxheSBpcyBhbHJlYWR5IGluIHByb2dyZXNzLlxuICAgKlxuICAgKiBDcmVhdGVzIG9yIGxvYWRzIGEgc2Vzc2lvbiwgYXR0YWNoZXMgbGlzdGVuZXJzIHRvIHZhcnlpbmcgZXZlbnRzIChET00sXG4gICAqIF9wZXJmb3JtYW5jZU9ic2VydmVyLCBSZWNvcmRpbmcsIFNlbnRyeSBTREssIGV0YylcbiAgICovXG4gICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5faXNFbmFibGVkICYmIHRoaXMucmVjb3JkaW5nTW9kZSA9PT0gJ3Nlc3Npb24nKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIuaW5mbygnUmVjb3JkaW5nIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNFbmFibGVkICYmIHRoaXMucmVjb3JkaW5nTW9kZSA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5pbmZvKCdCdWZmZXJpbmcgaXMgaW4gcHJvZ3Jlc3MsIGNhbGwgYGZsdXNoKClgIHRvIHNhdmUgdGhlIHJlcGxheScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5pbmZvVGljaygnU3RhcnRpbmcgcmVwbGF5IGluIHNlc3Npb24gbW9kZScpO1xuXG4gICAgLy8gUmVxdWlyZWQgYXMgdXNlciBhY3Rpdml0eSBpcyBpbml0aWFsbHkgc2V0IGluXG4gICAgLy8gY29uc3RydWN0b3IsIHNvIGlmIGBzdGFydCgpYCBpcyBjYWxsZWQgYWZ0ZXJcbiAgICAvLyBzZXNzaW9uIGlkbGUgZXhwaXJhdGlvbiwgYSByZXBsYXkgd2lsbCBub3QgYmVcbiAgICAvLyBjcmVhdGVkIGR1ZSB0byBhbiBpZGxlIHRpbWVvdXQuXG4gICAgdGhpcy5fdXBkYXRlVXNlckFjdGl2aXR5KCk7XG5cbiAgICBjb25zdCBzZXNzaW9uID0gbG9hZE9yQ3JlYXRlU2Vzc2lvbihcbiAgICAgIHtcbiAgICAgICAgbWF4UmVwbGF5RHVyYXRpb246IHRoaXMuX29wdGlvbnMubWF4UmVwbGF5RHVyYXRpb24sXG4gICAgICAgIHNlc3Npb25JZGxlRXhwaXJlOiB0aGlzLnRpbWVvdXRzLnNlc3Npb25JZGxlRXhwaXJlLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3RpY2t5U2Vzc2lvbjogdGhpcy5fb3B0aW9ucy5zdGlja3lTZXNzaW9uLFxuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsOiBjcmVhdGUgYSBuZXcgc2Vzc2lvbi1iYXNlZCByZXBsYXkgd2hlbiBjYWxsaW5nIGBzdGFydCgpYFxuICAgICAgICBzZXNzaW9uU2FtcGxlUmF0ZTogMSxcbiAgICAgICAgYWxsb3dCdWZmZXJpbmc6IGZhbHNlLFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcblxuICAgIHRoaXMuX2luaXRpYWxpemVSZWNvcmRpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCByZXBsYXkgYnVmZmVyaW5nLiBCdWZmZXJzIHVudGlsIGBmbHVzaCgpYCBpcyBjYWxsZWQgb3IsIGlmXG4gICAqIGByZXBsYXlzT25FcnJvclNhbXBsZVJhdGVgID4gMCwgYW4gZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgIHN0YXJ0QnVmZmVyaW5nKCkge1xuICAgIGlmICh0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5pbmZvKCdCdWZmZXJpbmcgaXMgaW4gcHJvZ3Jlc3MsIGNhbGwgYGZsdXNoKClgIHRvIHNhdmUgdGhlIHJlcGxheScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5pbmZvVGljaygnU3RhcnRpbmcgcmVwbGF5IGluIGJ1ZmZlciBtb2RlJyk7XG5cbiAgICBjb25zdCBzZXNzaW9uID0gbG9hZE9yQ3JlYXRlU2Vzc2lvbihcbiAgICAgIHtcbiAgICAgICAgc2Vzc2lvbklkbGVFeHBpcmU6IHRoaXMudGltZW91dHMuc2Vzc2lvbklkbGVFeHBpcmUsXG4gICAgICAgIG1heFJlcGxheUR1cmF0aW9uOiB0aGlzLl9vcHRpb25zLm1heFJlcGxheUR1cmF0aW9uLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3RpY2t5U2Vzc2lvbjogdGhpcy5fb3B0aW9ucy5zdGlja3lTZXNzaW9uLFxuICAgICAgICBzZXNzaW9uU2FtcGxlUmF0ZTogMCxcbiAgICAgICAgYWxsb3dCdWZmZXJpbmc6IHRydWUsXG4gICAgICB9LFxuICAgICk7XG5cbiAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuXG4gICAgdGhpcy5yZWNvcmRpbmdNb2RlID0gJ2J1ZmZlcic7XG4gICAgdGhpcy5faW5pdGlhbGl6ZVJlY29yZGluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHJlY29yZGluZy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCBjYXVzZSBhIG5ldyBET00gY2hlY2tvdXRcbiAgICovXG4gICBzdGFydFJlY29yZGluZygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FudmFzT3B0aW9ucyA9IHRoaXMuX2NhbnZhcztcblxuICAgICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IHJlY29yZCh7XG4gICAgICAgIC4uLnRoaXMuX3JlY29yZGluZ09wdGlvbnMsXG4gICAgICAgIC8vIFdoZW4gcnVubmluZyBpbiBlcnJvciBzYW1wbGluZyBtb2RlLCB3ZSBuZWVkIHRvIG92ZXJ3cml0ZSBgY2hlY2tvdXRFdmVyeU5tc2BcbiAgICAgICAgLy8gV2l0aG91dCB0aGlzLCBpdCB3b3VsZCByZWNvcmQgZm9yZXZlciwgdW50aWwgYW4gZXJyb3IgaGFwcGVucywgd2hpY2ggd2UgZG9uJ3Qgd2FudFxuICAgICAgICAvLyBpbnN0ZWFkLCB3ZSdsbCBhbHdheXMga2VlcCB0aGUgbGFzdCA2MCBzZWNvbmRzIG9mIHJlcGxheSBiZWZvcmUgYW4gZXJyb3IgaGFwcGVuZWRcbiAgICAgICAgLi4uKHRoaXMucmVjb3JkaW5nTW9kZSA9PT0gJ2J1ZmZlcidcbiAgICAgICAgICA/IHsgY2hlY2tvdXRFdmVyeU5tczogQlVGRkVSX0NIRUNLT1VUX1RJTUUgfVxuICAgICAgICAgIDogLy8gT3RoZXJ3aXNlLCB1c2UgZXhwZXJpbWVudGFsIG9wdGlvbiB3LyBtaW4gY2hlY2tvdXQgdGltZSBvZiA2IG1pbnV0ZXNcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdG8gaW1wcm92ZSBwbGF5YmFjayBzZWVraW5nIGFzIHRoZXJlIGNvdWxkIHBvdGVudGlhbGx5IGJlXG4gICAgICAgICAgICAvLyBsZXNzIG11dGF0aW9ucyB0byBwcm9jZXNzIGluIHRoZSB3b3JzZSBjYXNlcy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBjaGVja291dCBieSBcIk5cIiBldmVudHMgaXMgcHJvYmFibHkgaWRlYWwsIGJ1dCBtZWFucyB3ZSBoYXZlIGxlc3NcbiAgICAgICAgICAgIC8vIGNvbnRyb2wgYWJvdXQgdGhlIG51bWJlciBvZiBjaGVja291dHMgd2UgbWFrZSAod2hpY2ggZ2VuZXJhbGx5XG4gICAgICAgICAgICAvLyBpbmNyZWFzZXMgcmVwbGF5IHNpemUpXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLl9leHBlcmltZW50cy5jb250aW51b3VzQ2hlY2tvdXQgJiYge1xuICAgICAgICAgICAgICAvLyBNaW5pbXVtIGNoZWNrb3V0IHRpbWUgaXMgNiBtaW51dGVzXG4gICAgICAgICAgICAgIGNoZWNrb3V0RXZlcnlObXM6IE1hdGgubWF4KDM2MDAwMCwgdGhpcy5fb3B0aW9ucy5fZXhwZXJpbWVudHMuY29udGludW91c0NoZWNrb3V0KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBlbWl0OiBnZXRIYW5kbGVSZWNvcmRpbmdFbWl0KHRoaXMpLFxuICAgICAgICAuLi5nZXRSZWNvcmRpbmdTYW1wbGluZ09wdGlvbnMoKSxcbiAgICAgICAgb25NdXRhdGlvbjogdGhpcy5fb25NdXRhdGlvbkhhbmRsZXIuYmluZCh0aGlzKSxcbiAgICAgICAgLi4uKGNhbnZhc09wdGlvbnNcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiBjYW52YXNPcHRpb25zLnJlY29yZENhbnZhcyxcbiAgICAgICAgICAgICAgZ2V0Q2FudmFzTWFuYWdlcjogY2FudmFzT3B0aW9ucy5nZXRDYW52YXNNYW5hZ2VyLFxuICAgICAgICAgICAgICBzYW1wbGluZzogY2FudmFzT3B0aW9ucy5zYW1wbGluZyxcbiAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGNhbnZhc09wdGlvbnMuZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7fSksXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuaGFuZGxlRXhjZXB0aW9uKGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSByZWNvcmRpbmcsIGlmIGl0IHdhcyBydW5uaW5nLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgaXQgd2FzIHByZXZpb3VzbHkgc3RvcHBlZCwgb3IgaXMgbm93IHN0b3BwZWQsXG4gICAqIG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gICBzdG9wUmVjb3JkaW5nKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5fc3RvcFJlY29yZGluZykge1xuICAgICAgICB0aGlzLl9zdG9wUmVjb3JkaW5nKCk7XG4gICAgICAgIHRoaXMuX3N0b3BSZWNvcmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5oYW5kbGVFeGNlcHRpb24oZXJyKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudGx5LCB0aGlzIG5lZWRzIHRvIGJlIG1hbnVhbGx5IGNhbGxlZCAoZS5nLiBmb3IgdGVzdHMpLiBTZW50cnkgU0RLXG4gICAqIGRvZXMgbm90IHN1cHBvcnQgYSB0ZWFyZG93blxuICAgKi9cbiAgIGFzeW5jIHN0b3AoeyBmb3JjZUZsdXNoID0gZmFsc2UsIHJlYXNvbiB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IG1vdmUgYF9pc0VuYWJsZWRgIGFmdGVyIGF3YWl0aW5nIGEgZmx1c2gsIG90aGVyd2lzZSB3ZSBjYW5cbiAgICAvLyBlbnRlciBpbnRvIGFuIGluZmluaXRlIGxvb3Agd2hlbiBgc3RvcCgpYCBpcyBjYWxsZWQgd2hpbGUgZmx1c2hpbmcuXG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmluZm8oYFN0b3BwaW5nIFJlcGxheSR7cmVhc29uID8gYCB0cmlnZ2VyZWQgYnkgJHtyZWFzb259YCA6ICcnfWApO1xuXG4gICAgICByZXNldFJlcGxheUlkT25EeW5hbWljU2FtcGxpbmdDb250ZXh0KCk7XG5cbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy5zdG9wUmVjb3JkaW5nKCk7XG5cbiAgICAgIHRoaXMuX2RlYm91bmNlZEZsdXNoLmNhbmNlbCgpO1xuICAgICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUgcmU6IGBfaXNFbmFibGVkYCwgd2UgXCJmb3JjZVwiIGEgZmx1c2gsIGlnbm9yaW5nIHRoZVxuICAgICAgLy8gYF9pc0VuYWJsZWRgIHN0YXRlIG9mIHRoZSBwbHVnaW4gc2luY2UgaXQgd2FzIGRpc2FibGVkIGFib3ZlLlxuICAgICAgaWYgKGZvcmNlRmx1c2gpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZmx1c2goeyBmb3JjZTogdHJ1ZSB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQWZ0ZXIgZmx1c2gsIGRlc3Ryb3kgZXZlbnQgYnVmZmVyXG4gICAgICB0aGlzLmV2ZW50QnVmZmVyPy5kZXN0cm95KCk7XG4gICAgICB0aGlzLmV2ZW50QnVmZmVyID0gbnVsbDtcblxuICAgICAgLy8gQ2xlYXIgc2Vzc2lvbiBmcm9tIHNlc3Npb24gc3RvcmFnZSwgbm90ZSB0aGlzIG1lYW5zIGlmIGEgbmV3IHNlc3Npb25cbiAgICAgIC8vIGlzIHN0YXJ0ZWQgYWZ0ZXIsIGl0IHdpbGwgbm90IGhhdmUgYHByZXZpb3VzU2Vzc2lvbklkYFxuICAgICAgY2xlYXJTZXNzaW9uKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5oYW5kbGVFeGNlcHRpb24oZXJyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGF1c2Ugc29tZSByZXBsYXkgZnVuY3Rpb25hbGl0eS4gU2VlIGNvbW1lbnRzIGZvciBgX2lzUGF1c2VkYC5cbiAgICogVGhpcyBkaWZmZXJzIGZyb20gc3RvcCBhcyB0aGlzIG9ubHkgc3RvcHMgRE9NIHJlY29yZGluZywgaXQgaXNcbiAgICogbm90IGFzIHRob3JvdWdoIG9mIGEgc2h1dGRvd24gYXMgYHN0b3AoKWAuXG4gICAqL1xuICAgcGF1c2UoKSB7XG4gICAgaWYgKHRoaXMuX2lzUGF1c2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuc3RvcFJlY29yZGluZygpO1xuXG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmluZm8oJ1BhdXNpbmcgcmVwbGF5Jyk7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lcyByZWNvcmRpbmcsIHNlZSBub3RlcyBmb3IgYHBhdXNlKCkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBjYWxsaW5nIGBzdGFydFJlY29yZGluZygpYCBoZXJlIHdpbGwgY2F1c2UgYVxuICAgKiBuZXcgRE9NIGNoZWNrb3V0LmBcbiAgICovXG4gICByZXN1bWUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1BhdXNlZCB8fCAhdGhpcy5fY2hlY2tTZXNzaW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRSZWNvcmRpbmcoKTtcblxuICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5pbmZvKCdSZXN1bWluZyByZXBsYXknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBub3QgaW4gXCJzZXNzaW9uXCIgcmVjb3JkaW5nIG1vZGUsIGZsdXNoIGV2ZW50IGJ1ZmZlciB3aGljaCB3aWxsIGNyZWF0ZSBhIG5ldyByZXBsYXkuXG4gICAqIFVubGVzcyBgY29udGludWVSZWNvcmRpbmdgIGlzIGZhbHNlLCB0aGUgcmVwbGF5IHdpbGwgY29udGludWUgdG8gcmVjb3JkIGFuZFxuICAgKiBiZWhhdmUgYXMgYSBcInNlc3Npb25cIi1iYXNlZCByZXBsYXkuXG4gICAqXG4gICAqIE90aGVyd2lzZSwgcXVldWUgdXAgYSBmbHVzaC5cbiAgICovXG4gICBhc3luYyBzZW5kQnVmZmVyZWRSZXBsYXlPckZsdXNoKHsgY29udGludWVSZWNvcmRpbmcgPSB0cnVlIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLnJlY29yZGluZ01vZGUgPT09ICdzZXNzaW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuZmx1c2hJbW1lZGlhdGUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3Rpdml0eVRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmluZm8oJ0NvbnZlcnRpbmcgYnVmZmVyIHRvIHNlc3Npb24nKTtcblxuICAgIC8vIEFsbG93IGZsdXNoIHRvIGNvbXBsZXRlIGJlZm9yZSByZXN1bWluZyBhcyBhIHNlc3Npb24gcmVjb3JkaW5nLCBvdGhlcndpc2VcbiAgICAvLyB0aGUgY2hlY2tvdXQgZnJvbSBgc3RhcnRSZWNvcmRpbmdgIG1heSBiZSBpbmNsdWRlZCBpbiB0aGUgcGF5bG9hZC5cbiAgICAvLyBQcmVmZXIgdG8ga2VlcCB0aGUgZXJyb3IgcmVwbGF5IGFzIGEgc2VwYXJhdGUgKGFuZCBzbWFsbGVyKSBzZWdtZW50XG4gICAgLy8gdGhhbiB0aGUgc2Vzc2lvbiByZXBsYXkuXG4gICAgYXdhaXQgdGhpcy5mbHVzaEltbWVkaWF0ZSgpO1xuXG4gICAgY29uc3QgaGFzU3RvcHBlZFJlY29yZGluZyA9IHRoaXMuc3RvcFJlY29yZGluZygpO1xuXG4gICAgaWYgKCFjb250aW51ZVJlY29yZGluZyB8fCAhaGFzU3RvcHBlZFJlY29yZGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucyB3aGVyZSB0aGlzIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcywgd2UgY2hlY2sgaGVyZSBhZ2FpbiB0aGF0IHdlIGFyZSBzdGlsbCBidWZmZXJpbmdcbiAgICBpZiAoKHRoaXMucmVjb3JkaW5nTW9kZSApID09PSAnc2Vzc2lvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZS1zdGFydCByZWNvcmRpbmcgaW4gc2Vzc2lvbi1tb2RlXG4gICAgdGhpcy5yZWNvcmRpbmdNb2RlID0gJ3Nlc3Npb24nO1xuXG4gICAgLy8gT25jZSB0aGlzIHNlc3Npb24gZW5kcywgd2UgZG8gbm90IHdhbnQgdG8gcmVmcmVzaCBpdFxuICAgIGlmICh0aGlzLnNlc3Npb24pIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVVzZXJBY3Rpdml0eShhY3Rpdml0eVRpbWUpO1xuICAgICAgdGhpcy5fdXBkYXRlU2Vzc2lvbkFjdGl2aXR5KGFjdGl2aXR5VGltZSk7XG4gICAgICB0aGlzLl9tYXliZVNhdmVTZXNzaW9uKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydFJlY29yZGluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlIHdhbnQgdG8gYmF0Y2ggdXBsb2FkcyBvZiByZXBsYXkgZXZlbnRzLiBTYXZlIGV2ZW50cyBvbmx5IGlmXG4gICAqIGA8Zmx1c2hNaW5EZWxheT5gIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgZXZlbnRcbiAgICogKk9SKiBpZiBgPGZsdXNoTWF4RGVsYXk+YCBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkLlxuICAgKlxuICAgKiBBY2NlcHRzIGEgY2FsbGJhY2sgdG8gcGVyZm9ybSBzaWRlLWVmZmVjdHMgYW5kIHJldHVybnMgdHJ1ZSB0byBzdG9wIGJhdGNoXG4gICAqIHByb2Nlc3NpbmcgYW5kIGhhbmQgYmFjayBjb250cm9sIHRvIGNhbGxlci5cbiAgICovXG4gICBhZGRVcGRhdGUoY2IpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGFsd2F5cyBydW4gYGNiYCAoZS5nLiBpbiB0aGUgY2FzZSBvZiBgdGhpcy5yZWNvcmRpbmdNb2RlID09ICdidWZmZXInYClcbiAgICBjb25zdCBjYlJlc3VsdCA9IGNiKCk7XG5cbiAgICAvLyBJZiB0aGlzIG9wdGlvbiBpcyB0dXJuZWQgb24gdGhlbiB3ZSB3aWxsIG9ubHkgd2FudCB0byBjYWxsIGBmbHVzaGBcbiAgICAvLyBleHBsaWNpdGx5XG4gICAgaWYgKHRoaXMucmVjb3JkaW5nTW9kZSA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBjYWxsYmFjayBpcyB0cnVlLCB3ZSBkbyBub3Qgd2FudCB0byBjb250aW51ZSB3aXRoIGZsdXNoaW5nIC0tIHRoZVxuICAgIC8vIGNhbGxlciB3aWxsIG5lZWQgdG8gaGFuZGxlIGl0LlxuICAgIGlmIChjYlJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFkZFVwZGF0ZSBpcyBjYWxsZWQgcXVpdGUgZnJlcXVlbnRseSAtIHVzZSBfZGVib3VuY2VkRmx1c2ggc28gdGhhdCBpdFxuICAgIC8vIHJlc3BlY3RzIHRoZSBmbHVzaCBkZWxheXMgYW5kIGRvZXMgbm90IGZsdXNoIGltbWVkaWF0ZWx5XG4gICAgdGhpcy5fZGVib3VuY2VkRmx1c2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB1c2VyIGFjdGl2aXR5IHRpbWVzdGFtcCBhbmQgcmVzdW1lcyByZWNvcmRpbmcuIFRoaXMgc2hvdWxkIGJlXG4gICAqIGNhbGxlZCBpbiBhbiBldmVudCBoYW5kbGVyIGZvciBhIHVzZXIgYWN0aW9uIHRoYXQgd2UgY29uc2lkZXIgYXMgdGhlIHVzZXJcbiAgICogYmVpbmcgXCJhY3RpdmVcIiAoZS5nLiBhIG1vdXNlIGNsaWNrKS5cbiAgICovXG4gICB0cmlnZ2VyVXNlckFjdGl2aXR5KCkge1xuICAgIHRoaXMuX3VwZGF0ZVVzZXJBY3Rpdml0eSgpO1xuXG4gICAgLy8gVGhpcyBjYXNlIG1lYW5zIHRoYXQgcmVjb3JkaW5nIHdhcyBvbmNlIHN0b3BwZWQgZHVlIHRvIGluYWN0aXZpdHkuXG4gICAgLy8gRW5zdXJlIHRoYXQgcmVjb3JkaW5nIGlzIHJlc3VtZWQuXG4gICAgaWYgKCF0aGlzLl9zdG9wUmVjb3JkaW5nKSB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgc2Vzc2lvbiwgb3RoZXJ3aXNlIHdoZW4gdGhlIHVzZXIgYWN0aW9uIGlzIGZsdXNoZWQsIGl0XG4gICAgICAvLyB3aWxsIGdldCByZWplY3RlZCBkdWUgdG8gYW4gZXhwaXJlZCBzZXNzaW9uLlxuICAgICAgaWYgKCF0aGlzLl9jaGVja1Nlc3Npb24oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdGU6IFRoaXMgd2lsbCBjYXVzZSBhIG5ldyBET00gY2hlY2tvdXRcbiAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLi4uIHJlY29yZGluZyB3YXMgbmV2ZXIgc3VzcGVuZGVkLCBjb250aW51ZSBhcyBub3JtYWxpc2hcbiAgICB0aGlzLmNoZWNrQW5kSGFuZGxlRXhwaXJlZFNlc3Npb24oKTtcblxuICAgIHRoaXMuX3VwZGF0ZVNlc3Npb25BY3Rpdml0eSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIgYWN0aXZpdHkgdGltZXN0YW1wICp3aXRob3V0KiByZXN1bWluZ1xuICAgKiByZWNvcmRpbmcuIFNvbWUgdXNlciBldmVudHMgKGUuZy4ga2V5ZG93bikgY2FuIGJlIGNyZWF0ZVxuICAgKiBsb3ctdmFsdWUgcmVwbGF5cyB0aGF0IG9ubHkgY29udGFpbiB0aGUga2V5cHJlc3MgYXMgYVxuICAgKiBicmVhZGNydW1iLiBJbnN0ZWFkIHRoaXMgd291bGQgcmVxdWlyZSBvdGhlciBldmVudHMgdG9cbiAgICogY3JlYXRlIGEgbmV3IHJlcGxheSBhZnRlciBhIHNlc3Npb24gaGFzIGV4cGlyZWQuXG4gICAqL1xuICAgdXBkYXRlVXNlckFjdGl2aXR5KCkge1xuICAgIHRoaXMuX3VwZGF0ZVVzZXJBY3Rpdml0eSgpO1xuICAgIHRoaXMuX3VwZGF0ZVNlc3Npb25BY3Rpdml0eSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ubHkgZmx1c2ggaWYgYHRoaXMucmVjb3JkaW5nTW9kZSA9PT0gJ3Nlc3Npb24nYFxuICAgKi9cbiAgIGNvbmRpdGlvbmFsRmx1c2goKSB7XG4gICAgaWYgKHRoaXMucmVjb3JkaW5nTW9kZSA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mbHVzaEltbWVkaWF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoIHVzaW5nIGRlYm91bmNlIGZsdXNoXG4gICAqL1xuICAgZmx1c2goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlYm91bmNlZEZsdXNoKCkgO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBmbHVzaCB2aWEgYF9kZWJvdW5jZWRGbHVzaGAgc28gdGhhdCB3ZSBkbyBub3QgaGF2ZSBmbHVzaGVzIHRyaWdnZXJlZFxuICAgKiBmcm9tIGNhbGxpbmcgYm90aCBgZmx1c2hgIGFuZCBgX2RlYm91bmNlZEZsdXNoYC4gT3RoZXJ3aXNlLCB0aGVyZSBjb3VsZCBiZVxuICAgKiBjYXNlcyBvZiBtdWx0aXBsZSBmbHVzaGVzIGhhcHBlbmluZyBjbG9zZWx5IHRvZ2V0aGVyLlxuICAgKi9cbiAgIGZsdXNoSW1tZWRpYXRlKCkge1xuICAgIHRoaXMuX2RlYm91bmNlZEZsdXNoKCk7XG4gICAgLy8gYC5mbHVzaGAgaXMgcHJvdmlkZWQgYnkgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiwgYW5hbG9nb3VzbHkgdG8gbG9kYXNoLmRlYm91bmNlXG4gICAgcmV0dXJuIHRoaXMuX2RlYm91bmNlZEZsdXNoLmZsdXNoKCkgO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgcXVldWVkIHVwIGZsdXNoZXMuXG4gICAqL1xuICAgY2FuY2VsRmx1c2goKSB7XG4gICAgdGhpcy5fZGVib3VuY2VkRmx1c2guY2FuY2VsKCk7XG4gIH1cblxuICAvKiogR2V0IHRoZSBjdXJyZW50IHNlc3Npb24gKD1yZXBsYXkpIElEICovXG4gICBnZXRTZXNzaW9uSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbj8uaWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHJlY29yZGluZyBzaG91bGQgYmUgc3RvcHBlZCBkdWUgdG8gdXNlciBpbmFjdGl2aXR5LiBPdGhlcndpc2VcbiAgICogY2hlY2sgaWYgc2Vzc2lvbiBpcyBleHBpcmVkIGFuZCBjcmVhdGUgYSBuZXcgc2Vzc2lvbiBpZiBzby4gVHJpZ2dlcnMgYSBuZXdcbiAgICogZnVsbCBzbmFwc2hvdCBvbiBuZXcgc2Vzc2lvbi5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIHNlc3Npb24gaXMgbm90IGV4cGlyZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQGhpZGRlblxuICAgKi9cbiAgIGNoZWNrQW5kSGFuZGxlRXhwaXJlZFNlc3Npb24oKSB7XG4gICAgLy8gUHJldmVudCBzdGFydGluZyBhIG5ldyBzZXNzaW9uIGlmIHRoZSBsYXN0IHVzZXIgYWN0aXZpdHkgaXMgb2xkZXIgdGhhblxuICAgIC8vIFNFU1NJT05fSURMRV9QQVVTRV9EVVJBVElPTi4gT3RoZXJ3aXNlIG5vbi11c2VyIGFjdGl2aXR5IGNhbiB0cmlnZ2VyIGEgbmV3XG4gICAgLy8gc2Vzc2lvbityZWNvcmRpbmcuIFRoaXMgY3JlYXRlcyBub2lzeSByZXBsYXlzIHRoYXQgZG8gbm90IGhhdmUgbXVjaFxuICAgIC8vIGNvbnRlbnQgaW4gdGhlbS5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9sYXN0QWN0aXZpdHkgJiZcbiAgICAgIGlzRXhwaXJlZCh0aGlzLl9sYXN0QWN0aXZpdHksIHRoaXMudGltZW91dHMuc2Vzc2lvbklkbGVQYXVzZSkgJiZcbiAgICAgIHRoaXMuc2Vzc2lvbiAmJlxuICAgICAgdGhpcy5zZXNzaW9uLnNhbXBsZWQgPT09ICdzZXNzaW9uJ1xuICAgICkge1xuICAgICAgLy8gUGF1c2UgcmVjb3JkaW5nIG9ubHkgZm9yIHNlc3Npb24tYmFzZWQgcmVwbGF5cy4gT3RoZXJ3aXNlLCByZXN1bWluZ1xuICAgICAgLy8gd2lsbCBjcmVhdGUgYSBuZXcgcmVwbGF5IGFuZCB3aWxsIGNvbmZsaWN0IHdpdGggdXNlcnMgd2hvIG9ubHkgY2hvb3NlXG4gICAgICAvLyB0byByZWNvcmQgZXJyb3ItYmFzZWQgcmVwbGF5cyBvbmx5LiAoZS5nLiB0aGUgcmVzdW1lZCByZXBsYXkgd2lsbCBub3RcbiAgICAgIC8vIGNvbnRhaW4gYSByZWZlcmVuY2UgdG8gYW4gZXJyb3IpXG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gLS0tIFRoZXJlIGlzIHJlY2VudCB1c2VyIGFjdGl2aXR5IC0tLSAvL1xuICAgIC8vIFRoaXMgd2lsbCBjcmVhdGUgYSBuZXcgc2Vzc2lvbiBpZiBleHBpcmVkLCBiYXNlZCBvbiBleHBpcnkgbGVuZ3RoXG4gICAgaWYgKCF0aGlzLl9jaGVja1Nlc3Npb24oKSkge1xuICAgICAgLy8gQ2hlY2sgc2Vzc2lvbiBoYW5kbGVzIHRoZSByZWZyZXNoaW5nIGl0c2VsZlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmUgc29tZSBpbml0aWFsIHN0YXRlIHRoYXQgY2FuIGNoYW5nZSB0aHJvdWdob3V0IHRoZSBsaWZlc3BhbiBvZiB0aGVcbiAgICogcmVwbGF5LiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZXkgd291bGQgYmUgY2FwdHVyZWQgYXQgdGhlXG4gICAqIGZpcnN0IGZsdXNoLlxuICAgKi9cbiAgIHNldEluaXRpYWxTdGF0ZSgpIHtcbiAgICBjb25zdCB1cmxQYXRoID0gYCR7V0lORE9XLmxvY2F0aW9uLnBhdGhuYW1lfSR7V0lORE9XLmxvY2F0aW9uLmhhc2h9JHtXSU5ET1cubG9jYXRpb24uc2VhcmNofWA7XG4gICAgY29uc3QgdXJsID0gYCR7V0lORE9XLmxvY2F0aW9uLm9yaWdpbn0ke3VybFBhdGh9YDtcblxuICAgIHRoaXMucGVyZm9ybWFuY2VFbnRyaWVzID0gW107XG4gICAgdGhpcy5yZXBsYXlQZXJmb3JtYW5jZUVudHJpZXMgPSBbXTtcblxuICAgIC8vIFJlc2V0IF9jb250ZXh0IGFzIHdlbGxcbiAgICB0aGlzLl9jbGVhckNvbnRleHQoKTtcblxuICAgIHRoaXMuX2NvbnRleHQuaW5pdGlhbFVybCA9IHVybDtcbiAgICB0aGlzLl9jb250ZXh0LmluaXRpYWxUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuX2NvbnRleHQudXJscy5wdXNoKHVybCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgYnJlYWRjcnVtYiBldmVudCwgdGhhdCBtYXkgYmUgdGhyb3R0bGVkLlxuICAgKiBJZiBpdCB3YXMgdGhyb3R0bGVkLCB3ZSBhZGQgYSBjdXN0b20gYnJlYWRjcnVtYiB0byBpbmRpY2F0ZSB0aGF0LlxuICAgKi9cbiAgIHRocm90dGxlZEFkZEV2ZW50KFxuICAgIGV2ZW50LFxuICAgIGlzQ2hlY2tvdXQsXG4gICkge1xuICAgIGNvbnN0IHJlcyA9IHRoaXMuX3Rocm90dGxlZEFkZEV2ZW50KGV2ZW50LCBpc0NoZWNrb3V0KTtcblxuICAgIC8vIElmIHRoaXMgaXMgVEhST1RUTEVELCBpdCBtZWFucyB3ZSBoYXZlIHRocm90dGxlZCB0aGUgZXZlbnQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSB3YW50IHRvIGFkZCBhIGJyZWFkY3J1bWIgaW5kaWNhdGluZyB0aGF0IHNvbWV0aGluZyB3YXMgc2tpcHBlZFxuICAgIGlmIChyZXMgPT09IFRIUk9UVExFRCkge1xuICAgICAgY29uc3QgYnJlYWRjcnVtYiA9IGNyZWF0ZUJyZWFkY3J1bWIoe1xuICAgICAgICBjYXRlZ29yeTogJ3JlcGxheS50aHJvdHRsZWQnLFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuYWRkVXBkYXRlKCgpID0+IHtcbiAgICAgICAgLy8gUmV0dXJuIGBmYWxzZWAgaWYgdGhlIGV2ZW50IF93YXNfIGFkZGVkLCBhcyB0aGF0IG1lYW5zIHdlIHNjaGVkdWxlIGEgZmx1c2hcbiAgICAgICAgcmV0dXJuICFhZGRFdmVudFN5bmModGhpcywge1xuICAgICAgICAgIHR5cGU6IFJlcGxheUV2ZW50VHlwZUN1c3RvbSxcbiAgICAgICAgICB0aW1lc3RhbXA6IGJyZWFkY3J1bWIudGltZXN0YW1wIHx8IDAsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdGFnOiAnYnJlYWRjcnVtYicsXG4gICAgICAgICAgICBwYXlsb2FkOiBicmVhZGNydW1iLFxuICAgICAgICAgICAgbWV0cmljOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgZ2V0IHRoZSBwYXJhbWV0cml6ZWQgcm91dGUgbmFtZSBvZiB0aGUgY3VycmVudCBwYWdlLlxuICAgKiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGlmIHBlcmZvcm1hbmNlIGlzIGVuYWJsZWQsIGFuZCBpZiBhbiBpbnN0cnVtZW50ZWQgcm91dGVyIGlzIHVzZWQuXG4gICAqL1xuICAgZ2V0Q3VycmVudFJvdXRlKCkge1xuICAgIGNvbnN0IGxhc3RBY3RpdmVTcGFuID0gdGhpcy5sYXN0QWN0aXZlU3BhbiB8fCBnZXRBY3RpdmVTcGFuKCk7XG4gICAgY29uc3QgbGFzdFJvb3RTcGFuID0gbGFzdEFjdGl2ZVNwYW4gJiYgZ2V0Um9vdFNwYW4obGFzdEFjdGl2ZVNwYW4pO1xuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IChsYXN0Um9vdFNwYW4gJiYgc3BhblRvSlNPTihsYXN0Um9vdFNwYW4pLmRhdGEpIHx8IHt9O1xuICAgIGNvbnN0IHNvdXJjZSA9IGF0dHJpYnV0ZXNbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdO1xuICAgIGlmICghbGFzdFJvb3RTcGFuIHx8ICFzb3VyY2UgfHwgIVsncm91dGUnLCAnY3VzdG9tJ10uaW5jbHVkZXMoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3BhblRvSlNPTihsYXN0Um9vdFNwYW4pLmRlc2NyaXB0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYW5kIHN0YXJ0IGFsbCBsaXN0ZW5lcnMgdG8gdmFyeWluZyBldmVudHMgKERPTSxcbiAgICogUGVyZm9ybWFuY2UgT2JzZXJ2ZXIsIFJlY29yZGluZywgU2VudHJ5IFNESywgZXRjKVxuICAgKi9cbiAgIF9pbml0aWFsaXplUmVjb3JkaW5nKCkge1xuICAgIHRoaXMuc2V0SW5pdGlhbFN0YXRlKCk7XG5cbiAgICAvLyB0aGlzIG1ldGhvZCBpcyBnZW5lcmFsbHkgY2FsbGVkIG9uIHBhZ2UgbG9hZCBvciBtYW51YWxseSAtIGluIGJvdGggY2FzZXNcbiAgICAvLyB3ZSBzaG91bGQgdHJlYXQgaXQgYXMgYW4gYWN0aXZpdHlcbiAgICB0aGlzLl91cGRhdGVTZXNzaW9uQWN0aXZpdHkoKTtcblxuICAgIHRoaXMuZXZlbnRCdWZmZXIgPSBjcmVhdGVFdmVudEJ1ZmZlcih7XG4gICAgICB1c2VDb21wcmVzc2lvbjogdGhpcy5fb3B0aW9ucy51c2VDb21wcmVzc2lvbixcbiAgICAgIHdvcmtlclVybDogdGhpcy5fb3B0aW9ucy53b3JrZXJVcmwsXG4gICAgfSk7XG5cbiAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9hZGRMaXN0ZW5lcnMoKTtcblxuICAgIC8vIE5lZWQgdG8gc2V0IGFzIGVuYWJsZWQgYmVmb3JlIHdlIHN0YXJ0IHJlY29yZGluZywgYXMgYHJlY29yZCgpYCBjYW4gdHJpZ2dlciBhIGZsdXNoIHdpdGggYSBuZXcgY2hlY2tvdXRcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLnN0YXJ0UmVjb3JkaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgKG9yIHJlZnJlc2hlcykgdGhlIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICovXG4gICBfaW5pdGlhbGl6ZVNlc3Npb25Gb3JTYW1wbGluZyhwcmV2aW91c1Nlc3Npb25JZCkge1xuICAgIC8vIFdoZW5ldmVyIHRoZXJlIGlzIF9hbnlfIGVycm9yIHNhbXBsZSByYXRlLCB3ZSBhbHdheXMgYWxsb3cgYnVmZmVyaW5nXG4gICAgLy8gQmVjYXVzZSB3ZSBkZWNpZGUgb24gc2FtcGxpbmcgd2hlbiBhbiBlcnJvciBvY2N1cnMsIHdlIG5lZWQgdG8gYnVmZmVyIGF0IGFsbCB0aW1lcyBpZiBzYW1wbGluZyBmb3IgZXJyb3JzXG4gICAgY29uc3QgYWxsb3dCdWZmZXJpbmcgPSB0aGlzLl9vcHRpb25zLmVycm9yU2FtcGxlUmF0ZSA+IDA7XG5cbiAgICBjb25zdCBzZXNzaW9uID0gbG9hZE9yQ3JlYXRlU2Vzc2lvbihcbiAgICAgIHtcbiAgICAgICAgc2Vzc2lvbklkbGVFeHBpcmU6IHRoaXMudGltZW91dHMuc2Vzc2lvbklkbGVFeHBpcmUsXG4gICAgICAgIG1heFJlcGxheUR1cmF0aW9uOiB0aGlzLl9vcHRpb25zLm1heFJlcGxheUR1cmF0aW9uLFxuICAgICAgICBwcmV2aW91c1Nlc3Npb25JZCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0aWNreVNlc3Npb246IHRoaXMuX29wdGlvbnMuc3RpY2t5U2Vzc2lvbixcbiAgICAgICAgc2Vzc2lvblNhbXBsZVJhdGU6IHRoaXMuX29wdGlvbnMuc2Vzc2lvblNhbXBsZVJhdGUsXG4gICAgICAgIGFsbG93QnVmZmVyaW5nLFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgYW5kIHBvdGVudGlhbGx5IHJlZnJlc2hlcyB0aGUgY3VycmVudCBzZXNzaW9uLlxuICAgKiBSZXR1cm5zIGZhbHNlIGlmIHNlc3Npb24gaXMgbm90IHJlY29yZGVkLlxuICAgKi9cbiAgIF9jaGVja1Nlc3Npb24oKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gc2Vzc2lvbiB5ZXQsIHdlIGRvIG5vdCB3YW50IHRvIHJlZnJlc2ggYW55dGhpbmdcbiAgICAvLyBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGhhcHBlbiwgYnV0IHRvIGJlIHNhZmUuLi4uXG4gICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcblxuICAgIGlmIChcbiAgICAgIHNob3VsZFJlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uLCB7XG4gICAgICAgIHNlc3Npb25JZGxlRXhwaXJlOiB0aGlzLnRpbWVvdXRzLnNlc3Npb25JZGxlRXhwaXJlLFxuICAgICAgICBtYXhSZXBsYXlEdXJhdGlvbjogdGhpcy5fb3B0aW9ucy5tYXhSZXBsYXlEdXJhdGlvbixcbiAgICAgIH0pXG4gICAgKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciByZWplY3RcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgIHRoaXMuX3JlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGEgc2Vzc2lvbiB3aXRoIGEgbmV3IG9uZS5cbiAgICogVGhpcyBzdG9wcyB0aGUgY3VycmVudCBzZXNzaW9uICh3aXRob3V0IGZvcmNpbmcgYSBmbHVzaCwgYXMgdGhhdCB3b3VsZCBuZXZlciB3b3JrIHNpbmNlIHdlIGFyZSBleHBpcmVkKSxcbiAgICogYW5kIHRoZW4gZG9lcyBhIG5ldyBzYW1wbGluZyBiYXNlZCBvbiB0aGUgcmVmcmVzaGVkIHNlc3Npb24uXG4gICAqL1xuICAgYXN5bmMgX3JlZnJlc2hTZXNzaW9uKHNlc3Npb24pIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnN0b3AoeyByZWFzb246ICdyZWZyZXNoIHNlc3Npb24nIH0pO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVNhbXBsaW5nKHNlc3Npb24uaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbGlzdGVuZXJzIHRvIHJlY29yZCBldmVudHMgZm9yIHRoZSByZXBsYXlcbiAgICovXG4gICBfYWRkTGlzdGVuZXJzKCkge1xuICAgIHRyeSB7XG4gICAgICBXSU5ET1cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgV0lORE9XLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9oYW5kbGVXaW5kb3dCbHVyKTtcbiAgICAgIFdJTkRPVy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2hhbmRsZVdpbmRvd0ZvY3VzKTtcbiAgICAgIFdJTkRPVy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlS2V5Ym9hcmRFdmVudCk7XG5cbiAgICAgIGlmICh0aGlzLmNsaWNrRGV0ZWN0b3IpIHtcbiAgICAgICAgdGhpcy5jbGlja0RldGVjdG9yLmFkZExpc3RlbmVycygpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGVyZSBpcyBubyB3YXkgdG8gcmVtb3ZlIHRoZXNlIGxpc3RlbmVycywgc28gZW5zdXJlIHRoZXkgYXJlIG9ubHkgYWRkZWQgb25jZVxuICAgICAgaWYgKCF0aGlzLl9oYXNJbml0aWFsaXplZENvcmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXJzKHRoaXMsIHsgYXV0b0ZsdXNoT25GZWVkYmFjazogdGhpcy5fb3B0aW9ucy5fZXhwZXJpbWVudHMuYXV0b0ZsdXNoT25GZWVkYmFjayB9KTtcblxuICAgICAgICB0aGlzLl9oYXNJbml0aWFsaXplZENvcmVMaXN0ZW5lcnMgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5oYW5kbGVFeGNlcHRpb24oZXJyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wZXJmb3JtYW5jZUNsZWFudXBDYWxsYmFjayA9IHNldHVwUGVyZm9ybWFuY2VPYnNlcnZlcih0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgbGlzdGVuZXJzIHRoYXQgd2VyZSBjcmVhdGVkIGluIGBfYWRkTGlzdGVuZXJzYFxuICAgKi9cbiAgIF9yZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIFdJTkRPVy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5faGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG5cbiAgICAgIFdJTkRPVy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5faGFuZGxlV2luZG93Qmx1cik7XG4gICAgICBXSU5ET1cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9oYW5kbGVXaW5kb3dGb2N1cyk7XG4gICAgICBXSU5ET1cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUtleWJvYXJkRXZlbnQpO1xuXG4gICAgICBpZiAodGhpcy5jbGlja0RldGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY2xpY2tEZXRlY3Rvci5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BlcmZvcm1hbmNlQ2xlYW51cENhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3BlcmZvcm1hbmNlQ2xlYW51cENhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmhhbmRsZUV4Y2VwdGlvbihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUYXNrcyB0byBydW4gd2hlbiB3ZSBjb25zaWRlciBhIHBhZ2UgdG8gYmUgaGlkZGVuICh2aWEgYmx1cnJpbmcgYW5kL29yIHZpc2liaWxpdHkpXG4gICAqL1xuICAgX2RvQ2hhbmdlVG9CYWNrZ3JvdW5kVGFza3MoYnJlYWRjcnVtYikge1xuICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXhwaXJlZCA9IGlzU2Vzc2lvbkV4cGlyZWQodGhpcy5zZXNzaW9uLCB7XG4gICAgICBtYXhSZXBsYXlEdXJhdGlvbjogdGhpcy5fb3B0aW9ucy5tYXhSZXBsYXlEdXJhdGlvbixcbiAgICAgIHNlc3Npb25JZGxlRXhwaXJlOiB0aGlzLnRpbWVvdXRzLnNlc3Npb25JZGxlRXhwaXJlLFxuICAgIH0pO1xuXG4gICAgaWYgKGV4cGlyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYnJlYWRjcnVtYikge1xuICAgICAgdGhpcy5fY3JlYXRlQ3VzdG9tQnJlYWRjcnVtYihicmVhZGNydW1iKTtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHJlcGxheSB3aGVuIHRoZSBwYWdlL3RhYiBiZWNvbWVzIGhpZGRlbi4gVGhlcmUgaXMgbm8gcmVhc29uIHRvIHNlbmRcbiAgICAvLyByZXBsYXkgaWYgaXQgYmVjb21lcyB2aXNpYmxlLCBzaW5jZSBubyBhY3Rpb25zIHdlIGNhcmUgYWJvdXQgd2VyZSBkb25lXG4gICAgLy8gd2hpbGUgaXQgd2FzIGhpZGRlblxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIHJlamVjdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICB2b2lkIHRoaXMuY29uZGl0aW9uYWxGbHVzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRhc2tzIHRvIHJ1biB3aGVuIHdlIGNvbnNpZGVyIGEgcGFnZSB0byBiZSB2aXNpYmxlICh2aWEgZm9jdXMgYW5kL29yIHZpc2liaWxpdHkpXG4gICAqL1xuICAgX2RvQ2hhbmdlVG9Gb3JlZ3JvdW5kVGFza3MoYnJlYWRjcnVtYikge1xuICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaXNTZXNzaW9uQWN0aXZlID0gdGhpcy5jaGVja0FuZEhhbmRsZUV4cGlyZWRTZXNzaW9uKCk7XG5cbiAgICBpZiAoIWlzU2Vzc2lvbkFjdGl2ZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzIGNvbWUgYmFjayB0byB0aGUgcGFnZSB3aXRoaW4gU0VTU0lPTl9JRExFX1BBVVNFX0RVUkFUSU9OXG4gICAgICAvLyBtcywgd2Ugd2lsbCByZS11c2UgdGhlIGV4aXN0aW5nIHNlc3Npb24sIG90aGVyd2lzZSBjcmVhdGUgYSBuZXdcbiAgICAgIC8vIHNlc3Npb25cbiAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5pbmZvKCdEb2N1bWVudCBoYXMgYmVjb21lIGFjdGl2ZSwgYnV0IHNlc3Npb24gaGFzIGV4cGlyZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYnJlYWRjcnVtYikge1xuICAgICAgdGhpcy5fY3JlYXRlQ3VzdG9tQnJlYWRjcnVtYihicmVhZGNydW1iKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHVzZXIgYWN0aXZpdHkgKGFjcm9zcyBzZXNzaW9uIGxpZmVzcGFucylcbiAgICovXG4gICBfdXBkYXRlVXNlckFjdGl2aXR5KF9sYXN0QWN0aXZpdHkgPSBEYXRlLm5vdygpKSB7XG4gICAgdGhpcy5fbGFzdEFjdGl2aXR5ID0gX2xhc3RBY3Rpdml0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzZXNzaW9uJ3MgbGFzdCBhY3Rpdml0eSB0aW1lc3RhbXBcbiAgICovXG4gICBfdXBkYXRlU2Vzc2lvbkFjdGl2aXR5KF9sYXN0QWN0aXZpdHkgPSBEYXRlLm5vdygpKSB7XG4gICAgaWYgKHRoaXMuc2Vzc2lvbikge1xuICAgICAgdGhpcy5zZXNzaW9uLmxhc3RBY3Rpdml0eSA9IF9sYXN0QWN0aXZpdHk7XG4gICAgICB0aGlzLl9tYXliZVNhdmVTZXNzaW9uKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBjcmVhdGUgKGFuZCBidWZmZXIpIGEgcmVwbGF5IGJyZWFkY3J1bWIgZnJvbSBhIGNvcmUgU0RLIGJyZWFkY3J1bWJcbiAgICovXG4gICBfY3JlYXRlQ3VzdG9tQnJlYWRjcnVtYihicmVhZGNydW1iKSB7XG4gICAgdGhpcy5hZGRVcGRhdGUoKCkgPT4ge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgcmVqZWN0XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICB0aGlzLnRocm90dGxlZEFkZEV2ZW50KHtcbiAgICAgICAgdHlwZTogRXZlbnRUeXBlLkN1c3RvbSxcbiAgICAgICAgdGltZXN0YW1wOiBicmVhZGNydW1iLnRpbWVzdGFtcCB8fCAwLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdGFnOiAnYnJlYWRjcnVtYicsXG4gICAgICAgICAgcGF5bG9hZDogYnJlYWRjcnVtYixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmVkIHBlcmZvcm1hbmNlIGV2ZW50cyBhcmUgYWRkZWQgdG8gYHRoaXMucGVyZm9ybWFuY2VFbnRyaWVzYC4gVGhlc2VcbiAgICogYXJlIGluY2x1ZGVkIGluIHRoZSByZXBsYXkgZXZlbnQgYmVmb3JlIGl0IGlzIGZpbmlzaGVkIGFuZCBzZW50IHRvIFNlbnRyeS5cbiAgICovXG4gICBfYWRkUGVyZm9ybWFuY2VFbnRyaWVzKCkge1xuICAgIGxldCBwZXJmb3JtYW5jZUVudHJpZXMgPSBjcmVhdGVQZXJmb3JtYW5jZUVudHJpZXModGhpcy5wZXJmb3JtYW5jZUVudHJpZXMpLmNvbmNhdCh0aGlzLnJlcGxheVBlcmZvcm1hbmNlRW50cmllcyk7XG5cbiAgICB0aGlzLnBlcmZvcm1hbmNlRW50cmllcyA9IFtdO1xuICAgIHRoaXMucmVwbGF5UGVyZm9ybWFuY2VFbnRyaWVzID0gW107XG5cbiAgICAvLyBJZiB3ZSBhcmUgbWFudWFsbHkgc3RhcnRpbmcsIHdlIHdhbnQgdG8gZW5zdXJlIHdlIG9ubHkgaW5jbHVkZSBwZXJmb3JtYW5jZSBlbnRyaWVzXG4gICAgLy8gdGhhdCBhcmUgYWZ0ZXIgdGhlIGluaXRpYWwgdGltZXN0YW1wXG4gICAgLy8gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IHdlIG1heSBoYXZlIHBlcmZvcm1hbmNlIGVudHJpZXMgZnJvbSB0aGUgcGFnZSBsb2FkLCBidXQgbWF5IGRlY2lkZSB0byBzdGFydFxuICAgIC8vIHRoZSByZXBsYXkgbGF0ZXIgb24sIGluIHdoaWNoIGNhc2Ugd2UgZG8gbm90IHdhbnQgdG8gaW5jbHVkZSB0aGVzZSBlbnRyaWVzLlxuICAgIC8vIHdpdGhvdXQgdGhpcywgbWFudWFsbHkgc3RhcnRlZCByZXBsYXlzIGNhbiBoYXZlIGV2ZW50cyBsb25nIGJlZm9yZSB0aGUgYWN0dWFsIHJlcGxheSByZWNvcmRpbmcgc3RhcnRzLFxuICAgIC8vIHdoaWNoIG1lc3NlcyB3aXRoIHRoZSB0aW1lbGluZSBldGMuXG4gICAgaWYgKHRoaXMuX3JlcXVpcmVzTWFudWFsU3RhcnQpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxUaW1lc3RhbXBJblNlY29uZHMgPSB0aGlzLl9jb250ZXh0LmluaXRpYWxUaW1lc3RhbXAgLyAxMDAwO1xuICAgICAgcGVyZm9ybWFuY2VFbnRyaWVzID0gcGVyZm9ybWFuY2VFbnRyaWVzLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5zdGFydCA+PSBpbml0aWFsVGltZXN0YW1wSW5TZWNvbmRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoY3JlYXRlUGVyZm9ybWFuY2VTcGFucyh0aGlzLCBwZXJmb3JtYW5jZUVudHJpZXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBfY29udGV4dFxuICAgKi9cbiAgIF9jbGVhckNvbnRleHQoKSB7XG4gICAgLy8gWFhYOiBgaW5pdGlhbFRpbWVzdGFtcGAgYW5kIGBpbml0aWFsVXJsYCBkbyBub3QgZ2V0IGNsZWFyZWRcbiAgICB0aGlzLl9jb250ZXh0LmVycm9ySWRzLmNsZWFyKCk7XG4gICAgdGhpcy5fY29udGV4dC50cmFjZUlkcy5jbGVhcigpO1xuICAgIHRoaXMuX2NvbnRleHQudXJscyA9IFtdO1xuICB9XG5cbiAgLyoqIFVwZGF0ZSB0aGUgaW5pdGlhbCB0aW1lc3RhbXAgYmFzZWQgb24gdGhlIGJ1ZmZlciBjb250ZW50LiAqL1xuICAgX3VwZGF0ZUluaXRpYWxUaW1lc3RhbXBGcm9tRXZlbnRCdWZmZXIoKSB7XG4gICAgY29uc3QgeyBzZXNzaW9uLCBldmVudEJ1ZmZlciB9ID0gdGhpcztcbiAgICAvLyBJZiByZXBsYXkgd2FzIHN0YXJ0ZWQgbWFudWFsbHkgKD1ubyBzYW1wbGUgcmF0ZSB3YXMgZ2l2ZW4pLFxuICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIGJhY2stcG9ydCB0aGUgaW5pdGlhbCB0aW1lc3RhbXBcbiAgICBpZiAoIXNlc3Npb24gfHwgIWV2ZW50QnVmZmVyIHx8IHRoaXMuX3JlcXVpcmVzTWFudWFsU3RhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB3ZSBvbmx5IGV2ZXIgdXBkYXRlIHRoaXMgb24gdGhlIGluaXRpYWwgc2VnbWVudFxuICAgIGlmIChzZXNzaW9uLnNlZ21lbnRJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVhcmxpZXN0RXZlbnQgPSBldmVudEJ1ZmZlci5nZXRFYXJsaWVzdFRpbWVzdGFtcCgpO1xuICAgIGlmIChlYXJsaWVzdEV2ZW50ICYmIGVhcmxpZXN0RXZlbnQgPCB0aGlzLl9jb250ZXh0LmluaXRpYWxUaW1lc3RhbXApIHtcbiAgICAgIHRoaXMuX2NvbnRleHQuaW5pdGlhbFRpbWVzdGFtcCA9IGVhcmxpZXN0RXZlbnQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbmQgY2xlYXIgX2NvbnRleHRcbiAgICovXG4gICBfcG9wRXZlbnRDb250ZXh0KCkge1xuICAgIGNvbnN0IF9jb250ZXh0ID0ge1xuICAgICAgaW5pdGlhbFRpbWVzdGFtcDogdGhpcy5fY29udGV4dC5pbml0aWFsVGltZXN0YW1wLFxuICAgICAgaW5pdGlhbFVybDogdGhpcy5fY29udGV4dC5pbml0aWFsVXJsLFxuICAgICAgZXJyb3JJZHM6IEFycmF5LmZyb20odGhpcy5fY29udGV4dC5lcnJvcklkcyksXG4gICAgICB0cmFjZUlkczogQXJyYXkuZnJvbSh0aGlzLl9jb250ZXh0LnRyYWNlSWRzKSxcbiAgICAgIHVybHM6IHRoaXMuX2NvbnRleHQudXJscyxcbiAgICB9O1xuXG4gICAgdGhpcy5fY2xlYXJDb250ZXh0KCk7XG5cbiAgICByZXR1cm4gX2NvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogRmx1c2hlcyByZXBsYXkgZXZlbnQgYnVmZmVyIHRvIFNlbnRyeS5cbiAgICpcbiAgICogUGVyZm9ybWFuY2UgZXZlbnRzIGFyZSBvbmx5IGFkZGVkIHJpZ2h0IGJlZm9yZSBmbHVzaGluZyAtIHRoaXMgaXNcbiAgICogZHVlIHRvIHRoZSBidWZmZXJlZCBwZXJmb3JtYW5jZSBvYnNlcnZlciBldmVudHMuXG4gICAqXG4gICAqIFNob3VsZCBuZXZlciBiZSBjYWxsZWQgZGlyZWN0bHksIG9ubHkgYnkgYGZsdXNoYFxuICAgKi9cbiAgIGFzeW5jIF9ydW5GbHVzaCgpIHtcbiAgICBjb25zdCByZXBsYXlJZCA9IHRoaXMuZ2V0U2Vzc2lvbklkKCk7XG5cbiAgICBpZiAoIXRoaXMuc2Vzc2lvbiB8fCAhdGhpcy5ldmVudEJ1ZmZlciB8fCAhcmVwbGF5SWQpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5lcnJvcignTm8gc2Vzc2lvbiBvciBldmVudEJ1ZmZlciBmb3VuZCB0byBmbHVzaC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLl9hZGRQZXJmb3JtYW5jZUVudHJpZXMoKTtcblxuICAgIC8vIENoZWNrIGV2ZW50QnVmZmVyIGFnYWluLCBhcyBpdCBjb3VsZCBoYXZlIGJlZW4gc3RvcHBlZCBpbiB0aGUgbWVhbndoaWxlXG4gICAgaWYgKCF0aGlzLmV2ZW50QnVmZmVyPy5oYXNFdmVudHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGF0dGFjaCBtZW1vcnkgZXZlbnQgaWYgZXZlbnRCdWZmZXIgaXMgbm90IGVtcHR5XG4gICAgYXdhaXQgYWRkTWVtb3J5RW50cnkodGhpcyk7XG5cbiAgICAvLyBDaGVjayBldmVudEJ1ZmZlciBhZ2FpbiwgYXMgaXQgY291bGQgaGF2ZSBiZWVuIHN0b3BwZWQgaW4gdGhlIG1lYW53aGlsZVxuICAgIGlmICghdGhpcy5ldmVudEJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgY2hhbmdlZCBpbiB0aGUgbWVhbndoaWxlLCBlLmcuIGJlY2F1c2UgdGhlIHNlc3Npb24gd2FzIHJlZnJlc2hlZCBvciBzaW1pbGFyLCB3ZSBhYm9ydCBoZXJlXG4gICAgaWYgKHJlcGxheUlkICE9PSB0aGlzLmdldFNlc3Npb25JZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoaXMgdXNlcyB0aGUgZGF0YSBmcm9tIHRoZSBldmVudEJ1ZmZlciwgc28gd2UgbmVlZCB0byBjYWxsIHRoaXMgYmVmb3JlIGBmaW5pc2goKVxuICAgICAgdGhpcy5fdXBkYXRlSW5pdGlhbFRpbWVzdGFtcEZyb21FdmVudEJ1ZmZlcigpO1xuXG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgICAvLyBDaGVjayB0b3RhbCBkdXJhdGlvbiBhZ2FpbiwgdG8gYXZvaWQgc2VuZGluZyBvdXRkYXRlZCBzdHVmZlxuICAgICAgLy8gV2UgbGVhdmUgMzBzIHdpZ2dsZSByb29tIHRvIGFjY29tbW9kYXRlIGxhdGUgZmx1c2hpbmcgZXRjLlxuICAgICAgLy8gVGhpcyBfY291bGRfIGhhcHBlbiB3aGVuIHRoZSBicm93c2VyIGlzIHN1c3BlbmRlZCBkdXJpbmcgZmx1c2hpbmcsIGluIHdoaWNoIGNhc2Ugd2UganVzdCB3YW50IHRvIHN0b3BcbiAgICAgIGlmICh0aW1lc3RhbXAgLSB0aGlzLl9jb250ZXh0LmluaXRpYWxUaW1lc3RhbXAgPiB0aGlzLl9vcHRpb25zLm1heFJlcGxheUR1cmF0aW9uICsgMzAwMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXNzaW9uIGlzIHRvbyBsb25nLCBub3Qgc2VuZGluZyByZXBsYXknKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXZlbnRDb250ZXh0ID0gdGhpcy5fcG9wRXZlbnRDb250ZXh0KCk7XG4gICAgICAvLyBBbHdheXMgaW5jcmVtZW50IHNlZ21lbnRJZCByZWdhcmRsZXNzIG9mIG91dGNvbWUgb2Ygc2VuZGluZyByZXBsYXlcbiAgICAgIGNvbnN0IHNlZ21lbnRJZCA9IHRoaXMuc2Vzc2lvbi5zZWdtZW50SWQrKztcbiAgICAgIHRoaXMuX21heWJlU2F2ZVNlc3Npb24oKTtcblxuICAgICAgLy8gTm90ZSB0aGlzIGVtcHRpZXMgdGhlIGV2ZW50IGJ1ZmZlciByZWdhcmRsZXNzIG9mIG91dGNvbWUgb2Ygc2VuZGluZyByZXBsYXlcbiAgICAgIGNvbnN0IHJlY29yZGluZ0RhdGEgPSBhd2FpdCB0aGlzLmV2ZW50QnVmZmVyLmZpbmlzaCgpO1xuXG4gICAgICBhd2FpdCBzZW5kUmVwbGF5KHtcbiAgICAgICAgcmVwbGF5SWQsXG4gICAgICAgIHJlY29yZGluZ0RhdGEsXG4gICAgICAgIHNlZ21lbnRJZCxcbiAgICAgICAgZXZlbnRDb250ZXh0LFxuICAgICAgICBzZXNzaW9uOiB0aGlzLnNlc3Npb24sXG4gICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgb25FcnJvcjogZXJyID0+IHRoaXMuaGFuZGxlRXhjZXB0aW9uKGVyciksXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuaGFuZGxlRXhjZXB0aW9uKGVycik7XG5cbiAgICAgIC8vIFRoaXMgbWVhbnMgd2UgcmV0cmllZCAzIHRpbWVzIGFuZCBhbGwgb2YgdGhlbSBmYWlsZWQsXG4gICAgICAvLyBvciB3ZSByYW4gaW50byBhIHByb2JsZW0gd2UgZG9uJ3Qgd2FudCB0byByZXRyeSwgbGlrZSByYXRlIGxpbWl0aW5nLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSB3YW50IHRvIGNvbXBsZXRlbHkgc3RvcCB0aGUgcmVwbGF5IC0gb3RoZXJ3aXNlLCB3ZSBtYXkgZ2V0IGluY29uc2lzdGVudCBzZWdtZW50c1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgcmVqZWN0XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICB0aGlzLnN0b3AoeyByZWFzb246ICdzZW5kUmVwbGF5JyB9KTtcblxuICAgICAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG5cbiAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgY29uc3QgZHJvcFJlYXNvbiA9IGVyciBpbnN0YW5jZW9mIFJhdGVMaW1pdEVycm9yID8gJ3JhdGVsaW1pdF9iYWNrb2ZmJyA6ICdzZW5kX2Vycm9yJztcbiAgICAgICAgY2xpZW50LnJlY29yZERyb3BwZWRFdmVudChkcm9wUmVhc29uLCAncmVwbGF5Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoIHJlY29yZGluZyBkYXRhIHRvIFNlbnRyeS4gQ3JlYXRlcyBhIGxvY2sgc28gdGhhdCBvbmx5IGEgc2luZ2xlIGZsdXNoXG4gICAqIGNhbiBiZSBhY3RpdmUgYXQgYSB0aW1lLiBEbyBub3QgY2FsbCB0aGlzIGRpcmVjdGx5LlxuICAgKi9cbiAgIGFzeW5jIF9mbHVzaCh7XG4gICAgZm9yY2UgPSBmYWxzZSxcbiAgfVxuXG4gPSB7fSkge1xuICAgIGlmICghdGhpcy5faXNFbmFibGVkICYmICFmb3JjZSkge1xuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIGUuZy4gdGhlIHJlcGxheSB3YXMgc3RvcHBlZCBiZWNhdXNlIG9mIGV4Y2VlZGluZyB0aGUgcmV0cnkgbGltaXRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY2hlY2tBbmRIYW5kbGVFeHBpcmVkU2Vzc2lvbigpKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIuZXJyb3IoJ0F0dGVtcHRpbmcgdG8gZmluaXNoIHJlcGxheSBldmVudCBhZnRlciBzZXNzaW9uIGV4cGlyZWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgIC8vIHNob3VsZCBuZXZlciBoYXBwZW4sIGFzIHdlIHdvdWxkIGhhdmUgYmFpbGVkIG91dCBiZWZvcmVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc2Vzc2lvbi5zdGFydGVkO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBub3cgLSBzdGFydDtcblxuICAgIC8vIEEgZmx1c2ggaXMgYWJvdXQgdG8gaGFwcGVuLCBjYW5jZWwgYW55IHF1ZXVlZCBmbHVzaGVzXG4gICAgdGhpcy5fZGVib3VuY2VkRmx1c2guY2FuY2VsKCk7XG5cbiAgICAvLyBJZiBzZXNzaW9uIGlzIHRvbyBzaG9ydCwgb3IgdG9vIGxvbmcgKGFsbG93IHNvbWUgd2lnZ2xlIHJvb20gb3ZlciBtYXhSZXBsYXlEdXJhdGlvbiksIGRvIG5vdCBzZW5kIGl0XG4gICAgLy8gVGhpcyBfc2hvdWxkXyBub3QgaGFwcGVuLCBidXQgaXQgbWF5IGhhcHBlbiBpZiBmbHVzaCBpcyB0cmlnZ2VyZWQgZHVlIHRvIGEgcGFnZSBhY3Rpdml0eSBjaGFuZ2Ugb3Igc2ltaWxhclxuICAgIGNvbnN0IHRvb1Nob3J0ID0gZHVyYXRpb24gPCB0aGlzLl9vcHRpb25zLm1pblJlcGxheUR1cmF0aW9uO1xuICAgIGNvbnN0IHRvb0xvbmcgPSBkdXJhdGlvbiA+IHRoaXMuX29wdGlvbnMubWF4UmVwbGF5RHVyYXRpb24gKyA1MDAwO1xuICAgIGlmICh0b29TaG9ydCB8fCB0b29Mb25nKSB7XG4gICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICBgU2Vzc2lvbiBkdXJhdGlvbiAoJHtNYXRoLmZsb29yKGR1cmF0aW9uIC8gMTAwMCl9cykgaXMgdG9vICR7XG4gICAgICAgICAgICB0b29TaG9ydCA/ICdzaG9ydCcgOiAnbG9uZydcbiAgICAgICAgICB9LCBub3Qgc2VuZGluZyByZXBsYXkuYCxcbiAgICAgICAgKTtcblxuICAgICAgaWYgKHRvb1Nob3J0KSB7XG4gICAgICAgIHRoaXMuX2RlYm91bmNlZEZsdXNoKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnRCdWZmZXIgPSB0aGlzLmV2ZW50QnVmZmVyO1xuICAgIGlmIChldmVudEJ1ZmZlciAmJiB0aGlzLnNlc3Npb24uc2VnbWVudElkID09PSAwICYmICFldmVudEJ1ZmZlci5oYXNDaGVja291dCkge1xuICAgICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmluZm8oJ0ZsdXNoaW5nIGluaXRpYWwgc2VnbWVudCB3aXRob3V0IGNoZWNrb3V0LicpO1xuICAgICAgLy8gVE9ETyBGTjogRXZhbHVhdGUgaWYgd2Ugd2FudCB0byBzdG9wIGhlcmUsIG9yIHJlbW92ZSB0aGlzIGFnYWluP1xuICAgIH1cblxuICAgIGNvbnN0IF9mbHVzaEluUHJvZ3Jlc3MgPSAhIXRoaXMuX2ZsdXNoTG9jaztcblxuICAgIC8vIHRoaXMuX2ZsdXNoTG9jayBhY3RzIGFzIGEgbG9jayBzbyB0aGF0IGZ1dHVyZSBjYWxscyB0byBgX2ZsdXNoKClgIHdpbGxcbiAgICAvLyBiZSBibG9ja2VkIHVudGlsIGN1cnJlbnQgZmx1c2ggaXMgZmluaXNoZWQgKGkuZS4gdGhpcyBwcm9taXNlIHJlc29sdmVzKVxuICAgIGlmICghdGhpcy5fZmx1c2hMb2NrKSB7XG4gICAgICB0aGlzLl9mbHVzaExvY2sgPSB0aGlzLl9ydW5GbHVzaCgpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9mbHVzaExvY2s7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmhhbmRsZUV4Y2VwdGlvbihlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9mbHVzaExvY2sgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChfZmx1c2hJblByb2dyZXNzKSB7XG4gICAgICAgIC8vIFdhaXQgZm9yIHByZXZpb3VzIGZsdXNoIHRvIGZpbmlzaCwgdGhlbiBjYWxsIHRoZSBkZWJvdW5jZWRcbiAgICAgICAgLy8gYF9mbHVzaCgpYC4gSXQncyBwb3NzaWJsZSB0aGVyZSBhcmUgb3RoZXIgZmx1c2ggcmVxdWVzdHMgcXVldWVkIGFuZFxuICAgICAgICAvLyB3YWl0aW5nIGZvciBpdCB0byByZXNvbHZlLiBXZSB3YW50IHRvIHJlZHVjZSBhbGwgb3V0c3RhbmRpbmdcbiAgICAgICAgLy8gcmVxdWVzdHMgKGFzIHdlbGwgYXMgYW55IG5ldyBmbHVzaCByZXF1ZXN0cyB0aGF0IG9jY3VyIHdpdGhpbiBhXG4gICAgICAgIC8vIHNlY29uZCBvZiB0aGUgbG9ja2VkIGZsdXNoIGNvbXBsZXRpbmcpIGludG8gYSBzaW5nbGUgZmx1c2guXG4gICAgICAgIHRoaXMuX2RlYm91bmNlZEZsdXNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIFNhdmUgdGhlIHNlc3Npb24sIGlmIGl0IGlzIHN0aWNreSAqL1xuICAgX21heWJlU2F2ZVNlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMuc2Vzc2lvbiAmJiB0aGlzLl9vcHRpb25zLnN0aWNreVNlc3Npb24pIHtcbiAgICAgIHNhdmVTZXNzaW9uKHRoaXMuc2Vzc2lvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqIEhhbmRsZXIgZm9yIHJyd2ViLnJlY29yZC5vbk11dGF0aW9uICovXG4gICBfb25NdXRhdGlvbkhhbmRsZXIobXV0YXRpb25zKSB7XG4gICAgY29uc3QgY291bnQgPSBtdXRhdGlvbnMubGVuZ3RoO1xuXG4gICAgY29uc3QgbXV0YXRpb25MaW1pdCA9IHRoaXMuX29wdGlvbnMubXV0YXRpb25MaW1pdDtcbiAgICBjb25zdCBtdXRhdGlvbkJyZWFkY3J1bWJMaW1pdCA9IHRoaXMuX29wdGlvbnMubXV0YXRpb25CcmVhZGNydW1iTGltaXQ7XG4gICAgY29uc3Qgb3Zlck11dGF0aW9uTGltaXQgPSBtdXRhdGlvbkxpbWl0ICYmIGNvdW50ID4gbXV0YXRpb25MaW1pdDtcblxuICAgIC8vIENyZWF0ZSBhIGJyZWFkY3J1bWIgaWYgYSBsb3Qgb2YgbXV0YXRpb25zIGhhcHBlbiBhdCB0aGUgc2FtZSB0aW1lXG4gICAgLy8gV2UgY2FuIHNob3cgdGhpcyBpbiB0aGUgVUkgYXMgYW4gaW5mb3JtYXRpb24gd2l0aCBwb3RlbnRpYWwgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzXG4gICAgaWYgKGNvdW50ID4gbXV0YXRpb25CcmVhZGNydW1iTGltaXQgfHwgb3Zlck11dGF0aW9uTGltaXQpIHtcbiAgICAgIGNvbnN0IGJyZWFkY3J1bWIgPSBjcmVhdGVCcmVhZGNydW1iKHtcbiAgICAgICAgY2F0ZWdvcnk6ICdyZXBsYXkubXV0YXRpb25zJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGNvdW50LFxuICAgICAgICAgIGxpbWl0OiBvdmVyTXV0YXRpb25MaW1pdCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fY3JlYXRlQ3VzdG9tQnJlYWRjcnVtYihicmVhZGNydW1iKTtcbiAgICB9XG5cbiAgICAvLyBTdG9wIHJlcGxheSBpZiBvdmVyIHRoZSBtdXRhdGlvbiBsaW1pdFxuICAgIGlmIChvdmVyTXV0YXRpb25MaW1pdCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgcmVqZWN0XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICB0aGlzLnN0b3AoeyByZWFzb246ICdtdXRhdGlvbkxpbWl0JywgZm9yY2VGbHVzaDogdGhpcy5yZWNvcmRpbmdNb2RlID09PSAnc2Vzc2lvbicgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gYHRydWVgIG1lYW5zIHdlIHVzZSB0aGUgcmVndWxhciBtdXRhdGlvbiBoYW5kbGluZyBieSBycndlYlxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvbihzZWxlY3RvcnMsIGRlZmF1bHRTZWxlY3RvcnMpIHtcbiAgcmV0dXJuIFtcbiAgICAuLi5zZWxlY3RvcnMsXG4gICAgLy8gc2VudHJ5IGRlZmF1bHRzXG4gICAgLi4uZGVmYXVsdFNlbGVjdG9ycyxcbiAgXS5qb2luKCcsJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBwcml2YWN5IHJlbGF0ZWQgY29uZmlndXJhdGlvbiBmb3IgdXNlIGluIHJyd2ViXG4gKi9cbmZ1bmN0aW9uIGdldFByaXZhY3lPcHRpb25zKHsgbWFzaywgdW5tYXNrLCBibG9jaywgdW5ibG9jaywgaWdub3JlIH0pIHtcbiAgY29uc3QgZGVmYXVsdEJsb2NrZWRFbGVtZW50cyA9IFsnYmFzZScsICdpZnJhbWVbc3JjZG9jXTpub3QoW3NyY10pJ107XG5cbiAgY29uc3QgbWFza1NlbGVjdG9yID0gZ2V0T3B0aW9uKG1hc2ssIFsnLnNlbnRyeS1tYXNrJywgJ1tkYXRhLXNlbnRyeS1tYXNrXSddKTtcbiAgY29uc3QgdW5tYXNrU2VsZWN0b3IgPSBnZXRPcHRpb24odW5tYXNrLCBbXSk7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAvLyBXZSBhcmUgbWFraW5nIHRoZSBkZWNpc2lvbiB0byBtYWtlIHRleHQgYW5kIGlucHV0IHNlbGVjdG9ycyB0aGUgc2FtZVxuICAgIG1hc2tUZXh0U2VsZWN0b3I6IG1hc2tTZWxlY3RvcixcbiAgICB1bm1hc2tUZXh0U2VsZWN0b3I6IHVubWFza1NlbGVjdG9yLFxuXG4gICAgYmxvY2tTZWxlY3RvcjogZ2V0T3B0aW9uKGJsb2NrLCBbJy5zZW50cnktYmxvY2snLCAnW2RhdGEtc2VudHJ5LWJsb2NrXScsIC4uLmRlZmF1bHRCbG9ja2VkRWxlbWVudHNdKSxcbiAgICB1bmJsb2NrU2VsZWN0b3I6IGdldE9wdGlvbih1bmJsb2NrLCBbXSksXG4gICAgaWdub3JlU2VsZWN0b3I6IGdldE9wdGlvbihpZ25vcmUsIFsnLnNlbnRyeS1pZ25vcmUnLCAnW2RhdGEtc2VudHJ5LWlnbm9yZV0nLCAnaW5wdXRbdHlwZT1cImZpbGVcIl0nXSksXG4gIH07XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogTWFza3MgYW4gYXR0cmlidXRlIGlmIG5lY2Vzc2FyeSwgb3RoZXJ3aXNlIHJldHVybiBhdHRyaWJ1dGUgdmFsdWUgYXMtaXMuXG4gKi9cbmZ1bmN0aW9uIG1hc2tBdHRyaWJ1dGUoe1xuICBlbCxcbiAga2V5LFxuICBtYXNrQXR0cmlidXRlcyxcbiAgbWFza0FsbFRleHQsXG4gIHByaXZhY3lPcHRpb25zLFxuICB2YWx1ZSxcbn0pIHtcbiAgLy8gV2Ugb25seSBtYXNrIGF0dHJpYnV0ZXMgaWYgYG1hc2tBbGxUZXh0YCBpcyB0cnVlXG4gIGlmICghbWFza0FsbFRleHQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyB1bm1hc2tUZXh0U2VsZWN0b3IgdGFrZXMgcHJlY2VkZW5jZVxuICBpZiAocHJpdmFjeU9wdGlvbnMudW5tYXNrVGV4dFNlbGVjdG9yICYmIGVsLm1hdGNoZXMocHJpdmFjeU9wdGlvbnMudW5tYXNrVGV4dFNlbGVjdG9yKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChcbiAgICBtYXNrQXR0cmlidXRlcy5pbmNsdWRlcyhrZXkpIHx8XG4gICAgLy8gTmVlZCB0byBtYXNrIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBgPGlucHV0PmAgaWYgaXQncyBhIGJ1dHRvbi1saWtlXG4gICAgLy8gdHlwZVxuICAgIChrZXkgPT09ICd2YWx1ZScgJiYgZWwudGFnTmFtZSA9PT0gJ0lOUFVUJyAmJiBbJ3N1Ym1pdCcsICdidXR0b24nXS5pbmNsdWRlcyhlbC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSB8fCAnJykpXG4gICkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXFxTXS9nLCAnKicpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5jb25zdCBNRURJQV9TRUxFQ1RPUlMgPVxuICAnaW1nLGltYWdlLHN2Zyx2aWRlbyxvYmplY3QscGljdHVyZSxlbWJlZCxtYXAsYXVkaW8sbGlua1tyZWw9XCJpY29uXCJdLGxpbmtbcmVsPVwiYXBwbGUtdG91Y2gtaWNvblwiXSc7XG5cbmNvbnN0IERFRkFVTFRfTkVUV09SS19IRUFERVJTID0gWydjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnYWNjZXB0J107XG5cbmxldCBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBTZW50cnkgaW50ZWdyYXRpb24gZm9yIFtTZXNzaW9uIFJlcGxheV0oaHR0cHM6Ly9zZW50cnkuaW8vZm9yL3Nlc3Npb24tcmVwbGF5LykuXG4gKlxuICogU2VlIHRoZSBbUmVwbGF5IGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5zZW50cnkuaW8vcGxhdGZvcm1zL2phdmFzY3JpcHQvZ3VpZGVzL3Nlc3Npb24tcmVwbGF5LykgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqIFNlbnRyeS5pbml0KHtcbiAqICAgZHNuOiAnX19EU05fXycsXG4gKiAgIGludGVncmF0aW9uczogW1NlbnRyeS5yZXBsYXlJbnRlZ3JhdGlvbigpXSxcbiAqIH0pO1xuICogYGBgXG4gKi9cbmNvbnN0IHJlcGxheUludGVncmF0aW9uID0gKChvcHRpb25zKSA9PiB7XG4gIHJldHVybiBuZXcgUmVwbGF5KG9wdGlvbnMpO1xufSkgO1xuXG4vKipcbiAqIFJlcGxheSBpbnRlZ3JhdGlvblxuICovXG5jbGFzcyBSZXBsYXkgIHtcbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIHRvIHBhc3MgdG8gYHJyd2ViLnJlY29yZCgpYFxuICAgKi9cblxuICAvKipcbiAgICogSW5pdGlhbCBvcHRpb25zIHBhc3NlZCB0byB0aGUgcmVwbGF5IGludGVncmF0aW9uLCBtZXJnZWQgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICogTm90ZTogYHNlc3Npb25TYW1wbGVSYXRlYCBhbmQgYGVycm9yU2FtcGxlUmF0ZWAgYXJlIG5vdCByZXF1aXJlZCBoZXJlLCBhcyB0aGV5XG4gICAqIGNhbiBvbmx5IGJlIGZpbmFsbHkgc2V0IHdoZW4gc2V0dXBPbmNlKCkgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICAgY29uc3RydWN0b3Ioe1xuICAgIGZsdXNoTWluRGVsYXkgPSBERUZBVUxUX0ZMVVNIX01JTl9ERUxBWSxcbiAgICBmbHVzaE1heERlbGF5ID0gREVGQVVMVF9GTFVTSF9NQVhfREVMQVksXG4gICAgbWluUmVwbGF5RHVyYXRpb24gPSBNSU5fUkVQTEFZX0RVUkFUSU9OLFxuICAgIG1heFJlcGxheUR1cmF0aW9uID0gTUFYX1JFUExBWV9EVVJBVElPTixcbiAgICBzdGlja3lTZXNzaW9uID0gdHJ1ZSxcbiAgICB1c2VDb21wcmVzc2lvbiA9IHRydWUsXG4gICAgd29ya2VyVXJsLFxuICAgIF9leHBlcmltZW50cyA9IHt9LFxuICAgIG1hc2tBbGxUZXh0ID0gdHJ1ZSxcbiAgICBtYXNrQWxsSW5wdXRzID0gdHJ1ZSxcbiAgICBibG9ja0FsbE1lZGlhID0gdHJ1ZSxcblxuICAgIG11dGF0aW9uQnJlYWRjcnVtYkxpbWl0ID0gNzUwLFxuICAgIG11dGF0aW9uTGltaXQgPSAxMDAwMCxcblxuICAgIHNsb3dDbGlja1RpbWVvdXQgPSA3MDAwLFxuICAgIHNsb3dDbGlja0lnbm9yZVNlbGVjdG9ycyA9IFtdLFxuXG4gICAgbmV0d29ya0RldGFpbEFsbG93VXJscyA9IFtdLFxuICAgIG5ldHdvcmtEZXRhaWxEZW55VXJscyA9IFtdLFxuICAgIG5ldHdvcmtDYXB0dXJlQm9kaWVzID0gdHJ1ZSxcbiAgICBuZXR3b3JrUmVxdWVzdEhlYWRlcnMgPSBbXSxcbiAgICBuZXR3b3JrUmVzcG9uc2VIZWFkZXJzID0gW10sXG5cbiAgICBtYXNrID0gW10sXG4gICAgbWFza0F0dHJpYnV0ZXMgPSBbJ3RpdGxlJywgJ3BsYWNlaG9sZGVyJywgJ2FyaWEtbGFiZWwnXSxcbiAgICB1bm1hc2sgPSBbXSxcbiAgICBibG9jayA9IFtdLFxuICAgIHVuYmxvY2sgPSBbXSxcbiAgICBpZ25vcmUgPSBbXSxcbiAgICBtYXNrRm4sXG5cbiAgICBiZWZvcmVBZGRSZWNvcmRpbmdFdmVudCxcbiAgICBiZWZvcmVFcnJvclNhbXBsaW5nLFxuICAgIG9uRXJyb3IsXG4gIH0gPSB7fSkge1xuICAgIHRoaXMubmFtZSA9ICdSZXBsYXknO1xuXG4gICAgY29uc3QgcHJpdmFjeU9wdGlvbnMgPSBnZXRQcml2YWN5T3B0aW9ucyh7XG4gICAgICBtYXNrLFxuICAgICAgdW5tYXNrLFxuICAgICAgYmxvY2ssXG4gICAgICB1bmJsb2NrLFxuICAgICAgaWdub3JlLFxuICAgIH0pO1xuXG4gICAgdGhpcy5fcmVjb3JkaW5nT3B0aW9ucyA9IHtcbiAgICAgIG1hc2tBbGxJbnB1dHMsXG4gICAgICBtYXNrQWxsVGV4dCxcbiAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IHsgcGFzc3dvcmQ6IHRydWUgfSxcbiAgICAgIG1hc2tUZXh0Rm46IG1hc2tGbixcbiAgICAgIG1hc2tJbnB1dEZuOiBtYXNrRm4sXG4gICAgICBtYXNrQXR0cmlidXRlRm46IChrZXksIHZhbHVlLCBlbCkgPT5cbiAgICAgICAgbWFza0F0dHJpYnV0ZSh7XG4gICAgICAgICAgbWFza0F0dHJpYnV0ZXMsXG4gICAgICAgICAgbWFza0FsbFRleHQsXG4gICAgICAgICAgcHJpdmFjeU9wdGlvbnMsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGVsLFxuICAgICAgICB9KSxcblxuICAgICAgLi4ucHJpdmFjeU9wdGlvbnMsXG5cbiAgICAgIC8vIE91ciBkZWZhdWx0c1xuICAgICAgc2xpbURPTU9wdGlvbnM6ICdhbGwnLFxuICAgICAgaW5saW5lU3R5bGVzaGVldDogdHJ1ZSxcbiAgICAgIC8vIERpc2FibGUgaW5saW5lIGltYWdlcyBhcyBpdCB3aWxsIGluY3JlYXNlIHNlZ21lbnQvcmVwbGF5IHNpemVcbiAgICAgIGlubGluZUltYWdlczogZmFsc2UsXG4gICAgICAvLyBjb2xsZWN0IGZvbnRzLCBidXQgYmUgYXdhcmUgdGhhdCBgc2VudHJ5LmlvYCBuZWVkcyB0byBiZSBhbiBhbGxvd2VkXG4gICAgICAvLyBvcmlnaW4gZm9yIHBsYXliYWNrXG4gICAgICBjb2xsZWN0Rm9udHM6IHRydWUsXG4gICAgICBlcnJvckhhbmRsZXI6IChlcnIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlcnIuX19ycndlYl9fID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGhlcmVcbiAgICAgICAgICAvLyB0aGlzIGNhbiBoYXBwZW4gaWYgdGhlIGVycm9yIGlzIGZyb3plbiBvciBkb2VzIG5vdCBhbGxvdyBtdXRhdGlvbiBmb3Igb3RoZXIgcmVhc29uc1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gZXhwZXJpbWVudGFsIHN1cHBvcnQgZm9yIHJlY29yZGluZyBpZnJhbWVzIGZyb20gZGlmZmVyZW50IG9yaWdpbnNcbiAgICAgIHJlY29yZENyb3NzT3JpZ2luSWZyYW1lczogQm9vbGVhbihfZXhwZXJpbWVudHMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzKSxcbiAgICB9O1xuXG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSB7XG4gICAgICBmbHVzaE1pbkRlbGF5LFxuICAgICAgZmx1c2hNYXhEZWxheSxcbiAgICAgIG1pblJlcGxheUR1cmF0aW9uOiBNYXRoLm1pbihtaW5SZXBsYXlEdXJhdGlvbiwgTUlOX1JFUExBWV9EVVJBVElPTl9MSU1JVCksXG4gICAgICBtYXhSZXBsYXlEdXJhdGlvbjogTWF0aC5taW4obWF4UmVwbGF5RHVyYXRpb24sIE1BWF9SRVBMQVlfRFVSQVRJT04pLFxuICAgICAgc3RpY2t5U2Vzc2lvbixcbiAgICAgIHVzZUNvbXByZXNzaW9uLFxuICAgICAgd29ya2VyVXJsLFxuICAgICAgYmxvY2tBbGxNZWRpYSxcbiAgICAgIG1hc2tBbGxJbnB1dHMsXG4gICAgICBtYXNrQWxsVGV4dCxcbiAgICAgIG11dGF0aW9uQnJlYWRjcnVtYkxpbWl0LFxuICAgICAgbXV0YXRpb25MaW1pdCxcbiAgICAgIHNsb3dDbGlja1RpbWVvdXQsXG4gICAgICBzbG93Q2xpY2tJZ25vcmVTZWxlY3RvcnMsXG4gICAgICBuZXR3b3JrRGV0YWlsQWxsb3dVcmxzLFxuICAgICAgbmV0d29ya0RldGFpbERlbnlVcmxzLFxuICAgICAgbmV0d29ya0NhcHR1cmVCb2RpZXMsXG4gICAgICBuZXR3b3JrUmVxdWVzdEhlYWRlcnM6IF9nZXRNZXJnZWROZXR3b3JrSGVhZGVycyhuZXR3b3JrUmVxdWVzdEhlYWRlcnMpLFxuICAgICAgbmV0d29ya1Jlc3BvbnNlSGVhZGVyczogX2dldE1lcmdlZE5ldHdvcmtIZWFkZXJzKG5ldHdvcmtSZXNwb25zZUhlYWRlcnMpLFxuICAgICAgYmVmb3JlQWRkUmVjb3JkaW5nRXZlbnQsXG4gICAgICBiZWZvcmVFcnJvclNhbXBsaW5nLFxuICAgICAgb25FcnJvcixcblxuICAgICAgX2V4cGVyaW1lbnRzLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5faW5pdGlhbE9wdGlvbnMuYmxvY2tBbGxNZWRpYSkge1xuICAgICAgLy8gYGJsb2NrQWxsTWVkaWFgIGlzIGEgbW9yZSB1c2VyIGZyaWVuZGx5IG9wdGlvbiB0byBjb25maWd1cmUgYmxvY2tpbmdcbiAgICAgIC8vIGVtYmVkZGVkIG1lZGlhIGVsZW1lbnRzXG4gICAgICB0aGlzLl9yZWNvcmRpbmdPcHRpb25zLmJsb2NrU2VsZWN0b3IgPSAhdGhpcy5fcmVjb3JkaW5nT3B0aW9ucy5ibG9ja1NlbGVjdG9yXG4gICAgICAgID8gTUVESUFfU0VMRUNUT1JTXG4gICAgICAgIDogYCR7dGhpcy5fcmVjb3JkaW5nT3B0aW9ucy5ibG9ja1NlbGVjdG9yfSwke01FRElBX1NFTEVDVE9SU31gO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0luaXRpYWxpemVkICYmIGlzQnJvd3NlcigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIFNlbnRyeSBTZXNzaW9uIFJlcGxheSBpbnN0YW5jZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBJZiByZXBsYXkgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZCAqL1xuICAgZ2V0IF9pc0luaXRpYWxpemVkKCkge1xuICAgIHJldHVybiBfaW5pdGlhbGl6ZWQ7XG4gIH1cblxuICAvKiogVXBkYXRlIF9pc0luaXRpYWxpemVkICovXG4gICBzZXQgX2lzSW5pdGlhbGl6ZWQodmFsdWUpIHtcbiAgICBfaW5pdGlhbGl6ZWQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBhbmQgaW5pdGlhbGl6ZSByZXBsYXkgY29udGFpbmVyXG4gICAqL1xuICAgYWZ0ZXJBbGxTZXR1cChjbGllbnQpIHtcbiAgICBpZiAoIWlzQnJvd3NlcigpIHx8IHRoaXMuX3JlcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NldHVwKGNsaWVudCk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZShjbGllbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgcmVwbGF5IHJlZ2FyZGxlc3Mgb2Ygc2FtcGxpbmcgcmF0ZS4gQ2FsbGluZyB0aGlzIHdpbGwgYWx3YXlzXG4gICAqIGNyZWF0ZSBhIG5ldyBzZXNzaW9uLiBXaWxsIGxvZyBhIG1lc3NhZ2UgaWYgcmVwbGF5IGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MuXG4gICAqXG4gICAqIENyZWF0ZXMgb3IgbG9hZHMgYSBzZXNzaW9uLCBhdHRhY2hlcyBsaXN0ZW5lcnMgdG8gdmFyeWluZyBldmVudHMgKERPTSxcbiAgICogUGVyZm9ybWFuY2VPYnNlcnZlciwgUmVjb3JkaW5nLCBTZW50cnkgU0RLLCBldGMpXG4gICAqL1xuICAgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXBsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVwbGF5LnN0YXJ0KCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcmVwbGF5IGJ1ZmZlcmluZy4gQnVmZmVycyB1bnRpbCBgZmx1c2goKWAgaXMgY2FsbGVkIG9yLCBpZlxuICAgKiBgcmVwbGF5c09uRXJyb3JTYW1wbGVSYXRlYCA+IDAsIHVudGlsIGFuIGVycm9yIG9jY3Vycy5cbiAgICovXG4gICBzdGFydEJ1ZmZlcmluZygpIHtcbiAgICBpZiAoIXRoaXMuX3JlcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcGxheS5zdGFydEJ1ZmZlcmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnRseSwgdGhpcyBuZWVkcyB0byBiZSBtYW51YWxseSBjYWxsZWQgKGUuZy4gZm9yIHRlc3RzKS4gU2VudHJ5IFNES1xuICAgKiBkb2VzIG5vdCBzdXBwb3J0IGEgdGVhcmRvd25cbiAgICovXG4gICBzdG9wKCkge1xuICAgIGlmICghdGhpcy5fcmVwbGF5KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcGxheS5zdG9wKHsgZm9yY2VGbHVzaDogdGhpcy5fcmVwbGF5LnJlY29yZGluZ01vZGUgPT09ICdzZXNzaW9uJyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBub3QgaW4gXCJzZXNzaW9uXCIgcmVjb3JkaW5nIG1vZGUsIGZsdXNoIGV2ZW50IGJ1ZmZlciB3aGljaCB3aWxsIGNyZWF0ZSBhIG5ldyByZXBsYXkuXG4gICAqIElmIHJlcGxheSBpcyBub3QgZW5hYmxlZCwgYSBuZXcgc2Vzc2lvbiByZXBsYXkgaXMgc3RhcnRlZC5cbiAgICogVW5sZXNzIGBjb250aW51ZVJlY29yZGluZ2AgaXMgZmFsc2UsIHRoZSByZXBsYXkgd2lsbCBjb250aW51ZSB0byByZWNvcmQgYW5kXG4gICAqIGJlaGF2ZSBhcyBhIFwic2Vzc2lvblwiLWJhc2VkIHJlcGxheS5cbiAgICpcbiAgICogT3RoZXJ3aXNlLCBxdWV1ZSB1cCBhIGZsdXNoLlxuICAgKi9cbiAgIGZsdXNoKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuX3JlcGxheSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIC8vIGFzc3VtaW5nIGEgc2Vzc2lvbiBzaG91bGQgYmUgcmVjb3JkZWQgaW4gdGhpcyBjYXNlXG4gICAgaWYgKCF0aGlzLl9yZXBsYXkuaXNFbmFibGVkKCkpIHtcbiAgICAgIHRoaXMuX3JlcGxheS5zdGFydCgpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXBsYXkuc2VuZEJ1ZmZlcmVkUmVwbGF5T3JGbHVzaChvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc2Vzc2lvbiBJRC5cbiAgICovXG4gICBnZXRSZXBsYXlJZCgpIHtcbiAgICBpZiAoIXRoaXMuX3JlcGxheT8uaXNFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVwbGF5LmdldFNlc3Npb25JZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCByZWNvcmRpbmcgbW9kZS4gVGhpcyBjYW4gYmUgZWl0aGVyIGBzZXNzaW9uYCBvciBgYnVmZmVyYC5cbiAgICpcbiAgICogYHNlc3Npb25gOiBSZWNvcmRpbmcgdGhlIHdob2xlIHNlc3Npb24sIHNlbmRpbmcgaXQgY29udGludW91c2x5XG4gICAqIGBidWZmZXJgOiBBbHdheXMga2VlcGluZyB0aGUgbGFzdCA2MHMgb2YgcmVjb3JkaW5nLCByZXF1aXJlczpcbiAgICogICAtIGhhdmluZyByZXBsYXlzT25FcnJvclNhbXBsZVJhdGUgPiAwIHRvIGNhcHR1cmUgcmVwbGF5IHdoZW4gYW4gZXJyb3Igb2NjdXJzXG4gICAqICAgLSBvciBjYWxsaW5nIGBmbHVzaCgpYCB0byBzZW5kIHRoZSByZXBsYXlcbiAgICovXG4gICBnZXRSZWNvcmRpbmdNb2RlKCkge1xuICAgIGlmICghdGhpcy5fcmVwbGF5Py5pc0VuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXBsYXkucmVjb3JkaW5nTW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyByZXBsYXkuXG4gICAqL1xuICAgX2luaXRpYWxpemUoY2xpZW50KSB7XG4gICAgaWYgKCF0aGlzLl9yZXBsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXliZUxvYWRGcm9tUmVwbGF5Q2FudmFzSW50ZWdyYXRpb24oY2xpZW50KTtcbiAgICB0aGlzLl9yZXBsYXkuaW5pdGlhbGl6ZVNhbXBsaW5nKCk7XG4gIH1cblxuICAvKiogU2V0dXAgdGhlIGludGVncmF0aW9uLiAqL1xuICAgX3NldHVwKGNsaWVudCkge1xuICAgIC8vIENsaWVudCBpcyBub3QgYXZhaWxhYmxlIGluIGNvbnN0cnVjdG9yLCBzbyB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgc2V0dXBPbmNlXG4gICAgY29uc3QgZmluYWxPcHRpb25zID0gbG9hZFJlcGxheU9wdGlvbnNGcm9tQ2xpZW50KHRoaXMuX2luaXRpYWxPcHRpb25zLCBjbGllbnQpO1xuXG4gICAgdGhpcy5fcmVwbGF5ID0gbmV3IFJlcGxheUNvbnRhaW5lcih7XG4gICAgICBvcHRpb25zOiBmaW5hbE9wdGlvbnMsXG4gICAgICByZWNvcmRpbmdPcHRpb25zOiB0aGlzLl9yZWNvcmRpbmdPcHRpb25zLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEdldCBjYW52YXMgb3B0aW9ucyBmcm9tIFJlcGxheUNhbnZhcyBpbnRlZ3JhdGlvbiwgaWYgaXQgaXMgYWxzbyBhZGRlZC4gKi9cbiAgIF9tYXliZUxvYWRGcm9tUmVwbGF5Q2FudmFzSW50ZWdyYXRpb24oY2xpZW50KSB7XG4gICAgLy8gVG8gc2F2ZSBidW5kbGUgc2l6ZSwgd2Ugc2tpcCBjaGVja2luZyBmb3Igc3R1ZmYgaGVyZVxuICAgIC8vIGFuZCBpbnN0ZWFkIGp1c3QgdHJ5LWNhdGNoIGV2ZXJ5dGhpbmcgLSBhcyBnZW5lcmFsbHkgdGhpcyBzaG91bGQgYWxsIGJlIGRlZmluZWRcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhbnZhc0ludGVncmF0aW9uID0gY2xpZW50LmdldEludGVncmF0aW9uQnlOYW1lKCdSZXBsYXlDYW52YXMnKVxuXG47XG4gICAgICBpZiAoIWNhbnZhc0ludGVncmF0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVwbGF5WydfY2FudmFzJ10gPSBjYW52YXNJbnRlZ3JhdGlvbi5nZXRPcHRpb25zKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBpZ25vcmUgZXJyb3JzIGhlcmVcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG4gIH1cbn1cblxuLyoqIFBhcnNlIFJlcGxheS1yZWxhdGVkIG9wdGlvbnMgZnJvbSBTREsgb3B0aW9ucyAqL1xuZnVuY3Rpb24gbG9hZFJlcGxheU9wdGlvbnNGcm9tQ2xpZW50KGluaXRpYWxPcHRpb25zLCBjbGllbnQpIHtcbiAgY29uc3Qgb3B0ID0gY2xpZW50LmdldE9wdGlvbnMoKSA7XG5cbiAgY29uc3QgZmluYWxPcHRpb25zID0ge1xuICAgIHNlc3Npb25TYW1wbGVSYXRlOiAwLFxuICAgIGVycm9yU2FtcGxlUmF0ZTogMCxcbiAgICAuLi5pbml0aWFsT3B0aW9ucyxcbiAgfTtcblxuICBjb25zdCByZXBsYXlzU2Vzc2lvblNhbXBsZVJhdGUgPSBwYXJzZVNhbXBsZVJhdGUob3B0LnJlcGxheXNTZXNzaW9uU2FtcGxlUmF0ZSk7XG4gIGNvbnN0IHJlcGxheXNPbkVycm9yU2FtcGxlUmF0ZSA9IHBhcnNlU2FtcGxlUmF0ZShvcHQucmVwbGF5c09uRXJyb3JTYW1wbGVSYXRlKTtcblxuICBpZiAocmVwbGF5c1Nlc3Npb25TYW1wbGVSYXRlID09IG51bGwgJiYgcmVwbGF5c09uRXJyb3JTYW1wbGVSYXRlID09IG51bGwpIHtcbiAgICBjb25zb2xlU2FuZGJveCgoKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnUmVwbGF5IGlzIGRpc2FibGVkIGJlY2F1c2UgbmVpdGhlciBgcmVwbGF5c1Nlc3Npb25TYW1wbGVSYXRlYCBub3IgYHJlcGxheXNPbkVycm9yU2FtcGxlUmF0ZWAgYXJlIHNldC4nLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXBsYXlzU2Vzc2lvblNhbXBsZVJhdGUgIT0gbnVsbCkge1xuICAgIGZpbmFsT3B0aW9ucy5zZXNzaW9uU2FtcGxlUmF0ZSA9IHJlcGxheXNTZXNzaW9uU2FtcGxlUmF0ZTtcbiAgfVxuXG4gIGlmIChyZXBsYXlzT25FcnJvclNhbXBsZVJhdGUgIT0gbnVsbCkge1xuICAgIGZpbmFsT3B0aW9ucy5lcnJvclNhbXBsZVJhdGUgPSByZXBsYXlzT25FcnJvclNhbXBsZVJhdGU7XG4gIH1cblxuICByZXR1cm4gZmluYWxPcHRpb25zO1xufVxuXG5mdW5jdGlvbiBfZ2V0TWVyZ2VkTmV0d29ya0hlYWRlcnMoaGVhZGVycykge1xuICByZXR1cm4gWy4uLkRFRkFVTFRfTkVUV09SS19IRUFERVJTLCAuLi5oZWFkZXJzLm1hcChoZWFkZXIgPT4gaGVhZGVyLnRvTG93ZXJDYXNlKCkpXTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgc21hbGwgdXRpbGl0eSB0byBnZXQgYSB0eXBlLXNhZmUgaW5zdGFuY2Ugb2YgdGhlIFJlcGxheSBpbnRlZ3JhdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVwbGF5KCkge1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQoKTtcbiAgcmV0dXJuIGNsaWVudD8uZ2V0SW50ZWdyYXRpb25CeU5hbWUoJ1JlcGxheScpO1xufVxuXG5leHBvcnQgeyBnZXRSZXBsYXksIHJlcGxheUludGVncmF0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sentry-internal/replay/build/npm/esm/index.js\n'))}}]);