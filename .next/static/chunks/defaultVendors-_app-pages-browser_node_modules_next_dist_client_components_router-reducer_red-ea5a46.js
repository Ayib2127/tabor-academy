"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([["defaultVendors-_app-pages-browser_node_modules_next_dist_client_components_router-reducer_red-ea5a46"],{"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    abortTask: function() {\n        return abortTask;\n    },\n    listenForDynamicRequest: function() {\n        return listenForDynamicRequest;\n    },\n    startPPRNavigation: function() {\n        return startPPRNavigation;\n    },\n    updateCacheNodeOnPopstateRestoration: function() {\n        return updateCacheNodeOnPopstateRestoration;\n    }\n});\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ./is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ./prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst MPA_NAVIGATION_TASK = {\n    route: null,\n    node: null,\n    dynamicRequestTree: null,\n    children: null\n};\nfunction startPPRNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegmentsResult) {\n    const segmentPath = [];\n    return updateCacheNodeOnNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, false, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult);\n}\nfunction updateCacheNodeOnNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, didFindRootLayout, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult) {\n    // Diff the old and new trees to reuse the shared layouts.\n    const oldRouterStateChildren = oldRouterState[1];\n    const newRouterStateChildren = newRouterState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;\n    if (!didFindRootLayout) {\n        // We're currently traversing the part of the tree that was also part of\n        // the previous route. If we discover a root layout, then we don't need to\n        // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n        const isRootLayout = newRouterState[4] === true;\n        if (isRootLayout) {\n            // Found a matching root layout.\n            didFindRootLayout = true;\n        }\n    }\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    // Clone the current set of segment children, even if they aren't active in\n    // the new tree.\n    // TODO: We currently retain all the inactive segments indefinitely, until\n    // there's an explicit refresh, or a parent layout is lazily refreshed. We\n    // rely on this for popstate navigations, which update the Router State Tree\n    // but do not eagerly perform a data fetch, because they expect the segment\n    // data to already be in the Cache Node tree. For highly static sites that\n    // are mostly read-only, this may happen only rarely, causing memory to\n    // leak. We should figure out a better model for the lifetime of inactive\n    // segments, so we can maintain instant back/forward navigations without\n    // leaking memory indefinitely.\n    const prefetchParallelRoutes = new Map(oldParallelRoutes);\n    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n    // the Route Tree that was returned by the server — for example, in the case\n    // of default parallel routes, we preserve the currently active segment. To\n    // avoid mutating the original tree, we clone the router state children along\n    // the return path.\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    // Most navigations require a request to fetch additional data from the\n    // server, either because the data was not already prefetched, or because the\n    // target route contains dynamic data that cannot be prefetched.\n    //\n    // However, if the target route is fully static, and it's already completely\n    // loaded into the segment cache, then we can skip the server request.\n    //\n    // This starts off as `false`, and is set to `true` if any of the child\n    // routes requires a dynamic request.\n    let needsDynamicRequest = false;\n    // As we traverse the children, we'll construct a FlightRouterState that can\n    // be sent to the server to request the dynamic data. If it turns out that\n    // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n    // end), then this will be discarded.\n    // TODO: We can probably optimize the format of this data structure to only\n    // include paths that are dynamic. Instead of reusing the\n    // FlightRouterState type.\n    let dynamicRequestTreeChildren = {};\n    for(let parallelRouteKey in newRouterStateChildren){\n        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const newSegmentChild = newRouterStateChild[0];\n        const newSegmentPathChild = segmentPath.concat([\n            parallelRouteKey,\n            newSegmentChild\n        ]);\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        let taskChild;\n        if (newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {\n            // This is another kind of leaf segment — a default route.\n            //\n            // Default routes have special behavior. When there's no matching segment\n            // for a parallel route, Next.js preserves the currently active segment\n            // during a client navigation — but not for initial render. The server\n            // leaves it to the client to account for this. So we need to handle\n            // it here.\n            if (oldRouterStateChild !== undefined) {\n                // Reuse the existing Router State for this segment. We spawn a \"task\"\n                // just to keep track of the updated router state; unlike most, it's\n                // already fulfilled and won't be affected by the dynamic response.\n                taskChild = spawnReusedTask(oldRouterStateChild);\n            } else {\n                // There's no currently active segment. Switch to the \"create\" path.\n                taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n            }\n        } else if (isSamePageNavigation && // Check if this is a page segment.\n        // TODO: We're not consistent about how we do this check. Some places\n        // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n        // check if there any any children, which is why I'm doing it here. We\n        // should probably encode an empty children set as `null` though. Either\n        // way, we should update all the checks to be consistent.\n        Object.keys(newRouterStateChild[1]).length === 0) {\n            // We special case navigations to the exact same URL as the current\n            // location. It's a common UI pattern for apps to refresh when you click a\n            // link to the current page. So when this happens, we refresh the dynamic\n            // data in the page segments.\n            //\n            // Note that this does not apply if the any part of the hash or search\n            // query has changed. This might feel a bit weird but it makes more sense\n            // when you consider that the way to trigger this behavior is to click\n            // the same link multiple times.\n            //\n            // TODO: We should probably refresh the *entire* route when this case\n            // occurs, not just the page segments. Essentially treating it the same as\n            // a refresh() triggered by an action, which is the more explicit way of\n            // modeling the UI pattern described above.\n            //\n            // Also note that this only refreshes the dynamic data, not static/\n            // cached data. If the page segment is fully static and prefetched, the\n            // request is skipped. (This is also how refresh() works.)\n            taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n        } else if (oldRouterStateChild !== undefined && oldSegmentChild !== undefined && (0, _matchsegments.matchSegment)(newSegmentChild, oldSegmentChild)) {\n            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {\n                // This segment exists in both the old and new trees. Recursively update\n                // the children.\n                taskChild = updateCacheNodeOnNavigation(navigatedAt, oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, newSegmentPathChild, scrollableSegmentsResult);\n            } else {\n                // There's no existing Cache Node for this segment. Switch to the\n                // \"create\" path.\n                taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n            }\n        } else {\n            // This is a new tree. Switch to the \"create\" path.\n            taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n        }\n        if (taskChild !== null) {\n            // Recursively propagate up the child tasks.\n            if (taskChild.route === null) {\n                // One of the child tasks discovered a change to the root layout.\n                // Immediately unwind from this recursive traversal.\n                return MPA_NAVIGATION_TASK;\n            }\n            if (taskChildren === null) {\n                taskChildren = new Map();\n            }\n            taskChildren.set(parallelRouteKey, taskChild);\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n            // The child tree's route state may be different from the prefetched\n            // route sent by the server. We need to clone it as we traverse back up\n            // the tree.\n            const taskChildRoute = taskChild.route;\n            patchedRouterStateChildren[parallelRouteKey] = taskChildRoute;\n            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n            if (dynamicRequestTreeChild !== null) {\n                // Something in the child tree is dynamic.\n                needsDynamicRequest = true;\n                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n            } else {\n                dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute;\n            }\n        } else {\n            // The child didn't change. We can use the prefetched router state.\n            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;\n            dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild;\n        }\n    }\n    if (taskChildren === null) {\n        // No new tasks were spawned.\n        return null;\n    }\n    const newCacheNode = {\n        lazyData: null,\n        rsc: oldCacheNode.rsc,\n        // We intentionally aren't updating the prefetchRsc field, since this node\n        // is already part of the current tree, because it would be weird for\n        // prefetch data to be newer than the final data. It probably won't ever be\n        // observable anyway, but it could happen if the segment is unmounted then\n        // mounted again, because LayoutRouter will momentarily switch to rendering\n        // prefetchRsc, via useDeferredValue.\n        prefetchRsc: oldCacheNode.prefetchRsc,\n        head: oldCacheNode.head,\n        prefetchHead: oldCacheNode.prefetchHead,\n        loading: oldCacheNode.loading,\n        // Everything is cloned except for the children, which we computed above.\n        parallelRoutes: prefetchParallelRoutes,\n        navigatedAt\n    };\n    return {\n        // Return a cloned copy of the router state with updated children.\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(newRouterState, dynamicRequestTreeChildren) : null,\n        children: taskChildren\n    };\n}\nfunction beginRenderingNewRouteTree(navigatedAt, oldRouterState, newRouterState, existingCacheNode, didFindRootLayout, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    if (!didFindRootLayout) {\n        // The route tree changed before we reached a layout. (The highest-level\n        // layout in a route tree is referred to as the \"root\" layout.) This could\n        // mean that we're navigating between two different root layouts. When this\n        // happens, we perform a full-page (MPA-style) navigation.\n        //\n        // However, the algorithm for deciding where to start rendering a route\n        // (i.e. the one performed in order to reach this function) is stricter\n        // than the one used to detect a change in the root layout. So just because\n        // we're re-rendering a segment outside of the root layout does not mean we\n        // should trigger a full-page navigation.\n        //\n        // Specifically, we handle dynamic parameters differently: two segments are\n        // considered the same even if their parameter values are different.\n        //\n        // Refer to isNavigatingToNewRootLayout for details.\n        //\n        // Note that we only have to perform this extra traversal if we didn't\n        // already discover a root layout in the part of the tree that is unchanged.\n        // In the common case, this branch is skipped completely.\n        if (oldRouterState === undefined || (0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(oldRouterState, newRouterState)) {\n            // The root layout changed. Perform a full-page navigation.\n            return MPA_NAVIGATION_TASK;\n        }\n    }\n    return createCacheNodeOnNavigation(navigatedAt, newRouterState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n}\nfunction createCacheNodeOnNavigation(navigatedAt, routerState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    // Same traversal as updateCacheNodeNavigation, but we switch to this path\n    // once we reach the part of the tree that was not in the previous route. We\n    // don't need to diff against the old tree, we just need to create a new one.\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const routerStateChildren = routerState[1];\n    const isLeafSegment = Object.keys(routerStateChildren).length === 0;\n    // Even we're rendering inside the \"new\" part of the target tree, we may have\n    // a locally cached segment that we can reuse. This may come from either 1)\n    // the CacheNode tree, which lives in React state and is populated by previous\n    // navigations; or 2) the prefetch cache, which is a separate cache that is\n    // populated by prefetches.\n    let rsc;\n    let loading;\n    let head;\n    let cacheNodeNavigatedAt;\n    if (existingCacheNode !== undefined && // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n    // the experimental.staleTimes.dynamic config. When set, we'll avoid\n    // refetching dynamic data if it was fetched within the given threshold.\n    existingCacheNode.navigatedAt + _prefetchcacheutils.DYNAMIC_STALETIME_MS > navigatedAt) {\n        // We have an existing CacheNode for this segment, and it's not stale. We\n        // should reuse it rather than request a new one.\n        rsc = existingCacheNode.rsc;\n        loading = existingCacheNode.loading;\n        head = existingCacheNode.head;\n        // Don't update the navigatedAt timestamp, since we're reusing stale data.\n        cacheNodeNavigatedAt = existingCacheNode.navigatedAt;\n    } else if (prefetchData !== null) {\n        // There's no existing CacheNode for this segment, but we do have prefetch\n        // data. If the prefetch data is fully static (i.e. does not contain any\n        // dynamic holes), we don't need to request it from the server.\n        rsc = prefetchData[1];\n        loading = prefetchData[3];\n        head = isLeafSegment ? possiblyPartialPrefetchHead : null;\n        // Even though we're accessing the data from the prefetch cache, this is\n        // conceptually a new segment, not a reused one. So we should update the\n        // navigatedAt timestamp.\n        cacheNodeNavigatedAt = navigatedAt;\n        const isPrefetchRscPartial = prefetchData[4];\n        if (isPrefetchRscPartial || // Check if the head is partial (only relevant if this is a leaf segment)\n        isPrefetchHeadPartial && isLeafSegment) {\n            // We only have partial data from this segment. Like missing segments, we\n            // must request the full data from the server.\n            return spawnPendingTask(navigatedAt, routerState, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n        } else {\n        // The prefetch data is fully static, so we can omit it from the\n        // navigation request.\n        }\n    } else {\n        // There's no prefetch for this segment. Everything from this point will be\n        // requested from the server, even if there are static children below it.\n        // Create a terminal task node that will later be fulfilled by\n        // server response.\n        return spawnPendingTask(navigatedAt, routerState, null, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n    }\n    // We already have a full segment we can render, so we don't need to request a\n    // new one from the server. Keep traversing down the tree until we reach\n    // something that requires a dynamic request.\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;\n    const taskChildren = new Map();\n    const existingCacheNodeChildren = existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null;\n    const cacheNodeChildren = new Map(existingCacheNodeChildren);\n    let dynamicRequestTreeChildren = {};\n    let needsDynamicRequest = false;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        scrollableSegmentsResult.push(segmentPath);\n    } else {\n        for(let parallelRouteKey in routerStateChildren){\n            const routerStateChild = routerStateChildren[parallelRouteKey];\n            const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n            const existingSegmentMapChild = existingCacheNodeChildren !== null ? existingCacheNodeChildren.get(parallelRouteKey) : undefined;\n            const segmentChild = routerStateChild[0];\n            const segmentPathChild = segmentPath.concat([\n                parallelRouteKey,\n                segmentChild\n            ]);\n            const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n            const existingCacheNodeChild = existingSegmentMapChild !== undefined ? existingSegmentMapChild.get(segmentKeyChild) : undefined;\n            const taskChild = createCacheNodeOnNavigation(navigatedAt, routerStateChild, existingCacheNodeChild, prefetchDataChild, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);\n            taskChildren.set(parallelRouteKey, taskChild);\n            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n            if (dynamicRequestTreeChild !== null) {\n                // Something in the child tree is dynamic.\n                needsDynamicRequest = true;\n                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n            } else {\n                dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild;\n            }\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map();\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    return {\n        // Since we're inside a new route tree, unlike the\n        // `updateCacheNodeOnNavigation` path, the router state on the children\n        // tasks is always the same as the router state we pass in. So we don't need\n        // to clone/modify it.\n        route: routerState,\n        node: {\n            lazyData: null,\n            // Since this segment is already full, we don't need to use the\n            // `prefetchRsc` field.\n            rsc,\n            prefetchRsc: null,\n            head,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: cacheNodeChildren,\n            navigatedAt: cacheNodeNavigatedAt\n        },\n        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren) : null,\n        children: taskChildren\n    };\n}\nfunction patchRouterStateWithNewChildren(baseRouterState, newChildren) {\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\nfunction spawnPendingTask(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    // Create a task that will later be fulfilled by data from the server.\n    // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n    // this to the server so it knows where to start rendering.\n    const dynamicRequestTree = patchRouterStateWithNewChildren(routerState, routerState[1]);\n    dynamicRequestTree[3] = 'refetch';\n    const newTask = {\n        route: routerState,\n        // Corresponds to the part of the route that will be rendered on the server.\n        node: createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult),\n        // Because this is non-null, and it gets propagated up through the parent\n        // tasks, the root task will know that it needs to perform a server request.\n        dynamicRequestTree,\n        children: null\n    };\n    return newTask;\n}\nfunction spawnReusedTask(reusedRouterState) {\n    // Create a task that reuses an existing segment, e.g. when reusing\n    // the current active segment in place of a default route.\n    return {\n        route: reusedRouterState,\n        node: null,\n        dynamicRequestTree: null,\n        children: null\n    };\n}\nfunction listenForDynamicRequest(task, responsePromise) {\n    responsePromise.then((param)=>{\n        let { flightData } = param;\n        if (typeof flightData === 'string') {\n            // Happens when navigating to page in `pages` from `app`. We shouldn't\n            // get here because should have already handled this during\n            // the prefetch.\n            return;\n        }\n        for (const normalizedFlightData of flightData){\n            const { segmentPath, tree: serverRouterState, seedData: dynamicData, head: dynamicHead } = normalizedFlightData;\n            if (!dynamicData) {\n                continue;\n            }\n            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);\n        }\n        // Now that we've exhausted all the data we received from the server, if\n        // there are any remaining pending tasks in the tree, abort them now.\n        // If there's any missing data, it will trigger a lazy fetch.\n        abortTask(task, null);\n    }, (error)=>{\n        // This will trigger an error during render\n        abortTask(task, error);\n    });\n}\nfunction writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {\n    // The data sent by the server represents only a subtree of the app. We need\n    // to find the part of the task tree that matches the server response, and\n    // fulfill it using the dynamic data.\n    //\n    // segmentPath represents the parent path of subtree. It's a repeating pattern\n    // of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // Iterate through the path and finish any tasks that match this payload.\n    let task = rootTask;\n    for(let i = 0; i < segmentPath.length; i += 2){\n        const parallelRouteKey = segmentPath[i];\n        const segment = segmentPath[i + 1];\n        const taskChildren = task.children;\n        if (taskChildren !== null) {\n            const taskChild = taskChildren.get(parallelRouteKey);\n            if (taskChild !== undefined) {\n                const taskSegment = taskChild.route[0];\n                if ((0, _matchsegments.matchSegment)(segment, taskSegment)) {\n                    // Found a match for this task. Keep traversing down the task tree.\n                    task = taskChild;\n                    continue;\n                }\n            }\n        }\n        // We didn't find a child task that matches the server data. Exit. We won't\n        // abort the task, though, because a different FlightDataPath may be able to\n        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n        // once we've run out of data.\n        return;\n    }\n    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);\n}\nfunction finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {\n    if (task.dynamicRequestTree === null) {\n        // Everything in this subtree is already complete. Bail out.\n        return;\n    }\n    // dynamicData may represent a larger subtree than the task. Before we can\n    // finish the task, we need to line them up.\n    const taskChildren = task.children;\n    const taskNode = task.node;\n    if (taskChildren === null) {\n        // We've reached the leaf node of the pending task. The server data tree\n        // lines up the pending Cache Node tree. We can now switch to the\n        // normal algorithm.\n        if (taskNode !== null) {\n            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);\n            // Set this to null to indicate that this task is now complete.\n            task.dynamicRequestTree = null;\n        }\n        return;\n    }\n    // The server returned more data than we need to finish the task. Skip over\n    // the extra segments until we reach the leaf task node.\n    const serverChildren = serverRouterState[1];\n    const dynamicDataChildren = dynamicData[2];\n    for(const parallelRouteKey in serverRouterState){\n        const serverRouterStateChild = serverChildren[parallelRouteKey];\n        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];\n        const taskChild = taskChildren.get(parallelRouteKey);\n        if (taskChild !== undefined) {\n            const taskSegment = taskChild.route[0];\n            if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {\n                // Found a match for this task. Keep traversing down the task tree.\n                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);\n            }\n        }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    }\n}\nfunction createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    const routerStateChildren = routerState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;\n    const parallelRoutes = new Map();\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const segmentChild = routerStateChild[0];\n        const segmentPathChild = segmentPath.concat([\n            parallelRouteKey,\n            segmentChild\n        ]);\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const newCacheNodeChild = createPendingCacheNode(navigatedAt, routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);\n        const newSegmentMapChild = new Map();\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n    }\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const isLeafSegment = parallelRoutes.size === 0;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        scrollableSegmentsResult.push(segmentPath);\n    }\n    const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null;\n    const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null;\n    return {\n        lazyData: null,\n        parallelRoutes: parallelRoutes,\n        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n        prefetchHead: isLeafSegment ? prefetchHead : [\n            null,\n            null\n        ],\n        // TODO: Technically, a loading boundary could contain dynamic data. We must\n        // have separate `loading` and `prefetchLoading` fields to handle this, like\n        // we do for the segment data and head.\n        loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n        // Create a deferred promise. This will be fulfilled once the dynamic\n        // response is received from the server.\n        rsc: createDeferredRsc(),\n        head: isLeafSegment ? createDeferredRsc() : null,\n        navigatedAt\n    };\n}\nfunction finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {\n    // Writes a dynamic response into an existing Cache Node tree. This does _not_\n    // create a new tree, it updates the existing tree in-place. So it must follow\n    // the Suspense rules of cache safety — it can resolve pending promises, but\n    // it cannot overwrite existing data. It can add segments to the tree (because\n    // a missing segment will cause the layout router to suspend).\n    // but it cannot delete them.\n    //\n    // We must resolve every promise in the tree, or else it will suspend\n    // indefinitely. If we did not receive data for a segment, we will resolve its\n    // data promise to `null` to trigger a lazy fetch during render.\n    const taskStateChildren = taskState[1];\n    const serverStateChildren = serverState[1];\n    const dataChildren = dynamicData[2];\n    // The router state that we traverse the tree with (taskState) is the same one\n    // that we used to construct the pending Cache Node tree. That way we're sure\n    // to resolve all the pending promises.\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in taskStateChildren){\n        const taskStateChild = taskStateChildren[parallelRouteKey];\n        const serverStateChild = serverStateChildren[parallelRouteKey];\n        const dataChild = dataChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        const taskSegmentChild = taskStateChild[0];\n        const taskSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(taskSegmentChild);\n        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;\n        if (cacheNodeChild !== undefined) {\n            if (serverStateChild !== undefined && (0, _matchsegments.matchSegment)(taskSegmentChild, serverStateChild[0])) {\n                if (dataChild !== undefined && dataChild !== null) {\n                    // This is the happy path. Recursively update all the children.\n                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);\n                } else {\n                    // The server never returned data for this segment. Trigger a lazy\n                    // fetch during render. This shouldn't happen because the Route Tree\n                    // and the Seed Data tree sent by the server should always be the same\n                    // shape when part of the same server response.\n                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n                }\n            } else {\n                // The server never returned data for this segment. Trigger a lazy\n                // fetch during render.\n                abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n            }\n        } else {\n        // The server response matches what was expected to receive, but there's\n        // no matching Cache Node in the task tree. This is a bug in the\n        // implementation because we should have created a node for every\n        // segment in the tree that's associated with this task.\n        }\n    }\n    // Use the dynamic data from the server to fulfill the deferred RSC promise\n    // on the Cache Node.\n    const rsc = cacheNode.rsc;\n    const dynamicSegmentData = dynamicData[1];\n    if (rsc === null) {\n        // This is a lazy cache node. We can overwrite it. This is only safe\n        // because we know that the LayoutRouter suspends if `rsc` is `null`.\n        cacheNode.rsc = dynamicSegmentData;\n    } else if (isDeferredRsc(rsc)) {\n        // This is a deferred RSC promise. We can fulfill it with the data we just\n        // received from the server. If it was already resolved by a different\n        // navigation, then this does nothing because we can't overwrite data.\n        rsc.resolve(dynamicSegmentData);\n    } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved with the dynamic head from\n    // the server.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(dynamicHead);\n    }\n}\nfunction abortTask(task, error) {\n    const cacheNode = task.node;\n    if (cacheNode === null) {\n        // This indicates the task is already complete.\n        return;\n    }\n    const taskChildren = task.children;\n    if (taskChildren === null) {\n        // Reached the leaf task node. This is the root of a pending cache\n        // node tree.\n        abortPendingCacheNode(task.route, cacheNode, error);\n    } else {\n        // This is an intermediate task node. Keep traversing until we reach a\n        // task node with no children. That will be the root of the cache node tree\n        // that needs to be resolved.\n        for (const taskChild of taskChildren.values()){\n            abortTask(taskChild, error);\n        }\n    }\n    // Set this to null to indicate that this task is now complete.\n    task.dynamicRequestTree = null;\n}\nfunction abortPendingCacheNode(routerState, cacheNode, error) {\n    // For every pending segment in the tree, resolve its `rsc` promise to `null`\n    // to trigger a lazy fetch during render.\n    //\n    // Or, if an error object is provided, it will error instead.\n    const routerStateChildren = routerState[1];\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        if (segmentMapChild === undefined) {\n            continue;\n        }\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);\n        if (cacheNodeChild !== undefined) {\n            abortPendingCacheNode(routerStateChild, cacheNodeChild, error);\n        } else {\n        // This shouldn't happen because we're traversing the same tree that was\n        // used to construct the cache nodes in the first place.\n        }\n    }\n    const rsc = cacheNode.rsc;\n    if (isDeferredRsc(rsc)) {\n        if (error === null) {\n            // This will trigger a lazy fetch during render.\n            rsc.resolve(null);\n        } else {\n            // This will trigger an error during rendering.\n            rsc.reject(error);\n        }\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved. If an error was provided, we\n    // will not resolve it with an error, since this is rendered at the root of\n    // the app. We want the segment to error, not the entire app.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(null);\n    }\n}\nfunction updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {\n    // A popstate navigation reads data from the local cache. It does not issue\n    // new network requests (unless the cache entries have been evicted). So, we\n    // update the cache to drop the prefetch data for any segment whose dynamic\n    // data was already received. This prevents an unnecessary flash back to PPR\n    // state during a back/forward navigation.\n    //\n    // This function clones the entire cache node tree and sets the `prefetchRsc`\n    // field to `null` to prevent it from being rendered. We can't mutate the node\n    // in place because this is a concurrent data structure.\n    const routerStateChildren = routerState[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    const newParallelRoutes = new Map(oldParallelRoutes);\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        if (oldSegmentMapChild !== undefined) {\n            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);\n            if (oldCacheNodeChild !== undefined) {\n                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    // Only show prefetched data if the dynamic data is still pending.\n    //\n    // Tehnically, what we're actually checking is whether the dynamic network\n    // response was received. But since it's a streaming response, this does not\n    // mean that all the dynamic data has fully streamed in. It just means that\n    // _some_ of the dynamic data was received. But as a heuristic, we assume that\n    // the rest dynamic data will stream in quickly, so it's still better to skip\n    // the prefetch state.\n    const rsc = oldCacheNode.rsc;\n    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending';\n    return {\n        lazyData: null,\n        rsc,\n        head: oldCacheNode.head,\n        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [\n            null,\n            null\n        ],\n        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n        loading: oldCacheNode.loading,\n        // These are the cloned children we computed above\n        parallelRoutes: newParallelRoutes,\n        navigatedAt: oldCacheNode.navigatedAt\n    };\n}\nconst DEFERRED = Symbol();\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value) {\n    return value && value.tag === DEFERRED;\n}\nfunction createDeferredRsc() {\n    let resolve;\n    let reject;\n    const pendingRsc = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    pendingRsc.status = 'pending';\n    pendingRsc.resolve = (value)=>{\n        if (pendingRsc.status === 'pending') {\n            const fulfilledRsc = pendingRsc;\n            fulfilledRsc.status = 'fulfilled';\n            fulfilledRsc.value = value;\n            resolve(value);\n        }\n    };\n    pendingRsc.reject = (error)=>{\n        if (pendingRsc.status === 'pending') {\n            const rejectedRsc = pendingRsc;\n            rejectedRsc.status = 'rejected';\n            rejectedRsc.reason = error;\n            reject(error);\n        }\n    };\n    pendingRsc.tag = DEFERRED;\n    return pendingRsc;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ppr-navigations.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHByLW5hdmlnYXRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQTBrQ2dCQSxTQUFTO2VBQVRBOztJQTFWQUMsdUJBQXVCO2VBQXZCQTs7SUF2cEJBQyxrQkFBa0I7ZUFBbEJBOztJQTZqQ0FDLG9DQUFvQztlQUFwQ0E7OztxQ0F6b0NvQjsyQ0FDUDtrREFDUTt5REFFTztnREFDUDtBQWlDckMsTUFBTUMsc0JBQXlDO0lBQzdDQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsb0JBQW9CO0lBQ3BCQyxVQUFVO0FBQ1o7QUFpQ08sU0FBU04sbUJBQ2RPLFdBQW1CLEVBQ25CQyxZQUF1QixFQUN2QkMsY0FBaUMsRUFDakNDLGNBQWlDLEVBQ2pDQyxZQUFzQyxFQUN0Q0MsWUFBNkIsRUFDN0JDLHFCQUE4QixFQUM5QkMsb0JBQTZCLEVBQzdCQyx3QkFBa0Q7SUFFbEQsTUFBTUMsY0FBd0MsRUFBRTtJQUNoRCxPQUFPQyw0QkFDTFYsYUFDQUMsY0FDQUMsZ0JBQ0FDLGdCQUNBLE9BQ0FDLGNBQ0FDLGNBQ0FDLHVCQUNBQyxzQkFDQUUsYUFDQUQ7QUFFSjtBQUVBLFNBQVNFLDRCQUNQVixXQUFtQixFQUNuQkMsWUFBdUIsRUFDdkJDLGNBQWlDLEVBQ2pDQyxjQUFpQyxFQUNqQ1EsaUJBQTBCLEVBQzFCUCxZQUFzQyxFQUN0Q0MsWUFBNkIsRUFDN0JDLHFCQUE4QixFQUM5QkMsb0JBQTZCLEVBQzdCRSxXQUE4QixFQUM5QkQsd0JBQWtEO0lBRWxELDBEQUEwRDtJQUMxRCxNQUFNSSx5QkFBeUJWLGNBQWMsQ0FBQyxFQUFFO0lBQ2hELE1BQU1XLHlCQUF5QlYsY0FBYyxDQUFDLEVBQUU7SUFDaEQsTUFBTVcsdUJBQXVCVixpQkFBaUIsT0FBT0EsWUFBWSxDQUFDLEVBQUUsR0FBRztJQUV2RSxJQUFJLENBQUNPLG1CQUFtQjtR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STtRQUV2QmxELGNBQWM4SCxvQkFBb0JsSSxhQUFhSSxZQUFZLEdBQUc7WUFBQztZQUFNO1NBQUs7UUFDMUVpRCxhQUFhNkUsb0JBQW9CbEksYUFBYXFELFdBQVcsR0FBRztRQUM1REUsU0FBU3ZELGFBQWF1RCxPQUFPO1FBRTdCLGtEQUFrRDtRQUNsRHZDLGdCQUFnQmlIO1FBRWhCbEksYUFBYUMsYUFBYUQsV0FBVztJQUN2QztBQUNGO0FBRUEsTUFBTXFJLFdBQVdDO0FBOEJqQiw4RUFBOEU7QUFDOUUsZ0ZBQWdGO0FBQ2hGLDhFQUE4RTtBQUM5RSxtRUFBbUU7QUFDbkUsU0FBU1IsY0FBY1MsS0FBVTtJQUMvQixPQUFPQSxTQUFTQSxNQUFNQyxHQUFHLEtBQUtIO0FBQ2hDO0FBRUEsU0FBU3ZCO0lBQ1AsSUFBSWlCO0lBQ0osSUFBSUU7SUFDSixNQUFNUSxhQUFhLElBQUlDLFFBQXlCLENBQUNDLEtBQUtDO1FBQ3BEYixVQUFVWTtRQUNWVixTQUFTVztJQUNYO0lBQ0FILFdBQVdMLE1BQU0sR0FBRztJQUNwQkssV0FBV1YsT0FBTyxHQUFHLENBQUNRO1FBQ3BCLElBQUlFLFdBQVdMLE1BQU0sS0FBSyxXQUFXO1lBQ25DLE1BQU1TLGVBQXFDSjtZQUMzQ0ksYUFBYVQsTUFBTSxHQUFHO1lBQ3RCUyxhQUFhTixLQUFLLEdBQUdBO1lBQ3JCUixRQUFRUTtRQUNWO0lBQ0Y7SUFDQUUsV0FBV1IsTUFBTSxHQUFHLENBQUNsQztRQUNuQixJQUFJMEMsV0FBV0wsTUFBTSxLQUFLLFdBQVc7WUFDbkMsTUFBTVUsY0FBbUNMO1lBQ3pDSyxZQUFZVixNQUFNLEdBQUc7WUFDckJVLFlBQVlDLE1BQU0sR0FBR2hEO1lBQ3JCa0MsT0FBT2xDO1FBQ1Q7SUFDRjtJQUNBMEMsV0FBV0QsR0FBRyxHQUFHSDtJQUNqQixPQUFPSTtBQUNUIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccHByLW5hdmlnYXRpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgQ2FjaGVOb2RlU2VlZERhdGEsXG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHRTZWdtZW50UGF0aCxcbiAgU2VnbWVudCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7XG4gIENhY2hlTm9kZSxcbiAgQ2hpbGRTZWdtZW50TWFwLFxuICBIZWFkRGF0YSxcbiAgTG9hZGluZ01vZHVsZURhdGEsXG4gIFJlYWR5Q2FjaGVOb2RlLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IERFRkFVTFRfU0VHTUVOVF9LRVkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5pbXBvcnQgeyBtYXRjaFNlZ21lbnQgfSBmcm9tICcuLi9tYXRjaC1zZWdtZW50cydcbmltcG9ydCB7IGNyZWF0ZVJvdXRlckNhY2hlS2V5IH0gZnJvbSAnLi9jcmVhdGUtcm91dGVyLWNhY2hlLWtleSdcbmltcG9ydCB0eXBlIHsgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCB9IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHsgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IH0gZnJvbSAnLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB7IERZTkFNSUNfU1RBTEVUSU1FX01TIH0gZnJvbSAnLi9wcmVmZXRjaC1jYWNoZS11dGlscydcblxuLy8gVGhpcyBpcyB5ZXQgYW5vdGhlciB0cmVlIHR5cGUgdGhhdCBpcyB1c2VkIHRvIHRyYWNrIHBlbmRpbmcgcHJvbWlzZXMgdGhhdFxuLy8gbmVlZCB0byBiZSBmdWxmaWxsZWQgb25jZSB0aGUgZHluYW1pYyBkYXRhIGlzIHJlY2VpdmVkLiBUaGUgdGVybWluYWwgbm9kZXMgb2Zcbi8vIHRoaXMgdHJlZSByZXByZXNlbnQgdGhlIG5ldyBDYWNoZSBOb2RlIHRyZWVzIHRoYXQgd2VyZSBjcmVhdGVkIGR1cmluZyB0aGlzXG4vLyByZXF1ZXN0LiBXZSBjYW4ndCB1c2UgdGhlIENhY2hlIE5vZGUgdHJlZSBvciBSb3V0ZSBTdGF0ZSB0cmVlIGRpcmVjdGx5XG4vLyBiZWNhdXNlIHRob3NlIGluY2x1ZGUgcmV1c2VkIG5vZGVzLCB0b28uIFRoaXMgdHJlZSBpcyBkaXNjYXJkZWQgYXMgc29vbiBhc1xuLy8gdGhlIG5hdmlnYXRpb24gcmVzcG9uc2UgaXMgcmVjZWl2ZWQuXG50eXBlIFNQQU5hdmlnYXRpb25UYXNrID0ge1xuICAvLyBUaGUgcm91dGVyIHN0YXRlIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHRyZWUgdGhhdCB0aGlzIFRhc2sgcmVwcmVzZW50cy5cbiAgcm91dGU6IEZsaWdodFJvdXRlclN0YXRlXG4gIC8vIFRoZSBDYWNoZU5vZGUgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgdHJlZSB0aGF0IHRoaXMgVGFzayByZXByZXNlbnRzLiBJZlxuICAvLyBgY2hpbGRyZW5gIGlzIG51bGwgKGkuZS4gaWYgdGhpcyBpcyBhIHRlcm1pbmFsIHRhc2sgbm9kZSksIHRoZW4gYG5vZGVgXG4gIC8vIHJlcHJlc2VudHMgYSBicmFuZCBuZXcgQ2FjaGUgTm9kZSB0cmVlLCB3aGljaCB3YXkgb3IgbWF5IG5vdCBuZWVkIHRvIGJlXG4gIC8vIGZpbGxlZCB3aXRoIGR5bmFtaWMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gIG5vZGU6IENhY2hlTm9kZSB8IG51bGxcbiAgLy8gVGhlIHRyZWUgc2VudCB0byB0aGUgc2VydmVyIGR1cmluZyB0aGUgZHluYW1pYyByZXF1ZXN0LiBUaGlzIGlzIHRoZVxuICAvLyBzYW1lIGFzIGByb3V0ZWAsIGV4Y2VwdCB3aXRoIHRoZSBgcmVmZXRjaGAgbWFya2VyIHNldCBvbiBkeW5hbWljIHNlZ21lbnRzLlxuICAvLyBJZiBhbGwgdGhlIHNlZ21lbnRzIGFyZSBzdGF0aWMsIHRoZW4gdGhpcyB3aWxsIGJlIG51bGwsIGFuZCBubyBzZXJ2ZXJcbiAgLy8gcmVxdWVzdCBpcyByZXF1aXJlZC5cbiAgZHluYW1pY1JlcXVlc3RUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IG51bGxcbiAgY2hpbGRyZW46IE1hcDxzdHJpbmcsIFNQQU5hdmlnYXRpb25UYXNrPiB8IG51bGxcbn1cblxuLy8gQSBzcGVjaWFsIHR5cGUgdXNlZCB0byBiYWlsIG91dCBhbmQgdHJpZ2dlciBhIGZ1bGwtcGFnZSBuYXZpZ2F0aW9uLlxudHlwZSBNUEFOYXZpZ2F0aW9uVGFzayA9IHtcbiAgLy8gTVBBIHRhc2tzIGFyZSBkaXN0aW5ndWlzZWQgZnJvbSBTUEEgdGFza3MgYnkgaGF2aW5nIGEgbnVsbCBgcm91dGVgLlxuICByb3V0ZTogbnVsbFxuICBub2RlOiBudWxsXG4gIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbFxuICBjaGlsZHJlbjogbnVsbFxufVxuXG5jb25zdCBNUEFfTkFWSUdBVElPTl9UQVNLOiBNUEFOYXZpZ2F0aW9uVGFzayA9IHtcbiAgcm91dGU6IG51bGwsXG4gIG5vZGU6IG51bGwsXG4gIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbCxcbiAgY2hpbGRyZW46IG51bGwsXG59XG5cbmV4cG9ydCB0eXBlIFRhc2sgPSBTUEFOYXZpZ2F0aW9uVGFzayB8IE1QQU5hdmlnYXRpb25UYXNrXG5cbi8vIENyZWF0ZXMgYSBuZXcgQ2FjaGUgTm9kZSB0cmVlIChpLmUuIGNvcHktb24td3JpdGUpIHRoYXQgcmVwcmVzZW50cyB0aGVcbi8vIG9wdGltaXN0aWMgcmVzdWx0IG9mIGEgbmF2aWdhdGlvbiwgdXNpbmcgYm90aCB0aGUgY3VycmVudCBDYWNoZSBOb2RlIHRyZWUgYW5kXG4vLyBkYXRhIHRoYXQgd2FzIHByZWZldGNoZWQgcHJpb3IgdG8gbmF2aWdhdGlvbi5cbi8vXG4vLyBBdCB0aGUgbW9tZW50IHdlIGNhbGwgdGhpcyBmdW5jdGlvbiwgd2UgaGF2ZW4ndCB5ZXQgcmVjZWl2ZWQgdGhlIG5hdmlnYXRpb25cbi8vIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci4gSXQgY291bGQgc2VuZCBiYWNrIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudFxuLy8gZnJvbSB0aGUgdHJlZSB0aGF0IHdhcyBwcmVmZXRjaGVkIOKAlCBkdWUgdG8gcmV3cml0ZXMsIGRlZmF1bHQgcm91dGVzLCBwYXJhbGxlbFxuLy8gcm91dGVzLCBldGMuXG4vL1xuLy8gQnV0IGluIG1vc3QgY2FzZXMsIGl0IHdpbGwgcmV0dXJuIHRoZSBzYW1lIHRyZWUgdGhhdCB3ZSBwcmVmZXRjaGVkLCBqdXN0IHdpdGhcbi8vIHRoZSBkeW5hbWljIGhvbGVzIGZpbGxlZCBpbi4gU28gd2Ugb3B0aW1pc3RpY2FsbHkgYXNzdW1lIHRoaXMgd2lsbCBoYXBwZW4sXG4vLyBhbmQgYWNjZXB0IHRoYXQgdGhlIHJlYWwgcmVzdWx0IGNvdWxkIGJlIGFyYml0cmFyaWx5IGRpZmZlcmVudC5cbi8vXG4vLyBXZSdsbCByZXVzZSBhbnl0aGluZyB0aGF0IHdhcyBhbHJlYWR5IGluIHRoZSBwcmV2aW91cyB0cmVlLCBzaW5jZSB0aGF0J3Mgd2hhdFxuLy8gdGhlIHNlcnZlciBkb2VzLlxuLy9cbi8vIE5ldyBzZWdtZW50cyAob25lcyB0aGF0IGRvbid0IGFwcGVhciBpbiB0aGUgb2xkIHRyZWUpIGFyZSBhc3NpZ25lZCBhblxuLy8gdW5yZXNvbHZlZCBwcm9taXNlLiBUaGUgZGF0YSBmb3IgdGhlc2UgcHJvbWlzZXMgd2lsbCBiZSBmdWxmaWxsZWQgbGF0ZXIsIHdoZW5cbi8vIHRoZSBuYXZpZ2F0aW9uIHJlc3BvbnNlIGlzIHJlY2VpdmVkLlxuLy9cbi8vIFRoZSB0cmVlIGNhbiBiZSByZW5kZXJlZCBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyBjcmVhdGVkICh0aGF0J3Mgd2h5IHRoaXMgaXNcbi8vIGEgc3luY2hyb25vdXMgZnVuY3Rpb24pLiBBbnkgbmV3IHRyZWVzIHRoYXQgZG8gbm90IGhhdmUgcHJlZmV0Y2ggZGF0YSB3aWxsXG4vLyBzdXNwZW5kIGR1cmluZyByZW5kZXJpbmcsIHVudGlsIHRoZSBkeW5hbWljIGRhdGEgc3RyZWFtcyBpbi5cbi8vXG4vLyBSZXR1cm5zIGEgVGFzayBvYmplY3QsIHdoaWNoIGNvbnRhaW5zIGJvdGggdGhlIHVwZGF0ZWQgQ2FjaGUgTm9kZSBhbmQgYSBwYXRoXG4vLyB0byB0aGUgcGVuZGluZyBzdWJ0cmVlcyB0aGF0IG5lZWQgdG8gYmUgcmVzb2x2ZWQgYnkgdGhlIG5hdmlnYXRpb24gcmVzcG9uc2UuXG4vL1xuLy8gQSByZXR1cm4gdmFsdWUgb2YgYG51bGxgIG1lYW5zIHRoZXJlIHdlcmUgbm8gY2hhbmdlcywgYW5kIHRoZSBwcmV2aW91cyB0cmVlXG4vLyBjYW4gYmUgcmV1c2VkIHdpdGhvdXQgaW5pdGlhdGluZyBhIHNlcnZlciByZXF1ZXN0LlxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0UFBSTmF2aWdhdGlvbihcbiAgbmF2aWdhdGVkQXQ6IG51bWJlcixcbiAgb2xkQ2FjaGVOb2RlOiBDYWNoZU5vZGUsXG4gIG9sZFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgbmV3Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBwcmVmZXRjaERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCxcbiAgcHJlZmV0Y2hIZWFkOiBIZWFkRGF0YSB8IG51bGwsXG4gIGlzUHJlZmV0Y2hIZWFkUGFydGlhbDogYm9vbGVhbixcbiAgaXNTYW1lUGFnZU5hdmlnYXRpb246IGJvb2xlYW4sXG4gIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdDogQXJyYXk8RmxpZ2h0U2VnbWVudFBhdGg+XG4pOiBUYXNrIHwgbnVsbCB7XG4gIGNvbnN0IHNlZ21lbnRQYXRoOiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD4gPSBbXVxuICByZXR1cm4gdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKFxuICAgIG5hdmlnYXRlZEF0LFxuICAgIG9sZENhY2hlTm9kZSxcbiAgICBvbGRSb3V0ZXJTdGF0ZSxcbiAgICBuZXdSb3V0ZXJTdGF0ZSxcbiAgICBmYWxzZSxcbiAgICBwcmVmZXRjaERhdGEsXG4gICAgcHJlZmV0Y2hIZWFkLFxuICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICBpc1NhbWVQYWdlTmF2aWdhdGlvbixcbiAgICBzZWdtZW50UGF0aCxcbiAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgKVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG9sZENhY2hlTm9kZTogQ2FjaGVOb2RlLFxuICBvbGRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIG5ld1JvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZGlkRmluZFJvb3RMYXlvdXQ6IGJvb2xlYW4sXG4gIHByZWZldGNoRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsLFxuICBwcmVmZXRjaEhlYWQ6IEhlYWREYXRhIHwgbnVsbCxcbiAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsOiBib29sZWFuLFxuICBpc1NhbWVQYWdlTmF2aWdhdGlvbjogYm9vbGVhbixcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQ6IEFycmF5PEZsaWdodFNlZ21lbnRQYXRoPlxuKTogVGFzayB8IG51bGwge1xuICAvLyBEaWZmIHRoZSBvbGQgYW5kIG5ldyB0cmVlcyB0byByZXVzZSB0aGUgc2hhcmVkIGxheW91dHMuXG4gIGNvbnN0IG9sZFJvdXRlclN0YXRlQ2hpbGRyZW4gPSBvbGRSb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuID0gbmV3Um91dGVyU3RhdGVbMV1cbiAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbMl0gOiBudWxsXG5cbiAgaWYgKCFkaWRGaW5kUm9vdExheW91dCkge1xuICAgIC8vIFdlJ3JlIGN1cnJlbnRseSB0cmF2ZXJzaW5nIHRoZSBwYXJ0IG9mIHRoZSB0cmVlIHRoYXQgd2FzIGFsc28gcGFydCBvZlxuICAgIC8vIHRoZSBwcmV2aW91cyByb3V0ZS4gSWYgd2UgZGlzY292ZXIgYSByb290IGxheW91dCwgdGhlbiB3ZSBkb24ndCBuZWVkIHRvXG4gICAgLy8gdHJpZ2dlciBhbiBNUEEgbmF2aWdhdGlvbi4gU2VlIGJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlIGZvciBjb250ZXh0LlxuICAgIGNvbnN0IGlzUm9vdExheW91dCA9IG5ld1JvdXRlclN0YXRlWzRdID09PSB0cnVlXG4gICAgaWYgKGlzUm9vdExheW91dCkge1xuICAgICAgLy8gRm91bmQgYSBtYXRjaGluZyByb290IGxheW91dC5cbiAgICAgIGRpZEZpbmRSb290TGF5b3V0ID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9sZFBhcmFsbGVsUm91dGVzID0gb2xkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzXG5cbiAgLy8gQ2xvbmUgdGhlIGN1cnJlbnQgc2V0IG9mIHNlZ21lbnQgY2hpbGRyZW4sIGV2ZW4gaWYgdGhleSBhcmVuJ3QgYWN0aXZlIGluXG4gIC8vIHRoZSBuZXcgdHJlZS5cbiAgLy8gVE9ETzogV2UgY3VycmVudGx5IHJldGFpbiBhbGwgdGhlIGluYWN0aXZlIHNlZ21lbnRzIGluZGVmaW5pdGVseSwgdW50aWxcbiAgLy8gdGhlcmUncyBhbiBleHBsaWNpdCByZWZyZXNoLCBvciBhIHBhcmVudCBsYXlvdXQgaXMgbGF6aWx5IHJlZnJlc2hlZC4gV2VcbiAgLy8gcmVseSBvbiB0aGlzIGZvciBwb3BzdGF0ZSBuYXZpZ2F0aW9ucywgd2hpY2ggdXBkYXRlIHRoZSBSb3V0ZXIgU3RhdGUgVHJlZVxuICAvLyBidXQgZG8gbm90IGVhZ2VybHkgcGVyZm9ybSBhIGRhdGEgZmV0Y2gsIGJlY2F1c2UgdGhleSBleHBlY3QgdGhlIHNlZ21lbnRcbiAgLy8gZGF0YSB0byBhbHJlYWR5IGJlIGluIHRoZSBDYWNoZSBOb2RlIHRyZWUuIEZvciBoaWdobHkgc3RhdGljIHNpdGVzIHRoYXRcbiAgLy8gYXJlIG1vc3RseSByZWFkLW9ubHksIHRoaXMgbWF5IGhhcHBlbiBvbmx5IHJhcmVseSwgY2F1c2luZyBtZW1vcnkgdG9cbiAgLy8gbGVhay4gV2Ugc2hvdWxkIGZpZ3VyZSBvdXQgYSBiZXR0ZXIgbW9kZWwgZm9yIHRoZSBsaWZldGltZSBvZiBpbmFjdGl2ZVxuICAvLyBzZWdtZW50cywgc28gd2UgY2FuIG1haW50YWluIGluc3RhbnQgYmFjay9mb3J3YXJkIG5hdmlnYXRpb25zIHdpdGhvdXRcbiAgLy8gbGVha2luZyBtZW1vcnkgaW5kZWZpbml0ZWx5LlxuICBjb25zdCBwcmVmZXRjaFBhcmFsbGVsUm91dGVzID0gbmV3IE1hcChvbGRQYXJhbGxlbFJvdXRlcylcblxuICAvLyBBcyB3ZSBkaWZmIHRoZSB0cmVlcywgd2UgbWF5IHNvbWV0aW1lcyBtb2RpZnkgKGNvcHktb24td3JpdGUsIG5vdCBtdXRhdGUpXG4gIC8vIHRoZSBSb3V0ZSBUcmVlIHRoYXQgd2FzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIg4oCUIGZvciBleGFtcGxlLCBpbiB0aGUgY2FzZVxuICAvLyBvZiBkZWZhdWx0IHBhcmFsbGVsIHJvdXRlcywgd2UgcHJlc2VydmUgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2VnbWVudC4gVG9cbiAgLy8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIHRyZWUsIHdlIGNsb25lIHRoZSByb3V0ZXIgc3RhdGUgY2hpbGRyZW4gYWxvbmdcbiAgLy8gdGhlIHJldHVybiBwYXRoLlxuICBsZXQgcGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW46IHtcbiAgICBbcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgfSA9IHt9XG4gIGxldCB0YXNrQ2hpbGRyZW4gPSBudWxsXG5cbiAgLy8gTW9zdCBuYXZpZ2F0aW9ucyByZXF1aXJlIGEgcmVxdWVzdCB0byBmZXRjaCBhZGRpdGlvbmFsIGRhdGEgZnJvbSB0aGVcbiAgLy8gc2VydmVyLCBlaXRoZXIgYmVjYXVzZSB0aGUgZGF0YSB3YXMgbm90IGFscmVhZHkgcHJlZmV0Y2hlZCwgb3IgYmVjYXVzZSB0aGVcbiAgLy8gdGFyZ2V0IHJvdXRlIGNvbnRhaW5zIGR5bmFtaWMgZGF0YSB0aGF0IGNhbm5vdCBiZSBwcmVmZXRjaGVkLlxuICAvL1xuICAvLyBIb3dldmVyLCBpZiB0aGUgdGFyZ2V0IHJvdXRlIGlzIGZ1bGx5IHN0YXRpYywgYW5kIGl0J3MgYWxyZWFkeSBjb21wbGV0ZWx5XG4gIC8vIGxvYWRlZCBpbnRvIHRoZSBzZWdtZW50IGNhY2hlLCB0aGVuIHdlIGNhbiBza2lwIHRoZSBzZXJ2ZXIgcmVxdWVzdC5cbiAgLy9cbiAgLy8gVGhpcyBzdGFydHMgb2ZmIGFzIGBmYWxzZWAsIGFuZCBpcyBzZXQgdG8gYHRydWVgIGlmIGFueSBvZiB0aGUgY2hpbGRcbiAgLy8gcm91dGVzIHJlcXVpcmVzIGEgZHluYW1pYyByZXF1ZXN0LlxuICBsZXQgbmVlZHNEeW5hbWljUmVxdWVzdCA9IGZhbHNlXG4gIC8vIEFzIHdlIHRyYXZlcnNlIHRoZSBjaGlsZHJlbiwgd2UnbGwgY29uc3RydWN0IGEgRmxpZ2h0Um91dGVyU3RhdGUgdGhhdCBjYW5cbiAgLy8gYmUgc2VudCB0byB0aGUgc2VydmVyIHRvIHJlcXVlc3QgdGhlIGR5bmFtaWMgZGF0YS4gSWYgaXQgdHVybnMgb3V0IHRoYXRcbiAgLy8gbm90aGluZyBpbiB0aGUgc3VidHJlZSBpcyBkeW5hbWljIChpLmUuIG5lZWRzRHluYW1pY1JlcXVlc3QgaXMgZmFsc2UgYXQgdGhlXG4gIC8vIGVuZCksIHRoZW4gdGhpcyB3aWxsIGJlIGRpc2NhcmRlZC5cbiAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IG9wdGltaXplIHRoZSBmb3JtYXQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSB0byBvbmx5XG4gIC8vIGluY2x1ZGUgcGF0aHMgdGhhdCBhcmUgZHluYW1pYy4gSW5zdGVhZCBvZiByZXVzaW5nIHRoZVxuICAvLyBGbGlnaHRSb3V0ZXJTdGF0ZSB0eXBlLlxuICBsZXQgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW46IHtcbiAgICBbcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgfSA9IHt9XG5cbiAgZm9yIChsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiBuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuKSB7XG4gICAgY29uc3QgbmV3Um91dGVyU3RhdGVDaGlsZDogRmxpZ2h0Um91dGVyU3RhdGUgPVxuICAgICAgbmV3Um91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IG9sZFJvdXRlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlIHwgdm9pZCA9XG4gICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgY29uc3Qgb2xkU2VnbWVudE1hcENoaWxkID0gb2xkUGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGQ6IENhY2hlTm9kZVNlZWREYXRhIHwgdm9pZCB8IG51bGwgPVxuICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gIT09IG51bGxcbiAgICAgICAgPyBwcmVmZXRjaERhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgICA6IG51bGxcblxuICAgIGNvbnN0IG5ld1NlZ21lbnRDaGlsZCA9IG5ld1JvdXRlclN0YXRlQ2hpbGRbMF1cbiAgICBjb25zdCBuZXdTZWdtZW50UGF0aENoaWxkID0gc2VnbWVudFBhdGguY29uY2F0KFtcbiAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICBuZXdTZWdtZW50Q2hpbGQsXG4gICAgXSlcbiAgICBjb25zdCBuZXdTZWdtZW50S2V5Q2hpbGQgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShuZXdTZWdtZW50Q2hpbGQpXG5cbiAgICBjb25zdCBvbGRTZWdtZW50Q2hpbGQgPVxuICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCAhPT0gdW5kZWZpbmVkID8gb2xkUm91dGVyU3RhdGVDaGlsZFswXSA6IHVuZGVmaW5lZFxuXG4gICAgY29uc3Qgb2xkQ2FjaGVOb2RlQ2hpbGQgPVxuICAgICAgb2xkU2VnbWVudE1hcENoaWxkICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvbGRTZWdtZW50TWFwQ2hpbGQuZ2V0KG5ld1NlZ21lbnRLZXlDaGlsZClcbiAgICAgICAgOiB1bmRlZmluZWRcblxuICAgIGxldCB0YXNrQ2hpbGQ6IFRhc2sgfCBudWxsXG4gICAgaWYgKG5ld1NlZ21lbnRDaGlsZCA9PT0gREVGQVVMVF9TRUdNRU5UX0tFWSkge1xuICAgICAgLy8gVGhpcyBpcyBhbm90aGVyIGtpbmQgb2YgbGVhZiBzZWdtZW50IOKAlCBhIGRlZmF1bHQgcm91dGUuXG4gICAgICAvL1xuICAgICAgLy8gRGVmYXVsdCByb3V0ZXMgaGF2ZSBzcGVjaWFsIGJlaGF2aW9yLiBXaGVuIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgc2VnbWVudFxuICAgICAgLy8gZm9yIGEgcGFyYWxsZWwgcm91dGUsIE5leHQuanMgcHJlc2VydmVzIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNlZ21lbnRcbiAgICAgIC8vIGR1cmluZyBhIGNsaWVudCBuYXZpZ2F0aW9uIOKAlCBidXQgbm90IGZvciBpbml0aWFsIHJlbmRlci4gVGhlIHNlcnZlclxuICAgICAgLy8gbGVhdmVzIGl0IHRvIHRoZSBjbGllbnQgdG8gYWNjb3VudCBmb3IgdGhpcy4gU28gd2UgbmVlZCB0byBoYW5kbGVcbiAgICAgIC8vIGl0IGhlcmUuXG4gICAgICBpZiAob2xkUm91dGVyU3RhdGVDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFJldXNlIHRoZSBleGlzdGluZyBSb3V0ZXIgU3RhdGUgZm9yIHRoaXMgc2VnbWVudC4gV2Ugc3Bhd24gYSBcInRhc2tcIlxuICAgICAgICAvLyBqdXN0IHRvIGtlZXAgdHJhY2sgb2YgdGhlIHVwZGF0ZWQgcm91dGVyIHN0YXRlOyB1bmxpa2UgbW9zdCwgaXQnc1xuICAgICAgICAvLyBhbHJlYWR5IGZ1bGZpbGxlZCBhbmQgd29uJ3QgYmUgYWZmZWN0ZWQgYnkgdGhlIGR5bmFtaWMgcmVzcG9uc2UuXG4gICAgICAgIHRhc2tDaGlsZCA9IHNwYXduUmV1c2VkVGFzayhvbGRSb3V0ZXJTdGF0ZUNoaWxkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUncyBubyBjdXJyZW50bHkgYWN0aXZlIHNlZ21lbnQuIFN3aXRjaCB0byB0aGUgXCJjcmVhdGVcIiBwYXRoLlxuICAgICAgICB0YXNrQ2hpbGQgPSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZShcbiAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgIG5ld1JvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgICAgZGlkRmluZFJvb3RMYXlvdXQsXG4gICAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCxcbiAgICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgICAgIG5ld1NlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaXNTYW1lUGFnZU5hdmlnYXRpb24gJiZcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBwYWdlIHNlZ21lbnQuXG4gICAgICAvLyBUT0RPOiBXZSdyZSBub3QgY29uc2lzdGVudCBhYm91dCBob3cgd2UgZG8gdGhpcyBjaGVjay4gU29tZSBwbGFjZXNcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBzZWdtZW50IHN0YXJ0cyB3aXRoIFBBR0VfU0VHTUVOVF9LRVksIGJ1dCBtb3N0IHNlZW0gdG9cbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFueSBhbnkgY2hpbGRyZW4sIHdoaWNoIGlzIHdoeSBJJ20gZG9pbmcgaXQgaGVyZS4gV2VcbiAgICAgIC8vIHNob3VsZCBwcm9iYWJseSBlbmNvZGUgYW4gZW1wdHkgY2hpbGRyZW4gc2V0IGFzIGBudWxsYCB0aG91Z2guIEVpdGhlclxuICAgICAgLy8gd2F5LCB3ZSBzaG91bGQgdXBkYXRlIGFsbCB0aGUgY2hlY2tzIHRvIGJlIGNvbnNpc3RlbnQuXG4gICAgICBPYmplY3Qua2V5cyhuZXdSb3V0ZXJTdGF0ZUNoaWxkWzFdKS5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBuYXZpZ2F0aW9ucyB0byB0aGUgZXhhY3Qgc2FtZSBVUkwgYXMgdGhlIGN1cnJlbnRcbiAgICAgIC8vIGxvY2F0aW9uLiBJdCdzIGEgY29tbW9uIFVJIHBhdHRlcm4gZm9yIGFwcHMgdG8gcmVmcmVzaCB3aGVuIHlvdSBjbGljayBhXG4gICAgICAvLyBsaW5rIHRvIHRoZSBjdXJyZW50IHBhZ2UuIFNvIHdoZW4gdGhpcyBoYXBwZW5zLCB3ZSByZWZyZXNoIHRoZSBkeW5hbWljXG4gICAgICAvLyBkYXRhIGluIHRoZSBwYWdlIHNlZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGFwcGx5IGlmIHRoZSBhbnkgcGFydCBvZiB0aGUgaGFzaCBvciBzZWFyY2hcbiAgICAgIC8vIHF1ZXJ5IGhhcyBjaGFuZ2VkLiBUaGlzIG1pZ2h0IGZlZWwgYSBiaXQgd2VpcmQgYnV0IGl0IG1ha2VzIG1vcmUgc2Vuc2VcbiAgICAgIC8vIHdoZW4geW91IGNvbnNpZGVyIHRoYXQgdGhlIHdheSB0byB0cmlnZ2VyIHRoaXMgYmVoYXZpb3IgaXMgdG8gY2xpY2tcbiAgICAgIC8vIHRoZSBzYW1lIGxpbmsgbXVsdGlwbGUgdGltZXMuXG4gICAgICAvL1xuICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IHJlZnJlc2ggdGhlICplbnRpcmUqIHJvdXRlIHdoZW4gdGhpcyBjYXNlXG4gICAgICAvLyBvY2N1cnMsIG5vdCBqdXN0IHRoZSBwYWdlIHNlZ21lbnRzLiBFc3NlbnRpYWxseSB0cmVhdGluZyBpdCB0aGUgc2FtZSBhc1xuICAgICAgLy8gYSByZWZyZXNoKCkgdHJpZ2dlcmVkIGJ5IGFuIGFjdGlvbiwgd2hpY2ggaXMgdGhlIG1vcmUgZXhwbGljaXQgd2F5IG9mXG4gICAgICAvLyBtb2RlbGluZyB0aGUgVUkgcGF0dGVybiBkZXNjcmliZWQgYWJvdmUuXG4gICAgICAvL1xuICAgICAgLy8gQWxzbyBub3RlIHRoYXQgdGhpcyBvbmx5IHJlZnJlc2hlcyB0aGUgZHluYW1pYyBkYXRhLCBub3Qgc3RhdGljL1xuICAgICAgLy8gY2FjaGVkIGRhdGEuIElmIHRoZSBwYWdlIHNlZ21lbnQgaXMgZnVsbHkgc3RhdGljIGFuZCBwcmVmZXRjaGVkLCB0aGVcbiAgICAgIC8vIHJlcXVlc3QgaXMgc2tpcHBlZC4gKFRoaXMgaXMgYWxzbyBob3cgcmVmcmVzaCgpIHdvcmtzLilcbiAgICAgIHRhc2tDaGlsZCA9IGJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlKFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgbmV3Um91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgIGRpZEZpbmRSb290TGF5b3V0LFxuICAgICAgICBwcmVmZXRjaERhdGFDaGlsZCAhPT0gdW5kZWZpbmVkID8gcHJlZmV0Y2hEYXRhQ2hpbGQgOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgICAgbmV3U2VnbWVudFBhdGhDaGlsZCxcbiAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICApXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG9sZFJvdXRlclN0YXRlQ2hpbGQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgb2xkU2VnbWVudENoaWxkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIG1hdGNoU2VnbWVudChuZXdTZWdtZW50Q2hpbGQsIG9sZFNlZ21lbnRDaGlsZClcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICAvLyBUaGlzIHNlZ21lbnQgZXhpc3RzIGluIGJvdGggdGhlIG9sZCBhbmQgbmV3IHRyZWVzLiBSZWN1cnNpdmVseSB1cGRhdGVcbiAgICAgICAgLy8gdGhlIGNoaWxkcmVuLlxuICAgICAgICB0YXNrQ2hpbGQgPSB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgICBuZXdSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgIGRpZEZpbmRSb290TGF5b3V0LFxuICAgICAgICAgIHByZWZldGNoRGF0YUNoaWxkLFxuICAgICAgICAgIHByZWZldGNoSGVhZCxcbiAgICAgICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICAgICAgaXNTYW1lUGFnZU5hdmlnYXRpb24sXG4gICAgICAgICAgbmV3U2VnbWVudFBhdGhDaGlsZCxcbiAgICAgICAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUncyBubyBleGlzdGluZyBDYWNoZSBOb2RlIGZvciB0aGlzIHNlZ21lbnQuIFN3aXRjaCB0byB0aGVcbiAgICAgICAgLy8gXCJjcmVhdGVcIiBwYXRoLlxuICAgICAgICB0YXNrQ2hpbGQgPSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZShcbiAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgIG5ld1JvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgICAgZGlkRmluZFJvb3RMYXlvdXQsXG4gICAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCxcbiAgICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgICAgIG5ld1NlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhIG5ldyB0cmVlLiBTd2l0Y2ggdG8gdGhlIFwiY3JlYXRlXCIgcGF0aC5cbiAgICAgIHRhc2tDaGlsZCA9IGJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlKFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgbmV3Um91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgIGRpZEZpbmRSb290TGF5b3V0LFxuICAgICAgICBwcmVmZXRjaERhdGFDaGlsZCAhPT0gdW5kZWZpbmVkID8gcHJlZmV0Y2hEYXRhQ2hpbGQgOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgICAgbmV3U2VnbWVudFBhdGhDaGlsZCxcbiAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHRhc2tDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gUmVjdXJzaXZlbHkgcHJvcGFnYXRlIHVwIHRoZSBjaGlsZCB0YXNrcy5cblxuICAgICAgaWYgKHRhc2tDaGlsZC5yb3V0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBPbmUgb2YgdGhlIGNoaWxkIHRhc2tzIGRpc2NvdmVyZWQgYSBjaGFuZ2UgdG8gdGhlIHJvb3QgbGF5b3V0LlxuICAgICAgICAvLyBJbW1lZGlhdGVseSB1bndpbmQgZnJvbSB0aGlzIHJlY3Vyc2l2ZSB0cmF2ZXJzYWwuXG4gICAgICAgIHJldHVybiBNUEFfTkFWSUdBVElPTl9UQVNLXG4gICAgICB9XG5cbiAgICAgIGlmICh0YXNrQ2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgdGFza0NoaWxkcmVuID0gbmV3IE1hcCgpXG4gICAgICB9XG4gICAgICB0YXNrQ2hpbGRyZW4uc2V0KHBhcmFsbGVsUm91dGVLZXksIHRhc2tDaGlsZClcbiAgICAgIGNvbnN0IG5ld0NhY2hlTm9kZUNoaWxkID0gdGFza0NoaWxkLm5vZGVcbiAgICAgIGlmIChuZXdDYWNoZU5vZGVDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBuZXdTZWdtZW50TWFwQ2hpbGQ6IENoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAob2xkU2VnbWVudE1hcENoaWxkKVxuICAgICAgICBuZXdTZWdtZW50TWFwQ2hpbGQuc2V0KG5ld1NlZ21lbnRLZXlDaGlsZCwgbmV3Q2FjaGVOb2RlQ2hpbGQpXG4gICAgICAgIHByZWZldGNoUGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZClcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNoaWxkIHRyZWUncyByb3V0ZSBzdGF0ZSBtYXkgYmUgZGlmZmVyZW50IGZyb20gdGhlIHByZWZldGNoZWRcbiAgICAgIC8vIHJvdXRlIHNlbnQgYnkgdGhlIHNlcnZlci4gV2UgbmVlZCB0byBjbG9uZSBpdCBhcyB3ZSB0cmF2ZXJzZSBiYWNrIHVwXG4gICAgICAvLyB0aGUgdHJlZS5cbiAgICAgIGNvbnN0IHRhc2tDaGlsZFJvdXRlID0gdGFza0NoaWxkLnJvdXRlXG4gICAgICBwYXRjaGVkUm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IHRhc2tDaGlsZFJvdXRlXG5cbiAgICAgIGNvbnN0IGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkID0gdGFza0NoaWxkLmR5bmFtaWNSZXF1ZXN0VHJlZVxuICAgICAgaWYgKGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyBpbiB0aGUgY2hpbGQgdHJlZSBpcyBkeW5hbWljLlxuICAgICAgICBuZWVkc0R5bmFtaWNSZXF1ZXN0ID0gdHJ1ZVxuICAgICAgICBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IHRhc2tDaGlsZFJvdXRlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjaGlsZCBkaWRuJ3QgY2hhbmdlLiBXZSBjYW4gdXNlIHRoZSBwcmVmZXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgIHBhdGNoZWRSb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldID0gbmV3Um91dGVyU3RhdGVDaGlsZFxuICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSBuZXdSb3V0ZXJTdGF0ZUNoaWxkXG4gICAgfVxuICB9XG5cbiAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIC8vIE5vIG5ldyB0YXNrcyB3ZXJlIHNwYXduZWQuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IG5ld0NhY2hlTm9kZTogUmVhZHlDYWNoZU5vZGUgPSB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjOiBvbGRDYWNoZU5vZGUucnNjLFxuICAgIC8vIFdlIGludGVudGlvbmFsbHkgYXJlbid0IHVwZGF0aW5nIHRoZSBwcmVmZXRjaFJzYyBmaWVsZCwgc2luY2UgdGhpcyBub2RlXG4gICAgLy8gaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBjdXJyZW50IHRyZWUsIGJlY2F1c2UgaXQgd291bGQgYmUgd2VpcmQgZm9yXG4gICAgLy8gcHJlZmV0Y2ggZGF0YSB0byBiZSBuZXdlciB0aGFuIHRoZSBmaW5hbCBkYXRhLiBJdCBwcm9iYWJseSB3b24ndCBldmVyIGJlXG4gICAgLy8gb2JzZXJ2YWJsZSBhbnl3YXksIGJ1dCBpdCBjb3VsZCBoYXBwZW4gaWYgdGhlIHNlZ21lbnQgaXMgdW5tb3VudGVkIHRoZW5cbiAgICAvLyBtb3VudGVkIGFnYWluLCBiZWNhdXNlIExheW91dFJvdXRlciB3aWxsIG1vbWVudGFyaWx5IHN3aXRjaCB0byByZW5kZXJpbmdcbiAgICAvLyBwcmVmZXRjaFJzYywgdmlhIHVzZURlZmVycmVkVmFsdWUuXG4gICAgcHJlZmV0Y2hSc2M6IG9sZENhY2hlTm9kZS5wcmVmZXRjaFJzYyxcbiAgICBoZWFkOiBvbGRDYWNoZU5vZGUuaGVhZCxcbiAgICBwcmVmZXRjaEhlYWQ6IG9sZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgbG9hZGluZzogb2xkQ2FjaGVOb2RlLmxvYWRpbmcsXG5cbiAgICAvLyBFdmVyeXRoaW5nIGlzIGNsb25lZCBleGNlcHQgZm9yIHRoZSBjaGlsZHJlbiwgd2hpY2ggd2UgY29tcHV0ZWQgYWJvdmUuXG4gICAgcGFyYWxsZWxSb3V0ZXM6IHByZWZldGNoUGFyYWxsZWxSb3V0ZXMsXG5cbiAgICBuYXZpZ2F0ZWRBdCxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gUmV0dXJuIGEgY2xvbmVkIGNvcHkgb2YgdGhlIHJvdXRlciBzdGF0ZSB3aXRoIHVwZGF0ZWQgY2hpbGRyZW4uXG4gICAgcm91dGU6IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gICAgICBuZXdSb3V0ZXJTdGF0ZSxcbiAgICAgIHBhdGNoZWRSb3V0ZXJTdGF0ZUNoaWxkcmVuXG4gICAgKSxcbiAgICBub2RlOiBuZXdDYWNoZU5vZGUsXG4gICAgZHluYW1pY1JlcXVlc3RUcmVlOiBuZWVkc0R5bmFtaWNSZXF1ZXN0XG4gICAgICA/IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gICAgICAgICAgbmV3Um91dGVyU3RhdGUsXG4gICAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5cbiAgICAgICAgKVxuICAgICAgOiBudWxsLFxuICAgIGNoaWxkcmVuOiB0YXNrQ2hpbGRyZW4sXG4gIH1cbn1cblxuZnVuY3Rpb24gYmVnaW5SZW5kZXJpbmdOZXdSb3V0ZVRyZWUoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG9sZFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IHZvaWQsXG4gIG5ld1JvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZXhpc3RpbmdDYWNoZU5vZGU6IENhY2hlTm9kZSB8IHZvaWQsXG4gIGRpZEZpbmRSb290TGF5b3V0OiBib29sZWFuLFxuICBwcmVmZXRjaERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCxcbiAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkOiBIZWFkRGF0YSB8IG51bGwsXG4gIGlzUHJlZmV0Y2hIZWFkUGFydGlhbDogYm9vbGVhbixcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQ6IEFycmF5PEZsaWdodFNlZ21lbnRQYXRoPlxuKTogVGFzayB7XG4gIGlmICghZGlkRmluZFJvb3RMYXlvdXQpIHtcbiAgICAvLyBUaGUgcm91dGUgdHJlZSBjaGFuZ2VkIGJlZm9yZSB3ZSByZWFjaGVkIGEgbGF5b3V0LiAoVGhlIGhpZ2hlc3QtbGV2ZWxcbiAgICAvLyBsYXlvdXQgaW4gYSByb3V0ZSB0cmVlIGlzIHJlZmVycmVkIHRvIGFzIHRoZSBcInJvb3RcIiBsYXlvdXQuKSBUaGlzIGNvdWxkXG4gICAgLy8gbWVhbiB0aGF0IHdlJ3JlIG5hdmlnYXRpbmcgYmV0d2VlbiB0d28gZGlmZmVyZW50IHJvb3QgbGF5b3V0cy4gV2hlbiB0aGlzXG4gICAgLy8gaGFwcGVucywgd2UgcGVyZm9ybSBhIGZ1bGwtcGFnZSAoTVBBLXN0eWxlKSBuYXZpZ2F0aW9uLlxuICAgIC8vXG4gICAgLy8gSG93ZXZlciwgdGhlIGFsZ29yaXRobSBmb3IgZGVjaWRpbmcgd2hlcmUgdG8gc3RhcnQgcmVuZGVyaW5nIGEgcm91dGVcbiAgICAvLyAoaS5lLiB0aGUgb25lIHBlcmZvcm1lZCBpbiBvcmRlciB0byByZWFjaCB0aGlzIGZ1bmN0aW9uKSBpcyBzdHJpY3RlclxuICAgIC8vIHRoYW4gdGhlIG9uZSB1c2VkIHRvIGRldGVjdCBhIGNoYW5nZSBpbiB0aGUgcm9vdCBsYXlvdXQuIFNvIGp1c3QgYmVjYXVzZVxuICAgIC8vIHdlJ3JlIHJlLXJlbmRlcmluZyBhIHNlZ21lbnQgb3V0c2lkZSBvZiB0aGUgcm9vdCBsYXlvdXQgZG9lcyBub3QgbWVhbiB3ZVxuICAgIC8vIHNob3VsZCB0cmlnZ2VyIGEgZnVsbC1wYWdlIG5hdmlnYXRpb24uXG4gICAgLy9cbiAgICAvLyBTcGVjaWZpY2FsbHksIHdlIGhhbmRsZSBkeW5hbWljIHBhcmFtZXRlcnMgZGlmZmVyZW50bHk6IHR3byBzZWdtZW50cyBhcmVcbiAgICAvLyBjb25zaWRlcmVkIHRoZSBzYW1lIGV2ZW4gaWYgdGhlaXIgcGFyYW1ldGVyIHZhbHVlcyBhcmUgZGlmZmVyZW50LlxuICAgIC8vXG4gICAgLy8gUmVmZXIgdG8gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IGZvciBkZXRhaWxzLlxuICAgIC8vXG4gICAgLy8gTm90ZSB0aGF0IHdlIG9ubHkgaGF2ZSB0byBwZXJmb3JtIHRoaXMgZXh0cmEgdHJhdmVyc2FsIGlmIHdlIGRpZG4ndFxuICAgIC8vIGFscmVhZHkgZGlzY292ZXIgYSByb290IGxheW91dCBpbiB0aGUgcGFydCBvZiB0aGUgdHJlZSB0aGF0IGlzIHVuY2hhbmdlZC5cbiAgICAvLyBJbiB0aGUgY29tbW9uIGNhc2UsIHRoaXMgYnJhbmNoIGlzIHNraXBwZWQgY29tcGxldGVseS5cbiAgICBpZiAoXG4gICAgICBvbGRSb3V0ZXJTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQob2xkUm91dGVyU3RhdGUsIG5ld1JvdXRlclN0YXRlKVxuICAgICkge1xuICAgICAgLy8gVGhlIHJvb3QgbGF5b3V0IGNoYW5nZWQuIFBlcmZvcm0gYSBmdWxsLXBhZ2UgbmF2aWdhdGlvbi5cbiAgICAgIHJldHVybiBNUEFfTkFWSUdBVElPTl9UQVNLXG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gICAgbmF2aWdhdGVkQXQsXG4gICAgbmV3Um91dGVyU3RhdGUsXG4gICAgZXhpc3RpbmdDYWNoZU5vZGUsXG4gICAgcHJlZmV0Y2hEYXRhLFxuICAgIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCxcbiAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgc2VnbWVudFBhdGgsXG4gICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gIClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKFxuICBuYXZpZ2F0ZWRBdDogbnVtYmVyLFxuICByb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIGV4aXN0aW5nQ2FjaGVOb2RlOiBDYWNoZU5vZGUgfCB2b2lkLFxuICBwcmVmZXRjaERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCxcbiAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkOiBIZWFkRGF0YSB8IG51bGwsXG4gIGlzUHJlZmV0Y2hIZWFkUGFydGlhbDogYm9vbGVhbixcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQ6IEFycmF5PEZsaWdodFNlZ21lbnRQYXRoPlxuKTogU1BBTmF2aWdhdGlvblRhc2sge1xuICAvLyBTYW1lIHRyYXZlcnNhbCBhcyB1cGRhdGVDYWNoZU5vZGVOYXZpZ2F0aW9uLCBidXQgd2Ugc3dpdGNoIHRvIHRoaXMgcGF0aFxuICAvLyBvbmNlIHdlIHJlYWNoIHRoZSBwYXJ0IG9mIHRoZSB0cmVlIHRoYXQgd2FzIG5vdCBpbiB0aGUgcHJldmlvdXMgcm91dGUuIFdlXG4gIC8vIGRvbid0IG5lZWQgdG8gZGlmZiBhZ2FpbnN0IHRoZSBvbGQgdHJlZSwgd2UganVzdCBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG5cbiAgLy8gVGhlIGhlYWQgaXMgYXNzaWduZWQgdG8gZXZlcnkgbGVhZiBzZWdtZW50IGRlbGl2ZXJlZCBieSB0aGUgc2VydmVyLiBCYXNlZFxuICAvLyBvbiBjb3JyZXNwb25kaW5nIGxvZ2ljIGluIGZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLnRzXG4gIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBpc0xlYWZTZWdtZW50ID0gT2JqZWN0LmtleXMocm91dGVyU3RhdGVDaGlsZHJlbikubGVuZ3RoID09PSAwXG5cbiAgLy8gRXZlbiB3ZSdyZSByZW5kZXJpbmcgaW5zaWRlIHRoZSBcIm5ld1wiIHBhcnQgb2YgdGhlIHRhcmdldCB0cmVlLCB3ZSBtYXkgaGF2ZVxuICAvLyBhIGxvY2FsbHkgY2FjaGVkIHNlZ21lbnQgdGhhdCB3ZSBjYW4gcmV1c2UuIFRoaXMgbWF5IGNvbWUgZnJvbSBlaXRoZXIgMSlcbiAgLy8gdGhlIENhY2hlTm9kZSB0cmVlLCB3aGljaCBsaXZlcyBpbiBSZWFjdCBzdGF0ZSBhbmQgaXMgcG9wdWxhdGVkIGJ5IHByZXZpb3VzXG4gIC8vIG5hdmlnYXRpb25zOyBvciAyKSB0aGUgcHJlZmV0Y2ggY2FjaGUsIHdoaWNoIGlzIGEgc2VwYXJhdGUgY2FjaGUgdGhhdCBpc1xuICAvLyBwb3B1bGF0ZWQgYnkgcHJlZmV0Y2hlcy5cbiAgbGV0IHJzYzogUmVhY3QuUmVhY3ROb2RlXG4gIGxldCBsb2FkaW5nOiBMb2FkaW5nTW9kdWxlRGF0YSB8IFByb21pc2U8TG9hZGluZ01vZHVsZURhdGE+XG4gIGxldCBoZWFkOiBIZWFkRGF0YSB8IG51bGxcbiAgbGV0IGNhY2hlTm9kZU5hdmlnYXRlZEF0OiBudW1iZXJcbiAgaWYgKFxuICAgIGV4aXN0aW5nQ2FjaGVOb2RlICE9PSB1bmRlZmluZWQgJiZcbiAgICAvLyBEWU5BTUlDX1NUQUxFVElNRV9NUyBkZWZhdWx0cyB0byAwLCBidXQgaXQgY2FuIGJlIGluY3JlYXNlZCB1c2luZ1xuICAgIC8vIHRoZSBleHBlcmltZW50YWwuc3RhbGVUaW1lcy5keW5hbWljIGNvbmZpZy4gV2hlbiBzZXQsIHdlJ2xsIGF2b2lkXG4gICAgLy8gcmVmZXRjaGluZyBkeW5hbWljIGRhdGEgaWYgaXQgd2FzIGZldGNoZWQgd2l0aGluIHRoZSBnaXZlbiB0aHJlc2hvbGQuXG4gICAgZXhpc3RpbmdDYWNoZU5vZGUubmF2aWdhdGVkQXQgKyBEWU5BTUlDX1NUQUxFVElNRV9NUyA+IG5hdmlnYXRlZEF0XG4gICkge1xuICAgIC8vIFdlIGhhdmUgYW4gZXhpc3RpbmcgQ2FjaGVOb2RlIGZvciB0aGlzIHNlZ21lbnQsIGFuZCBpdCdzIG5vdCBzdGFsZS4gV2VcbiAgICAvLyBzaG91bGQgcmV1c2UgaXQgcmF0aGVyIHRoYW4gcmVxdWVzdCBhIG5ldyBvbmUuXG4gICAgcnNjID0gZXhpc3RpbmdDYWNoZU5vZGUucnNjXG4gICAgbG9hZGluZyA9IGV4aXN0aW5nQ2FjaGVOb2RlLmxvYWRpbmdcbiAgICBoZWFkID0gZXhpc3RpbmdDYWNoZU5vZGUuaGVhZFxuXG4gICAgLy8gRG9uJ3QgdXBkYXRlIHRoZSBuYXZpZ2F0ZWRBdCB0aW1lc3RhbXAsIHNpbmNlIHdlJ3JlIHJldXNpbmcgc3RhbGUgZGF0YS5cbiAgICBjYWNoZU5vZGVOYXZpZ2F0ZWRBdCA9IGV4aXN0aW5nQ2FjaGVOb2RlLm5hdmlnYXRlZEF0XG4gIH0gZWxzZSBpZiAocHJlZmV0Y2hEYXRhICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBubyBleGlzdGluZyBDYWNoZU5vZGUgZm9yIHRoaXMgc2VnbWVudCwgYnV0IHdlIGRvIGhhdmUgcHJlZmV0Y2hcbiAgICAvLyBkYXRhLiBJZiB0aGUgcHJlZmV0Y2ggZGF0YSBpcyBmdWxseSBzdGF0aWMgKGkuZS4gZG9lcyBub3QgY29udGFpbiBhbnlcbiAgICAvLyBkeW5hbWljIGhvbGVzKSwgd2UgZG9uJ3QgbmVlZCB0byByZXF1ZXN0IGl0IGZyb20gdGhlIHNlcnZlci5cbiAgICByc2MgPSBwcmVmZXRjaERhdGFbMV1cbiAgICBsb2FkaW5nID0gcHJlZmV0Y2hEYXRhWzNdXG4gICAgaGVhZCA9IGlzTGVhZlNlZ21lbnQgPyBwb3NzaWJseVBhcnRpYWxQcmVmZXRjaEhlYWQgOiBudWxsXG4gICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgYWNjZXNzaW5nIHRoZSBkYXRhIGZyb20gdGhlIHByZWZldGNoIGNhY2hlLCB0aGlzIGlzXG4gICAgLy8gY29uY2VwdHVhbGx5IGEgbmV3IHNlZ21lbnQsIG5vdCBhIHJldXNlZCBvbmUuIFNvIHdlIHNob3VsZCB1cGRhdGUgdGhlXG4gICAgLy8gbmF2aWdhdGVkQXQgdGltZXN0YW1wLlxuICAgIGNhY2hlTm9kZU5hdmlnYXRlZEF0ID0gbmF2aWdhdGVkQXRcbiAgICBjb25zdCBpc1ByZWZldGNoUnNjUGFydGlhbCA9IHByZWZldGNoRGF0YVs0XVxuICAgIGlmIChcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBzZWdtZW50IGRhdGEgaXMgcGFydGlhbFxuICAgICAgaXNQcmVmZXRjaFJzY1BhcnRpYWwgfHxcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBoZWFkIGlzIHBhcnRpYWwgKG9ubHkgcmVsZXZhbnQgaWYgdGhpcyBpcyBhIGxlYWYgc2VnbWVudClcbiAgICAgIChpc1ByZWZldGNoSGVhZFBhcnRpYWwgJiYgaXNMZWFmU2VnbWVudClcbiAgICApIHtcbiAgICAgIC8vIFdlIG9ubHkgaGF2ZSBwYXJ0aWFsIGRhdGEgZnJvbSB0aGlzIHNlZ21lbnQuIExpa2UgbWlzc2luZyBzZWdtZW50cywgd2VcbiAgICAgIC8vIG11c3QgcmVxdWVzdCB0aGUgZnVsbCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICAgIHJldHVybiBzcGF3blBlbmRpbmdUYXNrKFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgcm91dGVyU3RhdGUsXG4gICAgICAgIHByZWZldGNoRGF0YSxcbiAgICAgICAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkLFxuICAgICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICAgIHNlZ21lbnRQYXRoLFxuICAgICAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHByZWZldGNoIGRhdGEgaXMgZnVsbHkgc3RhdGljLCBzbyB3ZSBjYW4gb21pdCBpdCBmcm9tIHRoZVxuICAgICAgLy8gbmF2aWdhdGlvbiByZXF1ZXN0LlxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSdzIG5vIHByZWZldGNoIGZvciB0aGlzIHNlZ21lbnQuIEV2ZXJ5dGhpbmcgZnJvbSB0aGlzIHBvaW50IHdpbGwgYmVcbiAgICAvLyByZXF1ZXN0ZWQgZnJvbSB0aGUgc2VydmVyLCBldmVuIGlmIHRoZXJlIGFyZSBzdGF0aWMgY2hpbGRyZW4gYmVsb3cgaXQuXG4gICAgLy8gQ3JlYXRlIGEgdGVybWluYWwgdGFzayBub2RlIHRoYXQgd2lsbCBsYXRlciBiZSBmdWxmaWxsZWQgYnlcbiAgICAvLyBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgcmV0dXJuIHNwYXduUGVuZGluZ1Rhc2soXG4gICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgIHJvdXRlclN0YXRlLFxuICAgICAgbnVsbCxcbiAgICAgIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCxcbiAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgIHNlZ21lbnRQYXRoLFxuICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgKVxuICB9XG5cbiAgLy8gV2UgYWxyZWFkeSBoYXZlIGEgZnVsbCBzZWdtZW50IHdlIGNhbiByZW5kZXIsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVxdWVzdCBhXG4gIC8vIG5ldyBvbmUgZnJvbSB0aGUgc2VydmVyLiBLZWVwIHRyYXZlcnNpbmcgZG93biB0aGUgdHJlZSB1bnRpbCB3ZSByZWFjaFxuICAvLyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBhIGR5bmFtaWMgcmVxdWVzdC5cbiAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbMl0gOiBudWxsXG4gIGNvbnN0IHRhc2tDaGlsZHJlbiA9IG5ldyBNYXAoKVxuICBjb25zdCBleGlzdGluZ0NhY2hlTm9kZUNoaWxkcmVuID1cbiAgICBleGlzdGluZ0NhY2hlTm9kZSAhPT0gdW5kZWZpbmVkID8gZXhpc3RpbmdDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMgOiBudWxsXG4gIGNvbnN0IGNhY2hlTm9kZUNoaWxkcmVuID0gbmV3IE1hcChleGlzdGluZ0NhY2hlTm9kZUNoaWxkcmVuKVxuICBsZXQgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW46IHtcbiAgICBbcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgfSA9IHt9XG4gIGxldCBuZWVkc0R5bmFtaWNSZXF1ZXN0ID0gZmFsc2VcbiAgaWYgKGlzTGVhZlNlZ21lbnQpIHtcbiAgICAvLyBUaGUgc2VnbWVudCBwYXRoIG9mIGV2ZXJ5IGxlYWYgc2VnbWVudCAoaS5lLiBwYWdlKSBpcyBjb2xsZWN0ZWQgaW50b1xuICAgIC8vIGEgcmVzdWx0IGFycmF5LiBUaGlzIGlzIHVzZWQgYnkgdGhlIExheW91dFJvdXRlciB0byBzY3JvbGwgdG8gZW5zdXJlIHRoYXRcbiAgICAvLyBuZXcgcGFnZXMgYXJlIHZpc2libGUgYWZ0ZXIgYSBuYXZpZ2F0aW9uLlxuICAgIC8vIFRPRE86IFdlIHNob3VsZCB1c2UgYSBzdHJpbmcgdG8gcmVwcmVzZW50IHRoZSBzZWdtZW50IHBhdGggaW5zdGVhZCBvZlxuICAgIC8vIGFuIGFycmF5LiBXZSBhbHJlYWR5IHVzZSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgdGhlIHBhdGggd2hlblxuICAgIC8vIGFjY2Vzc2luZyB0aGUgU2VnbWVudCBDYWNoZSwgc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBvbmUuXG4gICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0LnB1c2goc2VnbWVudFBhdGgpXG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiByb3V0ZXJTdGF0ZUNoaWxkcmVuKSB7XG4gICAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9XG4gICAgICAgIHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICAgIGNvbnN0IHByZWZldGNoRGF0YUNoaWxkOiBDYWNoZU5vZGVTZWVkRGF0YSB8IHZvaWQgfCBudWxsID1cbiAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gIT09IG51bGxcbiAgICAgICAgICA/IHByZWZldGNoRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICAgICAgOiBudWxsXG4gICAgICBjb25zdCBleGlzdGluZ1NlZ21lbnRNYXBDaGlsZCA9XG4gICAgICAgIGV4aXN0aW5nQ2FjaGVOb2RlQ2hpbGRyZW4gIT09IG51bGxcbiAgICAgICAgICA/IGV4aXN0aW5nQ2FjaGVOb2RlQ2hpbGRyZW4uZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgIGNvbnN0IHNlZ21lbnRDaGlsZCA9IHJvdXRlclN0YXRlQ2hpbGRbMF1cbiAgICAgIGNvbnN0IHNlZ21lbnRQYXRoQ2hpbGQgPSBzZWdtZW50UGF0aC5jb25jYXQoW1xuICAgICAgICBwYXJhbGxlbFJvdXRlS2V5LFxuICAgICAgICBzZWdtZW50Q2hpbGQsXG4gICAgICBdKVxuICAgICAgY29uc3Qgc2VnbWVudEtleUNoaWxkID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudENoaWxkKVxuXG4gICAgICBjb25zdCBleGlzdGluZ0NhY2hlTm9kZUNoaWxkID1cbiAgICAgICAgZXhpc3RpbmdTZWdtZW50TWFwQ2hpbGQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gZXhpc3RpbmdTZWdtZW50TWFwQ2hpbGQuZ2V0KHNlZ21lbnRLZXlDaGlsZClcbiAgICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgICBjb25zdCB0YXNrQ2hpbGQgPSBjcmVhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICByb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICBleGlzdGluZ0NhY2hlTm9kZUNoaWxkLFxuICAgICAgICBwcmVmZXRjaERhdGFDaGlsZCxcbiAgICAgICAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkLFxuICAgICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICAgIHNlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICAgICAgKVxuICAgICAgdGFza0NoaWxkcmVuLnNldChwYXJhbGxlbFJvdXRlS2V5LCB0YXNrQ2hpbGQpXG4gICAgICBjb25zdCBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZCA9IHRhc2tDaGlsZC5keW5hbWljUmVxdWVzdFRyZWVcbiAgICAgIGlmIChkeW5hbWljUmVxdWVzdFRyZWVDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBTb21ldGhpbmcgaW4gdGhlIGNoaWxkIHRyZWUgaXMgZHluYW1pYy5cbiAgICAgICAgbmVlZHNEeW5hbWljUmVxdWVzdCA9IHRydWVcbiAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSByb3V0ZXJTdGF0ZUNoaWxkXG4gICAgICB9XG4gICAgICBjb25zdCBuZXdDYWNoZU5vZGVDaGlsZCA9IHRhc2tDaGlsZC5ub2RlXG4gICAgICBpZiAobmV3Q2FjaGVOb2RlQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbmV3U2VnbWVudE1hcENoaWxkOiBDaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgbmV3U2VnbWVudE1hcENoaWxkLnNldChzZWdtZW50S2V5Q2hpbGQsIG5ld0NhY2hlTm9kZUNoaWxkKVxuICAgICAgICBjYWNoZU5vZGVDaGlsZHJlbi5zZXQocGFyYWxsZWxSb3V0ZUtleSwgbmV3U2VnbWVudE1hcENoaWxkKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gU2luY2Ugd2UncmUgaW5zaWRlIGEgbmV3IHJvdXRlIHRyZWUsIHVubGlrZSB0aGVcbiAgICAvLyBgdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uYCBwYXRoLCB0aGUgcm91dGVyIHN0YXRlIG9uIHRoZSBjaGlsZHJlblxuICAgIC8vIHRhc2tzIGlzIGFsd2F5cyB0aGUgc2FtZSBhcyB0aGUgcm91dGVyIHN0YXRlIHdlIHBhc3MgaW4uIFNvIHdlIGRvbid0IG5lZWRcbiAgICAvLyB0byBjbG9uZS9tb2RpZnkgaXQuXG4gICAgcm91dGU6IHJvdXRlclN0YXRlLFxuICAgIG5vZGU6IHtcbiAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgLy8gU2luY2UgdGhpcyBzZWdtZW50IGlzIGFscmVhZHkgZnVsbCwgd2UgZG9uJ3QgbmVlZCB0byB1c2UgdGhlXG4gICAgICAvLyBgcHJlZmV0Y2hSc2NgIGZpZWxkLlxuICAgICAgcnNjLFxuICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICBoZWFkLFxuICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgbG9hZGluZyxcbiAgICAgIHBhcmFsbGVsUm91dGVzOiBjYWNoZU5vZGVDaGlsZHJlbixcbiAgICAgIG5hdmlnYXRlZEF0OiBjYWNoZU5vZGVOYXZpZ2F0ZWRBdCxcbiAgICB9LFxuICAgIGR5bmFtaWNSZXF1ZXN0VHJlZTogbmVlZHNEeW5hbWljUmVxdWVzdFxuICAgICAgPyBwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuKHJvdXRlclN0YXRlLCBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbilcbiAgICAgIDogbnVsbCxcbiAgICBjaGlsZHJlbjogdGFza0NoaWxkcmVuLFxuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gIGJhc2VSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIG5ld0NoaWxkcmVuOiB7IFtwYXJhbGxlbFJvdXRlS2V5OiBzdHJpbmddOiBGbGlnaHRSb3V0ZXJTdGF0ZSB9XG4pOiBGbGlnaHRSb3V0ZXJTdGF0ZSB7XG4gIGNvbnN0IGNsb25lOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9IFtiYXNlUm91dGVyU3RhdGVbMF0sIG5ld0NoaWxkcmVuXVxuICAvLyBCYXNlZCBvbiBlcXVpdmFsZW50IGxvZ2ljIGluIGFwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlLCBidXQgc2hvdWxkXG4gIC8vIGNvbmZpcm0gd2hldGhlciB3ZSBuZWVkIHRvIGNvcHkgYWxsIG9mIHRoZXNlIGZpZWxkcy4gTm90IHN1cmUgdGhlIHNlcnZlclxuICAvLyBldmVyIHNlbmRzLCBlLmcuIHRoZSByZWZldGNoIG1hcmtlci5cbiAgaWYgKDIgaW4gYmFzZVJvdXRlclN0YXRlKSB7XG4gICAgY2xvbmVbMl0gPSBiYXNlUm91dGVyU3RhdGVbMl1cbiAgfVxuICBpZiAoMyBpbiBiYXNlUm91dGVyU3RhdGUpIHtcbiAgICBjbG9uZVszXSA9IGJhc2VSb3V0ZXJTdGF0ZVszXVxuICB9XG4gIGlmICg0IGluIGJhc2VSb3V0ZXJTdGF0ZSkge1xuICAgIGNsb25lWzRdID0gYmFzZVJvdXRlclN0YXRlWzRdXG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIHNwYXduUGVuZGluZ1Rhc2soXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIHJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcHJlZmV0Y2hEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwsXG4gIHByZWZldGNoSGVhZDogSGVhZERhdGEgfCBudWxsLFxuICBpc1ByZWZldGNoSGVhZFBhcnRpYWw6IGJvb2xlYW4sXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0OiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD5cbik6IFNQQU5hdmlnYXRpb25UYXNrIHtcbiAgLy8gQ3JlYXRlIGEgdGFzayB0aGF0IHdpbGwgbGF0ZXIgYmUgZnVsZmlsbGVkIGJ5IGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuXG4gIC8vIENsb25lIHRoZSBwcmVmZXRjaGVkIHJvdXRlIHRyZWUgYW5kIHRoZSBgcmVmZXRjaGAgbWFya2VyIHRvIGl0LiBXZSdsbCBzZW5kXG4gIC8vIHRoaXMgdG8gdGhlIHNlcnZlciBzbyBpdCBrbm93cyB3aGVyZSB0byBzdGFydCByZW5kZXJpbmcuXG4gIGNvbnN0IGR5bmFtaWNSZXF1ZXN0VHJlZSA9IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gICAgcm91dGVyU3RhdGUsXG4gICAgcm91dGVyU3RhdGVbMV1cbiAgKVxuICBkeW5hbWljUmVxdWVzdFRyZWVbM10gPSAncmVmZXRjaCdcblxuICBjb25zdCBuZXdUYXNrOiBUYXNrID0ge1xuICAgIHJvdXRlOiByb3V0ZXJTdGF0ZSxcblxuICAgIC8vIENvcnJlc3BvbmRzIHRvIHRoZSBwYXJ0IG9mIHRoZSByb3V0ZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgb24gdGhlIHNlcnZlci5cbiAgICBub2RlOiBjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlKFxuICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICByb3V0ZXJTdGF0ZSxcbiAgICAgIHByZWZldGNoRGF0YSxcbiAgICAgIHByZWZldGNoSGVhZCxcbiAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgIHNlZ21lbnRQYXRoLFxuICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgKSxcbiAgICAvLyBCZWNhdXNlIHRoaXMgaXMgbm9uLW51bGwsIGFuZCBpdCBnZXRzIHByb3BhZ2F0ZWQgdXAgdGhyb3VnaCB0aGUgcGFyZW50XG4gICAgLy8gdGFza3MsIHRoZSByb290IHRhc2sgd2lsbCBrbm93IHRoYXQgaXQgbmVlZHMgdG8gcGVyZm9ybSBhIHNlcnZlciByZXF1ZXN0LlxuICAgIGR5bmFtaWNSZXF1ZXN0VHJlZSxcbiAgICBjaGlsZHJlbjogbnVsbCxcbiAgfVxuICByZXR1cm4gbmV3VGFza1xufVxuXG5mdW5jdGlvbiBzcGF3blJldXNlZFRhc2socmV1c2VkUm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlKTogVGFzayB7XG4gIC8vIENyZWF0ZSBhIHRhc2sgdGhhdCByZXVzZXMgYW4gZXhpc3Rpbmcgc2VnbWVudCwgZS5nLiB3aGVuIHJldXNpbmdcbiAgLy8gdGhlIGN1cnJlbnQgYWN0aXZlIHNlZ21lbnQgaW4gcGxhY2Ugb2YgYSBkZWZhdWx0IHJvdXRlLlxuICByZXR1cm4ge1xuICAgIHJvdXRlOiByZXVzZWRSb3V0ZXJTdGF0ZSxcbiAgICBub2RlOiBudWxsLFxuICAgIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbCxcbiAgICBjaGlsZHJlbjogbnVsbCxcbiAgfVxufVxuXG4vLyBXcml0ZXMgYSBkeW5hbWljIHNlcnZlciByZXNwb25zZSBpbnRvIHRoZSB0cmVlIGNyZWF0ZWQgYnlcbi8vIHVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbi4gQWxsIHBlbmRpbmcgcHJvbWlzZXMgdGhhdCB3ZXJlIHNwYXduZWQgYnkgdGhlXG4vLyBuYXZpZ2F0aW9uIHdpbGwgYmUgcmVzb2x2ZWQsIGVpdGhlciB3aXRoIGR5bmFtaWMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIG9yXG4vLyBgbnVsbGAgdG8gaW5kaWNhdGUgdGhhdCB0aGUgZGF0YSBpcyBtaXNzaW5nLlxuLy9cbi8vIEEgYG51bGxgIHZhbHVlIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2ggZHVyaW5nIHJlbmRlciwgd2hpY2ggd2lsbCB0aGVuIHBhdGNoXG4vLyB1cCB0aGUgdHJlZSB1c2luZyB0aGUgc2FtZSBtZWNoYW5pc20gYXMgdGhlIG5vbi1QUFIgaW1wbGVtZW50YXRpb25cbi8vIChzZXJ2ZXJQYXRjaFJlZHVjZXIpLlxuLy9cbi8vIFVzdWFsbHksIHRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGggZXhhY3RseSB0aGUgc3Vic2V0IG9mIGRhdGEgdGhhdCB3ZSdyZVxuLy8gd2FpdGluZyBmb3Ig4oCUIGV2ZXJ5dGhpbmcgYmVsb3cgdGhlIG5lYXJlc3Qgc2hhcmVkIGxheW91dC4gQnV0IHRlY2huaWNhbGx5LFxuLy8gdGhlIHNlcnZlciBjYW4gcmV0dXJuIGFueXRoaW5nIGl0IHdhbnRzLlxuLy9cbi8vIFRoaXMgZG9lcyBfbm90XyBjcmVhdGUgYSBuZXcgdHJlZTsgaXQgbW9kaWZpZXMgdGhlIGV4aXN0aW5nIG9uZSBpbiBwbGFjZS5cbi8vIFdoaWNoIG1lYW5zIGl0IG11c3QgZm9sbG93IHRoZSBTdXNwZW5zZSBydWxlcyBvZiBjYWNoZSBzYWZldHkuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QoXG4gIHRhc2s6IFNQQU5hdmlnYXRpb25UYXNrLFxuICByZXNwb25zZVByb21pc2U6IFByb21pc2U8RmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdD5cbikge1xuICByZXNwb25zZVByb21pc2UudGhlbihcbiAgICAoeyBmbGlnaHREYXRhIH06IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSGFwcGVucyB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGAuIFdlIHNob3VsZG4ndFxuICAgICAgICAvLyBnZXQgaGVyZSBiZWNhdXNlIHNob3VsZCBoYXZlIGFscmVhZHkgaGFuZGxlZCB0aGlzIGR1cmluZ1xuICAgICAgICAvLyB0aGUgcHJlZmV0Y2guXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZWdtZW50UGF0aCxcbiAgICAgICAgICB0cmVlOiBzZXJ2ZXJSb3V0ZXJTdGF0ZSxcbiAgICAgICAgICBzZWVkRGF0YTogZHluYW1pY0RhdGEsXG4gICAgICAgICAgaGVhZDogZHluYW1pY0hlYWQsXG4gICAgICAgIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YVxuXG4gICAgICAgIGlmICghZHluYW1pY0RhdGEpIHtcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4uIFBQUiBzaG91bGQgYWx3YXlzIHNlbmQgYmFjayBhIHJlc3BvbnNlLlxuICAgICAgICAgIC8vIEhvd2V2ZXIsIGBGbGlnaHREYXRhUGF0aGAgaXMgYSBzaGFyZWQgdHlwZSBhbmQgdGhlIHByZS1QUFIgaGFuZGxpbmcgb2ZcbiAgICAgICAgICAvLyB0aGlzIG1pZ2h0IHJldHVybiBudWxsLlxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICB3cml0ZUR5bmFtaWNEYXRhSW50b1BlbmRpbmdUYXNrKFxuICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgc2VnbWVudFBhdGgsXG4gICAgICAgICAgc2VydmVyUm91dGVyU3RhdGUsXG4gICAgICAgICAgZHluYW1pY0RhdGEsXG4gICAgICAgICAgZHluYW1pY0hlYWRcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBOb3cgdGhhdCB3ZSd2ZSBleGhhdXN0ZWQgYWxsIHRoZSBkYXRhIHdlIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciwgaWZcbiAgICAgIC8vIHRoZXJlIGFyZSBhbnkgcmVtYWluaW5nIHBlbmRpbmcgdGFza3MgaW4gdGhlIHRyZWUsIGFib3J0IHRoZW0gbm93LlxuICAgICAgLy8gSWYgdGhlcmUncyBhbnkgbWlzc2luZyBkYXRhLCBpdCB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoLlxuICAgICAgYWJvcnRUYXNrKHRhc2ssIG51bGwpXG4gICAgfSxcbiAgICAoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYW4gZXJyb3IgZHVyaW5nIHJlbmRlclxuICAgICAgYWJvcnRUYXNrKHRhc2ssIGVycm9yKVxuICAgIH1cbiAgKVxufVxuXG5mdW5jdGlvbiB3cml0ZUR5bmFtaWNEYXRhSW50b1BlbmRpbmdUYXNrKFxuICByb290VGFzazogU1BBTmF2aWdhdGlvblRhc2ssXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2VydmVyUm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBkeW5hbWljRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEsXG4gIGR5bmFtaWNIZWFkOiBIZWFkRGF0YVxuKSB7XG4gIC8vIFRoZSBkYXRhIHNlbnQgYnkgdGhlIHNlcnZlciByZXByZXNlbnRzIG9ubHkgYSBzdWJ0cmVlIG9mIHRoZSBhcHAuIFdlIG5lZWRcbiAgLy8gdG8gZmluZCB0aGUgcGFydCBvZiB0aGUgdGFzayB0cmVlIHRoYXQgbWF0Y2hlcyB0aGUgc2VydmVyIHJlc3BvbnNlLCBhbmRcbiAgLy8gZnVsZmlsbCBpdCB1c2luZyB0aGUgZHluYW1pYyBkYXRhLlxuICAvL1xuICAvLyBzZWdtZW50UGF0aCByZXByZXNlbnRzIHRoZSBwYXJlbnQgcGF0aCBvZiBzdWJ0cmVlLiBJdCdzIGEgcmVwZWF0aW5nIHBhdHRlcm5cbiAgLy8gb2YgcGFyYWxsZWwgcm91dGUga2V5IGFuZCBzZWdtZW50OlxuICAvL1xuICAvLyAgIFtzdHJpbmcsIFNlZ21lbnQsIHN0cmluZywgU2VnbWVudCwgc3RyaW5nLCBTZWdtZW50LCAuLi5dXG4gIC8vXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcGF0aCBhbmQgZmluaXNoIGFueSB0YXNrcyB0aGF0IG1hdGNoIHRoaXMgcGF5bG9hZC5cbiAgbGV0IHRhc2sgPSByb290VGFza1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRQYXRoLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nID0gc2VnbWVudFBhdGhbaV1cbiAgICBjb25zdCBzZWdtZW50OiBTZWdtZW50ID0gc2VnbWVudFBhdGhbaSArIDFdXG4gICAgY29uc3QgdGFza0NoaWxkcmVuID0gdGFzay5jaGlsZHJlblxuICAgIGlmICh0YXNrQ2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRhc2tDaGlsZCA9IHRhc2tDaGlsZHJlbi5nZXQocGFyYWxsZWxSb3V0ZUtleSlcbiAgICAgIGlmICh0YXNrQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YXNrU2VnbWVudCA9IHRhc2tDaGlsZC5yb3V0ZVswXVxuICAgICAgICBpZiAobWF0Y2hTZWdtZW50KHNlZ21lbnQsIHRhc2tTZWdtZW50KSkge1xuICAgICAgICAgIC8vIEZvdW5kIGEgbWF0Y2ggZm9yIHRoaXMgdGFzay4gS2VlcCB0cmF2ZXJzaW5nIGRvd24gdGhlIHRhc2sgdHJlZS5cbiAgICAgICAgICB0YXNrID0gdGFza0NoaWxkXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBkaWRuJ3QgZmluZCBhIGNoaWxkIHRhc2sgdGhhdCBtYXRjaGVzIHRoZSBzZXJ2ZXIgZGF0YS4gRXhpdC4gV2Ugd29uJ3RcbiAgICAvLyBhYm9ydCB0aGUgdGFzaywgdGhvdWdoLCBiZWNhdXNlIGEgZGlmZmVyZW50IEZsaWdodERhdGFQYXRoIG1heSBiZSBhYmxlIHRvXG4gICAgLy8gZnVsZmlsbCBpdCAoc2VlIGxvb3AgaW4gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QpLiBXZSBvbmx5IGFib3J0IHRhc2tzXG4gICAgLy8gb25jZSB3ZSd2ZSBydW4gb3V0IG9mIGRhdGEuXG4gICAgcmV0dXJuXG4gIH1cblxuICBmaW5pc2hUYXNrVXNpbmdEeW5hbWljRGF0YVBheWxvYWQoXG4gICAgdGFzayxcbiAgICBzZXJ2ZXJSb3V0ZXJTdGF0ZSxcbiAgICBkeW5hbWljRGF0YSxcbiAgICBkeW5hbWljSGVhZFxuICApXG59XG5cbmZ1bmN0aW9uIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZChcbiAgdGFzazogU1BBTmF2aWdhdGlvblRhc2ssXG4gIHNlcnZlclJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZHluYW1pY0RhdGE6IENhY2hlTm9kZVNlZWREYXRhLFxuICBkeW5hbWljSGVhZDogSGVhZERhdGFcbikge1xuICBpZiAodGFzay5keW5hbWljUmVxdWVzdFRyZWUgPT09IG51bGwpIHtcbiAgICAvLyBFdmVyeXRoaW5nIGluIHRoaXMgc3VidHJlZSBpcyBhbHJlYWR5IGNvbXBsZXRlLiBCYWlsIG91dC5cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGR5bmFtaWNEYXRhIG1heSByZXByZXNlbnQgYSBsYXJnZXIgc3VidHJlZSB0aGFuIHRoZSB0YXNrLiBCZWZvcmUgd2UgY2FuXG4gIC8vIGZpbmlzaCB0aGUgdGFzaywgd2UgbmVlZCB0byBsaW5lIHRoZW0gdXAuXG4gIGNvbnN0IHRhc2tDaGlsZHJlbiA9IHRhc2suY2hpbGRyZW5cbiAgY29uc3QgdGFza05vZGUgPSB0YXNrLm5vZGVcbiAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGxlYWYgbm9kZSBvZiB0aGUgcGVuZGluZyB0YXNrLiBUaGUgc2VydmVyIGRhdGEgdHJlZVxuICAgIC8vIGxpbmVzIHVwIHRoZSBwZW5kaW5nIENhY2hlIE5vZGUgdHJlZS4gV2UgY2FuIG5vdyBzd2l0Y2ggdG8gdGhlXG4gICAgLy8gbm9ybWFsIGFsZ29yaXRobS5cbiAgICBpZiAodGFza05vZGUgIT09IG51bGwpIHtcbiAgICAgIGZpbmlzaFBlbmRpbmdDYWNoZU5vZGUoXG4gICAgICAgIHRhc2tOb2RlLFxuICAgICAgICB0YXNrLnJvdXRlLFxuICAgICAgICBzZXJ2ZXJSb3V0ZXJTdGF0ZSxcbiAgICAgICAgZHluYW1pY0RhdGEsXG4gICAgICAgIGR5bmFtaWNIZWFkXG4gICAgICApXG4gICAgICAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoYXQgdGhpcyB0YXNrIGlzIG5vdyBjb21wbGV0ZS5cbiAgICAgIHRhc2suZHluYW1pY1JlcXVlc3RUcmVlID0gbnVsbFxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICAvLyBUaGUgc2VydmVyIHJldHVybmVkIG1vcmUgZGF0YSB0aGFuIHdlIG5lZWQgdG8gZmluaXNoIHRoZSB0YXNrLiBTa2lwIG92ZXJcbiAgLy8gdGhlIGV4dHJhIHNlZ21lbnRzIHVudGlsIHdlIHJlYWNoIHRoZSBsZWFmIHRhc2sgbm9kZS5cbiAgY29uc3Qgc2VydmVyQ2hpbGRyZW4gPSBzZXJ2ZXJSb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBkeW5hbWljRGF0YUNoaWxkcmVuID0gZHluYW1pY0RhdGFbMl1cblxuICBmb3IgKGNvbnN0IHBhcmFsbGVsUm91dGVLZXkgaW4gc2VydmVyUm91dGVyU3RhdGUpIHtcbiAgICBjb25zdCBzZXJ2ZXJSb3V0ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9XG4gICAgICBzZXJ2ZXJDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IGR5bmFtaWNEYXRhQ2hpbGQ6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCB8IHZvaWQgPVxuICAgICAgZHluYW1pY0RhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuXG4gICAgY29uc3QgdGFza0NoaWxkID0gdGFza0NoaWxkcmVuLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgIGlmICh0YXNrQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdGFza1NlZ21lbnQgPSB0YXNrQ2hpbGQucm91dGVbMF1cbiAgICAgIGlmIChcbiAgICAgICAgbWF0Y2hTZWdtZW50KHNlcnZlclJvdXRlclN0YXRlQ2hpbGRbMF0sIHRhc2tTZWdtZW50KSAmJlxuICAgICAgICBkeW5hbWljRGF0YUNoaWxkICE9PSBudWxsICYmXG4gICAgICAgIGR5bmFtaWNEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZFxuICAgICAgKSB7XG4gICAgICAgIC8vIEZvdW5kIGEgbWF0Y2ggZm9yIHRoaXMgdGFzay4gS2VlcCB0cmF2ZXJzaW5nIGRvd24gdGhlIHRhc2sgdHJlZS5cbiAgICAgICAgcmV0dXJuIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZChcbiAgICAgICAgICB0YXNrQ2hpbGQsXG4gICAgICAgICAgc2VydmVyUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgICBkeW5hbWljRGF0YUNoaWxkLFxuICAgICAgICAgIGR5bmFtaWNIZWFkXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgZGlkbid0IGZpbmQgYSBjaGlsZCB0YXNrIHRoYXQgbWF0Y2hlcyB0aGUgc2VydmVyIGRhdGEuIFdlIHdvbid0IGFib3J0XG4gICAgLy8gdGhlIHRhc2ssIHRob3VnaCwgYmVjYXVzZSBhIGRpZmZlcmVudCBGbGlnaHREYXRhUGF0aCBtYXkgYmUgYWJsZSB0b1xuICAgIC8vIGZ1bGZpbGwgaXQgKHNlZSBsb29wIGluIGxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0KS4gV2Ugb25seSBhYm9ydCB0YXNrc1xuICAgIC8vIG9uY2Ugd2UndmUgcnVuIG91dCBvZiBkYXRhLlxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdDYWNoZU5vZGUoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIHJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcHJlZmV0Y2hEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwsXG4gIHByZWZldGNoSGVhZDogSGVhZERhdGEgfCBudWxsLFxuICBpc1ByZWZldGNoSGVhZFBhcnRpYWw6IGJvb2xlYW4sXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0OiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD5cbik6IFJlYWR5Q2FjaGVOb2RlIHtcbiAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZHJlbiA9IHJvdXRlclN0YXRlWzFdXG4gIGNvbnN0IHByZWZldGNoRGF0YUNoaWxkcmVuID0gcHJlZmV0Y2hEYXRhICE9PSBudWxsID8gcHJlZmV0Y2hEYXRhWzJdIDogbnVsbFxuXG4gIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gbmV3IE1hcCgpXG4gIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gcm91dGVyU3RhdGVDaGlsZHJlbikge1xuICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlID1cbiAgICAgIHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBwcmVmZXRjaERhdGFDaGlsZDogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsIHwgdm9pZCA9XG4gICAgICBwcmVmZXRjaERhdGFDaGlsZHJlbiAhPT0gbnVsbFxuICAgICAgICA/IHByZWZldGNoRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICAgIDogbnVsbFxuXG4gICAgY29uc3Qgc2VnbWVudENoaWxkID0gcm91dGVyU3RhdGVDaGlsZFswXVxuICAgIGNvbnN0IHNlZ21lbnRQYXRoQ2hpbGQgPSBzZWdtZW50UGF0aC5jb25jYXQoW1xuICAgICAgcGFyYWxsZWxSb3V0ZUtleSxcbiAgICAgIHNlZ21lbnRDaGlsZCxcbiAgICBdKVxuICAgIGNvbnN0IHNlZ21lbnRLZXlDaGlsZCA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnRDaGlsZClcblxuICAgIGNvbnN0IG5ld0NhY2hlTm9kZUNoaWxkID0gY3JlYXRlUGVuZGluZ0NhY2hlTm9kZShcbiAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgcm91dGVyU3RhdGVDaGlsZCxcbiAgICAgIHByZWZldGNoRGF0YUNoaWxkID09PSB1bmRlZmluZWQgPyBudWxsIDogcHJlZmV0Y2hEYXRhQ2hpbGQsXG4gICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICBzZWdtZW50UGF0aENoaWxkLFxuICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgKVxuXG4gICAgY29uc3QgbmV3U2VnbWVudE1hcENoaWxkOiBDaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKClcbiAgICBuZXdTZWdtZW50TWFwQ2hpbGQuc2V0KHNlZ21lbnRLZXlDaGlsZCwgbmV3Q2FjaGVOb2RlQ2hpbGQpXG4gICAgcGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZClcbiAgfVxuXG4gIC8vIFRoZSBoZWFkIGlzIGFzc2lnbmVkIHRvIGV2ZXJ5IGxlYWYgc2VnbWVudCBkZWxpdmVyZWQgYnkgdGhlIHNlcnZlci4gQmFzZWRcbiAgLy8gb24gY29ycmVzcG9uZGluZyBsb2dpYyBpbiBmaWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZC50c1xuICBjb25zdCBpc0xlYWZTZWdtZW50ID0gcGFyYWxsZWxSb3V0ZXMuc2l6ZSA9PT0gMFxuXG4gIGlmIChpc0xlYWZTZWdtZW50KSB7XG4gICAgLy8gVGhlIHNlZ21lbnQgcGF0aCBvZiBldmVyeSBsZWFmIHNlZ21lbnQgKGkuZS4gcGFnZSkgaXMgY29sbGVjdGVkIGludG9cbiAgICAvLyBhIHJlc3VsdCBhcnJheS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBMYXlvdXRSb3V0ZXIgdG8gc2Nyb2xsIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gbmV3IHBhZ2VzIGFyZSB2aXNpYmxlIGFmdGVyIGEgbmF2aWdhdGlvbi5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgdXNlIGEgc3RyaW5nIHRvIHJlcHJlc2VudCB0aGUgc2VnbWVudCBwYXRoIGluc3RlYWQgb2ZcbiAgICAvLyBhbiBhcnJheS4gV2UgYWxyZWFkeSB1c2UgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIHRoZSBwYXRoIHdoZW5cbiAgICAvLyBhY2Nlc3NpbmcgdGhlIFNlZ21lbnQgQ2FjaGUsIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgb25lLlxuICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdC5wdXNoKHNlZ21lbnRQYXRoKVxuICB9XG5cbiAgY29uc3QgbWF5YmVQcmVmZXRjaFJzYyA9IHByZWZldGNoRGF0YSAhPT0gbnVsbCA/IHByZWZldGNoRGF0YVsxXSA6IG51bGxcbiAgY29uc3QgbWF5YmVQcmVmZXRjaExvYWRpbmcgPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbM10gOiBudWxsXG4gIHJldHVybiB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcGFyYWxsZWxSb3V0ZXM6IHBhcmFsbGVsUm91dGVzLFxuXG4gICAgcHJlZmV0Y2hSc2M6IG1heWJlUHJlZmV0Y2hSc2MgIT09IHVuZGVmaW5lZCA/IG1heWJlUHJlZmV0Y2hSc2MgOiBudWxsLFxuICAgIHByZWZldGNoSGVhZDogaXNMZWFmU2VnbWVudCA/IHByZWZldGNoSGVhZCA6IFtudWxsLCBudWxsXSxcblxuICAgIC8vIFRPRE86IFRlY2huaWNhbGx5LCBhIGxvYWRpbmcgYm91bmRhcnkgY291bGQgY29udGFpbiBkeW5hbWljIGRhdGEuIFdlIG11c3RcbiAgICAvLyBoYXZlIHNlcGFyYXRlIGBsb2FkaW5nYCBhbmQgYHByZWZldGNoTG9hZGluZ2AgZmllbGRzIHRvIGhhbmRsZSB0aGlzLCBsaWtlXG4gICAgLy8gd2UgZG8gZm9yIHRoZSBzZWdtZW50IGRhdGEgYW5kIGhlYWQuXG4gICAgbG9hZGluZzogbWF5YmVQcmVmZXRjaExvYWRpbmcgIT09IHVuZGVmaW5lZCA/IG1heWJlUHJlZmV0Y2hMb2FkaW5nIDogbnVsbCxcblxuICAgIC8vIENyZWF0ZSBhIGRlZmVycmVkIHByb21pc2UuIFRoaXMgd2lsbCBiZSBmdWxmaWxsZWQgb25jZSB0aGUgZHluYW1pY1xuICAgIC8vIHJlc3BvbnNlIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICByc2M6IGNyZWF0ZURlZmVycmVkUnNjKCkgYXMgUmVhY3QuUmVhY3ROb2RlLFxuICAgIGhlYWQ6IGlzTGVhZlNlZ21lbnQgPyAoY3JlYXRlRGVmZXJyZWRSc2MoKSBhcyBSZWFjdC5SZWFjdE5vZGUpIDogbnVsbCxcblxuICAgIG5hdmlnYXRlZEF0LFxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaFBlbmRpbmdDYWNoZU5vZGUoXG4gIGNhY2hlTm9kZTogQ2FjaGVOb2RlLFxuICB0YXNrU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBzZXJ2ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIGR5bmFtaWNEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSxcbiAgZHluYW1pY0hlYWQ6IEhlYWREYXRhXG4pOiB2b2lkIHtcbiAgLy8gV3JpdGVzIGEgZHluYW1pYyByZXNwb25zZSBpbnRvIGFuIGV4aXN0aW5nIENhY2hlIE5vZGUgdHJlZS4gVGhpcyBkb2VzIF9ub3RfXG4gIC8vIGNyZWF0ZSBhIG5ldyB0cmVlLCBpdCB1cGRhdGVzIHRoZSBleGlzdGluZyB0cmVlIGluLXBsYWNlLiBTbyBpdCBtdXN0IGZvbGxvd1xuICAvLyB0aGUgU3VzcGVuc2UgcnVsZXMgb2YgY2FjaGUgc2FmZXR5IOKAlCBpdCBjYW4gcmVzb2x2ZSBwZW5kaW5nIHByb21pc2VzLCBidXRcbiAgLy8gaXQgY2Fubm90IG92ZXJ3cml0ZSBleGlzdGluZyBkYXRhLiBJdCBjYW4gYWRkIHNlZ21lbnRzIHRvIHRoZSB0cmVlIChiZWNhdXNlXG4gIC8vIGEgbWlzc2luZyBzZWdtZW50IHdpbGwgY2F1c2UgdGhlIGxheW91dCByb3V0ZXIgdG8gc3VzcGVuZCkuXG4gIC8vIGJ1dCBpdCBjYW5ub3QgZGVsZXRlIHRoZW0uXG4gIC8vXG4gIC8vIFdlIG11c3QgcmVzb2x2ZSBldmVyeSBwcm9taXNlIGluIHRoZSB0cmVlLCBvciBlbHNlIGl0IHdpbGwgc3VzcGVuZFxuICAvLyBpbmRlZmluaXRlbHkuIElmIHdlIGRpZCBub3QgcmVjZWl2ZSBkYXRhIGZvciBhIHNlZ21lbnQsIHdlIHdpbGwgcmVzb2x2ZSBpdHNcbiAgLy8gZGF0YSBwcm9taXNlIHRvIGBudWxsYCB0byB0cmlnZ2VyIGEgbGF6eSBmZXRjaCBkdXJpbmcgcmVuZGVyLlxuICBjb25zdCB0YXNrU3RhdGVDaGlsZHJlbiA9IHRhc2tTdGF0ZVsxXVxuICBjb25zdCBzZXJ2ZXJTdGF0ZUNoaWxkcmVuID0gc2VydmVyU3RhdGVbMV1cbiAgY29uc3QgZGF0YUNoaWxkcmVuID0gZHluYW1pY0RhdGFbMl1cblxuICAvLyBUaGUgcm91dGVyIHN0YXRlIHRoYXQgd2UgdHJhdmVyc2UgdGhlIHRyZWUgd2l0aCAodGFza1N0YXRlKSBpcyB0aGUgc2FtZSBvbmVcbiAgLy8gdGhhdCB3ZSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcGVuZGluZyBDYWNoZSBOb2RlIHRyZWUuIFRoYXQgd2F5IHdlJ3JlIHN1cmVcbiAgLy8gdG8gcmVzb2x2ZSBhbGwgdGhlIHBlbmRpbmcgcHJvbWlzZXMuXG4gIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gY2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzXG4gIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gdGFza1N0YXRlQ2hpbGRyZW4pIHtcbiAgICBjb25zdCB0YXNrU3RhdGVDaGlsZDogRmxpZ2h0Um91dGVyU3RhdGUgPVxuICAgICAgdGFza1N0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBzZXJ2ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IHZvaWQgPVxuICAgICAgc2VydmVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IGRhdGFDaGlsZDogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsIHwgdm9pZCA9XG4gICAgICBkYXRhQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cblxuICAgIGNvbnN0IHNlZ21lbnRNYXBDaGlsZCA9IHBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgIGNvbnN0IHRhc2tTZWdtZW50Q2hpbGQgPSB0YXNrU3RhdGVDaGlsZFswXVxuICAgIGNvbnN0IHRhc2tTZWdtZW50S2V5Q2hpbGQgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleSh0YXNrU2VnbWVudENoaWxkKVxuXG4gICAgY29uc3QgY2FjaGVOb2RlQ2hpbGQgPVxuICAgICAgc2VnbWVudE1hcENoaWxkICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBzZWdtZW50TWFwQ2hpbGQuZ2V0KHRhc2tTZWdtZW50S2V5Q2hpbGQpXG4gICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICBpZiAoY2FjaGVOb2RlQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKFxuICAgICAgICBzZXJ2ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgbWF0Y2hTZWdtZW50KHRhc2tTZWdtZW50Q2hpbGQsIHNlcnZlclN0YXRlQ2hpbGRbMF0pXG4gICAgICApIHtcbiAgICAgICAgaWYgKGRhdGFDaGlsZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGhhcHB5IHBhdGguIFJlY3Vyc2l2ZWx5IHVwZGF0ZSBhbGwgdGhlIGNoaWxkcmVuLlxuICAgICAgICAgIGZpbmlzaFBlbmRpbmdDYWNoZU5vZGUoXG4gICAgICAgICAgICBjYWNoZU5vZGVDaGlsZCxcbiAgICAgICAgICAgIHRhc2tTdGF0ZUNoaWxkLFxuICAgICAgICAgICAgc2VydmVyU3RhdGVDaGlsZCxcbiAgICAgICAgICAgIGRhdGFDaGlsZCxcbiAgICAgICAgICAgIGR5bmFtaWNIZWFkXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSBzZXJ2ZXIgbmV2ZXIgcmV0dXJuZWQgZGF0YSBmb3IgdGhpcyBzZWdtZW50LiBUcmlnZ2VyIGEgbGF6eVxuICAgICAgICAgIC8vIGZldGNoIGR1cmluZyByZW5kZXIuIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHRoZSBSb3V0ZSBUcmVlXG4gICAgICAgICAgLy8gYW5kIHRoZSBTZWVkIERhdGEgdHJlZSBzZW50IGJ5IHRoZSBzZXJ2ZXIgc2hvdWxkIGFsd2F5cyBiZSB0aGUgc2FtZVxuICAgICAgICAgIC8vIHNoYXBlIHdoZW4gcGFydCBvZiB0aGUgc2FtZSBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgICAgICAgYWJvcnRQZW5kaW5nQ2FjaGVOb2RlKHRhc2tTdGF0ZUNoaWxkLCBjYWNoZU5vZGVDaGlsZCwgbnVsbClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHNlcnZlciBuZXZlciByZXR1cm5lZCBkYXRhIGZvciB0aGlzIHNlZ21lbnQuIFRyaWdnZXIgYSBsYXp5XG4gICAgICAgIC8vIGZldGNoIGR1cmluZyByZW5kZXIuXG4gICAgICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZSh0YXNrU3RhdGVDaGlsZCwgY2FjaGVOb2RlQ2hpbGQsIG51bGwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBzZXJ2ZXIgcmVzcG9uc2UgbWF0Y2hlcyB3aGF0IHdhcyBleHBlY3RlZCB0byByZWNlaXZlLCBidXQgdGhlcmUnc1xuICAgICAgLy8gbm8gbWF0Y2hpbmcgQ2FjaGUgTm9kZSBpbiB0aGUgdGFzayB0cmVlLiBUaGlzIGlzIGEgYnVnIGluIHRoZVxuICAgICAgLy8gaW1wbGVtZW50YXRpb24gYmVjYXVzZSB3ZSBzaG91bGQgaGF2ZSBjcmVhdGVkIGEgbm9kZSBmb3IgZXZlcnlcbiAgICAgIC8vIHNlZ21lbnQgaW4gdGhlIHRyZWUgdGhhdCdzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRhc2suXG4gICAgfVxuICB9XG5cbiAgLy8gVXNlIHRoZSBkeW5hbWljIGRhdGEgZnJvbSB0aGUgc2VydmVyIHRvIGZ1bGZpbGwgdGhlIGRlZmVycmVkIFJTQyBwcm9taXNlXG4gIC8vIG9uIHRoZSBDYWNoZSBOb2RlLlxuICBjb25zdCByc2MgPSBjYWNoZU5vZGUucnNjXG4gIGNvbnN0IGR5bmFtaWNTZWdtZW50RGF0YSA9IGR5bmFtaWNEYXRhWzFdXG4gIGlmIChyc2MgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgbGF6eSBjYWNoZSBub2RlLiBXZSBjYW4gb3ZlcndyaXRlIGl0LiBUaGlzIGlzIG9ubHkgc2FmZVxuICAgIC8vIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHRoZSBMYXlvdXRSb3V0ZXIgc3VzcGVuZHMgaWYgYHJzY2AgaXMgYG51bGxgLlxuICAgIGNhY2hlTm9kZS5yc2MgPSBkeW5hbWljU2VnbWVudERhdGFcbiAgfSBlbHNlIGlmIChpc0RlZmVycmVkUnNjKHJzYykpIHtcbiAgICAvLyBUaGlzIGlzIGEgZGVmZXJyZWQgUlNDIHByb21pc2UuIFdlIGNhbiBmdWxmaWxsIGl0IHdpdGggdGhlIGRhdGEgd2UganVzdFxuICAgIC8vIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci4gSWYgaXQgd2FzIGFscmVhZHkgcmVzb2x2ZWQgYnkgYSBkaWZmZXJlbnRcbiAgICAvLyBuYXZpZ2F0aW9uLCB0aGVuIHRoaXMgZG9lcyBub3RoaW5nIGJlY2F1c2Ugd2UgY2FuJ3Qgb3ZlcndyaXRlIGRhdGEuXG4gICAgcnNjLnJlc29sdmUoZHluYW1pY1NlZ21lbnREYXRhKVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgbm90IGEgZGVmZXJyZWQgUlNDIHByb21pc2UsIG5vciBpcyBpdCBlbXB0eSwgc28gaXQgbXVzdCBoYXZlXG4gICAgLy8gYmVlbiBwb3B1bGF0ZWQgYnkgYSBkaWZmZXJlbnQgbmF2aWdhdGlvbi4gV2UgbXVzdCBub3Qgb3ZlcndyaXRlIGl0LlxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGxlYWYgc2VnbWVudC4gSWYgc28sIGl0IHdpbGwgaGF2ZSBhIGBoZWFkYCBwcm9wZXJ0eSB3aXRoXG4gIC8vIGEgcGVuZGluZyBwcm9taXNlIHRoYXQgbmVlZHMgdG8gYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZHluYW1pYyBoZWFkIGZyb21cbiAgLy8gdGhlIHNlcnZlci5cbiAgY29uc3QgaGVhZCA9IGNhY2hlTm9kZS5oZWFkXG4gIGlmIChpc0RlZmVycmVkUnNjKGhlYWQpKSB7XG4gICAgaGVhZC5yZXNvbHZlKGR5bmFtaWNIZWFkKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydFRhc2sodGFzazogU1BBTmF2aWdhdGlvblRhc2ssIGVycm9yOiBhbnkpOiB2b2lkIHtcbiAgY29uc3QgY2FjaGVOb2RlID0gdGFzay5ub2RlXG4gIGlmIChjYWNoZU5vZGUgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGluZGljYXRlcyB0aGUgdGFzayBpcyBhbHJlYWR5IGNvbXBsZXRlLlxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgdGFza0NoaWxkcmVuID0gdGFzay5jaGlsZHJlblxuICBpZiAodGFza0NoaWxkcmVuID09PSBudWxsKSB7XG4gICAgLy8gUmVhY2hlZCB0aGUgbGVhZiB0YXNrIG5vZGUuIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYSBwZW5kaW5nIGNhY2hlXG4gICAgLy8gbm9kZSB0cmVlLlxuICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZSh0YXNrLnJvdXRlLCBjYWNoZU5vZGUsIGVycm9yKVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJtZWRpYXRlIHRhc2sgbm9kZS4gS2VlcCB0cmF2ZXJzaW5nIHVudGlsIHdlIHJlYWNoIGFcbiAgICAvLyB0YXNrIG5vZGUgd2l0aCBubyBjaGlsZHJlbi4gVGhhdCB3aWxsIGJlIHRoZSByb290IG9mIHRoZSBjYWNoZSBub2RlIHRyZWVcbiAgICAvLyB0aGF0IG5lZWRzIHRvIGJlIHJlc29sdmVkLlxuICAgIGZvciAoY29uc3QgdGFza0NoaWxkIG9mIHRhc2tDaGlsZHJlbi52YWx1ZXMoKSkge1xuICAgICAgYWJvcnRUYXNrKHRhc2tDaGlsZCwgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IHRoaXMgdG8gbnVsbCB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgdGFzayBpcyBub3cgY29tcGxldGUuXG4gIHRhc2suZHluYW1pY1JlcXVlc3RUcmVlID0gbnVsbFxufVxuXG5mdW5jdGlvbiBhYm9ydFBlbmRpbmdDYWNoZU5vZGUoXG4gIHJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgY2FjaGVOb2RlOiBDYWNoZU5vZGUsXG4gIGVycm9yOiBhbnlcbik6IHZvaWQge1xuICAvLyBGb3IgZXZlcnkgcGVuZGluZyBzZWdtZW50IGluIHRoZSB0cmVlLCByZXNvbHZlIGl0cyBgcnNjYCBwcm9taXNlIHRvIGBudWxsYFxuICAvLyB0byB0cmlnZ2VyIGEgbGF6eSBmZXRjaCBkdXJpbmcgcmVuZGVyLlxuICAvL1xuICAvLyBPciwgaWYgYW4gZXJyb3Igb2JqZWN0IGlzIHByb3ZpZGVkLCBpdCB3aWxsIGVycm9yIGluc3RlYWQuXG4gIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBwYXJhbGxlbFJvdXRlcyA9IGNhY2hlTm9kZS5wYXJhbGxlbFJvdXRlc1xuICBmb3IgKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHJvdXRlclN0YXRlQ2hpbGRyZW4pIHtcbiAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9XG4gICAgICByb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgY29uc3Qgc2VnbWVudE1hcENoaWxkID0gcGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgaWYgKHNlZ21lbnRNYXBDaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB3ZSdyZSB0cmF2ZXJzaW5nIHRoZSBzYW1lIHRyZWUgdGhhdCB3YXNcbiAgICAgIC8vIHVzZWQgdG8gY29uc3RydWN0IHRoZSBjYWNoZSBub2RlcyBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBjb25zdCBzZWdtZW50Q2hpbGQgPSByb3V0ZXJTdGF0ZUNoaWxkWzBdXG4gICAgY29uc3Qgc2VnbWVudEtleUNoaWxkID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudENoaWxkKVxuICAgIGNvbnN0IGNhY2hlTm9kZUNoaWxkID0gc2VnbWVudE1hcENoaWxkLmdldChzZWdtZW50S2V5Q2hpbGQpXG4gICAgaWYgKGNhY2hlTm9kZUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZShyb3V0ZXJTdGF0ZUNoaWxkLCBjYWNoZU5vZGVDaGlsZCwgZXJyb3IpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHdlJ3JlIHRyYXZlcnNpbmcgdGhlIHNhbWUgdHJlZSB0aGF0IHdhc1xuICAgICAgLy8gdXNlZCB0byBjb25zdHJ1Y3QgdGhlIGNhY2hlIG5vZGVzIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICB9XG4gIH1cbiAgY29uc3QgcnNjID0gY2FjaGVOb2RlLnJzY1xuICBpZiAoaXNEZWZlcnJlZFJzYyhyc2MpKSB7XG4gICAgaWYgKGVycm9yID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2ggZHVyaW5nIHJlbmRlci5cbiAgICAgIHJzYy5yZXNvbHZlKG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGR1cmluZyByZW5kZXJpbmcuXG4gICAgICByc2MucmVqZWN0KGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBsZWFmIHNlZ21lbnQuIElmIHNvLCBpdCB3aWxsIGhhdmUgYSBgaGVhZGAgcHJvcGVydHkgd2l0aFxuICAvLyBhIHBlbmRpbmcgcHJvbWlzZSB0aGF0IG5lZWRzIHRvIGJlIHJlc29sdmVkLiBJZiBhbiBlcnJvciB3YXMgcHJvdmlkZWQsIHdlXG4gIC8vIHdpbGwgbm90IHJlc29sdmUgaXQgd2l0aCBhbiBlcnJvciwgc2luY2UgdGhpcyBpcyByZW5kZXJlZCBhdCB0aGUgcm9vdCBvZlxuICAvLyB0aGUgYXBwLiBXZSB3YW50IHRoZSBzZWdtZW50IHRvIGVycm9yLCBub3QgdGhlIGVudGlyZSBhcHAuXG4gIGNvbnN0IGhlYWQgPSBjYWNoZU5vZGUuaGVhZFxuICBpZiAoaXNEZWZlcnJlZFJzYyhoZWFkKSkge1xuICAgIGhlYWQucmVzb2x2ZShudWxsKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24oXG4gIG9sZENhY2hlTm9kZTogQ2FjaGVOb2RlLFxuICByb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGVcbik6IFJlYWR5Q2FjaGVOb2RlIHtcbiAgLy8gQSBwb3BzdGF0ZSBuYXZpZ2F0aW9uIHJlYWRzIGRhdGEgZnJvbSB0aGUgbG9jYWwgY2FjaGUuIEl0IGRvZXMgbm90IGlzc3VlXG4gIC8vIG5ldyBuZXR3b3JrIHJlcXVlc3RzICh1bmxlc3MgdGhlIGNhY2hlIGVudHJpZXMgaGF2ZSBiZWVuIGV2aWN0ZWQpLiBTbywgd2VcbiAgLy8gdXBkYXRlIHRoZSBjYWNoZSB0byBkcm9wIHRoZSBwcmVmZXRjaCBkYXRhIGZvciBhbnkgc2VnbWVudCB3aG9zZSBkeW5hbWljXG4gIC8vIGRhdGEgd2FzIGFscmVhZHkgcmVjZWl2ZWQuIFRoaXMgcHJldmVudHMgYW4gdW5uZWNlc3NhcnkgZmxhc2ggYmFjayB0byBQUFJcbiAgLy8gc3RhdGUgZHVyaW5nIGEgYmFjay9mb3J3YXJkIG5hdmlnYXRpb24uXG4gIC8vXG4gIC8vIFRoaXMgZnVuY3Rpb24gY2xvbmVzIHRoZSBlbnRpcmUgY2FjaGUgbm9kZSB0cmVlIGFuZCBzZXRzIHRoZSBgcHJlZmV0Y2hSc2NgXG4gIC8vIGZpZWxkIHRvIGBudWxsYCB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQuIFdlIGNhbid0IG11dGF0ZSB0aGUgbm9kZVxuICAvLyBpbiBwbGFjZSBiZWNhdXNlIHRoaXMgaXMgYSBjb25jdXJyZW50IGRhdGEgc3RydWN0dXJlLlxuXG4gIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBvbGRQYXJhbGxlbFJvdXRlcyA9IG9sZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlc1xuICBjb25zdCBuZXdQYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAob2xkUGFyYWxsZWxSb3V0ZXMpXG4gIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gcm91dGVyU3RhdGVDaGlsZHJlbikge1xuICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlID1cbiAgICAgIHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBzZWdtZW50Q2hpbGQgPSByb3V0ZXJTdGF0ZUNoaWxkWzBdXG4gICAgY29uc3Qgc2VnbWVudEtleUNoaWxkID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudENoaWxkKVxuICAgIGNvbnN0IG9sZFNlZ21lbnRNYXBDaGlsZCA9IG9sZFBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgIGlmIChvbGRTZWdtZW50TWFwQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3Qgb2xkQ2FjaGVOb2RlQ2hpbGQgPSBvbGRTZWdtZW50TWFwQ2hpbGQuZ2V0KHNlZ21lbnRLZXlDaGlsZClcbiAgICAgIGlmIChvbGRDYWNoZU5vZGVDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG5ld0NhY2hlTm9kZUNoaWxkID0gdXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uKFxuICAgICAgICAgIG9sZENhY2hlTm9kZUNoaWxkLFxuICAgICAgICAgIHJvdXRlclN0YXRlQ2hpbGRcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBuZXdTZWdtZW50TWFwQ2hpbGQgPSBuZXcgTWFwKG9sZFNlZ21lbnRNYXBDaGlsZClcbiAgICAgICAgbmV3U2VnbWVudE1hcENoaWxkLnNldChzZWdtZW50S2V5Q2hpbGQsIG5ld0NhY2hlTm9kZUNoaWxkKVxuICAgICAgICBuZXdQYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgbmV3U2VnbWVudE1hcENoaWxkKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE9ubHkgc2hvdyBwcmVmZXRjaGVkIGRhdGEgaWYgdGhlIGR5bmFtaWMgZGF0YSBpcyBzdGlsbCBwZW5kaW5nLlxuICAvL1xuICAvLyBUZWhuaWNhbGx5LCB3aGF0IHdlJ3JlIGFjdHVhbGx5IGNoZWNraW5nIGlzIHdoZXRoZXIgdGhlIGR5bmFtaWMgbmV0d29ya1xuICAvLyByZXNwb25zZSB3YXMgcmVjZWl2ZWQuIEJ1dCBzaW5jZSBpdCdzIGEgc3RyZWFtaW5nIHJlc3BvbnNlLCB0aGlzIGRvZXMgbm90XG4gIC8vIG1lYW4gdGhhdCBhbGwgdGhlIGR5bmFtaWMgZGF0YSBoYXMgZnVsbHkgc3RyZWFtZWQgaW4uIEl0IGp1c3QgbWVhbnMgdGhhdFxuICAvLyBfc29tZV8gb2YgdGhlIGR5bmFtaWMgZGF0YSB3YXMgcmVjZWl2ZWQuIEJ1dCBhcyBhIGhldXJpc3RpYywgd2UgYXNzdW1lIHRoYXRcbiAgLy8gdGhlIHJlc3QgZHluYW1pYyBkYXRhIHdpbGwgc3RyZWFtIGluIHF1aWNrbHksIHNvIGl0J3Mgc3RpbGwgYmV0dGVyIHRvIHNraXBcbiAgLy8gdGhlIHByZWZldGNoIHN0YXRlLlxuICBjb25zdCByc2MgPSBvbGRDYWNoZU5vZGUucnNjXG4gIGNvbnN0IHNob3VsZFVzZVByZWZldGNoID0gaXNEZWZlcnJlZFJzYyhyc2MpICYmIHJzYy5zdGF0dXMgPT09ICdwZW5kaW5nJ1xuXG4gIHJldHVybiB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjLFxuICAgIGhlYWQ6IG9sZENhY2hlTm9kZS5oZWFkLFxuXG4gICAgcHJlZmV0Y2hIZWFkOiBzaG91bGRVc2VQcmVmZXRjaCA/IG9sZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQgOiBbbnVsbCwgbnVsbF0sXG4gICAgcHJlZmV0Y2hSc2M6IHNob3VsZFVzZVByZWZldGNoID8gb2xkQ2FjaGVOb2RlLnByZWZldGNoUnNjIDogbnVsbCxcbiAgICBsb2FkaW5nOiBvbGRDYWNoZU5vZGUubG9hZGluZyxcblxuICAgIC8vIFRoZXNlIGFyZSB0aGUgY2xvbmVkIGNoaWxkcmVuIHdlIGNvbXB1dGVkIGFib3ZlXG4gICAgcGFyYWxsZWxSb3V0ZXM6IG5ld1BhcmFsbGVsUm91dGVzLFxuXG4gICAgbmF2aWdhdGVkQXQ6IG9sZENhY2hlTm9kZS5uYXZpZ2F0ZWRBdCxcbiAgfVxufVxuXG5jb25zdCBERUZFUlJFRCA9IFN5bWJvbCgpXG5cbnR5cGUgUGVuZGluZ0RlZmVycmVkUnNjID0gUHJvbWlzZTxSZWFjdC5SZWFjdE5vZGU+ICYge1xuICBzdGF0dXM6ICdwZW5kaW5nJ1xuICByZXNvbHZlOiAodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkgPT4gdm9pZFxuICByZWplY3Q6IChlcnJvcjogYW55KSA9PiB2b2lkXG4gIHRhZzogU3ltYm9sXG59XG5cbnR5cGUgRnVsZmlsbGVkRGVmZXJyZWRSc2MgPSBQcm9taXNlPFJlYWN0LlJlYWN0Tm9kZT4gJiB7XG4gIHN0YXR1czogJ2Z1bGZpbGxlZCdcbiAgdmFsdWU6IFJlYWN0LlJlYWN0Tm9kZVxuICByZXNvbHZlOiAodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkgPT4gdm9pZFxuICByZWplY3Q6IChlcnJvcjogYW55KSA9PiB2b2lkXG4gIHRhZzogU3ltYm9sXG59XG5cbnR5cGUgUmVqZWN0ZWREZWZlcnJlZFJzYyA9IFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPiAmIHtcbiAgc3RhdHVzOiAncmVqZWN0ZWQnXG4gIHJlYXNvbjogYW55XG4gIHJlc29sdmU6ICh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKSA9PiB2b2lkXG4gIHJlamVjdDogKGVycm9yOiBhbnkpID0+IHZvaWRcbiAgdGFnOiBTeW1ib2xcbn1cblxudHlwZSBEZWZlcnJlZFJzYyA9XG4gIHwgUGVuZGluZ0RlZmVycmVkUnNjXG4gIHwgRnVsZmlsbGVkRGVmZXJyZWRSc2NcbiAgfCBSZWplY3RlZERlZmVycmVkUnNjXG5cbi8vIFRoaXMgdHlwZSBleGlzdHMgdG8gZGlzdGluZ3Vpc2ggYSBEZWZlcnJlZFJzYyBmcm9tIGEgRmxpZ2h0IHByb21pc2UuIEl0J3MgYVxuLy8gY29tcHJvbWlzZSB0byBhdm9pZCBhZGRpbmcgYW4gZXh0cmEgZmllbGQgb24gZXZlcnkgQ2FjaGUgTm9kZSwgd2hpY2ggd291bGQgYmVcbi8vIGF3a3dhcmQgYmVjYXVzZSB0aGUgcHJlLVBQUiBwYXJ0cyBvZiBjb2RlYmFzZSB3b3VsZCBuZWVkIHRvIGFjY291bnQgZm9yIGl0LFxuLy8gdG9vLiBXZSBjYW4gcmVtb3ZlIGl0IG9uY2UgdHlwZSBDYWNoZSBOb2RlIHR5cGUgaXMgbW9yZSBzZXR0bGVkLlxuZnVuY3Rpb24gaXNEZWZlcnJlZFJzYyh2YWx1ZTogYW55KTogdmFsdWUgaXMgRGVmZXJyZWRSc2Mge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUudGFnID09PSBERUZFUlJFRFxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZlcnJlZFJzYygpOiBQZW5kaW5nRGVmZXJyZWRSc2Mge1xuICBsZXQgcmVzb2x2ZTogYW55XG4gIGxldCByZWplY3Q6IGFueVxuICBjb25zdCBwZW5kaW5nUnNjID0gbmV3IFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPigocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzXG4gICAgcmVqZWN0ID0gcmVqXG4gIH0pIGFzIFBlbmRpbmdEZWZlcnJlZFJzY1xuICBwZW5kaW5nUnNjLnN0YXR1cyA9ICdwZW5kaW5nJ1xuICBwZW5kaW5nUnNjLnJlc29sdmUgPSAodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkgPT4ge1xuICAgIGlmIChwZW5kaW5nUnNjLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICBjb25zdCBmdWxmaWxsZWRSc2M6IEZ1bGZpbGxlZERlZmVycmVkUnNjID0gcGVuZGluZ1JzYyBhcyBhbnlcbiAgICAgIGZ1bGZpbGxlZFJzYy5zdGF0dXMgPSAnZnVsZmlsbGVkJ1xuICAgICAgZnVsZmlsbGVkUnNjLnZhbHVlID0gdmFsdWVcbiAgICAgIHJlc29sdmUodmFsdWUpXG4gICAgfVxuICB9XG4gIHBlbmRpbmdSc2MucmVqZWN0ID0gKGVycm9yOiBhbnkpID0+IHtcbiAgICBpZiAocGVuZGluZ1JzYy5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgY29uc3QgcmVqZWN0ZWRSc2M6IFJlamVjdGVkRGVmZXJyZWRSc2MgPSBwZW5kaW5nUnNjIGFzIGFueVxuICAgICAgcmVqZWN0ZWRSc2Muc3RhdHVzID0gJ3JlamVjdGVkJ1xuICAgICAgcmVqZWN0ZWRSc2MucmVhc29uID0gZXJyb3JcbiAgICAgIHJlamVjdChlcnJvcilcbiAgICB9XG4gIH1cbiAgcGVuZGluZ1JzYy50YWcgPSBERUZFUlJFRFxuICByZXR1cm4gcGVuZGluZ1JzY1xufVxuIl0sIm5hbWVzIjpbImFib3J0VGFzayIsImxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0Iiwic3RhcnRQUFJOYXZpZ2F0aW9uIiwidXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uIiwiTVBBX05BVklHQVRJT05fVEFTSyIsInJvdXRlIiwibm9kZSIsImR5bmFtaWNSZXF1ZXN0VHJlZSIsImNoaWxkcmVuIiwibmF2aWdhdGVkQXQiLCJvbGRDYWNoZU5vZGUiLCJvbGRSb3V0ZXJTdGF0ZSIsIm5ld1JvdXRlclN0YXRlIiwicHJlZmV0Y2hEYXRhIiwicHJlZmV0Y2hIZWFkIiwiaXNQcmVmZXRjaEhlYWRQYXJ0aWFsIiwiaXNTYW1lUGFnZU5hdmlnYXRpb24iLCJzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQiLCJzZWdtZW50UGF0aCIsInVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbiIsImRpZEZpbmRSb290TGF5b3V0Iiwib2xkUm91dGVyU3RhdGVDaGlsZHJlbiIsIm5ld1JvdXRlclN0YXRlQ2hpbGRyZW4iLCJwcmVmZXRjaERhdGFDaGlsZHJlbiIsImlzUm9vdExheW91dCIsIm9sZFBhcmFsbGVsUm91dGVzIiwicGFyYWxsZWxSb3V0ZXMiLCJwcmVmZXRjaFBhcmFsbGVsUm91dGVzIiwiTWFwIiwicGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW4iLCJ0YXNrQ2hpbGRyZW4iLCJuZWVkc0R5bmFtaWNSZXF1ZXN0IiwiZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW4iLCJwYXJhbGxlbFJvdXRlS2V5IiwibmV3Um91dGVyU3RhdGVDaGlsZCIsIm9sZFJvdXRlclN0YXRlQ2hpbGQiLCJvbGRTZWdtZW50TWFwQ2hpbGQiLCJnZXQiLCJwcmVmZXRjaERhdGFDaGlsZCIsIm5ld1NlZ21lbnRDaGlsZCIsIm5ld1NlZ21lbnRQYXRoQ2hpbGQiLCJjb25jYXQiLCJuZXdTZWdtZW50S2V5Q2hpbGQiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsIm9sZFNlZ21lbnRDaGlsZCIsInVuZGVmaW5lZCIsIm9sZENhY2hlTm9kZUNoaWxkIiwidGFza0NoaWxkIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsInNwYXduUmV1c2VkVGFzayIsImJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsIm1hdGNoU2VnbWVudCIsInNldCIsIm5ld0NhY2hlTm9kZUNoaWxkIiwibmV3U2VnbWVudE1hcENoaWxkIiwidGFza0NoaWxkUm91dGUiLCJkeW5hbWljUmVxdWVzdFRyZWVDaGlsZCIsIm5ld0NhY2hlTm9kZSIsImxhenlEYXRhIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJoZWFkIiwibG9hZGluZyIsInBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4iLCJleGlzdGluZ0NhY2hlTm9kZSIsInBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNyZWF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbiIsInJvdXRlclN0YXRlIiwicm91dGVyU3RhdGVDaGlsZHJlbiIsImlzTGVhZlNlZ21lbnQiLCJjYWNoZU5vZGVOYXZpZ2F0ZWRBdCIsIkRZTkFNSUNfU1RBTEVUSU1FX01TIiwiaXNQcmVmZXRjaFJzY1BhcnRpYWwiLCJzcGF3blBlbmRpbmdUYXNrIiwiZXhpc3RpbmdDYWNoZU5vZGVDaGlsZHJlbiIsImNhY2hlTm9kZUNoaWxkcmVuIiwicHVzaCIsInJvdXRlclN0YXRlQ2hpbGQiLCJleGlzdGluZ1NlZ21lbnRNYXBDaGlsZCIsInNlZ21lbnRDaGlsZCIsInNlZ21lbnRQYXRoQ2hpbGQiLCJzZWdtZW50S2V5Q2hpbGQiLCJleGlzdGluZ0NhY2hlTm9kZUNoaWxkIiwiYmFzZVJvdXRlclN0YXRlIiwibmV3Q2hpbGRyZW4iLCJjbG9uZSIsIm5ld1Rhc2siLCJjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlIiwicmV1c2VkUm91dGVyU3RhdGUiLCJ0YXNrIiwicmVzcG9uc2VQcm9taXNlIiwidGhlbiIsImZsaWdodERhdGEiLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsInRyZWUiLCJzZXJ2ZXJSb3V0ZXJTdGF0ZSIsInNlZWREYXRhIiwiZHluYW1pY0RhdGEiLCJkeW5hbWljSGVhZCIsIndyaXRlRHluYW1pY0RhdGFJbnRvUGVuZGluZ1Rhc2siLCJlcnJvciIsInJvb3RUYXNrIiwiaSIsInNlZ21lbnQiLCJ0YXNrU2VnbWVudCIsImZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZCIsInRhc2tOb2RlIiwiZmluaXNoUGVuZGluZ0NhY2hlTm9kZSIsInNlcnZlckNoaWxkcmVuIiwiZHluYW1pY0RhdGFDaGlsZHJlbiIsInNlcnZlclJvdXRlclN0YXRlQ2hpbGQiLCJkeW5hbWljRGF0YUNoaWxkIiwic2l6ZSIsIm1heWJlUHJlZmV0Y2hSc2MiLCJtYXliZVByZWZldGNoTG9hZGluZyIsImNyZWF0ZURlZmVycmVkUnNjIiwiY2FjaGVOb2RlIiwidGFza1N0YXRlIiwic2VydmVyU3RhdGUiLCJ0YXNrU3RhdGVDaGlsZHJlbiIsInNlcnZlclN0YXRlQ2hpbGRyZW4iLCJkYXRhQ2hpbGRyZW4iLCJ0YXNrU3RhdGVDaGlsZCIsInNlcnZlclN0YXRlQ2hpbGQiLCJkYXRhQ2hpbGQiLCJzZWdtZW50TWFwQ2hpbGQiLCJ0YXNrU2VnbWVudENoaWxkIiwidGFza1NlZ21lbnRLZXlDaGlsZCIsImNhY2hlTm9kZUNoaWxkIiwiYWJvcnRQZW5kaW5nQ2FjaGVOb2RlIiwiZHluYW1pY1NlZ21lbnREYXRhIiwiaXNEZWZlcnJlZFJzYyIsInJlc29sdmUiLCJ2YWx1ZXMiLCJyZWplY3QiLCJuZXdQYXJhbGxlbFJvdXRlcyIsInNob3VsZFVzZVByZWZldGNoIiwic3RhdHVzIiwiREVGRVJSRUQiLCJTeW1ib2wiLCJ2YWx1ZSIsInRhZyIsInBlbmRpbmdSc2MiLCJQcm9taXNlIiwicmVzIiwicmVqIiwiZnVsZmlsbGVkUnNjIiwicmVqZWN0ZWRSc2MiLCJyZWFzb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DYNAMIC_STALETIME_MS: function() {\n        return DYNAMIC_STALETIME_MS;\n    },\n    STATIC_STALETIME_MS: function() {\n        return STATIC_STALETIME_MS;\n    },\n    createSeededPrefetchCacheEntry: function() {\n        return createSeededPrefetchCacheEntry;\n    },\n    getOrCreatePrefetchCacheEntry: function() {\n        return getOrCreatePrefetchCacheEntry;\n    },\n    prunePrefetchCache: function() {\n        return prunePrefetchCache;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst INTERCEPTION_CACHE_KEY_MARKER = '%';\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */ function createPrefetchCacheKeyImpl(url, includeSearchParams, prefix) {\n    // Initially we only use the pathname as the cache key. We don't want to include\n    // search params so that multiple URLs with the same search parameter can re-use\n    // loading states.\n    let pathnameFromUrl = url.pathname;\n    // RSC responses can differ based on search params, specifically in the case where we aren't\n    // returning a partial response (ie with `PrefetchKind.AUTO`).\n    // In the auto case, since loading.js & layout.js won't have access to search params,\n    // we can safely re-use that cache entry. But for full prefetches, we should not\n    // re-use the cache entry as the response may differ.\n    if (includeSearchParams) {\n        // if we have a full prefetch, we can include the search param in the key,\n        // as we'll be getting back a full response. The server might have read the search\n        // params when generating the full response.\n        pathnameFromUrl += url.search;\n    }\n    if (prefix) {\n        return \"\" + prefix + INTERCEPTION_CACHE_KEY_MARKER + pathnameFromUrl;\n    }\n    return pathnameFromUrl;\n}\nfunction createPrefetchCacheKey(url, kind, nextUrl) {\n    return createPrefetchCacheKeyImpl(url, kind === _routerreducertypes.PrefetchKind.FULL, nextUrl);\n}\nfunction getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing) {\n    if (kind === void 0) kind = _routerreducertypes.PrefetchKind.TEMPORARY;\n    // We first check if there's a more specific interception route prefetch entry\n    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n    for (const maybeNextUrl of [\n        nextUrl,\n        null\n    ]){\n        const cacheKeyWithParams = createPrefetchCacheKeyImpl(url, true, maybeNextUrl);\n        const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(url, false, maybeNextUrl);\n        // First, we check if we have a cache entry that exactly matches the URL\n        const cacheKeyToUse = url.search ? cacheKeyWithParams : cacheKeyWithoutParams;\n        const existingEntry = prefetchCache.get(cacheKeyToUse);\n        if (existingEntry && allowAliasing) {\n            // We know we're returning an aliased entry when the pathname matches but the search params don't,\n            const isAliased = existingEntry.url.pathname === url.pathname && existingEntry.url.search !== url.search;\n            if (isAliased) {\n                return {\n                    ...existingEntry,\n                    aliased: true\n                };\n            }\n            return existingEntry;\n        }\n        // If the request contains search params, and we're not doing a full prefetch, we can return the\n        // param-less entry if it exists.\n        // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n        // but lets us arrive there quicker in the param-full case.\n        const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams);\n        if (false) {}\n    }\n    // If we've gotten to this point, we didn't find a specific cache entry that matched\n    // the request URL.\n    // We attempt a partial match by checking if there's a cache entry with the same pathname.\n    // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n    // This will signal to the router that it should only apply the loading state on the prefetched data.\n    if (false) {}\n    return undefined;\n}\nfunction getOrCreatePrefetchCacheEntry(param) {\n    let { url, nextUrl, tree, prefetchCache, kind, allowAliasing = true } = param;\n    const existingCacheEntry = getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing);\n    if (existingCacheEntry) {\n        // Grab the latest status of the cache entry and update it\n        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);\n        // when `kind` is provided, an explicit prefetch was requested.\n        // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;\n        if (switchedToFullPrefetch) {\n            // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n            // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n            // are seeded but without a prefetch intent)\n            existingCacheEntry.data.then((prefetchResponse)=>{\n                const isFullPrefetch = Array.isArray(prefetchResponse.flightData) && prefetchResponse.flightData.some((flightData)=>{\n                    // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n                    return flightData.isRootRender && flightData.seedData !== null;\n                });\n                if (!isFullPrefetch) {\n                    return createLazyPrefetchEntry({\n                        tree,\n                        url,\n                        nextUrl,\n                        prefetchCache,\n                        // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n                        // rather than assuming the same intent as the previous entry, to be consistent with how we\n                        // lazily create prefetch entries when intent is left unspecified.\n                        kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY\n                    });\n                }\n            });\n        }\n        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {\n            existingCacheEntry.kind = kind;\n        }\n        // We've determined that the existing entry we found is still valid, so we return it.\n        return existingCacheEntry;\n    }\n    // If we didn't return an entry, create a new one.\n    return createLazyPrefetchEntry({\n        tree,\n        url,\n        nextUrl,\n        prefetchCache,\n        kind: kind || _routerreducertypes.PrefetchKind.TEMPORARY\n    });\n}\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */ function prefixExistingPrefetchCacheEntry(param) {\n    let { url, nextUrl, prefetchCache, existingCacheKey } = param;\n    const existingCacheEntry = prefetchCache.get(existingCacheKey);\n    if (!existingCacheEntry) {\n        // no-op -- there wasn't an entry to move\n        return;\n    }\n    const newCacheKey = createPrefetchCacheKey(url, existingCacheEntry.kind, nextUrl);\n    prefetchCache.set(newCacheKey, {\n        ...existingCacheEntry,\n        key: newCacheKey\n    });\n    prefetchCache.delete(existingCacheKey);\n    return newCacheKey;\n}\nfunction createSeededPrefetchCacheEntry(param) {\n    let { nextUrl, tree, prefetchCache, url, data, kind } = param;\n    // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n    // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n    const prefetchCacheKey = data.couldBeIntercepted ? createPrefetchCacheKey(url, kind, nextUrl) : createPrefetchCacheKey(url, kind);\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data: Promise.resolve(data),\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: Date.now(),\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */ function createLazyPrefetchEntry(param) {\n    let { url, kind, tree, nextUrl, prefetchCache } = param;\n    const prefetchCacheKey = createPrefetchCacheKey(url, kind);\n    // initiates the fetch request for the prefetch and attaches a listener\n    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, {\n            flightRouterState: tree,\n            nextUrl,\n            prefetchKind: kind\n        }).then((prefetchResponse)=>{\n            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n            // to avoid drift between this cache key prefixing logic\n            // (which is currently directly influenced by the server response)\n            let newCacheKey;\n            if (prefetchResponse.couldBeIntercepted) {\n                // Determine if we need to prefix the cache key with the nextUrl\n                newCacheKey = prefixExistingPrefetchCacheEntry({\n                    url,\n                    existingCacheKey: prefetchCacheKey,\n                    nextUrl,\n                    prefetchCache\n                });\n            }\n            // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n            // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n            // staleTime.\n            if (prefetchResponse.prerendered) {\n                const existingCacheEntry = prefetchCache.get(newCacheKey != null ? newCacheKey : prefetchCacheKey);\n                if (existingCacheEntry) {\n                    existingCacheEntry.kind = _routerreducertypes.PrefetchKind.FULL;\n                    if (prefetchResponse.staleTime !== -1) {\n                        // This is the stale time that was collected by the server during\n                        // static generation. Use this in place of the default stale time.\n                        existingCacheEntry.staleTime = prefetchResponse.staleTime;\n                    }\n                }\n            }\n            return prefetchResponse;\n        }));\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data,\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null,\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\nfunction prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\nconst DYNAMIC_STALETIME_MS = Number(\"0\") * 1000;\nconst STATIC_STALETIME_MS = Number(\"300\") * 1000;\nfunction getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime, staleTime } = param;\n    if (staleTime !== -1) {\n        // `staleTime` is the value sent by the server during static generation.\n        // When this is available, it takes precedence over any of the heuristics\n        // that follow.\n        //\n        // TODO: When PPR is enabled, the server will *always* return a stale time\n        // when prefetching. We should never use a prefetch entry that hasn't yet\n        // received data from the server. So the only two cases should be 1) we use\n        // the server-generated stale time 2) the unresolved entry is discarded.\n        return Date.now() < prefetchTime + staleTime ? _routerreducertypes.PrefetchCacheEntryStatus.fresh : _routerreducertypes.PrefetchCacheEntryStatus.stale;\n    }\n    // We will re-use the cache entry data for up to the `dynamic` staletime window.\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {\n        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;\n    }\n    // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n    // A stale entry will only re-use the `loading` boundary, not the full data.\n    // This will trigger a \"lazy fetch\" for the full data.\n    if (kind === _routerreducertypes.PrefetchKind.AUTO) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.stale;\n        }\n    }\n    // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n    if (kind === _routerreducertypes.PrefetchKind.FULL) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n        }\n    }\n    return _routerreducertypes.PrefetchCacheEntryStatus.expired;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-cache-utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHJlZmV0Y2gtY2FjaGUtdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBNFlhQSxvQkFBb0I7ZUFBcEJBOztJQUdBQyxtQkFBbUI7ZUFBbkJBOztJQW5JR0MsOEJBQThCO2VBQTlCQTs7SUE5R0FDLDZCQUE2QjtlQUE3QkE7O0lBK05BQyxrQkFBa0I7ZUFBbEJBOzs7aURBMVhUO2dEQU1BOzZDQUN1QjtBQUU5QixNQUFNQyxnQ0FBZ0M7QUFVdEM7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsMkJBQ1BDLEdBQVEsRUFDUkMsbUJBQTRCLEVBQzVCQyxNQUFzQjtJQUV0QixnRkFBZ0Y7SUFDaEYsZ0ZBQWdGO0lBQ2hGLGtCQUFrQjtJQUNsQixJQUFJQyxrQkFBa0JILElBQUlJLFFBQVE7SUFFbEMsNEZBQTRGO0lBQzVGLDhEQUE4RDtJQUM5RCxxRkFBcUY7SUFDckYsZ0ZBQWdGO0lBQ2hGLHFEQUFxRDtJQUNyRCxJQUFJSCxxQkFBcUI7UUFDdkIsMEVBQTBFO1FBQzFFLGtGQUFrRjtRQUNsRiw0Q0FBNEM7UUFDNUNFLG1CQUFtQkgsSUFBSUssTUFBTTtJQUMvQjtJQUVBLElBQUlILFFBQVE7UUFDVixPQUFRLEtBQUVBLFNBQVNKLGdDQUFnQ0s7SUFDckQ7SUFFQSxPQUFPQTtBQUNUO0FBRUEsU0FBU0csdUJBQ1BOLEdBQVEsRUFDUk8sSUFBOEIsRUFDOUJDLE9BQXVCO0lBRXZCLE9BQU9ULDJCQUEyQkMsS0FBS08sU0FBU0Usb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSSxFQUFFRjtBQUNyRTtBQUVBLFNBQVNHLHNCQUNQWCxHQUFRLEVBQ1JPLElBQTJDLEVBQzNDQyxPQUFzQixFQUN0QkksYUFBOEMsRUFDOUNDLGFBQXNCO0lBSHRCTixJQUFBQSxTQUFBQSxLQUFBQSxHQUFBQSxPQUFxQkUsb0JBQUFBLFlBQVksQ0FBQ0ss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NUUsc0RBQXNEO0lBQ3RELElBQUkxRCxTQUFTRSxvQkFBQUEsWUFBWSxDQUFDdUUsSUFBSSxFQUFFO1FBQzlCLElBQUlwQixLQUFLQyxHQUFHLEtBQUtGLGVBQWVqRSxxQkFBcUI7WUFDbkQsT0FBT3NFLG9CQUFBQSx3QkFBd0IsQ0FBQ2MsS0FBSztRQUN2QztJQUNGO0lBRUEsaUdBQWlHO0lBQ2pHLElBQUl2RSxTQUFTRSxvQkFBQUEsWUFBWSxDQUFDQyxJQUFJLEVBQUU7UUFDOUIsSUFBSWtELEtBQUtDLEdBQUcsS0FBS0YsZUFBZWpFLHFCQUFxQjtZQUNuRCxPQUFPc0Usb0JBQUFBLHdCQUF3QixDQUFDZSxRQUFRO1FBQzFDO0lBQ0Y7SUFFQSxPQUFPZixvQkFBQUEsd0JBQXdCLENBQUNVLE9BQU87QUFDekMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxwcmVmZXRjaC1jYWNoZS11dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBmZXRjaFNlcnZlclJlc3BvbnNlLFxuICB0eXBlIEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQsXG59IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHtcbiAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLFxuICB0eXBlIFByZWZldGNoQ2FjaGVFbnRyeSxcbiAgUHJlZmV0Y2hLaW5kLFxuICB0eXBlIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgcHJlZmV0Y2hRdWV1ZSB9IGZyb20gJy4vcmVkdWNlcnMvcHJlZmV0Y2gtcmVkdWNlcidcblxuY29uc3QgSU5URVJDRVBUSU9OX0NBQ0hFX0tFWV9NQVJLRVIgPSAnJSdcblxuZXhwb3J0IHR5cGUgQWxpYXNlZFByZWZldGNoQ2FjaGVFbnRyeSA9IFByZWZldGNoQ2FjaGVFbnRyeSAmIHtcbiAgLyoqIFRoaXMgaXMgYSBzcGVjaWFsIHByb3BlcnR5IHRoYXQgaW5kaWNhdGVzIGEgcHJlZmV0Y2ggZW50cnkgYXNzb2NpYXRlZCB3aXRoIGEgZGlmZmVyZW50IFVSTFxuICAgKiB3YXMgcmV0dXJuZWQgcmF0aGVyIHRoYW4gdGhlIHJlcXVlc3RlZCBVUkwuIFRoaXMgc2lnbmFscyB0byB0aGUgcm91dGVyIHRoYXQgaXQgc2hvdWxkIG9ubHlcbiAgICogYXBwbHkgdGhlIHBhcnQgdGhhdCBkb2Vzbid0IGRlcGVuZCBvbiBzZWFyY2hQYXJhbXMgKHNwZWNpZmljYWxseSB0aGUgbG9hZGluZyBzdGF0ZSkuXG4gICAqL1xuICBhbGlhc2VkPzogYm9vbGVhblxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjYWNoZSBrZXkgZm9yIHRoZSByb3V0ZXIgcHJlZmV0Y2ggY2FjaGVcbiAqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBiZWluZyBuYXZpZ2F0ZWQgdG9cbiAqIEBwYXJhbSBuZXh0VXJsIC0gYW4gaW50ZXJuYWwgVVJMLCBwcmltYXJpbHkgdXNlZCBmb3IgaGFuZGxpbmcgcmV3cml0ZXMuIERlZmF1bHRzIHRvICcvJy5cbiAqIEByZXR1cm4gVGhlIGdlbmVyYXRlZCBwcmVmZXRjaCBjYWNoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKFxuICB1cmw6IFVSTCxcbiAgaW5jbHVkZVNlYXJjaFBhcmFtczogYm9vbGVhbixcbiAgcHJlZml4Pzogc3RyaW5nIHwgbnVsbFxuKSB7XG4gIC8vIEluaXRpYWxseSB3ZSBvbmx5IHVzZSB0aGUgcGF0aG5hbWUgYXMgdGhlIGNhY2hlIGtleS4gV2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlXG4gIC8vIHNlYXJjaCBwYXJhbXMgc28gdGhhdCBtdWx0aXBsZSBVUkxzIHdpdGggdGhlIHNhbWUgc2VhcmNoIHBhcmFtZXRlciBjYW4gcmUtdXNlXG4gIC8vIGxvYWRpbmcgc3RhdGVzLlxuICBsZXQgcGF0aG5hbWVGcm9tVXJsID0gdXJsLnBhdGhuYW1lXG5cbiAgLy8gUlNDIHJlc3BvbnNlcyBjYW4gZGlmZmVyIGJhc2VkIG9uIHNlYXJjaCBwYXJhbXMsIHNwZWNpZmljYWxseSBpbiB0aGUgY2FzZSB3aGVyZSB3ZSBhcmVuJ3RcbiAgLy8gcmV0dXJuaW5nIGEgcGFydGlhbCByZXNwb25zZSAoaWUgd2l0aCBgUHJlZmV0Y2hLaW5kLkFVVE9gKS5cbiAgLy8gSW4gdGhlIGF1dG8gY2FzZSwgc2luY2UgbG9hZGluZy5qcyAmIGxheW91dC5qcyB3b24ndCBoYXZlIGFjY2VzcyB0byBzZWFyY2ggcGFyYW1zLFxuICAvLyB3ZSBjYW4gc2FmZWx5IHJlLXVzZSB0aGF0IGNhY2hlIGVudHJ5LiBCdXQgZm9yIGZ1bGwgcHJlZmV0Y2hlcywgd2Ugc2hvdWxkIG5vdFxuICAvLyByZS11c2UgdGhlIGNhY2hlIGVudHJ5IGFzIHRoZSByZXNwb25zZSBtYXkgZGlmZmVyLlxuICBpZiAoaW5jbHVkZVNlYXJjaFBhcmFtcykge1xuICAgIC8vIGlmIHdlIGhhdmUgYSBmdWxsIHByZWZldGNoLCB3ZSBjYW4gaW5jbHVkZSB0aGUgc2VhcmNoIHBhcmFtIGluIHRoZSBrZXksXG4gICAgLy8gYXMgd2UnbGwgYmUgZ2V0dGluZyBiYWNrIGEgZnVsbCByZXNwb25zZS4gVGhlIHNlcnZlciBtaWdodCBoYXZlIHJlYWQgdGhlIHNlYXJjaFxuICAgIC8vIHBhcmFtcyB3aGVuIGdlbmVyYXRpbmcgdGhlIGZ1bGwgcmVzcG9uc2UuXG4gICAgcGF0aG5hbWVGcm9tVXJsICs9IHVybC5zZWFyY2hcbiAgfVxuXG4gIGlmIChwcmVmaXgpIHtcbiAgICByZXR1cm4gYCR7cHJlZml4fSR7SU5URVJDRVBUSU9OX0NBQ0hFX0tFWV9NQVJLRVJ9JHtwYXRobmFtZUZyb21Vcmx9YFxuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lRnJvbVVybFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KFxuICB1cmw6IFVSTCxcbiAga2luZDogUHJlZmV0Y2hLaW5kIHwgdW5kZWZpbmVkLFxuICBuZXh0VXJsPzogc3RyaW5nIHwgbnVsbFxuKSB7XG4gIHJldHVybiBjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbCh1cmwsIGtpbmQgPT09IFByZWZldGNoS2luZC5GVUxMLCBuZXh0VXJsKVxufVxuXG5mdW5jdGlvbiBnZXRFeGlzdGluZ0NhY2hlRW50cnkoXG4gIHVybDogVVJMLFxuICBraW5kOiBQcmVmZXRjaEtpbmQgPSBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZLFxuICBuZXh0VXJsOiBzdHJpbmcgfCBudWxsLFxuICBwcmVmZXRjaENhY2hlOiBNYXA8c3RyaW5nLCBQcmVmZXRjaENhY2hlRW50cnk+LFxuICBhbGxvd0FsaWFzaW5nOiBib29sZWFuXG4pOiBBbGlhc2VkUHJlZmV0Y2hDYWNoZUVudHJ5IHwgdW5kZWZpbmVkIHtcbiAgLy8gV2UgZmlyc3QgY2hlY2sgaWYgdGhlcmUncyBhIG1vcmUgc3BlY2lmaWMgaW50ZXJjZXB0aW9uIHJvdXRlIHByZWZldGNoIGVudHJ5XG4gIC8vIFRoaXMgaXMgYmVjYXVzZSB3aGVuIHdlIGRldGVjdCBhIHByZWZldGNoIHRoYXQgY29ycmVzcG9uZHMgd2l0aCBhbiBpbnRlcmNlcHRpb24gcm91dGUsIHdlIHByZWZpeCBpdCB3aXRoIG5leHRVcmwgKHNlZSBgY3JlYXRlUHJlZmV0Y2hDYWNoZUtleWApXG4gIC8vIHRvIGF2b2lkIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBhZ2VzIHRoYXQgbWF5IGhhdmUgdGhlIHNhbWUgVVJMIGJ1dCByZW5kZXIgZGlmZmVyZW50IHRoaW5ncyBkZXBlbmRpbmcgb24gdGhlIGBOZXh0LVVSTGAgaGVhZGVyLlxuICBmb3IgKGNvbnN0IG1heWJlTmV4dFVybCBvZiBbbmV4dFVybCwgbnVsbF0pIHtcbiAgICBjb25zdCBjYWNoZUtleVdpdGhQYXJhbXMgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbChcbiAgICAgIHVybCxcbiAgICAgIHRydWUsXG4gICAgICBtYXliZU5leHRVcmxcbiAgICApXG4gICAgY29uc3QgY2FjaGVLZXlXaXRob3V0UGFyYW1zID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwoXG4gICAgICB1cmwsXG4gICAgICBmYWxzZSxcbiAgICAgIG1heWJlTmV4dFVybFxuICAgIClcblxuICAgIC8vIEZpcnN0LCB3ZSBjaGVjayBpZiB3ZSBoYXZlIGEgY2FjaGUgZW50cnkgdGhhdCBleGFjdGx5IG1hdGNoZXMgdGhlIFVSTFxuICAgIGNvbnN0IGNhY2hlS2V5VG9Vc2UgPSB1cmwuc2VhcmNoXG4gICAgICA/IGNhY2hlS2V5V2l0aFBhcmFtc1xuICAgICAgOiBjYWNoZUtleVdpdGhvdXRQYXJhbXNcblxuICAgIGNvbnN0IGV4aXN0aW5nRW50cnkgPSBwcmVmZXRjaENhY2hlLmdldChjYWNoZUtleVRvVXNlKVxuICAgIGlmIChleGlzdGluZ0VudHJ5ICYmIGFsbG93QWxpYXNpbmcpIHtcbiAgICAgIC8vIFdlIGtub3cgd2UncmUgcmV0dXJuaW5nIGFuIGFsaWFzZWQgZW50cnkgd2hlbiB0aGUgcGF0aG5hbWUgbWF0Y2hlcyBidXQgdGhlIHNlYXJjaCBwYXJhbXMgZG9uJ3QsXG4gICAgICBjb25zdCBpc0FsaWFzZWQgPVxuICAgICAgICBleGlzdGluZ0VudHJ5LnVybC5wYXRobmFtZSA9PT0gdXJsLnBhdGhuYW1lICYmXG4gICAgICAgIGV4aXN0aW5nRW50cnkudXJsLnNlYXJjaCAhPT0gdXJsLnNlYXJjaFxuXG4gICAgICBpZiAoaXNBbGlhc2VkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZXhpc3RpbmdFbnRyeSxcbiAgICAgICAgICBhbGlhc2VkOiB0cnVlLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleGlzdGluZ0VudHJ5XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgY29udGFpbnMgc2VhcmNoIHBhcmFtcywgYW5kIHdlJ3JlIG5vdCBkb2luZyBhIGZ1bGwgcHJlZmV0Y2gsIHdlIGNhbiByZXR1cm4gdGhlXG4gICAgLy8gcGFyYW0tbGVzcyBlbnRyeSBpZiBpdCBleGlzdHMuXG4gICAgLy8gVGhpcyBpcyB0ZWNobmljYWxseSBjb3ZlcmVkIGJ5IHRoZSBjaGVjayBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZnVuY3Rpb24sIHdoaWNoIGl0ZXJhdGVzIG92ZXIgY2FjaGUgZW50cmllcyxcbiAgICAvLyBidXQgbGV0cyB1cyBhcnJpdmUgdGhlcmUgcXVpY2tlciBpbiB0aGUgcGFyYW0tZnVsbCBjYXNlLlxuICAgIGNvbnN0IGVudHJ5V2l0aG91dFBhcmFtcyA9IHByZWZldGNoQ2FjaGUuZ2V0KGNhY2hlS2V5V2l0aG91dFBhcmFtcylcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyAmJlxuICAgICAgYWxsb3dBbGlhc2luZyAmJlxuICAgICAgdXJsLnNlYXJjaCAmJlxuICAgICAga2luZCAhPT0gUHJlZmV0Y2hLaW5kLkZVTEwgJiZcbiAgICAgIGVudHJ5V2l0aG91dFBhcmFtcyAmJlxuICAgICAgLy8gV2Ugc2hvdWxkbid0IHJldHVybiB0aGUgYWxpYXNlZCBlbnRyeSBpZiBpdCB3YXMgcmVsb2NhdGVkIHRvIGEgbmV3IGNhY2hlIGtleS5cbiAgICAgIC8vIFNpbmNlIGl0J3MgcmV3cml0dGVuLCBpdCBjb3VsZCByZXNwb25kIHdpdGggYSBjb21wbGV0ZWx5IGRpZmZlcmVudCBsb2FkaW5nIHN0YXRlLlxuICAgICAgIWVudHJ5V2l0aG91dFBhcmFtcy5rZXkuaW5jbHVkZXMoSU5URVJDRVBUSU9OX0NBQ0hFX0tFWV9NQVJLRVIpXG4gICAgKSB7XG4gICAgICByZXR1cm4geyAuLi5lbnRyeVdpdGhvdXRQYXJhbXMsIGFsaWFzZWQ6IHRydWUgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlJ3ZlIGdvdHRlbiB0byB0aGlzIHBvaW50LCB3ZSBkaWRuJ3QgZmluZCBhIHNwZWNpZmljIGNhY2hlIGVudHJ5IHRoYXQgbWF0Y2hlZFxuICAvLyB0aGUgcmVxdWVzdCBVUkwuXG4gIC8vIFdlIGF0dGVtcHQgYSBwYXJ0aWFsIG1hdGNoIGJ5IGNoZWNraW5nIGlmIHRoZXJlJ3MgYSBjYWNoZSBlbnRyeSB3aXRoIHRoZSBzYW1lIHBhdGhuYW1lLlxuICAvLyBSZWdhcmRsZXNzIG9mIHdoYXQgd2UgZmluZCwgc2luY2UgaXQgZG9lc24ndCBjb3JyZXNwb25kIHdpdGggdGhlIHJlcXVlc3RlZCBVUkwsIHdlJ2xsIG1hcmsgaXQgXCJhbGlhc2VkXCIuXG4gIC8vIFRoaXMgd2lsbCBzaWduYWwgdG8gdGhlIHJvdXRlciB0aGF0IGl0IHNob3VsZCBvbmx5IGFwcGx5IHRoZSBsb2FkaW5nIHN0YXRlIG9uIHRoZSBwcmVmZXRjaGVkIGRhdGEuXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyAmJlxuICAgIGtpbmQgIT09IFByZWZldGNoS2luZC5GVUxMICYmXG4gICAgYWxsb3dBbGlhc2luZ1xuICApIHtcbiAgICBmb3IgKGNvbnN0IGNhY2hlRW50cnkgb2YgcHJlZmV0Y2hDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgaWYgKFxuICAgICAgICBjYWNoZUVudHJ5LnVybC5wYXRobmFtZSA9PT0gdXJsLnBhdGhuYW1lICYmXG4gICAgICAgIC8vIFdlIHNob3VsZG4ndCByZXR1cm4gdGhlIGFsaWFzZWQgZW50cnkgaWYgaXQgd2FzIHJlbG9jYXRlZCB0byBhIG5ldyBjYWNoZSBrZXkuXG4gICAgICAgIC8vIFNpbmNlIGl0J3MgcmV3cml0dGVuLCBpdCBjb3VsZCByZXNwb25kIHdpdGggYSBjb21wbGV0ZWx5IGRpZmZlcmVudCBsb2FkaW5nIHN0YXRlLlxuICAgICAgICAhY2FjaGVFbnRyeS5rZXkuaW5jbHVkZXMoSU5URVJDRVBUSU9OX0NBQ0hFX0tFWV9NQVJLRVIpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uY2FjaGVFbnRyeSwgYWxpYXNlZDogdHJ1ZSB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIFJldHVybnMgYSBwcmVmZXRjaCBjYWNoZSBlbnRyeSBpZiBvbmUgZXhpc3RzLiBPdGhlcndpc2UgY3JlYXRlcyBhIG5ldyBvbmUgYW5kIGVucXVldWVzIGEgZmV0Y2ggcmVxdWVzdFxuICogdG8gcmV0cmlldmUgdGhlIHByZWZldGNoIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkoe1xuICB1cmwsXG4gIG5leHRVcmwsXG4gIHRyZWUsXG4gIHByZWZldGNoQ2FjaGUsXG4gIGtpbmQsXG4gIGFsbG93QWxpYXNpbmcgPSB0cnVlLFxufTogUGljazxSZWFkb25seVJlZHVjZXJTdGF0ZSwgJ25leHRVcmwnIHwgJ3ByZWZldGNoQ2FjaGUnIHwgJ3RyZWUnPiAmIHtcbiAgdXJsOiBVUkxcbiAga2luZD86IFByZWZldGNoS2luZFxuICBhbGxvd0FsaWFzaW5nOiBib29sZWFuXG59KTogQWxpYXNlZFByZWZldGNoQ2FjaGVFbnRyeSB7XG4gIGNvbnN0IGV4aXN0aW5nQ2FjaGVFbnRyeSA9IGdldEV4aXN0aW5nQ2FjaGVFbnRyeShcbiAgICB1cmwsXG4gICAga2luZCxcbiAgICBuZXh0VXJsLFxuICAgIHByZWZldGNoQ2FjaGUsXG4gICAgYWxsb3dBbGlhc2luZ1xuICApXG5cbiAgaWYgKGV4aXN0aW5nQ2FjaGVFbnRyeSkge1xuICAgIC8vIEdyYWIgdGhlIGxhdGVzdCBzdGF0dXMgb2YgdGhlIGNhY2hlIGVudHJ5IGFuZCB1cGRhdGUgaXRcbiAgICBleGlzdGluZ0NhY2hlRW50cnkuc3RhdHVzID0gZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzKGV4aXN0aW5nQ2FjaGVFbnRyeSlcblxuICAgIC8vIHdoZW4gYGtpbmRgIGlzIHByb3ZpZGVkLCBhbiBleHBsaWNpdCBwcmVmZXRjaCB3YXMgcmVxdWVzdGVkLlxuICAgIC8vIGlmIHRoZSByZXF1ZXN0ZWQgcHJlZmV0Y2ggaXMgXCJmdWxsXCIgYW5kIHRoZSBjdXJyZW50IGNhY2hlIGVudHJ5IHdhc24ndCwgd2Ugd2FudCB0byByZS1wcmVmZXRjaCB3aXRoIHRoZSBuZXcgaW50ZW50XG4gICAgY29uc3Qgc3dpdGNoZWRUb0Z1bGxQcmVmZXRjaCA9XG4gICAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCAhPT0gUHJlZmV0Y2hLaW5kLkZVTEwgJiZcbiAgICAgIGtpbmQgPT09IFByZWZldGNoS2luZC5GVUxMXG5cbiAgICBpZiAoc3dpdGNoZWRUb0Z1bGxQcmVmZXRjaCkge1xuICAgICAgLy8gSWYgd2Ugc3dpdGNoZWQgdG8gYSBmdWxsIHByZWZldGNoLCB2YWxpZGF0ZSB0aGF0IHRoZSBleGlzdGluZyBjYWNoZSBlbnRyeSBjb250YWluZWQgcGFydGlhbCBkYXRhLlxuICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHRoZSBjYWNoZSBlbnRyeSB3YXMgc2VlZGVkIHdpdGggZnVsbCBkYXRhIGJ1dCBoYXMgYSBjYWNoZSB0eXBlIG9mIFwiYXV0b1wiIChpZSB3aGVuIGNhY2hlIGVudHJpZXNcbiAgICAgIC8vIGFyZSBzZWVkZWQgYnV0IHdpdGhvdXQgYSBwcmVmZXRjaCBpbnRlbnQpXG4gICAgICBleGlzdGluZ0NhY2hlRW50cnkuZGF0YS50aGVuKChwcmVmZXRjaFJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRnVsbFByZWZldGNoID1cbiAgICAgICAgICBBcnJheS5pc0FycmF5KHByZWZldGNoUmVzcG9uc2UuZmxpZ2h0RGF0YSkgJiZcbiAgICAgICAgICBwcmVmZXRjaFJlc3BvbnNlLmZsaWdodERhdGEuc29tZSgoZmxpZ2h0RGF0YSkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgd2Ugc3RhcnRlZCByZW5kZXJpbmcgZnJvbSB0aGUgcm9vdCBhbmQgd2UgcmV0dXJuZWQgUlNDIGRhdGEgKHNlZWREYXRhKSwgd2UgYWxyZWFkeSBoYWQgYSBmdWxsIHByZWZldGNoLlxuICAgICAgICAgICAgcmV0dXJuIGZsaWdodERhdGEuaXNSb290UmVuZGVyICYmIGZsaWdodERhdGEuc2VlZERhdGEgIT09IG51bGxcbiAgICAgICAgICB9KVxuXG4gICAgICAgIGlmICghaXNGdWxsUHJlZmV0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTGF6eVByZWZldGNoRW50cnkoe1xuICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG5leHRVcmwsXG4gICAgICAgICAgICBwcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGdldCBhbiBleHBsaWNpdCBwcmVmZXRjaCBraW5kLCB3ZSB3YW50IHRvIHNldCBhIHRlbXBvcmFyeSBraW5kXG4gICAgICAgICAgICAvLyByYXRoZXIgdGhhbiBhc3N1bWluZyB0aGUgc2FtZSBpbnRlbnQgYXMgdGhlIHByZXZpb3VzIGVudHJ5LCB0byBiZSBjb25zaXN0ZW50IHdpdGggaG93IHdlXG4gICAgICAgICAgICAvLyBsYXppbHkgY3JlYXRlIHByZWZldGNoIGVudHJpZXMgd2hlbiBpbnRlbnQgaXMgbGVmdCB1bnNwZWNpZmllZC5cbiAgICAgICAgICAgIGtpbmQ6IGtpbmQgPz8gUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBleGlzdGluZyBjYWNoZSBlbnRyeSB3YXMgbWFya2VkIGFzIHRlbXBvcmFyeSwgaXQgbWVhbnMgaXQgd2FzIGxhemlseSBjcmVhdGVkIHdoZW4gYXR0ZW1wdGluZyB0byBnZXQgYW4gZW50cnksXG4gICAgLy8gd2hlcmUgd2UgZGlkbid0IGhhdmUgdGhlIHByZWZldGNoIGludGVudC4gTm93IHRoYXQgd2UgaGF2ZSB0aGUgaW50ZW50IChpbiBga2luZGApLCB3ZSB3YW50IHRvIHVwZGF0ZSB0aGUgZW50cnkgdG8gdGhlIG1vcmUgYWNjdXJhdGUga2luZC5cbiAgICBpZiAoa2luZCAmJiBleGlzdGluZ0NhY2hlRW50cnkua2luZCA9PT0gUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWSkge1xuICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgPSBraW5kXG4gICAgfVxuXG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IHRoZSBleGlzdGluZyBlbnRyeSB3ZSBmb3VuZCBpcyBzdGlsbCB2YWxpZCwgc28gd2UgcmV0dXJuIGl0LlxuICAgIHJldHVybiBleGlzdGluZ0NhY2hlRW50cnlcbiAgfVxuXG4gIC8vIElmIHdlIGRpZG4ndCByZXR1cm4gYW4gZW50cnksIGNyZWF0ZSBhIG5ldyBvbmUuXG4gIHJldHVybiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gICAgdHJlZSxcbiAgICB1cmwsXG4gICAgbmV4dFVybCxcbiAgICBwcmVmZXRjaENhY2hlLFxuICAgIGtpbmQ6IGtpbmQgfHwgUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWSxcbiAgfSlcbn1cblxuLypcbiAqIFVzZWQgdG8gdGFrZSBhbiBleGlzdGluZyBjYWNoZSBlbnRyeSBhbmQgcHJlZml4IGl0IHdpdGggdGhlIG5leHRVcmwsIGlmIGl0IGV4aXN0cy5cbiAqIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IGhhdmUgY29uZmxpY3RpbmcgY2FjaGUgZW50cmllcyBmb3IgdGhlIHNhbWUgVVJMIChhcyBpcyB0aGUgY2FzZSB3aXRoIHJvdXRlIGludGVyY2VwdGlvbikuXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEV4aXN0aW5nUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgdXJsLFxuICBuZXh0VXJsLFxuICBwcmVmZXRjaENhY2hlLFxuICBleGlzdGluZ0NhY2hlS2V5LFxufTogUGljazxSZWFkb25seVJlZHVjZXJTdGF0ZSwgJ25leHRVcmwnIHwgJ3ByZWZldGNoQ2FjaGUnPiAmIHtcbiAgdXJsOiBVUkxcbiAgZXhpc3RpbmdDYWNoZUtleTogc3RyaW5nXG59KSB7XG4gIGNvbnN0IGV4aXN0aW5nQ2FjaGVFbnRyeSA9IHByZWZldGNoQ2FjaGUuZ2V0KGV4aXN0aW5nQ2FjaGVLZXkpXG4gIGlmICghZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgLy8gbm8tb3AgLS0gdGhlcmUgd2Fzbid0IGFuIGVudHJ5IHRvIG1vdmVcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IG5ld0NhY2hlS2V5ID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleShcbiAgICB1cmwsXG4gICAgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQsXG4gICAgbmV4dFVybFxuICApXG4gIHByZWZldGNoQ2FjaGUuc2V0KG5ld0NhY2hlS2V5LCB7IC4uLmV4aXN0aW5nQ2FjaGVFbnRyeSwga2V5OiBuZXdDYWNoZUtleSB9KVxuICBwcmVmZXRjaENhY2hlLmRlbGV0ZShleGlzdGluZ0NhY2hlS2V5KVxuXG4gIHJldHVybiBuZXdDYWNoZUtleVxufVxuXG4vKipcbiAqIFVzZSB0byBzZWVkIHRoZSBwcmVmZXRjaCBjYWNoZSB3aXRoIGRhdGEgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGZldGNoZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkoe1xuICBuZXh0VXJsLFxuICB0cmVlLFxuICBwcmVmZXRjaENhY2hlLFxuICB1cmwsXG4gIGRhdGEsXG4gIGtpbmQsXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAndHJlZScgfCAncHJlZmV0Y2hDYWNoZSc+ICYge1xuICB1cmw6IFVSTFxuICBkYXRhOiBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0XG4gIGtpbmQ6IFByZWZldGNoS2luZFxufSkge1xuICAvLyBUaGUgaW5pdGlhbCBjYWNoZSBlbnRyeSB0ZWNobmljYWxseSBpbmNsdWRlcyBmdWxsIGRhdGEsIGJ1dCBpdCBpc24ndCBleHBsaWNpdGx5IHByZWZldGNoZWQgLS0gd2UganVzdCBzZWVkIHRoZVxuICAvLyBwcmVmZXRjaCBjYWNoZSBzbyB0aGF0IHdlIGNhbiBza2lwIGFuIGV4dHJhIHByZWZldGNoIHJlcXVlc3QgbGF0ZXIsIHNpbmNlIHdlIGFscmVhZHkgaGF2ZSB0aGUgZGF0YS5cbiAgLy8gaWYgdGhlIHByZWZldGNoIGNvcnJlc3BvbmRzIHdpdGggYW4gaW50ZXJjZXB0aW9uIHJvdXRlLCB3ZSB1c2UgdGhlIG5leHRVcmwgdG8gcHJlZml4IHRoZSBjYWNoZSBrZXlcbiAgY29uc3QgcHJlZmV0Y2hDYWNoZUtleSA9IGRhdGEuY291bGRCZUludGVyY2VwdGVkXG4gICAgPyBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCwga2luZCwgbmV4dFVybClcbiAgICA6IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkodXJsLCBraW5kKVxuXG4gIGNvbnN0IHByZWZldGNoRW50cnkgPSB7XG4gICAgdHJlZUF0VGltZU9mUHJlZmV0Y2g6IHRyZWUsXG4gICAgZGF0YTogUHJvbWlzZS5yZXNvbHZlKGRhdGEpLFxuICAgIGtpbmQsXG4gICAgcHJlZmV0Y2hUaW1lOiBEYXRlLm5vdygpLFxuICAgIGxhc3RVc2VkVGltZTogRGF0ZS5ub3coKSxcbiAgICBzdGFsZVRpbWU6IC0xLFxuICAgIGtleTogcHJlZmV0Y2hDYWNoZUtleSxcbiAgICBzdGF0dXM6IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5mcmVzaCxcbiAgICB1cmwsXG4gIH0gc2F0aXNmaWVzIFByZWZldGNoQ2FjaGVFbnRyeVxuXG4gIHByZWZldGNoQ2FjaGUuc2V0KHByZWZldGNoQ2FjaGVLZXksIHByZWZldGNoRW50cnkpXG5cbiAgcmV0dXJuIHByZWZldGNoRW50cnlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcHJlZmV0Y2ggZW50cnkgZW50cnkgYW5kIGVucXVldWVzIGEgZmV0Y2ggcmVxdWVzdCB0byByZXRyaWV2ZSB0aGUgZGF0YS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTGF6eVByZWZldGNoRW50cnkoe1xuICB1cmwsXG4gIGtpbmQsXG4gIHRyZWUsXG4gIG5leHRVcmwsXG4gIHByZWZldGNoQ2FjaGUsXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAndHJlZScgfCAncHJlZmV0Y2hDYWNoZSc+ICYge1xuICB1cmw6IFVSTFxuICBraW5kOiBQcmVmZXRjaEtpbmRcbn0pOiBQcmVmZXRjaENhY2hlRW50cnkge1xuICBjb25zdCBwcmVmZXRjaENhY2hlS2V5ID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQpXG5cbiAgLy8gaW5pdGlhdGVzIHRoZSBmZXRjaCByZXF1ZXN0IGZvciB0aGUgcHJlZmV0Y2ggYW5kIGF0dGFjaGVzIGEgbGlzdGVuZXJcbiAgLy8gdG8gdGhlIHByb21pc2UgdG8gdXBkYXRlIHRoZSBwcmVmZXRjaCBjYWNoZSBlbnRyeSB3aGVuIHRoZSBwcm9taXNlIHJlc29sdmVzIChpZiBuZWNlc3NhcnkpXG4gIGNvbnN0IGRhdGEgPSBwcmVmZXRjaFF1ZXVlLmVucXVldWUoKCkgPT5cbiAgICBmZXRjaFNlcnZlclJlc3BvbnNlKHVybCwge1xuICAgICAgZmxpZ2h0Um91dGVyU3RhdGU6IHRyZWUsXG4gICAgICBuZXh0VXJsLFxuICAgICAgcHJlZmV0Y2hLaW5kOiBraW5kLFxuICAgIH0pLnRoZW4oKHByZWZldGNoUmVzcG9uc2UpID0+IHtcbiAgICAgIC8vIFRPRE86IGBmZXRjaFNlcnZlclJlc3BvbnNlYCBzaG91bGQgYmUgbW9yZSB0aWdobHkgY291cGxlZCB0byB0aGVzZSBwcmVmZXRjaCBjYWNoZSBvcGVyYXRpb25zXG4gICAgICAvLyB0byBhdm9pZCBkcmlmdCBiZXR3ZWVuIHRoaXMgY2FjaGUga2V5IHByZWZpeGluZyBsb2dpY1xuICAgICAgLy8gKHdoaWNoIGlzIGN1cnJlbnRseSBkaXJlY3RseSBpbmZsdWVuY2VkIGJ5IHRoZSBzZXJ2ZXIgcmVzcG9uc2UpXG4gICAgICBsZXQgbmV3Q2FjaGVLZXlcblxuICAgICAgaWYgKHByZWZldGNoUmVzcG9uc2UuY291bGRCZUludGVyY2VwdGVkKSB7XG4gICAgICAgIC8vIERldGVybWluZSBpZiB3ZSBuZWVkIHRvIHByZWZpeCB0aGUgY2FjaGUga2V5IHdpdGggdGhlIG5leHRVcmxcbiAgICAgICAgbmV3Q2FjaGVLZXkgPSBwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeSh7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGV4aXN0aW5nQ2FjaGVLZXk6IHByZWZldGNoQ2FjaGVLZXksXG4gICAgICAgICAgbmV4dFVybCxcbiAgICAgICAgICBwcmVmZXRjaENhY2hlLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgcHJlZmV0Y2ggd2FzIGEgY2FjaGUgaGl0LCB3ZSB3YW50IHRvIHVwZGF0ZSB0aGUgZXhpc3RpbmcgY2FjaGUgZW50cnkgdG8gcmVmbGVjdCB0aGF0IGl0IHdhcyBhIGZ1bGwgcHJlZmV0Y2guXG4gICAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2Uga25vdyB0aGF0IGEgc3RhdGljIHJlc3BvbnNlIHdpbGwgY29udGFpbiB0aGUgZnVsbCBSU0MgcGF5bG9hZCwgYW5kIGNhbiBiZSB1cGRhdGVkIHRvIHJlc3BlY3QgdGhlIGBzdGF0aWNgXG4gICAgICAvLyBzdGFsZVRpbWUuXG4gICAgICBpZiAocHJlZmV0Y2hSZXNwb25zZS5wcmVyZW5kZXJlZCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0NhY2hlRW50cnkgPSBwcmVmZXRjaENhY2hlLmdldChcbiAgICAgICAgICAvLyBpZiB3ZSBwcmVmaXhlZCB0aGUgY2FjaGUga2V5IGR1ZSB0byByb3V0ZSBpbnRlcmNlcHRpb24sIHdlIHdhbnQgdG8gdXNlIHRoZSBuZXcga2V5LiBPdGhlcndpc2Ugd2UgdXNlIHRoZSBvcmlnaW5hbCBrZXlcbiAgICAgICAgICBuZXdDYWNoZUtleSA/PyBwcmVmZXRjaENhY2hlS2V5XG4gICAgICAgIClcbiAgICAgICAgaWYgKGV4aXN0aW5nQ2FjaGVFbnRyeSkge1xuICAgICAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID0gUHJlZmV0Y2hLaW5kLkZVTExcbiAgICAgICAgICBpZiAocHJlZmV0Y2hSZXNwb25zZS5zdGFsZVRpbWUgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBzdGFsZSB0aW1lIHRoYXQgd2FzIGNvbGxlY3RlZCBieSB0aGUgc2VydmVyIGR1cmluZ1xuICAgICAgICAgICAgLy8gc3RhdGljIGdlbmVyYXRpb24uIFVzZSB0aGlzIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IHN0YWxlIHRpbWUuXG4gICAgICAgICAgICBleGlzdGluZ0NhY2hlRW50cnkuc3RhbGVUaW1lID0gcHJlZmV0Y2hSZXNwb25zZS5zdGFsZVRpbWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZWZldGNoUmVzcG9uc2VcbiAgICB9KVxuICApXG5cbiAgY29uc3QgcHJlZmV0Y2hFbnRyeSA9IHtcbiAgICB0cmVlQXRUaW1lT2ZQcmVmZXRjaDogdHJlZSxcbiAgICBkYXRhLFxuICAgIGtpbmQsXG4gICAgcHJlZmV0Y2hUaW1lOiBEYXRlLm5vdygpLFxuICAgIGxhc3RVc2VkVGltZTogbnVsbCxcbiAgICBzdGFsZVRpbWU6IC0xLFxuICAgIGtleTogcHJlZmV0Y2hDYWNoZUtleSxcbiAgICBzdGF0dXM6IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5mcmVzaCxcbiAgICB1cmwsXG4gIH1cblxuICBwcmVmZXRjaENhY2hlLnNldChwcmVmZXRjaENhY2hlS2V5LCBwcmVmZXRjaEVudHJ5KVxuXG4gIHJldHVybiBwcmVmZXRjaEVudHJ5XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcnVuZVByZWZldGNoQ2FjaGUoXG4gIHByZWZldGNoQ2FjaGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlWydwcmVmZXRjaENhY2hlJ11cbikge1xuICBmb3IgKGNvbnN0IFtocmVmLCBwcmVmZXRjaENhY2hlRW50cnldIG9mIHByZWZldGNoQ2FjaGUpIHtcbiAgICBpZiAoXG4gICAgICBnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMocHJlZmV0Y2hDYWNoZUVudHJ5KSA9PT1cbiAgICAgIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5leHBpcmVkXG4gICAgKSB7XG4gICAgICBwcmVmZXRjaENhY2hlLmRlbGV0ZShocmVmKVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGVzZSB2YWx1ZXMgYXJlIHNldCBieSBgZGVmaW5lLWVudi1wbHVnaW5gIChiYXNlZCBvbiBgbmV4dENvbmZpZy5leHBlcmltZW50YWwuc3RhbGVUaW1lc2ApXG4vLyBhbmQgZGVmYXVsdCB0byA1IG1pbnV0ZXMgKHN0YXRpYykgLyAwIHNlY29uZHMgKGR5bmFtaWMpXG5leHBvcnQgY29uc3QgRFlOQU1JQ19TVEFMRVRJTUVfTVMgPVxuICBOdW1iZXIocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRFlOQU1JQ19TVEFMRVRJTUUpICogMTAwMFxuXG5leHBvcnQgY29uc3QgU1RBVElDX1NUQUxFVElNRV9NUyA9XG4gIE51bWJlcihwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9TVEFUSUNfU1RBTEVUSU1FKSAqIDEwMDBcblxuZnVuY3Rpb24gZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzKHtcbiAga2luZCxcbiAgcHJlZmV0Y2hUaW1lLFxuICBsYXN0VXNlZFRpbWUsXG4gIHN0YWxlVGltZSxcbn06IFByZWZldGNoQ2FjaGVFbnRyeSk6IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyB7XG4gIGlmIChzdGFsZVRpbWUgIT09IC0xKSB7XG4gICAgLy8gYHN0YWxlVGltZWAgaXMgdGhlIHZhbHVlIHNlbnQgYnkgdGhlIHNlcnZlciBkdXJpbmcgc3RhdGljIGdlbmVyYXRpb24uXG4gICAgLy8gV2hlbiB0aGlzIGlzIGF2YWlsYWJsZSwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGFueSBvZiB0aGUgaGV1cmlzdGljc1xuICAgIC8vIHRoYXQgZm9sbG93LlxuICAgIC8vXG4gICAgLy8gVE9ETzogV2hlbiBQUFIgaXMgZW5hYmxlZCwgdGhlIHNlcnZlciB3aWxsICphbHdheXMqIHJldHVybiBhIHN0YWxlIHRpbWVcbiAgICAvLyB3aGVuIHByZWZldGNoaW5nLiBXZSBzaG91bGQgbmV2ZXIgdXNlIGEgcHJlZmV0Y2ggZW50cnkgdGhhdCBoYXNuJ3QgeWV0XG4gICAgLy8gcmVjZWl2ZWQgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuIFNvIHRoZSBvbmx5IHR3byBjYXNlcyBzaG91bGQgYmUgMSkgd2UgdXNlXG4gICAgLy8gdGhlIHNlcnZlci1nZW5lcmF0ZWQgc3RhbGUgdGltZSAyKSB0aGUgdW5yZXNvbHZlZCBlbnRyeSBpcyBkaXNjYXJkZWQuXG4gICAgcmV0dXJuIERhdGUubm93KCkgPCBwcmVmZXRjaFRpbWUgKyBzdGFsZVRpbWVcbiAgICAgID8gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoXG4gICAgICA6IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5zdGFsZVxuICB9XG5cbiAgLy8gV2Ugd2lsbCByZS11c2UgdGhlIGNhY2hlIGVudHJ5IGRhdGEgZm9yIHVwIHRvIHRoZSBgZHluYW1pY2Agc3RhbGV0aW1lIHdpbmRvdy5cbiAgaWYgKERhdGUubm93KCkgPCAobGFzdFVzZWRUaW1lID8/IHByZWZldGNoVGltZSkgKyBEWU5BTUlDX1NUQUxFVElNRV9NUykge1xuICAgIHJldHVybiBsYXN0VXNlZFRpbWVcbiAgICAgID8gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnJldXNhYmxlXG4gICAgICA6IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5mcmVzaFxuICB9XG5cbiAgLy8gRm9yIFwiYXV0b1wiIHByZWZldGNoaW5nLCB3ZSdsbCByZS11c2Ugb25seSB0aGUgbG9hZGluZyBib3VuZGFyeSBmb3IgdXAgdG8gYHN0YXRpY2Agc3RhbGV0aW1lIHdpbmRvdy5cbiAgLy8gQSBzdGFsZSBlbnRyeSB3aWxsIG9ubHkgcmUtdXNlIHRoZSBgbG9hZGluZ2AgYm91bmRhcnksIG5vdCB0aGUgZnVsbCBkYXRhLlxuICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIFwibGF6eSBmZXRjaFwiIGZvciB0aGUgZnVsbCBkYXRhLlxuICBpZiAoa2luZCA9PT0gUHJlZmV0Y2hLaW5kLkFVVE8pIHtcbiAgICBpZiAoRGF0ZS5ub3coKSA8IHByZWZldGNoVGltZSArIFNUQVRJQ19TVEFMRVRJTUVfTVMpIHtcbiAgICAgIHJldHVybiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuc3RhbGVcbiAgICB9XG4gIH1cblxuICAvLyBmb3IgXCJmdWxsXCIgcHJlZmV0Y2hpbmcsIHdlJ2xsIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgZGF0YSBmb3IgdXAgdG8gYHN0YXRpY2Agc3RhbGV0aW1lIHdpbmRvdy5cbiAgaWYgKGtpbmQgPT09IFByZWZldGNoS2luZC5GVUxMKSB7XG4gICAgaWYgKERhdGUubm93KCkgPCBwcmVmZXRjaFRpbWUgKyBTVEFUSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgICByZXR1cm4gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnJldXNhYmxlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5leHBpcmVkXG59XG4iXSwibmFtZXMiOlsiRFlOQU1JQ19TVEFMRVRJTUVfTVMiLCJTVEFUSUNfU1RBTEVUSU1FX01TIiwiY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5IiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUiIsImNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsIiwidXJsIiwiaW5jbHVkZVNlYXJjaFBhcmFtcyIsInByZWZpeCIsInBhdGhuYW1lRnJvbVVybCIsInBhdGhuYW1lIiwic2VhcmNoIiwiY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSIsImtpbmQiLCJuZXh0VXJsIiwiUHJlZmV0Y2hLaW5kIiwiRlVMTCIsImdldEV4aXN0aW5nQ2FjaGVFbnRyeSIsInByZWZldGNoQ2FjaGUiLCJhbGxvd0FsaWFzaW5nIiwiVEVNUE9SQVJZIiwibWF5YmVOZXh0VXJsIiwiY2FjaGVLZXlXaXRoUGFyYW1zIiwiY2FjaGVLZXlXaXRob3V0UGFyYW1zIiwiY2FjaGVLZXlUb1VzZSIsImV4aXN0aW5nRW50cnkiLCJnZXQiLCJpc0FsaWFzZWQiLCJhbGlhc2VkIiwiZW50cnlXaXRob3V0UGFyYW1zIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwia2V5IiwiaW5jbHVkZXMiLCJjYWNoZUVudHJ5IiwidmFsdWVzIiwidW5kZWZpbmVkIiwidHJlZSIsImV4aXN0aW5nQ2FjaGVFbnRyeSIsInN0YXR1cyIsImdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyIsInN3aXRjaGVkVG9GdWxsUHJlZmV0Y2giLCJkYXRhIiwidGhlbiIsInByZWZldGNoUmVzcG9uc2UiLCJpc0Z1bGxQcmVmZXRjaCIsIkFycmF5IiwiaXNBcnJheSIsImZsaWdodERhdGEiLCJzb21lIiwiaXNSb290UmVuZGVyIiwic2VlZERhdGEiLCJjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSIsInByZWZpeEV4aXN0aW5nUHJlZmV0Y2hDYWNoZUVudHJ5IiwiZXhpc3RpbmdDYWNoZUtleSIsIm5ld0NhY2hlS2V5Iiwic2V0IiwiZGVsZXRlIiwicHJlZmV0Y2hDYWNoZUtleSIsImNvdWxkQmVJbnRlcmNlcHRlZCIsInByZWZldGNoRW50cnkiLCJ0cmVlQXRUaW1lT2ZQcmVmZXRjaCIsIlByb21pc2UiLCJyZXNvbHZlIiwicHJlZmV0Y2hUaW1lIiwiRGF0ZSIsIm5vdyIsImxhc3RVc2VkVGltZSIsInN0YWxlVGltZSIsIlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyIsImZyZXNoIiwicHJlZmV0Y2hRdWV1ZSIsImVucXVldWUiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJwcmVmZXRjaEtpbmQiLCJwcmVyZW5kZXJlZCIsImhyZWYiLCJwcmVmZXRjaENhY2hlRW50cnkiLCJleHBpcmVkIiwiTnVtYmVyIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRFlOQU1JQ19TVEFMRVRJTUUiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9TVEFUSUNfU1RBTEVUSU1FIiwic3RhbGUiLCJyZXVzYWJsZSIsIkFVVE8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"findHeadInCache\", ({\n    enumerable: true,\n    get: function() {\n        return findHeadInCache;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ../create-router-cache-key */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nfunction findHeadInCache(cache, parallelRoutes) {\n    return findHeadInCacheImpl(cache, parallelRoutes, '');\n}\nfunction findHeadInCacheImpl(cache, parallelRoutes, keyPrefix) {\n    const isLastItem = Object.keys(parallelRoutes).length === 0;\n    if (isLastItem) {\n        // Returns the entire Cache Node of the segment whose head we will render.\n        return [\n            cache,\n            keyPrefix\n        ];\n    }\n    // First try the 'children' parallel route if it exists\n    // when starting from the \"root\", this corresponds with the main page component\n    if (parallelRoutes.children) {\n        const [segment, childParallelRoutes] = parallelRoutes.children;\n        const childSegmentMap = cache.parallelRoutes.get('children');\n        if (childSegmentMap) {\n            const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n            const cacheNode = childSegmentMap.get(cacheKey);\n            if (cacheNode) {\n                const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + '/' + cacheKey);\n                if (item) return item;\n            }\n        }\n    }\n    // if we didn't find metadata in the page slot, check the other parallel routes\n    for(const key in parallelRoutes){\n        if (key === 'children') continue; // already checked above\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        const childSegmentMap = cache.parallelRoutes.get(key);\n        if (!childSegmentMap) {\n            continue;\n        }\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + '/' + cacheKey);\n        if (item) {\n            return item;\n        }\n    }\n    return null;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=find-head-in-cache.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmluZC1oZWFkLWluLWNhY2hlLmpzIiwibWFwcGluZ3MiOiI7Ozs7bURBSWdCQTs7O2VBQUFBOzs7a0RBRnFCO0FBRTlCLFNBQVNBLGdCQUNkQyxLQUFnQixFQUNoQkMsY0FBb0M7SUFFcEMsT0FBT0Msb0JBQW9CRixPQUFPQyxnQkFBZ0I7QUFDcEQ7QUFFQSxTQUFTQyxvQkFDUEYsS0FBZ0IsRUFDaEJDLGNBQW9DLEVBQ3BDRSxTQUFpQjtJQUVqQixNQUFNQyxhQUFhQyxPQUFPQyxJQUFJLENBQUNMLGdCQUFnQk0sTUFBTSxLQUFLO0lBQzFELElBQUlILFlBQVk7UUFDZCwwRUFBMEU7UUFDMUUsT0FBTztZQUFDSjtZQUFPRztTQUFVO0lBQzNCO0lBRUEsdURBQXVEO0lBQ3ZELCtFQUErRTtJQUMvRSxJQUFJRixlQUFlTyxRQUFRLEVBQUU7UUFDM0IsTUFBTSxDQUFDQyxTQUFTQyxvQkFBb0IsR0FBR1QsZUFBZU8sUUFBUTtRQUM5RCxNQUFNRyxrQkFBa0JYLE1BQU1DLGNBQWMsQ0FBQ1csR0FBRyxDQUFDO1FBQ2pELElBQUlELGlCQUFpQjtZQUNuQixNQUFNRSxXQUFXQyxDQUFBQSxHQUFBQSxzQkFBQUEsb0JBQUFBLEVBQXFCTDtZQUN0QyxNQUFNTSxZQUFZSixnQkFBZ0JDLEdBQUcsQ0FBQ0M7WUFDdEMsSUFBSUUsV0FBVztnQkFDYixNQUFNQyxPQUFPZCxvQkFDWGEsV0FDQUwscUJBQ0FQLFlBQVksTUFBTVU7Z0JBRXBCLElBQUlHLE1BQU0sT0FBT0E7WUFDbkI7UUFDRjtJQUNGO0lBRUEsK0VBQStFO0lBQy9FLElBQUssTUFBTUMsT0FBT2hCLGVBQWdCO1FBQ2hDLElBQUlnQixRQUFRLFlBQVksVUFBUyx3QkFBd0I7UUFFekQsTUFBTSxDQUFDUixTQUFTQyxvQkFBb0IsR0FBR1QsY0FBYyxDQUFDZ0IsSUFBSTtRQUMxRCxNQUFNTixrQkFBa0JYLE1BQU1DLGNBQWMsQ0FBQ1csR0FBRyxDQUFDSztRQUNqRCxJQUFJLENBQUNOLGlCQUFpQjtZQUNwQjtRQUNGO1FBRUEsTUFBTUUsV0FBV0MsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFBQSxFQUFxQkw7UUFFdEMsTUFBTU0sWUFBWUosZ0JBQWdCQyxHQUFHLENBQUNDO1FBQ3RDLElBQUksQ0FBQ0UsV0FBVztZQUNkO1FBQ0Y7UUFFQSxNQUFNQyxPQUFPZCxvQkFDWGEsV0FDQUwscUJBQ0FQLFlBQVksTUFBTVU7UUFFcEIsSUFBSUcsTUFBTTtZQUNSLE9BQU9BO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccmVkdWNlcnNcXGZpbmQtaGVhZC1pbi1jYWNoZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyQ2FjaGVLZXkgfSBmcm9tICcuLi9jcmVhdGUtcm91dGVyLWNhY2hlLWtleSdcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRIZWFkSW5DYWNoZShcbiAgY2FjaGU6IENhY2hlTm9kZSxcbiAgcGFyYWxsZWxSb3V0ZXM6IEZsaWdodFJvdXRlclN0YXRlWzFdXG4pOiBbQ2FjaGVOb2RlLCBzdHJpbmddIHwgbnVsbCB7XG4gIHJldHVybiBmaW5kSGVhZEluQ2FjaGVJbXBsKGNhY2hlLCBwYXJhbGxlbFJvdXRlcywgJycpXG59XG5cbmZ1bmN0aW9uIGZpbmRIZWFkSW5DYWNoZUltcGwoXG4gIGNhY2hlOiBDYWNoZU5vZGUsXG4gIHBhcmFsbGVsUm91dGVzOiBGbGlnaHRSb3V0ZXJTdGF0ZVsxXSxcbiAga2V5UHJlZml4OiBzdHJpbmdcbik6IFtDYWNoZU5vZGUsIHN0cmluZ10gfCBudWxsIHtcbiAgY29uc3QgaXNMYXN0SXRlbSA9IE9iamVjdC5rZXlzKHBhcmFsbGVsUm91dGVzKS5sZW5ndGggPT09IDBcbiAgaWYgKGlzTGFzdEl0ZW0pIHtcbiAgICAvLyBSZXR1cm5zIHRoZSBlbnRpcmUgQ2FjaGUgTm9kZSBvZiB0aGUgc2VnbWVudCB3aG9zZSBoZWFkIHdlIHdpbGwgcmVuZGVyLlxuICAgIHJldHVybiBbY2FjaGUsIGtleVByZWZpeF1cbiAgfVxuXG4gIC8vIEZpcnN0IHRyeSB0aGUgJ2NoaWxkcmVuJyBwYXJhbGxlbCByb3V0ZSBpZiBpdCBleGlzdHNcbiAgLy8gd2hlbiBzdGFydGluZyBmcm9tIHRoZSBcInJvb3RcIiwgdGhpcyBjb3JyZXNwb25kcyB3aXRoIHRoZSBtYWluIHBhZ2UgY29tcG9uZW50XG4gIGlmIChwYXJhbGxlbFJvdXRlcy5jaGlsZHJlbikge1xuICAgIGNvbnN0IFtzZWdtZW50LCBjaGlsZFBhcmFsbGVsUm91dGVzXSA9IHBhcmFsbGVsUm91dGVzLmNoaWxkcmVuXG4gICAgY29uc3QgY2hpbGRTZWdtZW50TWFwID0gY2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KCdjaGlsZHJlbicpXG4gICAgaWYgKGNoaWxkU2VnbWVudE1hcCkge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50KVxuICAgICAgY29uc3QgY2FjaGVOb2RlID0gY2hpbGRTZWdtZW50TWFwLmdldChjYWNoZUtleSlcbiAgICAgIGlmIChjYWNoZU5vZGUpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGZpbmRIZWFkSW5DYWNoZUltcGwoXG4gICAgICAgICAgY2FjaGVOb2RlLFxuICAgICAgICAgIGNoaWxkUGFyYWxsZWxSb3V0ZXMsXG4gICAgICAgICAga2V5UHJlZml4ICsgJy8nICsgY2FjaGVLZXlcbiAgICAgICAgKVxuICAgICAgICBpZiAoaXRlbSkgcmV0dXJuIGl0ZW1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBtZXRhZGF0YSBpbiB0aGUgcGFnZSBzbG90LCBjaGVjayB0aGUgb3RoZXIgcGFyYWxsZWwgcm91dGVzXG4gIGZvciAoY29uc3Qga2V5IGluIHBhcmFsbGVsUm91dGVzKSB7XG4gICAgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykgY29udGludWUgLy8gYWxyZWFkeSBjaGVja2VkIGFib3ZlXG5cbiAgICBjb25zdCBbc2VnbWVudCwgY2hpbGRQYXJhbGxlbFJvdXRlc10gPSBwYXJhbGxlbFJvdXRlc1trZXldXG4gICAgY29uc3QgY2hpbGRTZWdtZW50TWFwID0gY2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSlcbiAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnQpXG5cbiAgICBjb25zdCBjYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KVxuICAgIGlmICghY2FjaGVOb2RlKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IGl0ZW0gPSBmaW5kSGVhZEluQ2FjaGVJbXBsKFxuICAgICAgY2FjaGVOb2RlLFxuICAgICAgY2hpbGRQYXJhbGxlbFJvdXRlcyxcbiAgICAgIGtleVByZWZpeCArICcvJyArIGNhY2hlS2V5XG4gICAgKVxuICAgIGlmIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iXSwibmFtZXMiOlsiZmluZEhlYWRJbkNhY2hlIiwiY2FjaGUiLCJwYXJhbGxlbFJvdXRlcyIsImZpbmRIZWFkSW5DYWNoZUltcGwiLCJrZXlQcmVmaXgiLCJpc0xhc3RJdGVtIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImNoaWxkcmVuIiwic2VnbWVudCIsImNoaWxkUGFyYWxsZWxSb3V0ZXMiLCJjaGlsZFNlZ21lbnRNYXAiLCJnZXQiLCJjYWNoZUtleSIsImNyZWF0ZVJvdXRlckNhY2hlS2V5IiwiY2FjaGVOb2RlIiwiaXRlbSIsImtleSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSegmentValue\", ({\n    enumerable: true,\n    get: function() {\n        return getSegmentValue;\n    }\n}));\nfunction getSegmentValue(segment) {\n    return Array.isArray(segment) ? segment[1] : segment;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-segment-value.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZ2V0LXNlZ21lbnQtdmFsdWUuanMiLCJtYXBwaW5ncyI6Ijs7OzttREFFZ0JBOzs7ZUFBQUE7OztBQUFULFNBQVNBLGdCQUFnQkMsT0FBZ0I7SUFDOUMsT0FBT0MsTUFBTUMsT0FBTyxDQUFDRixXQUFXQSxPQUFPLENBQUMsRUFBRSxHQUFHQTtBQUMvQyIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccmVkdWNlcnNcXGdldC1zZWdtZW50LXZhbHVlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgU2VnbWVudCB9IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VnbWVudFZhbHVlKHNlZ21lbnQ6IFNlZ21lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc2VnbWVudCkgPyBzZWdtZW50WzFdIDogc2VnbWVudFxufVxuIl0sIm5hbWVzIjpbImdldFNlZ21lbnRWYWx1ZSIsInNlZ21lbnQiLCJBcnJheSIsImlzQXJyYXkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hasInterceptionRouteInCurrentTree\", ({\n    enumerable: true,\n    get: function() {\n        return hasInterceptionRouteInCurrentTree;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../shared/lib/router/utils/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interception-routes.js\");\nfunction hasInterceptionRouteInCurrentTree(param) {\n    let [segment, parallelRoutes] = param;\n    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n    if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\n        return true;\n    }\n    // If segment is not an array, apply the existing string-based check\n    if (typeof segment === 'string' && (0, _interceptionroutes.isInterceptionRouteAppPath)(segment)) {\n        return true;\n    }\n    // Iterate through parallelRoutes if they exist\n    if (parallelRoutes) {\n        for(const key in parallelRoutes){\n            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-interception-route-in-current-tree.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUuanMiLCJtYXBwaW5ncyI6Ijs7OztxRUFHZ0JBOzs7ZUFBQUE7OztnREFGMkI7QUFFcEMsU0FBU0Esa0NBQWtDLEtBRzlCO0lBSDhCLEtBQ2hEQyxTQUNBQyxlQUNrQixHQUg4QjtJQUloRCx3R0FBd0c7SUFDeEcsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSCxZQUFhQSxDQUFBQSxPQUFPLENBQUMsRUFBRSxLQUFLLFFBQVFBLE9BQU8sQ0FBQyxFQUFFLEtBQUssS0FBRyxFQUFJO1FBQzFFLE9BQU87SUFDVDtJQUVBLG9FQUFvRTtJQUNwRSxJQUFJLE9BQU9BLFlBQVksWUFBWUksQ0FBQUEsR0FBQUEsb0JBQUFBLDBCQUFBQSxFQUEyQkosVUFBVTtRQUN0RSxPQUFPO0lBQ1Q7SUFFQSwrQ0FBK0M7SUFDL0MsSUFBSUMsZ0JBQWdCO1FBQ2xCLElBQUssTUFBTUksT0FBT0osZUFBZ0I7WUFDaEMsSUFBSUYsa0NBQWtDRSxjQUFjLENBQUNJLElBQUksR0FBRztnQkFDMUQsT0FBTztZQUNUO1FBQ0Y7SUFDRjtJQUVBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccmVkdWNlcnNcXGhhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IGlzSW50ZXJjZXB0aW9uUm91dGVBcHBQYXRoIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJjZXB0aW9uLXJvdXRlcydcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZShbXG4gIHNlZ21lbnQsXG4gIHBhcmFsbGVsUm91dGVzLFxuXTogRmxpZ2h0Um91dGVyU3RhdGUpOiBib29sZWFuIHtcbiAgLy8gSWYgd2UgaGF2ZSBhIGR5bmFtaWMgc2VnbWVudCwgaXQncyBtYXJrZWQgYXMgYW4gaW50ZXJjZXB0aW9uIHJvdXRlIGJ5IHRoZSBwcmVzZW5jZSBvZiB0aGUgYGlgIHN1ZmZpeC5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VnbWVudCkgJiYgKHNlZ21lbnRbMl0gPT09ICdkaScgfHwgc2VnbWVudFsyXSA9PT0gJ2NpJykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSWYgc2VnbWVudCBpcyBub3QgYW4gYXJyYXksIGFwcGx5IHRoZSBleGlzdGluZyBzdHJpbmctYmFzZWQgY2hlY2tcbiAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJyAmJiBpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aChzZWdtZW50KSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBJdGVyYXRlIHRocm91Z2ggcGFyYWxsZWxSb3V0ZXMgaWYgdGhleSBleGlzdFxuICBpZiAocGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcykge1xuICAgICAgaWYgKGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZShwYXJhbGxlbFJvdXRlc1trZXldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIl0sIm5hbWVzIjpbImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsInNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlcyIsIkFycmF5IiwiaXNBcnJheSIsImlzSW50ZXJjZXB0aW9uUm91dGVBcHBQYXRoIiwia2V5Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hmrRefreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return hmrRefreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    const navigatedAt = Date.now();\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n        isHmrRefresh: true\n    });\n    return cache.lazyData.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction hmrRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst hmrRefreshReducer =  false ? 0 : hmrRefreshReducerImpl;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hmr-refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaG1yLXJlZnJlc2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O3FEQStIYUE7OztlQUFBQTs7O2lEQS9IdUI7K0NBQ0Y7eURBQ1U7OzZDQVFWOzJDQUNKOzZDQUNFO3VDQUVLO21EQUNDOytEQUNZO0FBRWxELHdGQUF3RjtBQUN4RixTQUFTQyxzQkFDUEMsS0FBMkIsRUFDM0JDLE1BQXdCO0lBRXhCLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdEO0lBQ25CLE1BQU1FLFVBQW1CLENBQUM7SUFDMUIsTUFBTUMsT0FBT0osTUFBTUssWUFBWTtJQUUvQkYsUUFBUUcsMEJBQTBCLEdBQUc7SUFFckMsTUFBTUMsUUFBbUJDLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFBQTtJQUN6QixzRkFBc0Y7SUFDdEYsc0hBQXNIO0lBQ3RILE1BQU1DLGlCQUFpQkMsQ0FBQUEsR0FBQUEsbUNBQUFBLGlDQUFBQSxFQUFrQ1YsTUFBTVcsSUFBSTtJQUVuRSx1REFBdUQ7SUFDdkQsd0NBQXdDO0lBQ3hDLE1BQU1DLGNBQWNDLEtBQUtDLEdBQUc7SUFDNUJQLE1BQU1RLFFBQVEsR0FBR0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFBQSxFQUFvQixJQUFJQyxJQUFJYixNQUFNRixTQUFTO1FBQzFEZ0IsbUJBQW1CO1lBQUNsQixNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUFFWCxNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUFFWCxNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUFFO1NBQVU7UUFDM0VRLFNBQVNWLGlCQUFpQlQsTUFBTW1CLE9BQU8sR0FBRztRQUMxQ0MsY0FBYztJQUNoQjtJQUVBLE9BQU9iLE1BQU1RLFFBQVEsQ0FBQ00sSUFBSSxDQUN4QjtZQUFDLEVBQUVDLFVBQVUsRUFBRWpCLGNBQWNrQixvQkFBb0IsRUFBRTtRQUNqRCw0REFBNEQ7UUFDNUQsSUFBSSxPQUFPRCxlQUFlLFVBQVU7WUFDbEMsT0FBT0UsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFBQSxFQUNMeEIsT0FDQUcsU0FDQW1CLFlBQ0F0QixNQUFNeUIsT0FBTyxDQUFDQyxXQUFXO1FBRTdCO1FBRUEsK0RBQStEO1FBQy9EbkIsTUFBTVEsUUFBUSxHQUFHO1FBRWpCLElBQUlZLGNBQWMzQixNQUFNVyxJQUFJO1FBQzVCLElBQUlpQixlQUFlNUIsTUFBTU8sS0FBSztRQUU5QixLQUFLLE1BQU1zQix3QkFBd0JQLFdBQVk7WUFDN0MsTUFBTSxFQUFFWCxNQUFNbUIsU0FBUyxFQUFFQyxZQUFZLEVBQUUsR0FBR0Y7WUFDMUMsSUFBSSxDQUFDRSxjQUFjO2dCQUNqQixvQ0FBb0M7Z0JBQ3BDQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osT0FBT2pDO1lBQ1Q7WUFFQSxNQUFNa0MsVUFBVUMsQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUFBQSxFQUNkO2dCQUNDO2FBQUcsRUFDSlIsYUFDQUcsV0FDQTlCLE1BQU1LLFlBQVk7WUFHcEIsSUFBSTZCLFlBQVksTUFBTTtnQkFDcEIsT0FBT0UsQ0FBQUEsR0FBQUEsdUJBQUFBLHFCQUFBQSxFQUFzQnBDLE9BQU9DLFFBQVE2QjtZQUM5QztZQUVBLElBQUlPLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBQUEsRUFBNEJWLGFBQWFPLFVBQVU7Z0JBQ3JELE9BQU9WLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBQUEsRUFDTHhCLE9BQ0FHLFNBQ0FDLE1BQ0FKLE1BQU15QixPQUFPLENBQUNDLFdBQVc7WUFFN0I7WUFFQSxNQUFNWSwyQkFBMkJmLHVCQUM3QmdCLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JoQix3QkFDbEJpQjtZQUVKLElBQUlqQixzQkFBc0I7Z0JBQ3hCcEIsUUFBUUUsWUFBWSxHQUFHaUM7WUFDekI7WUFDQSxNQUFNRyxVQUFVQyxDQUFBQSxHQUFBQSxpQkFBQUEsZUFBQUEsRUFDZDlCLGFBQ0FnQixjQUNBckIsT0FDQXNCO1lBR0YsSUFBSVksU0FBUztnQkFDWHRDLFFBQVFJLEtBQUssR0FBR0E7Z0JBQ2hCcUIsZUFBZXJCO1lBQ2pCO1lBRUFKLFFBQVF3QyxXQUFXLEdBQUdUO1lBQ3RCL0IsUUFBUUUsWUFBWSxHQUFHRDtZQUV2QnVCLGNBQWNPO1FBQ2hCO1FBQ0EsT0FBT1UsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBQUEsRUFBYzVDLE9BQU9HO0lBQzlCLEdBQ0EsSUFBTUg7QUFFVjtBQUVBLFNBQVM2QyxzQkFDUDdDLEtBQTJCLEVBQzNCOEMsT0FBeUI7SUFFekIsT0FBTzlDO0FBQ1Q7QUFFTyxNQUFNRixvQkE1SCtCLE1BNkh0QixHQUNoQitDLENBQXFCQSxHQUNyQjlDIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxyZWR1Y2Vyc1xcaG1yLXJlZnJlc2gtcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmZXRjaFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnLi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSB9IGZyb20gJy4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlJ1xuaW1wb3J0IHsgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IH0gZnJvbSAnLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXQnXG5pbXBvcnQgdHlwZSB7XG4gIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBSZWR1Y2VyU3RhdGUsXG4gIEhtclJlZnJlc2hBY3Rpb24sXG4gIE11dGFibGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgaGFuZGxlRXh0ZXJuYWxVcmwgfSBmcm9tICcuL25hdmlnYXRlLXJlZHVjZXInXG5pbXBvcnQgeyBoYW5kbGVNdXRhYmxlIH0gZnJvbSAnLi4vaGFuZGxlLW11dGFibGUnXG5pbXBvcnQgeyBhcHBseUZsaWdodERhdGEgfSBmcm9tICcuLi9hcHBseS1mbGlnaHQtZGF0YSdcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUNhY2hlTm9kZSB9IGZyb20gJy4uLy4uL2FwcC1yb3V0ZXInXG5pbXBvcnQgeyBoYW5kbGVTZWdtZW50TWlzbWF0Y2ggfSBmcm9tICcuLi9oYW5kbGUtc2VnbWVudC1taXNtYXRjaCdcbmltcG9ydCB7IGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSB9IGZyb20gJy4vaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUnXG5cbi8vIEEgdmVyc2lvbiBvZiByZWZyZXNoIHJlZHVjZXIgdGhhdCBrZWVwcyB0aGUgY2FjaGUgYXJvdW5kIGluc3RlYWQgb2Ygd2lwaW5nIGFsbCBvZiBpdC5cbmZ1bmN0aW9uIGhtclJlZnJlc2hSZWR1Y2VySW1wbChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IEhtclJlZnJlc2hBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIGNvbnN0IHsgb3JpZ2luIH0gPSBhY3Rpb25cbiAgY29uc3QgbXV0YWJsZTogTXV0YWJsZSA9IHt9XG4gIGNvbnN0IGhyZWYgPSBzdGF0ZS5jYW5vbmljYWxVcmxcblxuICBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID0gZmFsc2VcblxuICBjb25zdCBjYWNoZTogQ2FjaGVOb2RlID0gY3JlYXRlRW1wdHlDYWNoZU5vZGUoKVxuICAvLyBJZiB0aGUgY3VycmVudCB0cmVlIHdhcyBpbnRlcmNlcHRlZCwgdGhlIG5leHRVcmwgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0LlxuICAvLyBUaGlzIGlzIHRvIGVuc3VyZSB0aGF0IHRoZSByZWZyZXNoIHJlcXVlc3QgZG9lc24ndCBnZXQgaW50ZXJjZXB0ZWQsIGFjY2lkZW50YWxseSB0cmlnZ2VyaW5nIHRoZSBpbnRlcmNlcHRpb24gcm91dGUuXG4gIGNvbnN0IGluY2x1ZGVOZXh0VXJsID0gaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKHN0YXRlLnRyZWUpXG5cbiAgLy8gVE9ETy1BUFA6IHZlcmlmeSB0aGF0IGBocmVmYCBpcyBub3QgYW4gZXh0ZXJuYWwgdXJsLlxuICAvLyBGZXRjaCBkYXRhIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXG4gIGNvbnN0IG5hdmlnYXRlZEF0ID0gRGF0ZS5ub3coKVxuICBjYWNoZS5sYXp5RGF0YSA9IGZldGNoU2VydmVyUmVzcG9uc2UobmV3IFVSTChocmVmLCBvcmlnaW4pLCB7XG4gICAgZmxpZ2h0Um91dGVyU3RhdGU6IFtzdGF0ZS50cmVlWzBdLCBzdGF0ZS50cmVlWzFdLCBzdGF0ZS50cmVlWzJdLCAncmVmZXRjaCddLFxuICAgIG5leHRVcmw6IGluY2x1ZGVOZXh0VXJsID8gc3RhdGUubmV4dFVybCA6IG51bGwsXG4gICAgaXNIbXJSZWZyZXNoOiB0cnVlLFxuICB9KVxuXG4gIHJldHVybiBjYWNoZS5sYXp5RGF0YS50aGVuKFxuICAgICh7IGZsaWdodERhdGEsIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGUgfSkgPT4ge1xuICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBtdXRhYmxlLFxuICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBjYWNoZS5sYXp5RGF0YSBhcyBpdCBoYXMgYmVlbiByZXNvbHZlZCBhdCB0aGlzIHBvaW50LlxuICAgICAgY2FjaGUubGF6eURhdGEgPSBudWxsXG5cbiAgICAgIGxldCBjdXJyZW50VHJlZSA9IHN0YXRlLnRyZWVcbiAgICAgIGxldCBjdXJyZW50Q2FjaGUgPSBzdGF0ZS5jYWNoZVxuXG4gICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhIG9mIGZsaWdodERhdGEpIHtcbiAgICAgICAgY29uc3QgeyB0cmVlOiB0cmVlUGF0Y2gsIGlzUm9vdFJlbmRlciB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcbiAgICAgICAgaWYgKCFpc1Jvb3RSZW5kZXIpIHtcbiAgICAgICAgICAvLyBUT0RPLUFQUDogaGFuZGxlIHRoaXMgY2FzZSBiZXR0ZXJcbiAgICAgICAgICBjb25zb2xlLmxvZygnUkVGUkVTSCBGQUlMRUQnKVxuICAgICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShcbiAgICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgWycnXSxcbiAgICAgICAgICBjdXJyZW50VHJlZSxcbiAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgc3RhdGUuY2Fub25pY2FsVXJsXG4gICAgICAgIClcblxuICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVTZWdtZW50TWlzbWF0Y2goc3RhdGUsIGFjdGlvbiwgdHJlZVBhdGNoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlXG4gICAgICAgICAgPyBjcmVhdGVIcmVmRnJvbVVybChjYW5vbmljYWxVcmxPdmVycmlkZSlcbiAgICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZSkge1xuICAgICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwbGllZCA9IGFwcGx5RmxpZ2h0RGF0YShcbiAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICBjdXJyZW50Q2FjaGUsXG4gICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgbm9ybWFsaXplZEZsaWdodERhdGFcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChhcHBsaWVkKSB7XG4gICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlXG4gICAgICAgICAgY3VycmVudENhY2hlID0gY2FjaGVcbiAgICAgICAgfVxuXG4gICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlXG4gICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gaHJlZlxuXG4gICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpXG4gICAgfSxcbiAgICAoKSA9PiBzdGF0ZVxuICApXG59XG5cbmZ1bmN0aW9uIGhtclJlZnJlc2hSZWR1Y2VyTm9vcChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBfYWN0aW9uOiBIbXJSZWZyZXNoQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICByZXR1cm4gc3RhdGVcbn1cblxuZXhwb3J0IGNvbnN0IGhtclJlZnJlc2hSZWR1Y2VyID1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJ1xuICAgID8gaG1yUmVmcmVzaFJlZHVjZXJOb29wXG4gICAgOiBobXJSZWZyZXNoUmVkdWNlckltcGxcbiJdLCJuYW1lcyI6WyJobXJSZWZyZXNoUmVkdWNlciIsImhtclJlZnJlc2hSZWR1Y2VySW1wbCIsInN0YXRlIiwiYWN0aW9uIiwib3JpZ2luIiwibXV0YWJsZSIsImhyZWYiLCJjYW5vbmljYWxVcmwiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImNhY2hlIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJpbmNsdWRlTmV4dFVybCIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsInRyZWUiLCJuYXZpZ2F0ZWRBdCIsIkRhdGUiLCJub3ciLCJsYXp5RGF0YSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIm5leHRVcmwiLCJpc0htclJlZnJlc2giLCJ0aGVuIiwiZmxpZ2h0RGF0YSIsImNhbm9uaWNhbFVybE92ZXJyaWRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJjdXJyZW50VHJlZSIsImN1cnJlbnRDYWNoZSIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwidHJlZVBhdGNoIiwiaXNSb290UmVuZGVyIiwiY29uc29sZSIsImxvZyIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImFwcGxpZWQiLCJhcHBseUZsaWdodERhdGEiLCJwYXRjaGVkVHJlZSIsImhhbmRsZU11dGFibGUiLCJobXJSZWZyZXNoUmVkdWNlck5vb3AiLCJfYWN0aW9uIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleExternalUrl: function() {\n        return handleExternalUrl;\n    },\n    navigateReducer: function() {\n        return navigateReducer;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _invalidatecachebelowflightsegmentpath = __webpack_require__(/*! ../invalidate-cache-below-flight-segmentpath */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _shouldhardnavigate = __webpack_require__(/*! ../should-hard-navigate */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _routerreducertypes = __webpack_require__(/*! ../router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _segment = __webpack_require__(/*! ../../../../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst _clearcachenodedataforsegmentpath = __webpack_require__(/*! ../clear-cache-node-data-for-segment-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js\");\nconst _aliasedprefetchnavigations = __webpack_require__(/*! ../aliased-prefetch-navigations */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/aliased-prefetch-navigations.js\");\nconst _segmentcache = __webpack_require__(/*! ../../segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === '') {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {\n    let appliedPatch = false;\n    newCache.rsc = currentCache.rsc;\n    newCache.prefetchRsc = currentCache.prefetchRsc;\n    newCache.loading = currentCache.loading;\n    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);\n    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[\n            ...flightSegmentPath,\n            ...segment\n        ]);\n    for (const segmentPaths of segmentPathsToFill){\n        (0, _clearcachenodedataforsegmentpath.clearCacheNodeDataForSegmentPath)(newCache, currentCache, segmentPaths);\n        appliedPatch = true;\n    }\n    return appliedPatch;\n}\nfunction handleNavigationResult(url, state, mutable, pendingPush, result) {\n    switch(result.tag){\n        case _segmentcache.NavigationResultTag.MPA:\n            {\n                // Perform an MPA navigation.\n                const newUrl = result.data;\n                return handleExternalUrl(state, mutable, newUrl, pendingPush);\n            }\n        case _segmentcache.NavigationResultTag.NoOp:\n            {\n                // The server responded with no change to the current page. However, if\n                // the URL changed, we still need to update that.\n                const newCanonicalUrl = result.data.canonicalUrl;\n                mutable.canonicalUrl = newCanonicalUrl;\n                // Check if the only thing that changed was the hash fragment.\n                const oldUrl = new URL(state.canonicalUrl, url);\n                const onlyHashChange = // navigations are always same-origin.\n                url.pathname === oldUrl.pathname && url.search === oldUrl.search && url.hash !== oldUrl.hash;\n                if (onlyHashChange) {\n                    // The only updated part of the URL is the hash.\n                    mutable.onlyHashChange = true;\n                    mutable.shouldScroll = result.data.shouldScroll;\n                    mutable.hashFragment = url.hash;\n                    // Setting this to an empty array triggers a scroll for all new and\n                    // updated segments. See `ScrollAndFocusHandler` for more details.\n                    mutable.scrollableSegments = [];\n                }\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _segmentcache.NavigationResultTag.Success:\n            {\n                // Received a new result.\n                mutable.cache = result.data.cacheNode;\n                mutable.patchedTree = result.data.flightRouterState;\n                mutable.canonicalUrl = result.data.canonicalUrl;\n                mutable.scrollableSegments = result.data.scrollableSegments;\n                mutable.shouldScroll = result.data.shouldScroll;\n                mutable.hashFragment = result.data.hash;\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _segmentcache.NavigationResultTag.Async:\n            {\n                return result.data.then((asyncResult)=>handleNavigationResult(url, state, mutable, pendingPush, asyncResult), // TODO: This matches the current behavior but we need to do something\n                // better here if the network fails.\n                ()=>{\n                    return state;\n                });\n            }\n        default:\n            {\n                result;\n                return state;\n            }\n    }\n}\nfunction navigateReducer(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } = action;\n    const mutable = {};\n    const { hash } = url;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === 'push';\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    mutable.preserveCustomHistoryState = false;\n    mutable.pendingPush = pendingPush;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n    // which will trigger an MPA navigation.\n    if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush);\n    }\n    if (false) {}\n    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        tree: state.tree,\n        prefetchCache: state.prefetchCache,\n        allowAliasing\n    });\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    _prefetchreducer.prefetchQueue.bump(data);\n    return data.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride, postponed } = param;\n        const navigatedAt = Date.now();\n        let isFirstRead = false;\n        // we only want to mark this once\n        if (!prefetchValues.lastUsedTime) {\n            // important: we should only mark the cache node as dirty after we unsuspend from the call above\n            prefetchValues.lastUsedTime = navigatedAt;\n            isFirstRead = true;\n        }\n        if (prefetchValues.aliased) {\n            const result = (0, _aliasedprefetchnavigations.handleAliasedPrefetchEntry)(navigatedAt, state, flightData, url, mutable);\n            // We didn't return new router state because we didn't apply the aliased entry for some reason.\n            // We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This\n            // will create an on-demand prefetch entry.\n            if (result === false) {\n                return navigateReducer(state, {\n                    ...action,\n                    allowAliasing: false\n                });\n            }\n            return result;\n        }\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        const updatedCanonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;\n        const onlyHashChange = !!hash && state.canonicalUrl.split('#', 1)[0] === updatedCanonicalUrl.split('#', 1)[0];\n        // If only the hash has changed, the server hasn't sent us any new data. We can just update\n        // the mutable properties responsible for URL and scroll handling and return early.\n        if (onlyHashChange) {\n            mutable.onlyHashChange = true;\n            mutable.canonicalUrl = updatedCanonicalUrl;\n            mutable.shouldScroll = shouldScroll;\n            mutable.hashFragment = hash;\n            mutable.scrollableSegments = [];\n            return (0, _handlemutable.handleMutable)(state, mutable);\n        }\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        let scrollableSegments = [];\n        for (const normalizedFlightData of flightData){\n            const { pathToSegment: flightSegmentPath, seedData, head, isHeadPartial, isRootRender } = normalizedFlightData;\n            let treePatch = normalizedFlightData.tree;\n            // TODO-APP: remove ''\n            const flightSegmentPathWithLeadingEmpty = [\n                '',\n                ...flightSegmentPath\n            ];\n            // Create new tree based on the flightSegmentPath and router state patch\n            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n            if (newTree === null) {\n                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);\n            }\n            if (newTree !== null) {\n                if (// will send back a static response that's rendered from\n                // the root. If for some reason it doesn't, we fall back to the\n                // non-PPR implementation.\n                // TODO: We should get rid of the else branch and do all navigations\n                // via startPPRNavigation. The current structure is just\n                // an incremental step.\n                seedData && isRootRender && postponed) {\n                    const task = (0, _pprnavigations.startPPRNavigation)(navigatedAt, currentCache, currentTree, treePatch, seedData, head, isHeadPartial, false, scrollableSegments);\n                    if (task !== null) {\n                        if (task.route === null) {\n                            // Detected a change to the root layout. Perform an full-\n                            // page navigation.\n                            return handleExternalUrl(state, mutable, href, pendingPush);\n                        }\n                        // Use the tree computed by startPPRNavigation instead\n                        // of the one computed by applyRouterStatePatchToTree.\n                        // TODO: We should remove applyRouterStatePatchToTree\n                        // from the PPR path entirely.\n                        const patchedRouterState = task.route;\n                        newTree = patchedRouterState;\n                        const newCache = task.node;\n                        if (newCache !== null) {\n                            // We've created a new Cache Node tree that contains a prefetched\n                            // version of the next page. This can be rendered instantly.\n                            mutable.cache = newCache;\n                        }\n                        const dynamicRequestTree = task.dynamicRequestTree;\n                        if (dynamicRequestTree !== null) {\n                            // The prefetched tree has dynamic holes in it. We initiate a\n                            // dynamic request to fill them in.\n                            //\n                            // Do not block on the result. We'll immediately render the Cache\n                            // Node tree and suspend on the dynamic parts. When the request\n                            // comes in, we'll fill in missing data and ping React to\n                            // re-render. Unlike the lazy fetching model in the non-PPR\n                            // implementation, this is modeled as a single React update +\n                            // streaming, rather than multiple top-level updates. (However,\n                            // even in the new model, we'll still need to sometimes update the\n                            // root multiple times per navigation, like if the server sends us\n                            // a different response than we expected. For now, we revert back\n                            // to the lazy fetching mechanism in that case.)\n                            const dynamicRequest = (0, _fetchserverresponse.fetchServerResponse)(url, {\n                                flightRouterState: dynamicRequestTree,\n                                nextUrl: state.nextUrl\n                            });\n                            (0, _pprnavigations.listenForDynamicRequest)(task, dynamicRequest);\n                        // We store the dynamic request on the `lazyData` property of the CacheNode\n                        // because we're not going to await the dynamic request here. Since we're not blocking\n                        // on the dynamic request, `layout-router` will\n                        // task.node.lazyData = dynamicRequest\n                        } else {\n                        // The prefetched tree does not contain dynamic holes — it's\n                        // fully static. We can skip the dynamic request.\n                        }\n                    } else {\n                        // Nothing changed, so reuse the old cache.\n                        // TODO: What if the head changed but not any of the segment data?\n                        // Is that possible? If so, we should clone the whole tree and\n                        // update the head.\n                        newTree = treePatch;\n                    }\n                } else {\n                    // The static response does not include any dynamic holes, so\n                    // there's no need to do a second request.\n                    // TODO: As an incremental step this just reverts back to the\n                    // non-PPR implementation. We can simplify this branch further,\n                    // given that PPR prefetches are always static and return the whole\n                    // tree. Or in the meantime we could factor it out into a\n                    // separate function.\n                    if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                        return handleExternalUrl(state, mutable, href, pendingPush);\n                    }\n                    const cache = (0, _approuter.createEmptyCacheNode)();\n                    let applied = false;\n                    if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {\n                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n                        // while copying over the `loading` for the segment that contains the page data.\n                        // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n                        // We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case\n                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);\n                        // since we re-used the stale cache's loading state & refreshed the data,\n                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n                        prefetchValues.lastUsedTime = navigatedAt;\n                    } else {\n                        applied = (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData, prefetchValues);\n                    }\n                    const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);\n                    if (hardNavigate) {\n                        // Copy rsc for the root node of the cache.\n                        cache.rsc = currentCache.rsc;\n                        cache.prefetchRsc = currentCache.prefetchRsc;\n                        (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);\n                        // Ensure the existing cache value is used when the cache was not invalidated.\n                        mutable.cache = cache;\n                    } else if (applied) {\n                        mutable.cache = cache;\n                        // If we applied the cache, we update the \"current cache\" value so any other\n                        // segments in the FlightDataPath will be able to reference the updated cache.\n                        currentCache = cache;\n                    }\n                    for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                        const scrollableSegmentPath = [\n                            ...flightSegmentPath,\n                            ...subSegment\n                        ];\n                        // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n                        if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {\n                            scrollableSegments.push(scrollableSegmentPath);\n                        }\n                    }\n                }\n                currentTree = newTree;\n            }\n        }\n        mutable.patchedTree = currentTree;\n        mutable.canonicalUrl = updatedCanonicalUrl;\n        mutable.scrollableSegments = scrollableSegments;\n        mutable.hashFragment = hash;\n        mutable.shouldScroll = shouldScroll;\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigate-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFvQ2dCQSxpQkFBaUI7ZUFBakJBOztJQXNJQUMsZUFBZTtlQUFmQTs7O2lEQXJLb0I7K0NBQ0Y7bUVBQ29CO3lEQUNWO2dEQUNUO3lEQUNTO2dEQU9yQzsyQ0FDdUI7NkNBQ0U7NkNBQ0Y7dUNBQ087cUNBQ0Q7NENBQ3dCO2dEQUlyRDs4REFDMEM7d0RBQ047MENBS3BDO0FBRUEsU0FBU0Qsa0JBQ2RFLEtBQTJCLEVBQzNCQyxPQUFnQixFQUNoQkMsR0FBVyxFQUNYQyxXQUFvQjtJQUVwQkYsUUFBUUcsYUFBYSxHQUFHO0lBQ3hCSCxRQUFRSSxZQUFZLEdBQUdIO0lBQ3ZCRCxRQUFRRSxXQUFXLEdBQUdBO0lBQ3RCRixRQUFRSyxrQkFBa0IsR0FBR0M7SUFFN0IsT0FBT0MsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBQUEsRUFBY1IsT0FBT0M7QUFDOUI7QUFFQSxTQUFTUSwwQkFDUEMsaUJBQW9DO0lBRXBDLE1BQU1DLFdBQWdDLEVBQUU7SUFDeEMsTUFBTSxDQUFDQyxTQUFTQyxlQUFlLEdBQUdIO0lBRWxDLElBQUlJLE9BQU9DLElBQUksQ0FBQ0YsZ0JBQWdCRyxNQUFNLEtBQUssR0FBRztRQUM1QyxPQUFPO1lBQUM7Z0JBQUNKO2FBQVE7U0FBQztJQUNwQjtJQUVBLEtBQUssTUFBTSxDQUFDSyxrQkFBa0JDLGNBQWMsSUFBSUosT0FBT0ssT0FBTyxDQUM1RE4sZ0JBQ0M7UUFDRCxLQUFLLE1BQU1PLGdCQUFnQlgsMEJBQTBCUyxlQUFnQjtZQUNuRSxtRUFBbUU7WUFDbkUsSUFBSU4sWUFBWSxJQUFJO2dCQUNsQkQsU0FBU1UsSUFBSSxDQUFDO29CQUFDSjt1QkFBcUJHO2lCQUFhO1lBQ25ELE9BQU87Z0JBQ0xULFNBQVNVLElB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QVc7d0JBRTVDK0YsQ0FBQUEsR0FBQUEsdUNBQUFBLHFDQUFBQSxFQUNFdEUsT0FDQTlCLGNBQ0FDO3dCQUVGLDhFQUE4RTt3QkFDOUV4QixRQUFRcUQsS0FBSyxHQUFHQTtvQkFDbEIsT0FBTyxJQUFJK0QsU0FBUzt3QkFDbEJwSCxRQUFRcUQsS0FBSyxHQUFHQTt3QkFDaEIsNEVBQTRFO3dCQUM1RSw4RUFBOEU7d0JBQzlFOUIsZUFBZThCO29CQUNqQjtvQkFFQSxLQUFLLE1BQU11RSxjQUFjcEgsMEJBQTBCaUIsV0FBWTt3QkFDN0QsTUFBTW9HLHdCQUF3QjsrQkFDekJyRzsrQkFDQW9HO3lCQUNKO3dCQUNELGtGQUFrRjt3QkFDbEYsSUFDRUMscUJBQXFCLENBQUNBLHNCQUFzQjlHLE1BQU0sR0FBRyxFQUFFLEtBQ3ZEK0csU0FBQUEsbUJBQW1CLEVBQ25COzRCQUNBekgsbUJBQW1CZSxJQUFJLENBQUN5Rzt3QkFDMUI7b0JBQ0Y7Z0JBQ0Y7Z0JBRUE5QixjQUFjUTtZQUNoQjtRQUNGO1FBRUF2RyxRQUFRdUQsV0FBVyxHQUFHd0M7UUFDdEIvRixRQUFRSSxZQUFZLEdBQUd5RjtRQUN2QjdGLFFBQVFLLGtCQUFrQixHQUFHQTtRQUM3QkwsUUFBUW1ELFlBQVksR0FBR0Y7UUFDdkJqRCxRQUFRa0QsWUFBWSxHQUFHQTtRQUV2QixPQUFPM0MsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBQUEsRUFBY1IsT0FBT0M7SUFDOUIsR0FDQSxJQUFNRDtBQUVWIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxyZWR1Y2Vyc1xcbmF2aWdhdGUtcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUge1xuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgRmxpZ2h0U2VnbWVudFBhdGgsXG59IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgZmV0Y2hTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJy4uL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi4vY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQgeyBpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIH0gZnJvbSAnLi4vaW52YWxpZGF0ZS1jYWNoZS1iZWxvdy1mbGlnaHQtc2VnbWVudHBhdGgnXG5pbXBvcnQgeyBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgfSBmcm9tICcuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSdcbmltcG9ydCB7IHNob3VsZEhhcmROYXZpZ2F0ZSB9IGZyb20gJy4uL3Nob3VsZC1oYXJkLW5hdmlnYXRlJ1xuaW1wb3J0IHsgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IH0gZnJvbSAnLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXQnXG5pbXBvcnQge1xuICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMsXG4gIHR5cGUgTXV0YWJsZSxcbiAgdHlwZSBOYXZpZ2F0ZUFjdGlvbixcbiAgdHlwZSBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgdHlwZSBSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgaGFuZGxlTXV0YWJsZSB9IGZyb20gJy4uL2hhbmRsZS1tdXRhYmxlJ1xuaW1wb3J0IHsgYXBwbHlGbGlnaHREYXRhIH0gZnJvbSAnLi4vYXBwbHktZmxpZ2h0LWRhdGEnXG5pbXBvcnQgeyBwcmVmZXRjaFF1ZXVlIH0gZnJvbSAnLi9wcmVmZXRjaC1yZWR1Y2VyJ1xuaW1wb3J0IHsgY3JlYXRlRW1wdHlDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi9hcHAtcm91dGVyJ1xuaW1wb3J0IHsgREVGQVVMVF9TRUdNRU5UX0tFWSB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcbmltcG9ydCB7IGxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0LCBzdGFydFBQUk5hdmlnYXRpb24gfSBmcm9tICcuLi9wcHItbmF2aWdhdGlvbnMnXG5pbXBvcnQge1xuICBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSxcbiAgcHJ1bmVQcmVmZXRjaENhY2hlLFxufSBmcm9tICcuLi9wcmVmZXRjaC1jYWNoZS11dGlscydcbmltcG9ydCB7IGNsZWFyQ2FjaGVOb2RlRGF0YUZvclNlZ21lbnRQYXRoIH0gZnJvbSAnLi4vY2xlYXItY2FjaGUtbm9kZS1kYXRhLWZvci1zZWdtZW50LXBhdGgnXG5pbXBvcnQgeyBoYW5kbGVBbGlhc2VkUHJlZmV0Y2hFbnRyeSB9IGZyb20gJy4uL2FsaWFzZWQtcHJlZmV0Y2gtbmF2aWdhdGlvbnMnXG5pbXBvcnQge1xuICBuYXZpZ2F0ZSBhcyBuYXZpZ2F0ZVVzaW5nU2VnbWVudENhY2hlLFxuICBOYXZpZ2F0aW9uUmVzdWx0VGFnLFxuICB0eXBlIE5hdmlnYXRpb25SZXN1bHQsXG59IGZyb20gJy4uLy4uL3NlZ21lbnQtY2FjaGUnXG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVFeHRlcm5hbFVybChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBtdXRhYmxlOiBNdXRhYmxlLFxuICB1cmw6IHN0cmluZyxcbiAgcGVuZGluZ1B1c2g6IGJvb2xlYW5cbikge1xuICBtdXRhYmxlLm1wYU5hdmlnYXRpb24gPSB0cnVlXG4gIG11dGFibGUuY2Fub25pY2FsVXJsID0gdXJsXG4gIG11dGFibGUucGVuZGluZ1B1c2ggPSBwZW5kaW5nUHVzaFxuICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoKFxuICBmbGlnaHRSb3V0ZXJQYXRjaDogRmxpZ2h0Um91dGVyU3RhdGVcbik6IEZsaWdodFNlZ21lbnRQYXRoW10ge1xuICBjb25zdCBzZWdtZW50czogRmxpZ2h0U2VnbWVudFBhdGhbXSA9IFtdXG4gIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlc10gPSBmbGlnaHRSb3V0ZXJQYXRjaFxuXG4gIGlmIChPYmplY3Qua2V5cyhwYXJhbGxlbFJvdXRlcykubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtbc2VnbWVudF1dXG4gIH1cblxuICBmb3IgKGNvbnN0IFtwYXJhbGxlbFJvdXRlS2V5LCBwYXJhbGxlbFJvdXRlXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICBwYXJhbGxlbFJvdXRlc1xuICApKSB7XG4gICAgZm9yIChjb25zdCBjaGlsZFNlZ21lbnQgb2YgZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaChwYXJhbGxlbFJvdXRlKSkge1xuICAgICAgLy8gSWYgdGhlIHNlZ21lbnQgaXMgZW1wdHksIGl0IG1lYW5zIHdlIGFyZSBhdCB0aGUgcm9vdCBvZiB0aGUgdHJlZVxuICAgICAgaWYgKHNlZ21lbnQgPT09ICcnKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goW3BhcmFsbGVsUm91dGVLZXksIC4uLmNoaWxkU2VnbWVudF0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50cy5wdXNoKFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5LCAuLi5jaGlsZFNlZ21lbnRdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWdtZW50c1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyTGF6eUZldGNoRm9yTGVhZlNlZ21lbnRzKFxuICBuZXdDYWNoZTogQ2FjaGVOb2RlLFxuICBjdXJyZW50Q2FjaGU6IENhY2hlTm9kZSxcbiAgZmxpZ2h0U2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICB0cmVlUGF0Y2g6IEZsaWdodFJvdXRlclN0YXRlXG4pIHtcbiAgbGV0IGFwcGxpZWRQYXRjaCA9IGZhbHNlXG5cbiAgbmV3Q2FjaGUucnNjID0gY3VycmVudENhY2hlLnJzY1xuICBuZXdDYWNoZS5wcmVmZXRjaFJzYyA9IGN1cnJlbnRDYWNoZS5wcmVmZXRjaFJzY1xuICBuZXdDYWNoZS5sb2FkaW5nID0gY3VycmVudENhY2hlLmxvYWRpbmdcbiAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMgPSBuZXcgTWFwKGN1cnJlbnRDYWNoZS5wYXJhbGxlbFJvdXRlcylcblxuICBjb25zdCBzZWdtZW50UGF0aHNUb0ZpbGwgPSBnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoKHRyZWVQYXRjaCkubWFwKFxuICAgIChzZWdtZW50KSA9PiBbLi4uZmxpZ2h0U2VnbWVudFBhdGgsIC4uLnNlZ21lbnRdXG4gIClcblxuICBmb3IgKGNvbnN0IHNlZ21lbnRQYXRocyBvZiBzZWdtZW50UGF0aHNUb0ZpbGwpIHtcbiAgICBjbGVhckNhY2hlTm9kZURhdGFGb3JTZWdtZW50UGF0aChuZXdDYWNoZSwgY3VycmVudENhY2hlLCBzZWdtZW50UGF0aHMpXG5cbiAgICBhcHBsaWVkUGF0Y2ggPSB0cnVlXG4gIH1cblxuICByZXR1cm4gYXBwbGllZFBhdGNoXG59XG5cbmZ1bmN0aW9uIGhhbmRsZU5hdmlnYXRpb25SZXN1bHQoXG4gIHVybDogVVJMLFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIG11dGFibGU6IE11dGFibGUsXG4gIHBlbmRpbmdQdXNoOiBib29sZWFuLFxuICByZXN1bHQ6IE5hdmlnYXRpb25SZXN1bHRcbik6IFJlZHVjZXJTdGF0ZSB7XG4gIHN3aXRjaCAocmVzdWx0LnRhZykge1xuICAgIGNhc2UgTmF2aWdhdGlvblJlc3VsdFRhZy5NUEE6IHtcbiAgICAgIC8vIFBlcmZvcm0gYW4gTVBBIG5hdmlnYXRpb24uXG4gICAgICBjb25zdCBuZXdVcmwgPSByZXN1bHQuZGF0YVxuICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBuZXdVcmwsIHBlbmRpbmdQdXNoKVxuICAgIH1cbiAgICBjYXNlIE5hdmlnYXRpb25SZXN1bHRUYWcuTm9PcDoge1xuICAgICAgLy8gVGhlIHNlcnZlciByZXNwb25kZWQgd2l0aCBubyBjaGFuZ2UgdG8gdGhlIGN1cnJlbnQgcGFnZS4gSG93ZXZlciwgaWZcbiAgICAgIC8vIHRoZSBVUkwgY2hhbmdlZCwgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhhdC5cbiAgICAgIGNvbnN0IG5ld0Nhbm9uaWNhbFVybCA9IHJlc3VsdC5kYXRhLmNhbm9uaWNhbFVybFxuICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBuZXdDYW5vbmljYWxVcmxcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG9ubHkgdGhpbmcgdGhhdCBjaGFuZ2VkIHdhcyB0aGUgaGFzaCBmcmFnbWVudC5cbiAgICAgIGNvbnN0IG9sZFVybCA9IG5ldyBVUkwoc3RhdGUuY2Fub25pY2FsVXJsLCB1cmwpXG4gICAgICBjb25zdCBvbmx5SGFzaENoYW5nZSA9XG4gICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY29tcGFyZSB0aGUgb3JpZ2lucywgYmVjYXVzZSBjbGllbnQtZHJpdmVuXG4gICAgICAgIC8vIG5hdmlnYXRpb25zIGFyZSBhbHdheXMgc2FtZS1vcmlnaW4uXG4gICAgICAgIHVybC5wYXRobmFtZSA9PT0gb2xkVXJsLnBhdGhuYW1lICYmXG4gICAgICAgIHVybC5zZWFyY2ggPT09IG9sZFVybC5zZWFyY2ggJiZcbiAgICAgICAgdXJsLmhhc2ggIT09IG9sZFVybC5oYXNoXG4gICAgICBpZiAob25seUhhc2hDaGFuZ2UpIHtcbiAgICAgICAgLy8gVGhlIG9ubHkgdXBkYXRlZCBwYXJ0IG9mIHRoZSBVUkwgaXMgdGhlIGhhc2guXG4gICAgICAgIG11dGFibGUub25seUhhc2hDaGFuZ2UgPSB0cnVlXG4gICAgICAgIG11dGFibGUuc2hvdWxkU2Nyb2xsID0gcmVzdWx0LmRhdGEuc2hvdWxkU2Nyb2xsXG4gICAgICAgIG11dGFibGUuaGFzaEZyYWdtZW50ID0gdXJsLmhhc2hcbiAgICAgICAgLy8gU2V0dGluZyB0aGlzIHRvIGFuIGVtcHR5IGFycmF5IHRyaWdnZXJzIGEgc2Nyb2xsIGZvciBhbGwgbmV3IGFuZFxuICAgICAgICAvLyB1cGRhdGVkIHNlZ21lbnRzLiBTZWUgYFNjcm9sbEFuZEZvY3VzSGFuZGxlcmAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMgPSBbXVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9XG4gICAgY2FzZSBOYXZpZ2F0aW9uUmVzdWx0VGFnLlN1Y2Nlc3M6IHtcbiAgICAgIC8vIFJlY2VpdmVkIGEgbmV3IHJlc3VsdC5cbiAgICAgIG11dGFibGUuY2FjaGUgPSByZXN1bHQuZGF0YS5jYWNoZU5vZGVcbiAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSByZXN1bHQuZGF0YS5mbGlnaHRSb3V0ZXJTdGF0ZVxuICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSByZXN1bHQuZGF0YS5jYW5vbmljYWxVcmxcbiAgICAgIG11dGFibGUuc2Nyb2xsYWJsZVNlZ21lbnRzID0gcmVzdWx0LmRhdGEuc2Nyb2xsYWJsZVNlZ21lbnRzXG4gICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHJlc3VsdC5kYXRhLnNob3VsZFNjcm9sbFxuICAgICAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgPSByZXN1bHQuZGF0YS5oYXNoXG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9XG4gICAgY2FzZSBOYXZpZ2F0aW9uUmVzdWx0VGFnLkFzeW5jOiB7XG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGEudGhlbihcbiAgICAgICAgKGFzeW5jUmVzdWx0KSA9PlxuICAgICAgICAgIGhhbmRsZU5hdmlnYXRpb25SZXN1bHQodXJsLCBzdGF0ZSwgbXV0YWJsZSwgcGVuZGluZ1B1c2gsIGFzeW5jUmVzdWx0KSxcbiAgICAgICAgLy8gSWYgdGhlIG5hdmlnYXRpb24gZmFpbGVkLCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgbWF0Y2hlcyB0aGUgY3VycmVudCBiZWhhdmlvciBidXQgd2UgbmVlZCB0byBkbyBzb21ldGhpbmdcbiAgICAgICAgLy8gYmV0dGVyIGhlcmUgaWYgdGhlIG5ldHdvcmsgZmFpbHMuXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXN1bHQgc2F0aXNmaWVzIG5ldmVyXG4gICAgICByZXR1cm4gc3RhdGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hdmlnYXRlUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IE5hdmlnYXRlQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBjb25zdCB7IHVybCwgaXNFeHRlcm5hbFVybCwgbmF2aWdhdGVUeXBlLCBzaG91bGRTY3JvbGwsIGFsbG93QWxpYXNpbmcgfSA9XG4gICAgYWN0aW9uXG4gIGNvbnN0IG11dGFibGU6IE11dGFibGUgPSB7fVxuICBjb25zdCB7IGhhc2ggfSA9IHVybFxuICBjb25zdCBocmVmID0gY3JlYXRlSHJlZkZyb21VcmwodXJsKVxuICBjb25zdCBwZW5kaW5nUHVzaCA9IG5hdmlnYXRlVHlwZSA9PT0gJ3B1c2gnXG4gIC8vIHdlIHdhbnQgdG8gcHJ1bmUgdGhlIHByZWZldGNoIGNhY2hlIG9uIGV2ZXJ5IG5hdmlnYXRpb24gdG8gYXZvaWQgaXQgZ3Jvd2luZyB0b28gbGFyZ2VcbiAgcHJ1bmVQcmVmZXRjaENhY2hlKHN0YXRlLnByZWZldGNoQ2FjaGUpXG5cbiAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlXG4gIG11dGFibGUucGVuZGluZ1B1c2ggPSBwZW5kaW5nUHVzaFxuXG4gIGlmIChpc0V4dGVybmFsVXJsKSB7XG4gICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCB1cmwudG9TdHJpbmcoKSwgcGVuZGluZ1B1c2gpXG4gIH1cblxuICAvLyBIYW5kbGVzIGNhc2Ugd2hlcmUgYDxtZXRhIGh0dHAtZXF1aXY9XCJyZWZyZXNoXCI+YCB0YWcgaXMgcHJlc2VudCxcbiAgLy8gd2hpY2ggd2lsbCB0cmlnZ2VyIGFuIE1QQSBuYXZpZ2F0aW9uLlxuICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fbmV4dC1wYWdlLXJlZGlyZWN0JykpIHtcbiAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGhyZWYsIHBlbmRpbmdQdXNoKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgIC8vIChWZXJ5IEVhcmx5IEV4cGVyaW1lbnRhbCBGZWF0dXJlKSBTZWdtZW50IENhY2hlXG4gICAgLy9cbiAgICAvLyBCeXBhc3MgdGhlIG5vcm1hbCBwcmVmZXRjaCBjYWNoZSBhbmQgdXNlIHRoZSBuZXcgcGVyLXNlZ21lbnQgY2FjaGVcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBpbnN0ZWFkLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGlmIFBQUiBpcyBlbmFibGVkLCB0b28uXG4gICAgLy9cbiAgICAvLyBUZW1wb3JhcnkgZ2x1ZSBjb2RlIGJldHdlZW4gdGhlIHJvdXRlciByZWR1Y2VyIGFuZCB0aGUgbmV3IG5hdmlnYXRpb25cbiAgICAvLyBpbXBsZW1lbnRhdGlvbi4gRXZlbnR1YWxseSB3ZSdsbCByZXdyaXRlIHRoZSByb3V0ZXIgcmVkdWNlciB0byBhXG4gICAgLy8gc3RhdGUgbWFjaGluZS5cbiAgICBjb25zdCByZXN1bHQgPSBuYXZpZ2F0ZVVzaW5nU2VnbWVudENhY2hlKFxuICAgICAgdXJsLFxuICAgICAgc3RhdGUuY2FjaGUsXG4gICAgICBzdGF0ZS50cmVlLFxuICAgICAgc3RhdGUubmV4dFVybCxcbiAgICAgIHNob3VsZFNjcm9sbFxuICAgIClcbiAgICByZXR1cm4gaGFuZGxlTmF2aWdhdGlvblJlc3VsdCh1cmwsIHN0YXRlLCBtdXRhYmxlLCBwZW5kaW5nUHVzaCwgcmVzdWx0KVxuICB9XG5cbiAgY29uc3QgcHJlZmV0Y2hWYWx1ZXMgPSBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSh7XG4gICAgdXJsLFxuICAgIG5leHRVcmw6IHN0YXRlLm5leHRVcmwsXG4gICAgdHJlZTogc3RhdGUudHJlZSxcbiAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgIGFsbG93QWxpYXNpbmcsXG4gIH0pXG4gIGNvbnN0IHsgdHJlZUF0VGltZU9mUHJlZmV0Y2gsIGRhdGEgfSA9IHByZWZldGNoVmFsdWVzXG5cbiAgcHJlZmV0Y2hRdWV1ZS5idW1wKGRhdGEpXG5cbiAgcmV0dXJuIGRhdGEudGhlbihcbiAgICAoeyBmbGlnaHREYXRhLCBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlLCBwb3N0cG9uZWQgfSkgPT4ge1xuICAgICAgY29uc3QgbmF2aWdhdGVkQXQgPSBEYXRlLm5vdygpXG5cbiAgICAgIGxldCBpc0ZpcnN0UmVhZCA9IGZhbHNlXG4gICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gbWFyayB0aGlzIG9uY2VcbiAgICAgIGlmICghcHJlZmV0Y2hWYWx1ZXMubGFzdFVzZWRUaW1lKSB7XG4gICAgICAgIC8vIGltcG9ydGFudDogd2Ugc2hvdWxkIG9ubHkgbWFyayB0aGUgY2FjaGUgbm9kZSBhcyBkaXJ0eSBhZnRlciB3ZSB1bnN1c3BlbmQgZnJvbSB0aGUgY2FsbCBhYm92ZVxuICAgICAgICBwcmVmZXRjaFZhbHVlcy5sYXN0VXNlZFRpbWUgPSBuYXZpZ2F0ZWRBdFxuICAgICAgICBpc0ZpcnN0UmVhZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKHByZWZldGNoVmFsdWVzLmFsaWFzZWQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGFuZGxlQWxpYXNlZFByZWZldGNoRW50cnkoXG4gICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgbXV0YWJsZVxuICAgICAgICApXG5cbiAgICAgICAgLy8gV2UgZGlkbid0IHJldHVybiBuZXcgcm91dGVyIHN0YXRlIGJlY2F1c2Ugd2UgZGlkbid0IGFwcGx5IHRoZSBhbGlhc2VkIGVudHJ5IGZvciBzb21lIHJlYXNvbi5cbiAgICAgICAgLy8gV2UnbGwgcmUtaW52b2tlIHRoZSBuYXZpZ2F0aW9uIGhhbmRsZXIgYnV0IGVuc3VyZSB0aGF0IHdlIGRvbid0IGF0dGVtcHQgdG8gdXNlIHRoZSBhbGlhc2VkIGVudHJ5LiBUaGlzXG4gICAgICAgIC8vIHdpbGwgY3JlYXRlIGFuIG9uLWRlbWFuZCBwcmVmZXRjaCBlbnRyeS5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gbmF2aWdhdGVSZWR1Y2VyKHN0YXRlLCB7IC4uLmFjdGlvbiwgYWxsb3dBbGlhc2luZzogZmFsc2UgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgZmxpZ2h0RGF0YSwgcGVuZGluZ1B1c2gpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWRDYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZVxuICAgICAgICA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKVxuICAgICAgICA6IGhyZWZcblxuICAgICAgY29uc3Qgb25seUhhc2hDaGFuZ2UgPVxuICAgICAgICAhIWhhc2ggJiZcbiAgICAgICAgc3RhdGUuY2Fub25pY2FsVXJsLnNwbGl0KCcjJywgMSlbMF0gPT09XG4gICAgICAgICAgdXBkYXRlZENhbm9uaWNhbFVybC5zcGxpdCgnIycsIDEpWzBdXG5cbiAgICAgIC8vIElmIG9ubHkgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZSBzZXJ2ZXIgaGFzbid0IHNlbnQgdXMgYW55IG5ldyBkYXRhLiBXZSBjYW4ganVzdCB1cGRhdGVcbiAgICAgIC8vIHRoZSBtdXRhYmxlIHByb3BlcnRpZXMgcmVzcG9uc2libGUgZm9yIFVSTCBhbmQgc2Nyb2xsIGhhbmRsaW5nIGFuZCByZXR1cm4gZWFybHkuXG4gICAgICBpZiAob25seUhhc2hDaGFuZ2UpIHtcbiAgICAgICAgbXV0YWJsZS5vbmx5SGFzaENoYW5nZSA9IHRydWVcbiAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSB1cGRhdGVkQ2Fub25pY2FsVXJsXG4gICAgICAgIG11dGFibGUuc2hvdWxkU2Nyb2xsID0gc2hvdWxkU2Nyb2xsXG4gICAgICAgIG11dGFibGUuaGFzaEZyYWdtZW50ID0gaGFzaFxuICAgICAgICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IFtdXG4gICAgICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxuICAgICAgfVxuXG4gICAgICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlXG4gICAgICBsZXQgY3VycmVudENhY2hlID0gc3RhdGUuY2FjaGVcbiAgICAgIGxldCBzY3JvbGxhYmxlU2VnbWVudHM6IEZsaWdodFNlZ21lbnRQYXRoW10gPSBbXVxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwYXRoVG9TZWdtZW50OiBmbGlnaHRTZWdtZW50UGF0aCxcbiAgICAgICAgICBzZWVkRGF0YSxcbiAgICAgICAgICBoZWFkLFxuICAgICAgICAgIGlzSGVhZFBhcnRpYWwsXG4gICAgICAgICAgaXNSb290UmVuZGVyLFxuICAgICAgICB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcbiAgICAgICAgbGV0IHRyZWVQYXRjaCA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhLnRyZWVcblxuICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgIGNvbnN0IGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSA9IFsnJywgLi4uZmxpZ2h0U2VnbWVudFBhdGhdXG5cbiAgICAgICAgLy8gQ3JlYXRlIG5ldyB0cmVlIGJhc2VkIG9uIHRoZSBmbGlnaHRTZWdtZW50UGF0aCBhbmQgcm91dGVyIHN0YXRlIHBhdGNoXG4gICAgICAgIGxldCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHksXG4gICAgICAgICAgY3VycmVudFRyZWUsXG4gICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgIGhyZWZcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIElmIHRoZSB0cmVlIHBhdGNoIGNhbid0IGJlIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgdHJlZSB0aGVuIHdlIHVzZSB0aGUgdHJlZSBhdCB0aW1lIG9mIHByZWZldGNoXG4gICAgICAgIC8vIFRPRE8tQVBQOiBUaGlzIHNob3VsZCBpbnN0ZWFkIGZpbGwgaW4gdGhlIG1pc3NpbmcgcGllY2VzIGluIGBjdXJyZW50VHJlZWAgd2l0aCB0aGUgZGF0YSBmcm9tIGB0cmVlQXRUaW1lT2ZQcmVmZXRjaGAsIHRoZW4gYXBwbHkgdGhlIHBhdGNoLlxuICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoXG4gICAgICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHksXG4gICAgICAgICAgICB0cmVlQXRUaW1lT2ZQcmVmZXRjaCxcbiAgICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3VHJlZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIFRoaXMgaXMganVzdCBhIHBhcmFub2lkIGNoZWNrLiBXaGVuIGEgcm91dGUgaXMgUFBSZWQsIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIC8vIHdpbGwgc2VuZCBiYWNrIGEgc3RhdGljIHJlc3BvbnNlIHRoYXQncyByZW5kZXJlZCBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgcm9vdC4gSWYgZm9yIHNvbWUgcmVhc29uIGl0IGRvZXNuJ3QsIHdlIGZhbGwgYmFjayB0byB0aGVcbiAgICAgICAgICAgIC8vIG5vbi1QUFIgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgZ2V0IHJpZCBvZiB0aGUgZWxzZSBicmFuY2ggYW5kIGRvIGFsbCBuYXZpZ2F0aW9uc1xuICAgICAgICAgICAgLy8gdmlhIHN0YXJ0UFBSTmF2aWdhdGlvbi4gVGhlIGN1cnJlbnQgc3RydWN0dXJlIGlzIGp1c3RcbiAgICAgICAgICAgIC8vIGFuIGluY3JlbWVudGFsIHN0ZXAuXG4gICAgICAgICAgICBzZWVkRGF0YSAmJlxuICAgICAgICAgICAgaXNSb290UmVuZGVyICYmXG4gICAgICAgICAgICBwb3N0cG9uZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBzdGFydFBQUk5hdmlnYXRpb24oXG4gICAgICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgICAgICBjdXJyZW50Q2FjaGUsXG4gICAgICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgICAgIHNlZWREYXRhLFxuICAgICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgICBpc0hlYWRQYXJ0aWFsLFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGlmICh0YXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICh0YXNrLnJvdXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gRGV0ZWN0ZWQgYSBjaGFuZ2UgdG8gdGhlIHJvb3QgbGF5b3V0LiBQZXJmb3JtIGFuIGZ1bGwtXG4gICAgICAgICAgICAgICAgLy8gcGFnZSBuYXZpZ2F0aW9uLlxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgaHJlZiwgcGVuZGluZ1B1c2gpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVXNlIHRoZSB0cmVlIGNvbXB1dGVkIGJ5IHN0YXJ0UFBSTmF2aWdhdGlvbiBpbnN0ZWFkXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBvbmUgY29tcHV0ZWQgYnkgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlLlxuICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgcmVtb3ZlIGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZVxuICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBQUFIgcGF0aCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9IHRhc2sucm91dGVcbiAgICAgICAgICAgICAgbmV3VHJlZSA9IHBhdGNoZWRSb3V0ZXJTdGF0ZVxuXG4gICAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlID0gdGFzay5ub2RlXG4gICAgICAgICAgICAgIGlmIChuZXdDYWNoZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGNyZWF0ZWQgYSBuZXcgQ2FjaGUgTm9kZSB0cmVlIHRoYXQgY29udGFpbnMgYSBwcmVmZXRjaGVkXG4gICAgICAgICAgICAgICAgLy8gdmVyc2lvbiBvZiB0aGUgbmV4dCBwYWdlLiBUaGlzIGNhbiBiZSByZW5kZXJlZCBpbnN0YW50bHkuXG4gICAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IG5ld0NhY2hlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pY1JlcXVlc3RUcmVlID0gdGFzay5keW5hbWljUmVxdWVzdFRyZWVcbiAgICAgICAgICAgICAgaWYgKGR5bmFtaWNSZXF1ZXN0VHJlZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcmVmZXRjaGVkIHRyZWUgaGFzIGR5bmFtaWMgaG9sZXMgaW4gaXQuIFdlIGluaXRpYXRlIGFcbiAgICAgICAgICAgICAgICAvLyBkeW5hbWljIHJlcXVlc3QgdG8gZmlsbCB0aGVtIGluLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGJsb2NrIG9uIHRoZSByZXN1bHQuIFdlJ2xsIGltbWVkaWF0ZWx5IHJlbmRlciB0aGUgQ2FjaGVcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHRyZWUgYW5kIHN1c3BlbmQgb24gdGhlIGR5bmFtaWMgcGFydHMuIFdoZW4gdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAvLyBjb21lcyBpbiwgd2UnbGwgZmlsbCBpbiBtaXNzaW5nIGRhdGEgYW5kIHBpbmcgUmVhY3QgdG9cbiAgICAgICAgICAgICAgICAvLyByZS1yZW5kZXIuIFVubGlrZSB0aGUgbGF6eSBmZXRjaGluZyBtb2RlbCBpbiB0aGUgbm9uLVBQUlxuICAgICAgICAgICAgICAgIC8vIGltcGxlbWVudGF0aW9uLCB0aGlzIGlzIG1vZGVsZWQgYXMgYSBzaW5nbGUgUmVhY3QgdXBkYXRlICtcbiAgICAgICAgICAgICAgICAvLyBzdHJlYW1pbmcsIHJhdGhlciB0aGFuIG11bHRpcGxlIHRvcC1sZXZlbCB1cGRhdGVzLiAoSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyBldmVuIGluIHRoZSBuZXcgbW9kZWwsIHdlJ2xsIHN0aWxsIG5lZWQgdG8gc29tZXRpbWVzIHVwZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAvLyByb290IG11bHRpcGxlIHRpbWVzIHBlciBuYXZpZ2F0aW9uLCBsaWtlIGlmIHRoZSBzZXJ2ZXIgc2VuZHMgdXNcbiAgICAgICAgICAgICAgICAvLyBhIGRpZmZlcmVudCByZXNwb25zZSB0aGFuIHdlIGV4cGVjdGVkLiBGb3Igbm93LCB3ZSByZXZlcnQgYmFja1xuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBsYXp5IGZldGNoaW5nIG1lY2hhbmlzbSBpbiB0aGF0IGNhc2UuKVxuICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNSZXF1ZXN0ID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIHtcbiAgICAgICAgICAgICAgICAgIGZsaWdodFJvdXRlclN0YXRlOiBkeW5hbWljUmVxdWVzdFRyZWUsXG4gICAgICAgICAgICAgICAgICBuZXh0VXJsOiBzdGF0ZS5uZXh0VXJsLFxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBsaXN0ZW5Gb3JEeW5hbWljUmVxdWVzdCh0YXNrLCBkeW5hbWljUmVxdWVzdClcbiAgICAgICAgICAgICAgICAvLyBXZSBzdG9yZSB0aGUgZHluYW1pYyByZXF1ZXN0IG9uIHRoZSBgbGF6eURhdGFgIHByb3BlcnR5IG9mIHRoZSBDYWNoZU5vZGVcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdlJ3JlIG5vdCBnb2luZyB0byBhd2FpdCB0aGUgZHluYW1pYyByZXF1ZXN0IGhlcmUuIFNpbmNlIHdlJ3JlIG5vdCBibG9ja2luZ1xuICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBkeW5hbWljIHJlcXVlc3QsIGBsYXlvdXQtcm91dGVyYCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gdGFzay5ub2RlLmxhenlEYXRhID0gZHluYW1pY1JlcXVlc3RcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcHJlZmV0Y2hlZCB0cmVlIGRvZXMgbm90IGNvbnRhaW4gZHluYW1pYyBob2xlcyDigJQgaXQnc1xuICAgICAgICAgICAgICAgIC8vIGZ1bGx5IHN0YXRpYy4gV2UgY2FuIHNraXAgdGhlIGR5bmFtaWMgcmVxdWVzdC5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm90aGluZyBjaGFuZ2VkLCBzbyByZXVzZSB0aGUgb2xkIGNhY2hlLlxuICAgICAgICAgICAgICAvLyBUT0RPOiBXaGF0IGlmIHRoZSBoZWFkIGNoYW5nZWQgYnV0IG5vdCBhbnkgb2YgdGhlIHNlZ21lbnQgZGF0YT9cbiAgICAgICAgICAgICAgLy8gSXMgdGhhdCBwb3NzaWJsZT8gSWYgc28sIHdlIHNob3VsZCBjbG9uZSB0aGUgd2hvbGUgdHJlZSBhbmRcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBoZWFkLlxuICAgICAgICAgICAgICBuZXdUcmVlID0gdHJlZVBhdGNoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBzdGF0aWMgcmVzcG9uc2UgZG9lcyBub3QgaW5jbHVkZSBhbnkgZHluYW1pYyBob2xlcywgc29cbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbmVlZCB0byBkbyBhIHNlY29uZCByZXF1ZXN0LlxuICAgICAgICAgICAgLy8gVE9ETzogQXMgYW4gaW5jcmVtZW50YWwgc3RlcCB0aGlzIGp1c3QgcmV2ZXJ0cyBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgLy8gbm9uLVBQUiBpbXBsZW1lbnRhdGlvbi4gV2UgY2FuIHNpbXBsaWZ5IHRoaXMgYnJhbmNoIGZ1cnRoZXIsXG4gICAgICAgICAgICAvLyBnaXZlbiB0aGF0IFBQUiBwcmVmZXRjaGVzIGFyZSBhbHdheXMgc3RhdGljIGFuZCByZXR1cm4gdGhlIHdob2xlXG4gICAgICAgICAgICAvLyB0cmVlLiBPciBpbiB0aGUgbWVhbnRpbWUgd2UgY291bGQgZmFjdG9yIGl0IG91dCBpbnRvIGFcbiAgICAgICAgICAgIC8vIHNlcGFyYXRlIGZ1bmN0aW9uLlxuXG4gICAgICAgICAgICBpZiAoaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGhyZWYsIHBlbmRpbmdQdXNoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjYWNoZTogQ2FjaGVOb2RlID0gY3JlYXRlRW1wdHlDYWNoZU5vZGUoKVxuICAgICAgICAgICAgbGV0IGFwcGxpZWQgPSBmYWxzZVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHByZWZldGNoVmFsdWVzLnN0YXR1cyA9PT0gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlICYmXG4gICAgICAgICAgICAgICFpc0ZpcnN0UmVhZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBhIHN0YWxlIHByZWZldGNoIGVudHJ5LCB3ZSBvbmx5IHdhbnQgdG8gcmUtdXNlIHRoZSBsb2FkaW5nIHN0YXRlIG9mIHRoZSByb3V0ZSB3ZSdyZSBuYXZpZ2F0aW5nIHRvLCB0byBzdXBwb3J0IGluc3RhbnQgbG9hZGluZyBuYXZpZ2F0aW9uc1xuICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2ggZm9yIHRoZSBhY3R1YWwgcGFnZSBkYXRhIGJ5IG51bGxpbmcgdGhlIGByc2NgIGFuZCBgcHJlZmV0Y2hSc2NgIHZhbHVlcyBmb3IgcGFnZSBkYXRhLFxuICAgICAgICAgICAgICAvLyB3aGlsZSBjb3B5aW5nIG92ZXIgdGhlIGBsb2FkaW5nYCBmb3IgdGhlIHNlZ21lbnQgdGhhdCBjb250YWlucyB0aGUgcGFnZSBkYXRhLlxuICAgICAgICAgICAgICAvLyBXZSBvbmx5IGRvIHRoaXMgb24gc3Vic2VxdWVudCByZWFkcywgYXMgb3RoZXJ3aXNlIHRoZXJlJ2QgYmUgbm8gbG9hZGluZyBkYXRhIHRvIHJlLXVzZS5cblxuICAgICAgICAgICAgICAvLyBXZSBza2lwIHRoaXMgYnJhbmNoIGlmIG9ubHkgdGhlIGhhc2ggZnJhZ21lbnQgaGFzIGNoYW5nZWQsIGFzIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhIGxhenkgZmV0Y2ggaW4gdGhhdCBjYXNlXG4gICAgICAgICAgICAgIGFwcGxpZWQgPSB0cmlnZ2VyTGF6eUZldGNoRm9yTGVhZlNlZ21lbnRzKFxuICAgICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDYWNoZSxcbiAgICAgICAgICAgICAgICBmbGlnaHRTZWdtZW50UGF0aCxcbiAgICAgICAgICAgICAgICB0cmVlUGF0Y2hcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSByZS11c2VkIHRoZSBzdGFsZSBjYWNoZSdzIGxvYWRpbmcgc3RhdGUgJiByZWZyZXNoZWQgdGhlIGRhdGEsXG4gICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYGxhc3RVc2VkVGltZWAgc28gdGhhdCBpdCBjYW4gY29udGludWUgdG8gYmUgcmUtdXNlZCBmb3IgdGhlIG5leHQgMzBzXG4gICAgICAgICAgICAgIHByZWZldGNoVmFsdWVzLmxhc3RVc2VkVGltZSA9IG5hdmlnYXRlZEF0XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhcHBsaWVkID0gYXBwbHlGbGlnaHREYXRhKFxuICAgICAgICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDYWNoZSxcbiAgICAgICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkRmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgICBwcmVmZXRjaFZhbHVlc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGhhcmROYXZpZ2F0ZSA9IHNob3VsZEhhcmROYXZpZ2F0ZShcbiAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHksXG4gICAgICAgICAgICAgIGN1cnJlbnRUcmVlXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGlmIChoYXJkTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgLy8gQ29weSByc2MgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICBjYWNoZS5yc2MgPSBjdXJyZW50Q2FjaGUucnNjXG4gICAgICAgICAgICAgIGNhY2hlLnByZWZldGNoUnNjID0gY3VycmVudENhY2hlLnByZWZldGNoUnNjXG5cbiAgICAgICAgICAgICAgaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aChcbiAgICAgICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGV4aXN0aW5nIGNhY2hlIHZhbHVlIGlzIHVzZWQgd2hlbiB0aGUgY2FjaGUgd2FzIG5vdCBpbnZhbGlkYXRlZC5cbiAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlXG4gICAgICAgICAgICAgIC8vIElmIHdlIGFwcGxpZWQgdGhlIGNhY2hlLCB3ZSB1cGRhdGUgdGhlIFwiY3VycmVudCBjYWNoZVwiIHZhbHVlIHNvIGFueSBvdGhlclxuICAgICAgICAgICAgICAvLyBzZWdtZW50cyBpbiB0aGUgRmxpZ2h0RGF0YVBhdGggd2lsbCBiZSBhYmxlIHRvIHJlZmVyZW5jZSB0aGUgdXBkYXRlZCBjYWNoZS5cbiAgICAgICAgICAgICAgY3VycmVudENhY2hlID0gY2FjaGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCBzdWJTZWdtZW50IG9mIGdlbmVyYXRlU2VnbWVudHNGcm9tUGF0Y2godHJlZVBhdGNoKSkge1xuICAgICAgICAgICAgICBjb25zdCBzY3JvbGxhYmxlU2VnbWVudFBhdGggPSBbXG4gICAgICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgLi4uc3ViU2VnbWVudCxcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IHRoZSBfX0RFRkFVTFRfXyBwYXRocyBhcyB0aGV5IHNob3VsZG4ndCBiZSBzY3JvbGxlZCB0byBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzY3JvbGxhYmxlU2VnbWVudFBhdGhbc2Nyb2xsYWJsZVNlZ21lbnRQYXRoLmxlbmd0aCAtIDFdICE9PVxuICAgICAgICAgICAgICAgIERFRkFVTFRfU0VHTUVOVF9LRVlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzLnB1c2goc2Nyb2xsYWJsZVNlZ21lbnRQYXRoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFRyZWUgPSBuZXdUcmVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IGN1cnJlbnRUcmVlXG4gICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IHVwZGF0ZWRDYW5vbmljYWxVcmxcbiAgICAgIG11dGFibGUuc2Nyb2xsYWJsZVNlZ21lbnRzID0gc2Nyb2xsYWJsZVNlZ21lbnRzXG4gICAgICBtdXRhYmxlLmhhc2hGcmFnbWVudCA9IGhhc2hcbiAgICAgIG11dGFibGUuc2hvdWxkU2Nyb2xsID0gc2hvdWxkU2Nyb2xsXG5cbiAgICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxuICAgIH0sXG4gICAgKCkgPT4gc3RhdGVcbiAgKVxufVxuIl0sIm5hbWVzIjpbImhhbmRsZUV4dGVybmFsVXJsIiwibmF2aWdhdGVSZWR1Y2VyIiwic3RhdGUiLCJtdXRhYmxlIiwidXJsIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwiY2Fub25pY2FsVXJsIiwic2Nyb2xsYWJsZVNlZ21lbnRzIiwidW5kZWZpbmVkIiwiaGFuZGxlTXV0YWJsZSIsImdlbmVyYXRlU2VnbWVudHNGcm9tUGF0Y2giLCJmbGlnaHRSb3V0ZXJQYXRjaCIsInNlZ21lbnRzIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJwYXJhbGxlbFJvdXRlIiwiZW50cmllcyIsImNoaWxkU2VnbWVudCIsInB1c2giLCJ0cmlnZ2VyTGF6eUZldGNoRm9yTGVhZlNlZ21lbnRzIiwibmV3Q2FjaGUiLCJjdXJyZW50Q2FjaGUiLCJmbGlnaHRTZWdtZW50UGF0aCIsInRyZWVQYXRjaCIsImFwcGxpZWRQYXRjaCIsInJzYyIsInByZWZldGNoUnNjIiwibG9hZGluZyIsIk1hcCIsInNlZ21lbnRQYXRoc1RvRmlsbCIsIm1hcCIsInNlZ21lbnRQYXRocyIsImNsZWFyQ2FjaGVOb2RlRGF0YUZvclNlZ21lbnRQYXRoIiwiaGFuZGxlTmF2aWdhdGlvblJlc3VsdCIsInJlc3VsdCIsInRhZyIsIk5hdmlnYXRpb25SZXN1bHRUYWciLCJNUEEiLCJuZXdVcmwiLCJkYXRhIiwiTm9PcCIsIm5ld0Nhbm9uaWNhbFVybCIsIm9sZFVybCIsIlVSTCIsIm9ubHlIYXNoQ2hhbmdlIiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIiwic2hvdWxkU2Nyb2xsIiwiaGFzaEZyYWdtZW50IiwiU3VjY2VzcyIsImNhY2hlIiwiY2FjaGVOb2RlIiwicGF0Y2hlZFRyZWUiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIkFzeW5jIiwidGhlbiIsImFzeW5jUmVzdWx0IiwiYWN0aW9uIiwiaXNFeHRlcm5hbFVybCIsIm5hdmlnYXRlVHlwZSIsImFsbG93QWxpYXNpbmciLCJocmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJwcmVmZXRjaENhY2hlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJ0b1N0cmluZyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwibmF2aWdhdGVVc2luZ1NlZ21lbnRDYWNoZSIsInRyZWUiLCJuZXh0VXJsIiwicHJlZmV0Y2hWYWx1ZXMiLCJnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSIsInRyZWVBdFRpbWVPZlByZWZldGNoIiwicHJlZmV0Y2hRdWV1ZSIsImJ1bXAiLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJwb3N0cG9uZWQiLCJuYXZpZ2F0ZWRBdCIsIkRhdGUiLCJub3ciLCJpc0ZpcnN0UmVhZCIsImxhc3RVc2VkVGltZSIsImFsaWFzZWQiLCJoYW5kbGVBbGlhc2VkUHJlZmV0Y2hFbnRyeSIsInVwZGF0ZWRDYW5vbmljYWxVcmwiLCJzcGxpdCIsImN1cnJlbnRUcmVlIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJwYXRoVG9TZWdtZW50Iiwic2VlZERhdGEiLCJoZWFkIiwiaXNIZWFkUGFydGlhbCIsImlzUm9vdFJlbmRlciIsImZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJ0YXNrIiwic3RhcnRQUFJOYXZpZ2F0aW9uIiwicm91dGUiLCJwYXRjaGVkUm91dGVyU3RhdGUiLCJub2RlIiwiZHluYW1pY1JlcXVlc3RUcmVlIiwiZHluYW1pY1JlcXVlc3QiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwibGlzdGVuRm9yRHluYW1pY1JlcXVlc3QiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImFwcGxpZWQiLCJzdGF0dXMiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJzdGFsZSIsImFwcGx5RmxpZ2h0RGF0YSIsImhhcmROYXZpZ2F0ZSIsInNob3VsZEhhcmROYXZpZ2F0ZSIsImludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgiLCJzdWJTZWdtZW50Iiwic2Nyb2xsYWJsZVNlZ21lbnRQYXRoIiwiREVGQVVMVF9TRUdNRU5UX0tFWSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    prefetchQueue: function() {\n        return prefetchQueue;\n    },\n    prefetchReducer: function() {\n        return prefetchReducer;\n    }\n});\nconst _promisequeue = __webpack_require__(/*! ../../promise-queue */ \"(app-pages-browser)/./node_modules/next/dist/client/components/promise-queue.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst prefetchQueue = new _promisequeue.PromiseQueue(5);\nconst prefetchReducer =  false ? 0 : prefetchReducerImpl;\nfunction identityReducerWhenSegmentCacheIsEnabled(state) {\n    // Unlike the old implementation, the Segment Cache doesn't store its data in\n    // the router reducer state.\n    //\n    // This shouldn't be reachable because we wrap the prefetch API in a check,\n    // too, which prevents the action from being dispatched. But it's here for\n    // clarity + code elimination.\n    return state;\n}\nfunction prefetchReducerImpl(state, action) {\n    // let's prune the prefetch cache before we do anything else\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    const { url } = action;\n    (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        prefetchCache: state.prefetchCache,\n        kind: action.kind,\n        tree: state.tree,\n        allowAliasing: true\n    });\n    return state;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcHJlZmV0Y2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFVYUEsYUFBYTtlQUFiQTs7SUFFQUMsZUFBZTtlQUFmQTs7OzBDQVBnQjtnREFJdEI7QUFDQSxNQUFNRCxnQkFBZ0IsSUFBSUUsY0FBQUEsWUFBWSxDQUFDO0FBRXZDLE1BQU1ELGtCQUFrQkUsTUFBdUMsR0FDbEVHLENBQXdDQSxHQUN4Q0M7QUFFSixTQUFTRCx5Q0FBNENFLEtBQVE7SUFDM0QsNkVBQTZFO0lBQzdFLDRCQUE0QjtJQUM1QixFQUFFO0lBQ0YsMkVBQTJFO0lBQzNFLDBFQUEwRTtJQUMxRSw4QkFBOEI7SUFDOUIsT0FBT0E7QUFDVDtBQUVBLFNBQVNELG9CQUNQQyxLQUEyQixFQUMzQkMsTUFBc0I7SUFFdEIsNERBQTREO0lBQzVEQyxDQUFBQSxHQUFBQSxvQkFBQUEsa0JBQUFBLEVBQW1CRixNQUFNRyxhQUFhO0lBRXRDLE1BQU0sRUFBRUMsR0FBRyxFQUFFLEdBQUdIO0lBRWhCSSxDQUFBQSxHQUFBQSxvQkFBQUEsNkJBQUFBLEVBQThCO1FBQzVCRDtRQUNBRSxTQUFTTixNQUFNTSxPQUFPO1FBQ3RCSCxlQUFlSCxNQUFNRyxhQUFhO1FBQ2xDSSxNQUFNTixPQUFPTSxJQUFJO1FBQ2pCQyxNQUFNUixNQUFNUSxJQUFJO1FBQ2hCQyxlQUFlO0lBQ2pCO0lBRUEsT0FBT1Q7QUFDVCIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccmVkdWNlcnNcXHByZWZldGNoLXJlZHVjZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBQcmVmZXRjaEFjdGlvbixcbiAgUmVkdWNlclN0YXRlLFxuICBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBQcm9taXNlUXVldWUgfSBmcm9tICcuLi8uLi9wcm9taXNlLXF1ZXVlJ1xuaW1wb3J0IHtcbiAgZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnksXG4gIHBydW5lUHJlZmV0Y2hDYWNoZSxcbn0gZnJvbSAnLi4vcHJlZmV0Y2gtY2FjaGUtdXRpbHMnXG5leHBvcnQgY29uc3QgcHJlZmV0Y2hRdWV1ZSA9IG5ldyBQcm9taXNlUXVldWUoNSlcblxuZXhwb3J0IGNvbnN0IHByZWZldGNoUmVkdWNlciA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRVxuICA/IGlkZW50aXR5UmVkdWNlcldoZW5TZWdtZW50Q2FjaGVJc0VuYWJsZWRcbiAgOiBwcmVmZXRjaFJlZHVjZXJJbXBsXG5cbmZ1bmN0aW9uIGlkZW50aXR5UmVkdWNlcldoZW5TZWdtZW50Q2FjaGVJc0VuYWJsZWQ8VD4oc3RhdGU6IFQpOiBUIHtcbiAgLy8gVW5saWtlIHRoZSBvbGQgaW1wbGVtZW50YXRpb24sIHRoZSBTZWdtZW50IENhY2hlIGRvZXNuJ3Qgc3RvcmUgaXRzIGRhdGEgaW5cbiAgLy8gdGhlIHJvdXRlciByZWR1Y2VyIHN0YXRlLlxuICAvL1xuICAvLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUgYmVjYXVzZSB3ZSB3cmFwIHRoZSBwcmVmZXRjaCBBUEkgaW4gYSBjaGVjayxcbiAgLy8gdG9vLCB3aGljaCBwcmV2ZW50cyB0aGUgYWN0aW9uIGZyb20gYmVpbmcgZGlzcGF0Y2hlZC4gQnV0IGl0J3MgaGVyZSBmb3JcbiAgLy8gY2xhcml0eSArIGNvZGUgZWxpbWluYXRpb24uXG4gIHJldHVybiBzdGF0ZVxufVxuXG5mdW5jdGlvbiBwcmVmZXRjaFJlZHVjZXJJbXBsKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogUHJlZmV0Y2hBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIC8vIGxldCdzIHBydW5lIHRoZSBwcmVmZXRjaCBjYWNoZSBiZWZvcmUgd2UgZG8gYW55dGhpbmcgZWxzZVxuICBwcnVuZVByZWZldGNoQ2FjaGUoc3RhdGUucHJlZmV0Y2hDYWNoZSlcblxuICBjb25zdCB7IHVybCB9ID0gYWN0aW9uXG5cbiAgZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkoe1xuICAgIHVybCxcbiAgICBuZXh0VXJsOiBzdGF0ZS5uZXh0VXJsLFxuICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAga2luZDogYWN0aW9uLmtpbmQsXG4gICAgdHJlZTogc3RhdGUudHJlZSxcbiAgICBhbGxvd0FsaWFzaW5nOiB0cnVlLFxuICB9KVxuXG4gIHJldHVybiBzdGF0ZVxufVxuIl0sIm5hbWVzIjpbInByZWZldGNoUXVldWUiLCJwcmVmZXRjaFJlZHVjZXIiLCJQcm9taXNlUXVldWUiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwiaWRlbnRpdHlSZWR1Y2VyV2hlblNlZ21lbnRDYWNoZUlzRW5hYmxlZCIsInByZWZldGNoUmVkdWNlckltcGwiLCJzdGF0ZSIsImFjdGlvbiIsInBydW5lUHJlZmV0Y2hDYWNoZSIsInByZWZldGNoQ2FjaGUiLCJ1cmwiLCJnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSIsIm5leHRVcmwiLCJraW5kIiwidHJlZSIsImFsbG93QWxpYXNpbmciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "refreshReducer", ({\n    enumerable: true,\n    get: function() {\n        return refreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js");\nconst _approuter = __webpack_require__(/*! ../../app-router */ "(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js");\nconst _segmentcache = __webpack_require__(/*! ../../segment-cache */ "(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js");\nfunction refreshReducer(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn\'t get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            currentTree[0],\n            currentTree[1],\n            currentTree[2],\n            \'refetch\'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null\n    });\n    const navigatedAt = Date.now();\n    return cache.lazyData.then(async (param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \'string\') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log(\'REFRESH FAILED\');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                \'\'\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[1];\n                const loading = cacheNodeSeedData[3];\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                cache.loading = loading;\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, treePatch, cacheNodeSeedData, head, undefined);\n                if (false) {} else {\n                    mutable.prefetchCache = new Map();\n                }\n            }\n            await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                navigatedAt,\n                state,\n                updatedTree: newTree,\n                updatedCache: cache,\n                includeNextUrl,\n                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n            });\n            mutable.cache = cache;\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === \'function\' || typeof exports.default === \'object\' && exports.default !== null) && typeof exports.default.__esModule === \'undefined\') {\n    Object.defineProperty(exports.default, \'__esModule\', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcmVmcmVzaC1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7a0RBb0JnQkE7OztlQUFBQTs7O2lEQXBCb0I7K0NBQ0Y7eURBQ1U7eURBQ0E7NkNBT1Y7MkNBQ0o7MkRBRWdCO3VDQUNUO21EQUNDOytEQUNZOzZEQUNGOzBDQUNWO0FBRS9CLFNBQVNBLGVBQ2RDLEtBQTJCLEVBQzNCQyxNQUFxQjtJQUVyQixNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHRDtJQUNuQixNQUFNRSxVQUFtQixDQUFDO0lBQzFCLE1BQU1DLE9BQU9KLE1BQU1LLFlBQVk7SUFFL0IsSUFBSUMsY0FBY04sTUFBTU8sSUFBSTtJQUU1QkosUUFBUUssMEJBQTBCLEdBQUc7SUFFckMsTUFBTUMsUUFBbUJDLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFBQTtJQUV6QixzRkFBc0Y7SUFDdEYsc0hBQXNIO0lBQ3RILE1BQU1DLGlCQUFpQkMsQ0FBQUEsR0FBQUEsbUNBQUFBLGlDQUFpQyxFQUFDWixNQUFNTyxJQUFJO0lBRW5FLHVEQUF1RDtJQUN2RCx3Q0FBd0M7SUFDeENFLE1BQU1JLFFBQVEsR0FBR0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFBQSxFQUFvQixJQUFJQyxJQUFJWCxNQUFNRixTQUFTO1FBQzFEYyxtQkFBbUI7WUFDakJWLFdBQVcsQ0FBQyxFQUFFO1lBQ2RBLFdBQVcsQ0FBQyxFQUFFO1lBQ2RBLFdBQVcsQ0FBQyxFQUFFO1lBQ2Q7U0FDRDtRQUNEVyxTQUFTTixpQkFBaUJYLE1BQU1pQixPQUFPLEdBQUc7SUFDNUM7SUFFQSxNQUFNQyxjQUFjQyxLQUFLQyxHQUFHO0lBQzVCLE9BQU9YLE1BQU1JLFFBQVEsQ0FBQ1EsSUFBSSxDQUN4QjtZQUFPLEVBQUVDLFVBQVUsRUFBRWpCLGNBQWNrQixvQkFBb0IsRUFBRTtRQUN2RCw0REFBNEQ7UUFDNUQsSUFBSSxPQUFPRCxlQUFlLFVBQVU7WUFDbEMsT0FBT0UsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFBQSxFQUNMeEIsT0FDQUcsU0FDQW1CLFlBQ0F0QixNQUFNeUIsT0FBTyxDQUFDQyxXQUFXO1FBRTdCO1FBRUEsK0RBQStEO1FBQy9EakIsTUFBTUksUUFBUSxHQUFHO1FBRWpCLEtBQUssTUFBTWMsd0JBQXdCTCxXQUFZO1lBQzdDLE1BQU0sRUFDSmYsTUFBTXFCLFNBQVMsRUFDZkMsVUFBVUMsaUJBQWlCLEVBQzNCQyxJQUFJLEVBQ0pDLFlBQVksRUFDYixHQUFHTDtZQUVKLElBQUksQ0FBQ0ssY0FBYztnQkFDakIsb0NBQW9DO2dCQUNwQ0MsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE9BQU9sQztZQUNUO1lBRUEsTUFBTW1DLFVBQVVDLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBQUEsRUFDZDtnQkFDQzthQUFHLEVBQ0o5QixhQUNBc0IsV0FDQTVCLE1BQU1LLFlBQVk7WUFHcEIsSUFBSThCLFlBQVksTUFBTTtnQkFDcEIsT0FBT0UsQ0FBQUEsR0FBQUEsdUJBQUFBLHFCQUFBQSxFQUFzQnJDLE9BQU9DLFFBQVEyQjtZQUM5QztZQUVBLElBQUlVLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBQUEsRUFBNEJoQyxhQUFhNkIsVUFBVTtnQkFDckQsT0FBT1gsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFBQSxFQUNMeEIsT0FDQUcsU0FDQUMsTUFDQUosTUFBTXlCLE9BQU8sQ0FBQ0MsV0FBVztZQUU3QjtZQUVBLE1BQU1hLDJCQUEyQmhCLHVCQUM3QmlCLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JqQix3QkFDbEJrQjtZQUVKLElBQUlsQixzQkFBc0I7Z0JBQ3hCcEIsUUFBUUUsWUFBWSxHQUFHa0M7WUFDekI7WUFFQSw4RkFBOEY7WUFDOUYsSUFBSVQsc0JBQXNCLE1BQU07Z0JBQzlCLE1BQU1ZLE1BQU1aLGlCQUFpQixDQUFDLEVBQUU7Z0JBQ2hDLE1BQU1hLFVBQVViLGlCQUFpQixDQUFDLEVBQUU7Z0JBQ3BDckIsTUFBTWlDLEdBQUcsR0FBR0E7Z0JBQ1pqQyxNQUFNbUMsV0FBVyxHQUFHO2dCQUNwQm5DLE1BQU1rQyxPQUFPLEdBQUdBO2dCQUNoQkUsQ0FBQUEsR0FBQUEsK0JBQUFBLDZCQUFBQSxFQUNFM0IsYUFDQVQsT0FDQSxXQUVBbUIsV0FDQUUsbUJBQ0FDLE1BQ0FVO2dCQUVGLElBQUlLLEtBQXVDLEVBQUUsRUFFNUMsTUFBTTtvQkFDTDNDLFFBQVErQyxhQUFhLEdBQUcsSUFBSUM7Z0JBQzlCO1lBQ0Y7WUFFQSxNQUFNQyxDQUFBQSxHQUFBQSxpQ0FBQUEsK0JBQUFBLEVBQWdDO2dCQUNwQ2xDO2dCQUNBbEI7Z0JBQ0FxRCxhQUFhbEI7Z0JBQ2JtQixjQUFjN0M7Z0JBQ2RFO2dCQUNBTixjQUFjRixRQUFRRSxZQUFZLElBQUlMLE1BQU1LLFlBQVk7WUFDMUQ7WUFFQUYsUUFBUU0sS0FBSyxHQUFHQTtZQUNoQk4sUUFBUW9ELFdBQVcsR0FBR3BCO1lBRXRCN0IsY0FBYzZCO1FBQ2hCO1FBRUEsT0FBT3FCLENBQUFBLEdBQUFBLGVBQUFBLGFBQUFBLEVBQWN4RCxPQUFPRztJQUM5QixHQUNBLElBQU1IO0FBRVYiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXHJlZHVjZXJzXFxyZWZyZXNoLXJlZHVjZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZmV0Y2hTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJy4uL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi4vY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQgeyBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgfSBmcm9tICcuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSdcbmltcG9ydCB7IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCB9IGZyb20gJy4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0J1xuaW1wb3J0IHR5cGUge1xuICBNdXRhYmxlLFxuICBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgUmVkdWNlclN0YXRlLFxuICBSZWZyZXNoQWN0aW9uLFxufSBmcm9tICcuLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGhhbmRsZUV4dGVybmFsVXJsIH0gZnJvbSAnLi9uYXZpZ2F0ZS1yZWR1Y2VyJ1xuaW1wb3J0IHsgaGFuZGxlTXV0YWJsZSB9IGZyb20gJy4uL2hhbmRsZS1tdXRhYmxlJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIH0gZnJvbSAnLi4vZmlsbC1sYXp5LWl0ZW1zLXRpbGwtbGVhZi13aXRoLWhlYWQnXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUNhY2hlTm9kZSB9IGZyb20gJy4uLy4uL2FwcC1yb3V0ZXInXG5pbXBvcnQgeyBoYW5kbGVTZWdtZW50TWlzbWF0Y2ggfSBmcm9tICcuLi9oYW5kbGUtc2VnbWVudC1taXNtYXRjaCdcbmltcG9ydCB7IGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSB9IGZyb20gJy4vaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUnXG5pbXBvcnQgeyByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIH0gZnJvbSAnLi4vcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cydcbmltcG9ydCB7IHJldmFsaWRhdGVFbnRpcmVDYWNoZSB9IGZyb20gJy4uLy4uL3NlZ21lbnQtY2FjaGUnXG5cbmV4cG9ydCBmdW5jdGlvbiByZWZyZXNoUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFJlZnJlc2hBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIGNvbnN0IHsgb3JpZ2luIH0gPSBhY3Rpb25cbiAgY29uc3QgbXV0YWJsZTogTXV0YWJsZSA9IHt9XG4gIGNvbnN0IGhyZWYgPSBzdGF0ZS5jYW5vbmljYWxVcmxcblxuICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlXG5cbiAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlXG5cbiAgY29uc3QgY2FjaGU6IENhY2hlTm9kZSA9IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKClcblxuICAvLyBJZiB0aGUgY3VycmVudCB0cmVlIHdhcyBpbnRlcmNlcHRlZCwgdGhlIG5leHRVcmwgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0LlxuICAvLyBUaGlzIGlzIHRvIGVuc3VyZSB0aGF0IHRoZSByZWZyZXNoIHJlcXVlc3QgZG9lc24ndCBnZXQgaW50ZXJjZXB0ZWQsIGFjY2lkZW50YWxseSB0cmlnZ2VyaW5nIHRoZSBpbnRlcmNlcHRpb24gcm91dGUuXG4gIGNvbnN0IGluY2x1ZGVOZXh0VXJsID0gaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKHN0YXRlLnRyZWUpXG5cbiAgLy8gVE9ETy1BUFA6IHZlcmlmeSB0aGF0IGBocmVmYCBpcyBub3QgYW4gZXh0ZXJuYWwgdXJsLlxuICAvLyBGZXRjaCBkYXRhIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXG4gIGNhY2hlLmxhenlEYXRhID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZShuZXcgVVJMKGhyZWYsIG9yaWdpbiksIHtcbiAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogW1xuICAgICAgY3VycmVudFRyZWVbMF0sXG4gICAgICBjdXJyZW50VHJlZVsxXSxcbiAgICAgIGN1cnJlbnRUcmVlWzJdLFxuICAgICAgJ3JlZmV0Y2gnLFxuICAgIF0sXG4gICAgbmV4dFVybDogaW5jbHVkZU5leHRVcmwgPyBzdGF0ZS5uZXh0VXJsIDogbnVsbCxcbiAgfSlcblxuICBjb25zdCBuYXZpZ2F0ZWRBdCA9IERhdGUubm93KClcbiAgcmV0dXJuIGNhY2hlLmxhenlEYXRhLnRoZW4oXG4gICAgYXN5bmMgKHsgZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZSB9KSA9PiB7XG4gICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGNhY2hlLmxhenlEYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICBjYWNoZS5sYXp5RGF0YSA9IG51bGxcblxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0cmVlOiB0cmVlUGF0Y2gsXG4gICAgICAgICAgc2VlZERhdGE6IGNhY2hlTm9kZVNlZWREYXRhLFxuICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgaXNSb290UmVuZGVyLFxuICAgICAgICB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcblxuICAgICAgICBpZiAoIWlzUm9vdFJlbmRlcikge1xuICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSRUZSRVNIIEZBSUxFRCcpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICBbJyddLFxuICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVNlZ21lbnRNaXNtYXRjaChzdGF0ZSwgYWN0aW9uLCB0cmVlUGF0Y2gpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVcbiAgICAgICAgICA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKVxuICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlKSB7XG4gICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWZcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZXMgY2FzZSB3aGVyZSBwcmVmZXRjaCBvbmx5IHJldHVybnMgdGhlIHJvdXRlciB0cmVlIHBhdGNoIHdpdGhvdXQgcmVuZGVyZWQgY29tcG9uZW50cy5cbiAgICAgICAgaWYgKGNhY2hlTm9kZVNlZWREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgcnNjID0gY2FjaGVOb2RlU2VlZERhdGFbMV1cbiAgICAgICAgICBjb25zdCBsb2FkaW5nID0gY2FjaGVOb2RlU2VlZERhdGFbM11cbiAgICAgICAgICBjYWNoZS5yc2MgPSByc2NcbiAgICAgICAgICBjYWNoZS5wcmVmZXRjaFJzYyA9IG51bGxcbiAgICAgICAgICBjYWNoZS5sb2FkaW5nID0gbG9hZGluZ1xuICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIC8vIEV4aXN0aW5nIGNhY2hlIGlzIG5vdCBwYXNzZWQgaW4gYXMgYHJvdXRlci5yZWZyZXNoKClgIGhhcyB0byBpbnZhbGlkYXRlIHRoZSBlbnRpcmUgY2FjaGUuXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgICBjYWNoZU5vZGVTZWVkRGF0YSxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgICAgICAgICAgcmV2YWxpZGF0ZUVudGlyZUNhY2hlKHN0YXRlLm5leHRVcmwsIG5ld1RyZWUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG11dGFibGUucHJlZmV0Y2hDYWNoZSA9IG5ldyBNYXAoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMoe1xuICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHVwZGF0ZWRUcmVlOiBuZXdUcmVlLFxuICAgICAgICAgIHVwZGF0ZWRDYWNoZTogY2FjaGUsXG4gICAgICAgICAgaW5jbHVkZU5leHRVcmwsXG4gICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybCB8fCBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgIH0pXG5cbiAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlXG4gICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlXG5cbiAgICAgICAgY3VycmVudFRyZWUgPSBuZXdUcmVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxuICAgIH0sXG4gICAgKCkgPT4gc3RhdGVcbiAgKVxufVxuIl0sIm5hbWVzIjpbInJlZnJlc2hSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJvcmlnaW4iLCJtdXRhYmxlIiwiaHJlZiIsImNhbm9uaWNhbFVybCIsImN1cnJlbnRUcmVlIiwidHJlZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImluY2x1ZGVOZXh0VXJsIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwibGF6eURhdGEiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwibmF2aWdhdGVkQXQiLCJEYXRlIiwibm93IiwidGhlbiIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsImhhbmRsZUV4dGVybmFsVXJsIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJ0cmVlUGF0Y2giLCJzZWVkRGF0YSIsImNhY2hlTm9kZVNlZWREYXRhIiwiaGVhZCIsImlzUm9vdFJlbmRlciIsImNvbnNvbGUiLCJsb2ciLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiaGFuZGxlU2VnbWVudE1pc21hdGNoIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ1bmRlZmluZWQiLCJyc2MiLCJsb2FkaW5nIiwicHJlZmV0Y2hSc2MiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJyZXZhbGlkYXRlRW50aXJlQ2FjaGUiLCJwcmVmZXRjaENhY2hlIiwiTWFwIiwicmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyIsInVwZGF0ZWRUcmVlIiwidXBkYXRlZENhY2hlIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js\n'))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"restoreReducer\", ({\n    enumerable: true,\n    get: function() {\n        return restoreReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _computechangedpath = __webpack_require__(/*! ../compute-changed-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\");\nfunction restoreReducer(state, action) {\n    const { url, tree } = action;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    // This action is used to restore the router state from the history state.\n    // However, it's possible that the history state no longer contains the `FlightRouterState`.\n    // We will copy over the internal state on pushState/replaceState events, but if a history entry\n    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n    // the history state will not contain the `FlightRouterState`.\n    // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n    const treeToRestore = tree || state.tree;\n    const oldCache = state.cache;\n    const newCache =  false ? // prevents an unnecessary flash back to PPR state during a\n    // back/forward navigation.\n    0 : oldCache;\n    var _extractPathFromFlightRouterState;\n    return {\n        // Set canonical url\n        canonicalUrl: href,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // Ensures that the custom history state that was set is preserved when applying this update.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: state.focusAndScrollRef,\n        cache: newCache,\n        prefetchCache: state.prefetchCache,\n        // Restore provided tree\n        tree: treeToRestore,\n        nextUrl: (_extractPathFromFlightRouterState = (0, _computechangedpath.extractPathFromFlightRouterState)(treeToRestore)) != null ? _extractPathFromFlightRouterState : url.pathname\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=restore-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcmVzdG9yZS1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7a0RBU2dCQTs7O2VBQUFBOzs7K0NBVGtCO2dEQU1lOzRDQUNJO0FBRTlDLFNBQVNBLGVBQ2RDLEtBQTJCLEVBQzNCQyxNQUFxQjtJQUVyQixNQUFNLEVBQUVDLEdBQUcsRUFBRUMsSUFBSSxFQUFFLEdBQUdGO0lBQ3RCLE1BQU1HLE9BQU9DLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JIO0lBQy9CLDBFQUEwRTtJQUMxRSw0RkFBNEY7SUFDNUYsZ0dBQWdHO0lBQ2hHLDZGQUE2RjtJQUM3Riw4REFBOEQ7SUFDOUQseUdBQXlHO0lBQ3pHLE1BQU1JLGdCQUFnQkgsUUFBUUgsTUFBTUcsSUFBSTtJQUV4QyxNQUFNSSxXQUFXUCxNQUFNUSxLQUFLO0lBQzVCLE1BQU1DLFdBQVdDLE1BQXNCLEdBRW5DLDJEQUMyRDtJQUMzRCwyQkFBMkI7SUFDM0JHLENBQTZEUCxHQUM3REM7UUFnQk9PO0lBZFgsT0FBTztRQUNMLG9CQUFvQjtRQUNwQkMsY0FBY1g7UUFDZFksU0FBUztZQUNQQyxhQUFhO1lBQ2JDLGVBQWU7WUFDZiw2RkFBNkY7WUFDN0ZDLDRCQUE0QjtRQUM5QjtRQUNBQyxtQkFBbUJwQixNQUFNb0IsaUJBQWlCO1FBQzFDWixPQUFPQztRQUNQWSxlQUFlckIsTUFBTXFCLGFBQWE7UUFDbEMsd0JBQXdCO1FBQ3hCbEIsTUFBTUc7UUFDTmdCLFNBQVNSLENBQUFBLG9DQUFBQSxDQUFBQSxHQUFBQSxvQkFBQUEsZ0NBQUFBLEVBQWlDUixjQUFBQSxLQUFBQSxPQUFqQ1Esb0NBQW1EWixJQUFJcUIsUUFBUTtJQUMxRTtBQUNGIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxyZWR1Y2Vyc1xccmVzdG9yZS1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi4vY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQgdHlwZSB7XG4gIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBSZWR1Y2VyU3RhdGUsXG4gIFJlc3RvcmVBY3Rpb24sXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi9jb21wdXRlLWNoYW5nZWQtcGF0aCdcbmltcG9ydCB7IHVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbiB9IGZyb20gJy4uL3Bwci1uYXZpZ2F0aW9ucydcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVSZWR1Y2VyKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogUmVzdG9yZUFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgY29uc3QgeyB1cmwsIHRyZWUgfSA9IGFjdGlvblxuICBjb25zdCBocmVmID0gY3JlYXRlSHJlZkZyb21VcmwodXJsKVxuICAvLyBUaGlzIGFjdGlvbiBpcyB1c2VkIHRvIHJlc3RvcmUgdGhlIHJvdXRlciBzdGF0ZSBmcm9tIHRoZSBoaXN0b3J5IHN0YXRlLlxuICAvLyBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGhpc3Rvcnkgc3RhdGUgbm8gbG9uZ2VyIGNvbnRhaW5zIHRoZSBgRmxpZ2h0Um91dGVyU3RhdGVgLlxuICAvLyBXZSB3aWxsIGNvcHkgb3ZlciB0aGUgaW50ZXJuYWwgc3RhdGUgb24gcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSBldmVudHMsIGJ1dCBpZiBhIGhpc3RvcnkgZW50cnlcbiAgLy8gb2NjdXJyZWQgYmVmb3JlIGh5ZHJhdGlvbiwgb3IgaWYgdGhlIHVzZXIgbmF2aWdhdGVkIHRvIGEgaGFzaCB1c2luZyBhIHJlZ3VsYXIgYW5jaG9yIGxpbmssXG4gIC8vIHRoZSBoaXN0b3J5IHN0YXRlIHdpbGwgbm90IGNvbnRhaW4gdGhlIGBGbGlnaHRSb3V0ZXJTdGF0ZWAuXG4gIC8vIEluIHRoaXMgY2FzZSwgd2UnbGwgY29udGludWUgdG8gdXNlIHRoZSBleGlzdGluZyB0cmVlIHNvIHRoZSByb3V0ZXIgZG9lc24ndCBnZXQgaW50byBhbiBpbnZhbGlkIHN0YXRlLlxuICBjb25zdCB0cmVlVG9SZXN0b3JlID0gdHJlZSB8fCBzdGF0ZS50cmVlXG5cbiAgY29uc3Qgb2xkQ2FjaGUgPSBzdGF0ZS5jYWNoZVxuICBjb25zdCBuZXdDYWNoZSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9QUFJcbiAgICA/IC8vIFdoZW4gUFBSIGlzIGVuYWJsZWQsIHdlIHVwZGF0ZSB0aGUgY2FjaGUgdG8gZHJvcCB0aGUgcHJlZmV0Y2hcbiAgICAgIC8vIGRhdGEgZm9yIGFueSBzZWdtZW50IHdob3NlIGR5bmFtaWMgZGF0YSB3YXMgYWxyZWFkeSByZWNlaXZlZC4gVGhpc1xuICAgICAgLy8gcHJldmVudHMgYW4gdW5uZWNlc3NhcnkgZmxhc2ggYmFjayB0byBQUFIgc3RhdGUgZHVyaW5nIGFcbiAgICAgIC8vIGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9uLlxuICAgICAgdXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uKG9sZENhY2hlLCB0cmVlVG9SZXN0b3JlKVxuICAgIDogb2xkQ2FjaGVcblxuICByZXR1cm4ge1xuICAgIC8vIFNldCBjYW5vbmljYWwgdXJsXG4gICAgY2Fub25pY2FsVXJsOiBocmVmLFxuICAgIHB1c2hSZWY6IHtcbiAgICAgIHBlbmRpbmdQdXNoOiBmYWxzZSxcbiAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlLFxuICAgICAgLy8gRW5zdXJlcyB0aGF0IHRoZSBjdXN0b20gaGlzdG9yeSBzdGF0ZSB0aGF0IHdhcyBzZXQgaXMgcHJlc2VydmVkIHdoZW4gYXBwbHlpbmcgdGhpcyB1cGRhdGUuXG4gICAgICBwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZTogdHJ1ZSxcbiAgICB9LFxuICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiBzdGF0ZS5mb2N1c0FuZFNjcm9sbFJlZixcbiAgICBjYWNoZTogbmV3Q2FjaGUsXG4gICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAvLyBSZXN0b3JlIHByb3ZpZGVkIHRyZWVcbiAgICB0cmVlOiB0cmVlVG9SZXN0b3JlLFxuICAgIG5leHRVcmw6IGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlKHRyZWVUb1Jlc3RvcmUpID8/IHVybC5wYXRobmFtZSxcbiAgfVxufVxuIl0sIm5hbWVzIjpbInJlc3RvcmVSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJ1cmwiLCJ0cmVlIiwiaHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidHJlZVRvUmVzdG9yZSIsIm9sZENhY2hlIiwiY2FjaGUiLCJuZXdDYWNoZSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUFBSIiwidXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uIiwiZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUiLCJjYW5vbmljYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJmb2N1c0FuZFNjcm9sbFJlZiIsInByZWZldGNoQ2FjaGUiLCJuZXh0VXJsIiwicGF0aG5hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"serverActionReducer\", ({\n    enumerable: true,\n    get: function() {\n        return serverActionReducer;\n    }\n}));\nconst _appcallserver = __webpack_require__(/*! ../../../app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ../../../app-find-source-map-url */ \"(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _approuterheaders = __webpack_require__(/*! ../../app-router-headers */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst _routerreducertypes = __webpack_require__(/*! ../router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _assignlocation = __webpack_require__(/*! ../../../assign-location */ \"(app-pages-browser)/./node_modules/next/dist/client/assign-location.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _redirect = __webpack_require__(/*! ../../redirect */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect.js\");\nconst _redirecterror = __webpack_require__(/*! ../../redirect-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-error.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst _removebasepath = __webpack_require__(/*! ../../../remove-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nconst _serverreferenceinfo = __webpack_require__(/*! ../../../../shared/lib/server-reference-info */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/server-reference-info.js\");\nconst _segmentcache = __webpack_require__(/*! ../../segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { encodeReply } from 'react-server-dom-webpack/client'\nconst { createFromFetch, createTemporaryReferenceSet, encodeReply } =  false ? 0 : __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\nasync function fetchServerAction(state, nextUrl, param) {\n    let { actionId, actionArgs } = param;\n    const temporaryReferences = createTemporaryReferenceSet();\n    const info = (0, _serverreferenceinfo.extractInfoFromServerReferenceId)(actionId);\n    // TODO: Currently, we're only omitting unused args for the experimental \"use\n    // cache\" functions. Once the server reference info byte feature is stable, we\n    // should apply this to server actions as well.\n    const usedArgs = info.type === 'use-cache' ? (0, _serverreferenceinfo.omitUnusedArgs)(actionArgs, info) : actionArgs;\n    const body = await encodeReply(usedArgs, {\n        temporaryReferences\n    });\n    const res = await fetch('', {\n        method: 'POST',\n        headers: {\n            Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,\n            [_approuterheaders.ACTION_HEADER]: actionId,\n            [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(JSON.stringify(state.tree)),\n            ... false ? 0 : {},\n            ...nextUrl ? {\n                [_approuterheaders.NEXT_URL]: nextUrl\n            } : {}\n        },\n        body\n    });\n    const redirectHeader = res.headers.get('x-action-redirect');\n    const [location, _redirectType] = (redirectHeader == null ? void 0 : redirectHeader.split(';')) || [];\n    let redirectType;\n    switch(_redirectType){\n        case 'push':\n            redirectType = _redirecterror.RedirectType.push;\n            break;\n        case 'replace':\n            redirectType = _redirecterror.RedirectType.replace;\n            break;\n        default:\n            redirectType = undefined;\n    }\n    const isPrerender = !!res.headers.get(_approuterheaders.NEXT_IS_PRERENDER_HEADER);\n    let revalidatedParts;\n    try {\n        const revalidatedHeader = JSON.parse(res.headers.get('x-action-revalidated') || '[[],0,0]');\n        revalidatedParts = {\n            paths: revalidatedHeader[0] || [],\n            tag: !!revalidatedHeader[1],\n            cookie: revalidatedHeader[2]\n        };\n    } catch (e) {\n        revalidatedParts = {\n            paths: [],\n            tag: false,\n            cookie: false\n        };\n    }\n    const redirectLocation = location ? (0, _assignlocation.assignLocation)(location, new URL(state.canonicalUrl, window.location.href)) : undefined;\n    const contentType = res.headers.get('content-type');\n    if (contentType == null ? void 0 : contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER)) {\n        const response = await createFromFetch(Promise.resolve(res), {\n            callServer: _appcallserver.callServer,\n            findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n            temporaryReferences\n        });\n        if (location) {\n            // if it was a redirection, then result is just a regular RSC payload\n            return {\n                actionFlightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n                redirectLocation,\n                redirectType,\n                revalidatedParts,\n                isPrerender\n            };\n        }\n        return {\n            actionResult: response.a,\n            actionFlightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n            redirectLocation,\n            redirectType,\n            revalidatedParts,\n            isPrerender\n        };\n    }\n    // Handle invalid server action responses\n    if (res.status >= 400) {\n        // The server can respond with a text/plain error message, but we'll fallback to something generic\n        // if there isn't one.\n        const error = contentType === 'text/plain' ? await res.text() : 'An unexpected response was received from the server.';\n        throw Object.defineProperty(new Error(error), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return {\n        redirectLocation,\n        redirectType,\n        revalidatedParts,\n        isPrerender\n    };\n}\nfunction serverActionReducer(state, action) {\n    const { resolve, reject } = action;\n    const mutable = {};\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n    // If the route has been intercepted, the action should be as well.\n    // Otherwise the server action might be intercepted with the wrong action id\n    // (ie, one that corresponds with the intercepted route)\n    const nextUrl = state.nextUrl && (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.nextUrl : null;\n    const navigatedAt = Date.now();\n    return fetchServerAction(state, nextUrl, action).then(async (param)=>{\n        let { actionResult, actionFlightData: flightData, redirectLocation, redirectType, isPrerender, revalidatedParts } = param;\n        let redirectHref;\n        // honor the redirect type instead of defaulting to push in case of server actions.\n        if (redirectLocation) {\n            if (redirectType === _redirecterror.RedirectType.replace) {\n                state.pushRef.pendingPush = false;\n                mutable.pendingPush = false;\n            } else {\n                state.pushRef.pendingPush = true;\n                mutable.pendingPush = true;\n            }\n            redirectHref = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);\n            mutable.canonicalUrl = redirectHref;\n        }\n        if (!flightData) {\n            resolve(actionResult);\n            // If there is a redirect but no flight data we need to do a mpaNavigation.\n            if (redirectLocation) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, state.pushRef.pendingPush);\n            }\n            return state;\n        }\n        if (typeof flightData === 'string') {\n            // Handle case when navigating to page in `pages` from `app`\n            resolve(actionResult);\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        const actionRevalidated = revalidatedParts.paths.length > 0 || revalidatedParts.tag || revalidatedParts.cookie;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('SERVER ACTION APPLY FAILED');\n                resolve(actionResult);\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, redirectHref ? redirectHref : state.canonicalUrl);\n            if (newTree === null) {\n                resolve(actionResult);\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                resolve(actionResult);\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectHref || state.canonicalUrl, state.pushRef.pendingPush);\n            }\n            // The server sent back RSC data for the server action, so we need to apply it to the cache.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[1];\n                const cache = (0, _approuter.createEmptyCacheNode)();\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                cache.loading = cacheNodeSeedData[3];\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, treePatch, cacheNodeSeedData, head, undefined);\n                mutable.cache = cache;\n                if (false) {} else {\n                    mutable.prefetchCache = new Map();\n                }\n                if (actionRevalidated) {\n                    await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                        navigatedAt,\n                        state,\n                        updatedTree: newTree,\n                        updatedCache: cache,\n                        includeNextUrl: Boolean(nextUrl),\n                        canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n                    });\n                }\n            }\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        if (redirectLocation && redirectHref) {\n            if ( true && !actionRevalidated) {\n                // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache\n                // with the FlightData that we got from the server action for the target page, so that it's\n                // available when the page is navigated to and doesn't need to be re-fetched.\n                // We only do this if the server action didn't revalidate any data, as in that case the\n                // client cache will be cleared and the data will be re-fetched anyway.\n                // NOTE: We don't do this in the Segment Cache implementation.\n                // Dynamic data should never be placed into the cache, unless it's\n                // \"converted\" to static data using <Link prefetch={true}>. What we\n                // do instead is re-prefetch links and forms whenever the cache is\n                // invalidated.\n                (0, _prefetchcacheutils.createSeededPrefetchCacheEntry)({\n                    url: redirectLocation,\n                    data: {\n                        flightData,\n                        canonicalUrl: undefined,\n                        couldBeIntercepted: false,\n                        prerendered: false,\n                        postponed: false,\n                        // TODO: We should be able to set this if the server action\n                        // returned a fully static response.\n                        staleTime: -1\n                    },\n                    tree: state.tree,\n                    prefetchCache: state.prefetchCache,\n                    nextUrl: state.nextUrl,\n                    kind: isPrerender ? _routerreducertypes.PrefetchKind.FULL : _routerreducertypes.PrefetchKind.AUTO\n                });\n                mutable.prefetchCache = state.prefetchCache;\n            }\n            // If the action triggered a redirect, the action promise will be rejected with\n            // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n            // action result to resolve the promise with. This will effectively reset the state of\n            // the component that called the action as the error boundary will remount the tree.\n            // The status code doesn't matter here as the action handler will have already sent\n            // a response with the correct status code.\n            reject((0, _redirect.getRedirectError)((0, _hasbasepath.hasBasePath)(redirectHref) ? (0, _removebasepath.removeBasePath)(redirectHref) : redirectHref, redirectType || _redirecterror.RedirectType.push));\n        } else {\n            resolve(actionResult);\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, (e)=>{\n        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n        reject(e);\n        return state;\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-action-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvc2VydmVyLWFjdGlvbi1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7dURBNE1nQkE7OztlQUFBQTs7OzJDQXhNVztpREFDTTs4Q0FPMUI7Z0RBb0JBOzRDQUN3QjsrQ0FDRzs2Q0FDQTt5REFDVTt5REFDQTsyQ0FFZDsyREFDZ0I7dUNBQ1Q7K0RBQ2E7bURBQ1o7NkRBQ1U7K0NBSXpDO3NDQUMwQjsyQ0FDSjtnREFDa0I7NENBQ2hCO3lDQUNIO2lEQUlyQjswQ0FDK0I7QUE1Q3RDLGdFQUFnRTtBQUNoRSxvRUFBb0U7QUFDcEUsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSxNQUFNLEVBQUVDLGVBQWUsRUFBRUMsMkJBQTJCLEVBQUVDLFdBQVcsRUFBRSxHQUNqRSxNQUEwQixHQUV0QkksQ0FBK0MsR0FFL0NBLG1CQUFPQSxDQUFDLGlJQUFpQztBQWtEL0MsZUFBZUMsa0JBQ2JDLEtBQTJCLEVBQzNCQyxPQUF3QyxFQUN4QyxLQUE0QztJQUE1QyxNQUFFQyxRQUFRLEVBQUVDLFVBQVUsRUFBc0IsR0FBNUM7SUFFQSxNQUFNQyxzQkFBc0JYO0lBQzVCLE1BQU1ZLE9BQU9DLENBQUFBLEdBQUFBLHFCQUFBQSxnQ0FBZ0MsRUFBQ0o7SUFFOUMsNkVBQTZFO0lBQzdFLDhFQUE4RTtJQUM5RSwrQ0FBK0M7SUFDL0MsTUFBTUssV0FDSkYsS0FBS0csSUFBSSxLQUFLLGNBQWNDLENBQUFBLEdBQUFBLHFCQUFBQSxjQUFBQSxFQUFlTixZQUFZRSxRQUFRRjtJQUVqRSxNQUFNTyxPQUFPLE1BQU1oQixZQUFZYSxVQUFVO1FBQUVIO0lBQW9CO0lBRS9ELE1BQU1PLE1BQU0sTUFBTUMsTUFBTSxJQUFJO1FBQzFCQyxRQUFRO1FBQ1JDLFNBQVM7WUFDUEMsUUFBUUMsa0JBQUFBLHVCQUF1QjtZQUMvQixDQUFDQyxrQkFB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O29CQUM3QkMsS0FBS3JFO29CQUNMc0UsTUFBTTt3QkFDSnRDO3dCQUNBN0IsY0FBY2I7d0JBQ2RpRixvQkFBb0I7d0JBQ3BCQyxhQUFhO3dCQUNiQyxXQUFXO3dCQUNYLDJEQUEyRDt3QkFDM0Qsb0NBQW9DO3dCQUNwQ0MsV0FBVyxDQUFDO29CQUNkO29CQUNBaEcsTUFBTXRCLE1BQU1zQixJQUFJO29CQUNoQmtGLGVBQWV4RyxNQUFNd0csYUFBYTtvQkFDbEN2RyxTQUFTRCxNQUFNQyxPQUFPO29CQUN0QnNILE1BQU1wRixjQUFjcUYsb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSSxHQUFHRCxvQkFBQUEsWUFBWSxDQUFDRSxJQUFJO2dCQUMzRDtnQkFDQXRELFFBQVFvQyxhQUFhLEdBQUd4RyxNQUFNd0csYUFBYTtZQUM3QztZQUVBLCtFQUErRTtZQUMvRSwrRUFBK0U7WUFDL0Usc0ZBQXNGO1lBQ3RGLG9GQUFvRjtZQUNwRixtRkFBbUY7WUFDbkYsMkNBQTJDO1lBQzNDckMsT0FDRXdELENBQUFBLEdBQUFBLFVBQUFBLGdCQUFBQSxFQUNFQyxDQUFBQSxHQUFBQSxhQUFBQSxXQUFBQSxFQUFZL0MsZ0JBQ1JnRCxDQUFBQSxHQUFBQSxnQkFBQUEsY0FBQUEsRUFBZWhELGdCQUNmQSxjQUNKL0MsZ0JBQWdCQyxlQUFBQSxZQUFZLENBQUNDLElBQUk7UUFHdkMsT0FBTztZQUNMc0IsUUFBUU07UUFDVjtRQUVBLE9BQU9rRSxDQUFBQSxHQUFBQSxlQUFBQSxhQUFBQSxFQUFjOUgsT0FBT29FO0lBQzlCLEdBQ0EsQ0FBQ3pCO1FBQ0MsbUhBQW1IO1FBQ25Id0IsT0FBT3hCO1FBRVAsT0FBTzNDO0lBQ1Q7QUFFSiIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccmVkdWNlcnNcXHNlcnZlci1hY3Rpb24tcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIEFjdGlvbkZsaWdodFJlc3BvbnNlLFxuICBBY3Rpb25SZXN1bHQsXG59IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgY2FsbFNlcnZlciB9IGZyb20gJy4uLy4uLy4uL2FwcC1jYWxsLXNlcnZlcidcbmltcG9ydCB7IGZpbmRTb3VyY2VNYXBVUkwgfSBmcm9tICcuLi8uLi8uLi9hcHAtZmluZC1zb3VyY2UtbWFwLXVybCdcbmltcG9ydCB7XG4gIEFDVElPTl9IRUFERVIsXG4gIE5FWFRfSVNfUFJFUkVOREVSX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIsXG4gIE5FWFRfVVJMLFxuICBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUixcbn0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuXG4vLyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4vLyBpbXBvcnQgeyBjcmVhdGVGcm9tRmV0Y2ggfSBmcm9tICdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50J1xuLy8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuLy8gaW1wb3J0IHsgZW5jb2RlUmVwbHkgfSBmcm9tICdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50J1xuY29uc3QgeyBjcmVhdGVGcm9tRmV0Y2gsIGNyZWF0ZVRlbXBvcmFyeVJlZmVyZW5jZVNldCwgZW5jb2RlUmVwbHkgfSA9IChcbiAgISFwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUVcbiAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbiAgICAgIHJlcXVpcmUoJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQuZWRnZScpXG4gICAgOiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4gICAgICByZXF1aXJlKCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50JylcbikgYXMgdHlwZW9mIGltcG9ydCgncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCcpXG5cbmltcG9ydCB7XG4gIFByZWZldGNoS2luZCxcbiAgdHlwZSBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgdHlwZSBSZWR1Y2VyU3RhdGUsXG4gIHR5cGUgU2VydmVyQWN0aW9uQWN0aW9uLFxuICB0eXBlIFNlcnZlckFjdGlvbk11dGFibGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgYXNzaWduTG9jYXRpb24gfSBmcm9tICcuLi8uLi8uLi9hc3NpZ24tbG9jYXRpb24nXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgaGFuZGxlRXh0ZXJuYWxVcmwgfSBmcm9tICcuL25hdmlnYXRlLXJlZHVjZXInXG5pbXBvcnQgeyBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgfSBmcm9tICcuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSdcbmltcG9ydCB7IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCB9IGZyb20gJy4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0J1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuLi9oYW5kbGUtbXV0YWJsZSdcbmltcG9ydCB7IGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIH0gZnJvbSAnLi4vZmlsbC1sYXp5LWl0ZW1zLXRpbGwtbGVhZi13aXRoLWhlYWQnXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUNhY2hlTm9kZSB9IGZyb20gJy4uLy4uL2FwcC1yb3V0ZXInXG5pbXBvcnQgeyBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUgfSBmcm9tICcuL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlJ1xuaW1wb3J0IHsgaGFuZGxlU2VnbWVudE1pc21hdGNoIH0gZnJvbSAnLi4vaGFuZGxlLXNlZ21lbnQtbWlzbWF0Y2gnXG5pbXBvcnQgeyByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIH0gZnJvbSAnLi4vcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cydcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZUZsaWdodERhdGEsXG4gIHR5cGUgTm9ybWFsaXplZEZsaWdodERhdGEsXG59IGZyb20gJy4uLy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5pbXBvcnQgeyBnZXRSZWRpcmVjdEVycm9yIH0gZnJvbSAnLi4vLi4vcmVkaXJlY3QnXG5pbXBvcnQgeyBSZWRpcmVjdFR5cGUgfSBmcm9tICcuLi8uLi9yZWRpcmVjdC1lcnJvcidcbmltcG9ydCB7IGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSB9IGZyb20gJy4uL3ByZWZldGNoLWNhY2hlLXV0aWxzJ1xuaW1wb3J0IHsgcmVtb3ZlQmFzZVBhdGggfSBmcm9tICcuLi8uLi8uLi9yZW1vdmUtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgaGFzQmFzZVBhdGggfSBmcm9tICcuLi8uLi8uLi9oYXMtYmFzZS1wYXRoJ1xuaW1wb3J0IHtcbiAgZXh0cmFjdEluZm9Gcm9tU2VydmVyUmVmZXJlbmNlSWQsXG4gIG9taXRVbnVzZWRBcmdzLFxufSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL3NlcnZlci1yZWZlcmVuY2UtaW5mbydcbmltcG9ydCB7IHJldmFsaWRhdGVFbnRpcmVDYWNoZSB9IGZyb20gJy4uLy4uL3NlZ21lbnQtY2FjaGUnXG5cbnR5cGUgRmV0Y2hTZXJ2ZXJBY3Rpb25SZXN1bHQgPSB7XG4gIHJlZGlyZWN0TG9jYXRpb246IFVSTCB8IHVuZGVmaW5lZFxuICByZWRpcmVjdFR5cGU6IFJlZGlyZWN0VHlwZSB8IHVuZGVmaW5lZFxuICBhY3Rpb25SZXN1bHQ/OiBBY3Rpb25SZXN1bHRcbiAgYWN0aW9uRmxpZ2h0RGF0YT86IE5vcm1hbGl6ZWRGbGlnaHREYXRhW10gfCBzdHJpbmdcbiAgaXNQcmVyZW5kZXI6IGJvb2xlYW5cbiAgcmV2YWxpZGF0ZWRQYXJ0czoge1xuICAgIHRhZzogYm9vbGVhblxuICAgIGNvb2tpZTogYm9vbGVhblxuICAgIHBhdGhzOiBzdHJpbmdbXVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoU2VydmVyQWN0aW9uKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIG5leHRVcmw6IFJlYWRvbmx5UmVkdWNlclN0YXRlWyduZXh0VXJsJ10sXG4gIHsgYWN0aW9uSWQsIGFjdGlvbkFyZ3MgfTogU2VydmVyQWN0aW9uQWN0aW9uXG4pOiBQcm9taXNlPEZldGNoU2VydmVyQWN0aW9uUmVzdWx0PiB7XG4gIGNvbnN0IHRlbXBvcmFyeVJlZmVyZW5jZXMgPSBjcmVhdGVUZW1wb3JhcnlSZWZlcmVuY2VTZXQoKVxuICBjb25zdCBpbmZvID0gZXh0cmFjdEluZm9Gcm9tU2VydmVyUmVmZXJlbmNlSWQoYWN0aW9uSWQpXG5cbiAgLy8gVE9ETzogQ3VycmVudGx5LCB3ZSdyZSBvbmx5IG9taXR0aW5nIHVudXNlZCBhcmdzIGZvciB0aGUgZXhwZXJpbWVudGFsIFwidXNlXG4gIC8vIGNhY2hlXCIgZnVuY3Rpb25zLiBPbmNlIHRoZSBzZXJ2ZXIgcmVmZXJlbmNlIGluZm8gYnl0ZSBmZWF0dXJlIGlzIHN0YWJsZSwgd2VcbiAgLy8gc2hvdWxkIGFwcGx5IHRoaXMgdG8gc2VydmVyIGFjdGlvbnMgYXMgd2VsbC5cbiAgY29uc3QgdXNlZEFyZ3MgPVxuICAgIGluZm8udHlwZSA9PT0gJ3VzZS1jYWNoZScgPyBvbWl0VW51c2VkQXJncyhhY3Rpb25BcmdzLCBpbmZvKSA6IGFjdGlvbkFyZ3NcblxuICBjb25zdCBib2R5ID0gYXdhaXQgZW5jb2RlUmVwbHkodXNlZEFyZ3MsIHsgdGVtcG9yYXJ5UmVmZXJlbmNlcyB9KVxuXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcnLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgaGVhZGVyczoge1xuICAgICAgQWNjZXB0OiBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUixcbiAgICAgIFtBQ1RJT05fSEVBREVSXTogYWN0aW9uSWQsXG4gICAgICBbTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVJdOiBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpXG4gICAgICApLFxuICAgICAgLi4uKHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICAgICAgICA/IHtcbiAgICAgICAgICAgICd4LWRlcGxveW1lbnQtaWQnOiBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQsXG4gICAgICAgICAgfVxuICAgICAgICA6IHt9KSxcbiAgICAgIC4uLihuZXh0VXJsXG4gICAgICAgID8ge1xuICAgICAgICAgICAgW05FWFRfVVJMXTogbmV4dFVybCxcbiAgICAgICAgICB9XG4gICAgICAgIDoge30pLFxuICAgIH0sXG4gICAgYm9keSxcbiAgfSlcblxuICBjb25zdCByZWRpcmVjdEhlYWRlciA9IHJlcy5oZWFkZXJzLmdldCgneC1hY3Rpb24tcmVkaXJlY3QnKVxuICBjb25zdCBbbG9jYXRpb24sIF9yZWRpcmVjdFR5cGVdID0gcmVkaXJlY3RIZWFkZXI/LnNwbGl0KCc7JykgfHwgW11cbiAgbGV0IHJlZGlyZWN0VHlwZTogUmVkaXJlY3RUeXBlIHwgdW5kZWZpbmVkXG4gIHN3aXRjaCAoX3JlZGlyZWN0VHlwZSkge1xuICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgcmVkaXJlY3RUeXBlID0gUmVkaXJlY3RUeXBlLnB1c2hcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICByZWRpcmVjdFR5cGUgPSBSZWRpcmVjdFR5cGUucmVwbGFjZVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmVkaXJlY3RUeXBlID0gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBpc1ByZXJlbmRlciA9ICEhcmVzLmhlYWRlcnMuZ2V0KE5FWFRfSVNfUFJFUkVOREVSX0hFQURFUilcbiAgbGV0IHJldmFsaWRhdGVkUGFydHM6IEZldGNoU2VydmVyQWN0aW9uUmVzdWx0WydyZXZhbGlkYXRlZFBhcnRzJ11cbiAgdHJ5IHtcbiAgICBjb25zdCByZXZhbGlkYXRlZEhlYWRlciA9IEpTT04ucGFyc2UoXG4gICAgICByZXMuaGVhZGVycy5nZXQoJ3gtYWN0aW9uLXJldmFsaWRhdGVkJykgfHwgJ1tbXSwwLDBdJ1xuICAgIClcbiAgICByZXZhbGlkYXRlZFBhcnRzID0ge1xuICAgICAgcGF0aHM6IHJldmFsaWRhdGVkSGVhZGVyWzBdIHx8IFtdLFxuICAgICAgdGFnOiAhIXJldmFsaWRhdGVkSGVhZGVyWzFdLFxuICAgICAgY29va2llOiByZXZhbGlkYXRlZEhlYWRlclsyXSxcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXZhbGlkYXRlZFBhcnRzID0ge1xuICAgICAgcGF0aHM6IFtdLFxuICAgICAgdGFnOiBmYWxzZSxcbiAgICAgIGNvb2tpZTogZmFsc2UsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVkaXJlY3RMb2NhdGlvbiA9IGxvY2F0aW9uXG4gICAgPyBhc3NpZ25Mb2NhdGlvbihcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG5ldyBVUkwoc3RhdGUuY2Fub25pY2FsVXJsLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICAgIClcbiAgICA6IHVuZGVmaW5lZFxuXG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKVxuXG4gIGlmIChjb250ZW50VHlwZT8uc3RhcnRzV2l0aChSU0NfQ09OVEVOVF9UWVBFX0hFQURFUikpIHtcbiAgICBjb25zdCByZXNwb25zZTogQWN0aW9uRmxpZ2h0UmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVGcm9tRmV0Y2goXG4gICAgICBQcm9taXNlLnJlc29sdmUocmVzKSxcbiAgICAgIHsgY2FsbFNlcnZlciwgZmluZFNvdXJjZU1hcFVSTCwgdGVtcG9yYXJ5UmVmZXJlbmNlcyB9XG4gICAgKVxuXG4gICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAvLyBpZiBpdCB3YXMgYSByZWRpcmVjdGlvbiwgdGhlbiByZXN1bHQgaXMganVzdCBhIHJlZ3VsYXIgUlNDIHBheWxvYWRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFjdGlvbkZsaWdodERhdGE6IG5vcm1hbGl6ZUZsaWdodERhdGEocmVzcG9uc2UuZiksXG4gICAgICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICAgIHJlZGlyZWN0VHlwZSxcbiAgICAgICAgcmV2YWxpZGF0ZWRQYXJ0cyxcbiAgICAgICAgaXNQcmVyZW5kZXIsXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvblJlc3VsdDogcmVzcG9uc2UuYSxcbiAgICAgIGFjdGlvbkZsaWdodERhdGE6IG5vcm1hbGl6ZUZsaWdodERhdGEocmVzcG9uc2UuZiksXG4gICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgcmVkaXJlY3RUeXBlLFxuICAgICAgcmV2YWxpZGF0ZWRQYXJ0cyxcbiAgICAgIGlzUHJlcmVuZGVyLFxuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBpbnZhbGlkIHNlcnZlciBhY3Rpb24gcmVzcG9uc2VzXG4gIGlmIChyZXMuc3RhdHVzID49IDQwMCkge1xuICAgIC8vIFRoZSBzZXJ2ZXIgY2FuIHJlc3BvbmQgd2l0aCBhIHRleHQvcGxhaW4gZXJyb3IgbWVzc2FnZSwgYnV0IHdlJ2xsIGZhbGxiYWNrIHRvIHNvbWV0aGluZyBnZW5lcmljXG4gICAgLy8gaWYgdGhlcmUgaXNuJ3Qgb25lLlxuICAgIGNvbnN0IGVycm9yID1cbiAgICAgIGNvbnRlbnRUeXBlID09PSAndGV4dC9wbGFpbidcbiAgICAgICAgPyBhd2FpdCByZXMudGV4dCgpXG4gICAgICAgIDogJ0FuIHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2FzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci4nXG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgcmVkaXJlY3RUeXBlLFxuICAgIHJldmFsaWRhdGVkUGFydHMsXG4gICAgaXNQcmVyZW5kZXIsXG4gIH1cbn1cblxuLypcbiAqIFRoaXMgcmVkdWNlciBpcyByZXNwb25zaWJsZSBmb3IgY2FsbGluZyB0aGUgc2VydmVyIGFjdGlvbiBhbmQgcHJvY2Vzc2luZyBhbnkgc2lkZS1lZmZlY3RzIGZyb20gdGhlIHNlcnZlciBhY3Rpb24uXG4gKiBJdCBkb2VzIG5vdCBtdXRhdGUgdGhlIHN0YXRlIGJ5IGl0c2VsZiBidXQgcmF0aGVyIGRlbGVnYXRlcyB0byBvdGhlciByZWR1Y2VycyB0byBkbyB0aGUgYWN0dWFsIG11dGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VydmVyQWN0aW9uUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFNlcnZlckFjdGlvbkFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgY29uc3QgeyByZXNvbHZlLCByZWplY3QgfSA9IGFjdGlvblxuICBjb25zdCBtdXRhYmxlOiBTZXJ2ZXJBY3Rpb25NdXRhYmxlID0ge31cblxuICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlXG5cbiAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlXG5cbiAgLy8gb25seSBwYXNzIGFsb25nIHRoZSBgbmV4dFVybGAgcGFyYW0gKHVzZWQgZm9yIGludGVyY2VwdGlvbiByb3V0ZXMpIGlmIHRoZSBjdXJyZW50IHJvdXRlIHdhcyBpbnRlcmNlcHRlZC5cbiAgLy8gSWYgdGhlIHJvdXRlIGhhcyBiZWVuIGludGVyY2VwdGVkLCB0aGUgYWN0aW9uIHNob3VsZCBiZSBhcyB3ZWxsLlxuICAvLyBPdGhlcndpc2UgdGhlIHNlcnZlciBhY3Rpb24gbWlnaHQgYmUgaW50ZXJjZXB0ZWQgd2l0aCB0aGUgd3JvbmcgYWN0aW9uIGlkXG4gIC8vIChpZSwgb25lIHRoYXQgY29ycmVzcG9uZHMgd2l0aCB0aGUgaW50ZXJjZXB0ZWQgcm91dGUpXG4gIGNvbnN0IG5leHRVcmwgPVxuICAgIHN0YXRlLm5leHRVcmwgJiYgaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKHN0YXRlLnRyZWUpXG4gICAgICA/IHN0YXRlLm5leHRVcmxcbiAgICAgIDogbnVsbFxuXG4gIGNvbnN0IG5hdmlnYXRlZEF0ID0gRGF0ZS5ub3coKVxuXG4gIHJldHVybiBmZXRjaFNlcnZlckFjdGlvbihzdGF0ZSwgbmV4dFVybCwgYWN0aW9uKS50aGVuKFxuICAgIGFzeW5jICh7XG4gICAgICBhY3Rpb25SZXN1bHQsXG4gICAgICBhY3Rpb25GbGlnaHREYXRhOiBmbGlnaHREYXRhLFxuICAgICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgIHJlZGlyZWN0VHlwZSxcbiAgICAgIGlzUHJlcmVuZGVyLFxuICAgICAgcmV2YWxpZGF0ZWRQYXJ0cyxcbiAgICB9KSA9PiB7XG4gICAgICBsZXQgcmVkaXJlY3RIcmVmOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAgICAgLy8gaG9ub3IgdGhlIHJlZGlyZWN0IHR5cGUgaW5zdGVhZCBvZiBkZWZhdWx0aW5nIHRvIHB1c2ggaW4gY2FzZSBvZiBzZXJ2ZXIgYWN0aW9ucy5cbiAgICAgIGlmIChyZWRpcmVjdExvY2F0aW9uKSB7XG4gICAgICAgIGlmIChyZWRpcmVjdFR5cGUgPT09IFJlZGlyZWN0VHlwZS5yZXBsYWNlKSB7XG4gICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCA9IGZhbHNlXG4gICAgICAgICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCA9IHRydWVcbiAgICAgICAgICBtdXRhYmxlLnBlbmRpbmdQdXNoID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmVkaXJlY3RIcmVmID0gY3JlYXRlSHJlZkZyb21VcmwocmVkaXJlY3RMb2NhdGlvbiwgZmFsc2UpXG4gICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gcmVkaXJlY3RIcmVmXG4gICAgICB9XG5cbiAgICAgIGlmICghZmxpZ2h0RGF0YSkge1xuICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdClcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZGlyZWN0IGJ1dCBubyBmbGlnaHQgZGF0YSB3ZSBuZWVkIHRvIGRvIGEgbXBhTmF2aWdhdGlvbi5cbiAgICAgICAgaWYgKHJlZGlyZWN0TG9jYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgICByZWRpcmVjdExvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdClcblxuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICBmbGlnaHREYXRhLFxuICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBhY3Rpb25SZXZhbGlkYXRlZCA9XG4gICAgICAgIHJldmFsaWRhdGVkUGFydHMucGF0aHMubGVuZ3RoID4gMCB8fFxuICAgICAgICByZXZhbGlkYXRlZFBhcnRzLnRhZyB8fFxuICAgICAgICByZXZhbGlkYXRlZFBhcnRzLmNvb2tpZVxuXG4gICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhIG9mIGZsaWdodERhdGEpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHRyZWU6IHRyZWVQYXRjaCxcbiAgICAgICAgICBzZWVkRGF0YTogY2FjaGVOb2RlU2VlZERhdGEsXG4gICAgICAgICAgaGVhZCxcbiAgICAgICAgICBpc1Jvb3RSZW5kZXIsXG4gICAgICAgIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YVxuXG4gICAgICAgIGlmICghaXNSb290UmVuZGVyKSB7XG4gICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1NFUlZFUiBBQ1RJT04gQVBQTFkgRkFJTEVEJylcbiAgICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdClcblxuICAgICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2l2ZW4gdGhlIHBhdGggY2FuIG9ubHkgaGF2ZSB0d28gaXRlbXMgdGhlIGl0ZW1zIGFyZSBvbmx5IHRoZSByb3V0ZXIgc3RhdGUgYW5kIHJzYyBmb3IgdGhlIHJvb3QuXG4gICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoXG4gICAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgIFsnJ10sXG4gICAgICAgICAgY3VycmVudFRyZWUsXG4gICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgIHJlZGlyZWN0SHJlZiA/IHJlZGlyZWN0SHJlZiA6IHN0YXRlLmNhbm9uaWNhbFVybFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdClcblxuICAgICAgICAgIHJldHVybiBoYW5kbGVTZWdtZW50TWlzbWF0Y2goc3RhdGUsIGFjdGlvbiwgdHJlZVBhdGNoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdClcblxuICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICAgIHJlZGlyZWN0SHJlZiB8fCBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHNlcnZlciBzZW50IGJhY2sgUlNDIGRhdGEgZm9yIHRoZSBzZXJ2ZXIgYWN0aW9uLCBzbyB3ZSBuZWVkIHRvIGFwcGx5IGl0IHRvIHRoZSBjYWNoZS5cbiAgICAgICAgaWYgKGNhY2hlTm9kZVNlZWREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgcnNjID0gY2FjaGVOb2RlU2VlZERhdGFbMV1cbiAgICAgICAgICBjb25zdCBjYWNoZTogQ2FjaGVOb2RlID0gY3JlYXRlRW1wdHlDYWNoZU5vZGUoKVxuICAgICAgICAgIGNhY2hlLnJzYyA9IHJzY1xuICAgICAgICAgIGNhY2hlLnByZWZldGNoUnNjID0gbnVsbFxuICAgICAgICAgIGNhY2hlLmxvYWRpbmcgPSBjYWNoZU5vZGVTZWVkRGF0YVszXVxuICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIC8vIEV4aXN0aW5nIGNhY2hlIGlzIG5vdCBwYXNzZWQgaW4gYXMgc2VydmVyIGFjdGlvbnMgaGF2ZSB0byBpbnZhbGlkYXRlIHRoZSBlbnRpcmUgY2FjaGUuXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgICBjYWNoZU5vZGVTZWVkRGF0YSxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICApXG5cbiAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGVcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFKSB7XG4gICAgICAgICAgICByZXZhbGlkYXRlRW50aXJlQ2FjaGUoc3RhdGUubmV4dFVybCwgbmV3VHJlZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXV0YWJsZS5wcmVmZXRjaENhY2hlID0gbmV3IE1hcCgpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhY3Rpb25SZXZhbGlkYXRlZCkge1xuICAgICAgICAgICAgYXdhaXQgcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyh7XG4gICAgICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgdXBkYXRlZFRyZWU6IG5ld1RyZWUsXG4gICAgICAgICAgICAgIHVwZGF0ZWRDYWNoZTogY2FjaGUsXG4gICAgICAgICAgICAgIGluY2x1ZGVOZXh0VXJsOiBCb29sZWFuKG5leHRVcmwpLFxuICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IG11dGFibGUuY2Fub25pY2FsVXJsIHx8IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWVcbiAgICAgICAgY3VycmVudFRyZWUgPSBuZXdUcmVlXG4gICAgICB9XG5cbiAgICAgIGlmIChyZWRpcmVjdExvY2F0aW9uICYmIHJlZGlyZWN0SHJlZikge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSAmJiAhYWN0aW9uUmV2YWxpZGF0ZWQpIHtcbiAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBSZWRpcmVjdEJvdW5kYXJ5IHdpbGwgdHJpZ2dlciBhIG5hdmlnYXRpb24sIHdlIG5lZWQgdG8gc2VlZCB0aGUgcHJlZmV0Y2ggY2FjaGVcbiAgICAgICAgICAvLyB3aXRoIHRoZSBGbGlnaHREYXRhIHRoYXQgd2UgZ290IGZyb20gdGhlIHNlcnZlciBhY3Rpb24gZm9yIHRoZSB0YXJnZXQgcGFnZSwgc28gdGhhdCBpdCdzXG4gICAgICAgICAgLy8gYXZhaWxhYmxlIHdoZW4gdGhlIHBhZ2UgaXMgbmF2aWdhdGVkIHRvIGFuZCBkb2Vzbid0IG5lZWQgdG8gYmUgcmUtZmV0Y2hlZC5cbiAgICAgICAgICAvLyBXZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHNlcnZlciBhY3Rpb24gZGlkbid0IHJldmFsaWRhdGUgYW55IGRhdGEsIGFzIGluIHRoYXQgY2FzZSB0aGVcbiAgICAgICAgICAvLyBjbGllbnQgY2FjaGUgd2lsbCBiZSBjbGVhcmVkIGFuZCB0aGUgZGF0YSB3aWxsIGJlIHJlLWZldGNoZWQgYW55d2F5LlxuICAgICAgICAgIC8vIE5PVEU6IFdlIGRvbid0IGRvIHRoaXMgaW4gdGhlIFNlZ21lbnQgQ2FjaGUgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgLy8gRHluYW1pYyBkYXRhIHNob3VsZCBuZXZlciBiZSBwbGFjZWQgaW50byB0aGUgY2FjaGUsIHVubGVzcyBpdCdzXG4gICAgICAgICAgLy8gXCJjb252ZXJ0ZWRcIiB0byBzdGF0aWMgZGF0YSB1c2luZyA8TGluayBwcmVmZXRjaD17dHJ1ZX0+LiBXaGF0IHdlXG4gICAgICAgICAgLy8gZG8gaW5zdGVhZCBpcyByZS1wcmVmZXRjaCBsaW5rcyBhbmQgZm9ybXMgd2hlbmV2ZXIgdGhlIGNhY2hlIGlzXG4gICAgICAgICAgLy8gaW52YWxpZGF0ZWQuXG4gICAgICAgICAgY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgICAgICAgICAgIHVybDogcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZDogZmFsc2UsXG4gICAgICAgICAgICAgIHByZXJlbmRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgcG9zdHBvbmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGJlIGFibGUgdG8gc2V0IHRoaXMgaWYgdGhlIHNlcnZlciBhY3Rpb25cbiAgICAgICAgICAgICAgLy8gcmV0dXJuZWQgYSBmdWxseSBzdGF0aWMgcmVzcG9uc2UuXG4gICAgICAgICAgICAgIHN0YWxlVGltZTogLTEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJlZTogc3RhdGUudHJlZSxcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICBuZXh0VXJsOiBzdGF0ZS5uZXh0VXJsLFxuICAgICAgICAgICAga2luZDogaXNQcmVyZW5kZXIgPyBQcmVmZXRjaEtpbmQuRlVMTCA6IFByZWZldGNoS2luZC5BVVRPLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgbXV0YWJsZS5wcmVmZXRjaENhY2hlID0gc3RhdGUucHJlZmV0Y2hDYWNoZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGFjdGlvbiB0cmlnZ2VyZWQgYSByZWRpcmVjdCwgdGhlIGFjdGlvbiBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aFxuICAgICAgICAvLyBhIHJlZGlyZWN0IHNvIHRoYXQgaXQncyBoYW5kbGVkIGJ5IFJlZGlyZWN0Qm91bmRhcnkgYXMgd2Ugd29uJ3QgaGF2ZSBhIHZhbGlkXG4gICAgICAgIC8vIGFjdGlvbiByZXN1bHQgdG8gcmVzb2x2ZSB0aGUgcHJvbWlzZSB3aXRoLiBUaGlzIHdpbGwgZWZmZWN0aXZlbHkgcmVzZXQgdGhlIHN0YXRlIG9mXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgdGhhdCBjYWxsZWQgdGhlIGFjdGlvbiBhcyB0aGUgZXJyb3IgYm91bmRhcnkgd2lsbCByZW1vdW50IHRoZSB0cmVlLlxuICAgICAgICAvLyBUaGUgc3RhdHVzIGNvZGUgZG9lc24ndCBtYXR0ZXIgaGVyZSBhcyB0aGUgYWN0aW9uIGhhbmRsZXIgd2lsbCBoYXZlIGFscmVhZHkgc2VudFxuICAgICAgICAvLyBhIHJlc3BvbnNlIHdpdGggdGhlIGNvcnJlY3Qgc3RhdHVzIGNvZGUuXG4gICAgICAgIHJlamVjdChcbiAgICAgICAgICBnZXRSZWRpcmVjdEVycm9yKFxuICAgICAgICAgICAgaGFzQmFzZVBhdGgocmVkaXJlY3RIcmVmKVxuICAgICAgICAgICAgICA/IHJlbW92ZUJhc2VQYXRoKHJlZGlyZWN0SHJlZilcbiAgICAgICAgICAgICAgOiByZWRpcmVjdEhyZWYsXG4gICAgICAgICAgICByZWRpcmVjdFR5cGUgfHwgUmVkaXJlY3RUeXBlLnB1c2hcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoYWN0aW9uUmVzdWx0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9LFxuICAgIChlOiBhbnkpID0+IHtcbiAgICAgIC8vIFdoZW4gdGhlIHNlcnZlciBhY3Rpb24gaXMgcmVqZWN0ZWQgd2UgZG9uJ3QgdXBkYXRlIHRoZSBzdGF0ZSBhbmQgaW5zdGVhZCBjYWxsIHRoZSByZWplY3QgaGFuZGxlciBvZiB0aGUgcHJvbWlzZS5cbiAgICAgIHJlamVjdChlKVxuXG4gICAgICByZXR1cm4gc3RhdGVcbiAgICB9XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJzZXJ2ZXJBY3Rpb25SZWR1Y2VyIiwiY3JlYXRlRnJvbUZldGNoIiwiY3JlYXRlVGVtcG9yYXJ5UmVmZXJlbmNlU2V0IiwiZW5jb2RlUmVwbHkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9SVU5USU1FIiwicmVxdWlyZSIsImZldGNoU2VydmVyQWN0aW9uIiwic3RhdGUiLCJuZXh0VXJsIiwiYWN0aW9uSWQiLCJhY3Rpb25BcmdzIiwidGVtcG9yYXJ5UmVmZXJlbmNlcyIsImluZm8iLCJleHRyYWN0SW5mb0Zyb21TZXJ2ZXJSZWZlcmVuY2VJZCIsInVzZWRBcmdzIiwidHlwZSIsIm9taXRVbnVzZWRBcmdzIiwiYm9keSIsInJlcyIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIkFjY2VwdCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwiQUNUSU9OX0hFQURFUiIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsInRyZWUiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJORVhUX1VSTCIsInJlZGlyZWN0SGVhZGVyIiwiZ2V0IiwibG9jYXRpb24iLCJfcmVkaXJlY3RUeXBlIiwic3BsaXQiLCJyZWRpcmVjdFR5cGUiLCJSZWRpcmVjdFR5cGUiLCJwdXNoIiwicmVwbGFjZSIsInVuZGVmaW5lZCIsImlzUHJlcmVuZGVyIiwiTkVYVF9JU19QUkVSRU5ERVJfSEVBREVSIiwicmV2YWxpZGF0ZWRQYXJ0cyIsInJldmFsaWRhdGVkSGVhZGVyIiwicGFyc2UiLCJwYXRocyIsInRhZyIsImNvb2tpZSIsImUiLCJyZWRpcmVjdExvY2F0aW9uIiwiYXNzaWduTG9jYXRpb24iLCJVUkwiLCJjYW5vbmljYWxVcmwiLCJ3aW5kb3ciLCJocmVmIiwiY29udGVudFR5cGUiLCJzdGFydHNXaXRoIiwicmVzcG9uc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhbGxTZXJ2ZXIiLCJmaW5kU291cmNlTWFwVVJMIiwiYWN0aW9uRmxpZ2h0RGF0YSIsIm5vcm1hbGl6ZUZsaWdodERhdGEiLCJmIiwiYWN0aW9uUmVzdWx0IiwiYSIsInN0YXR1cyIsImVycm9yIiwidGV4dCIsIkVycm9yIiwiYWN0aW9uIiwicmVqZWN0IiwibXV0YWJsZSIsImN1cnJlbnRUcmVlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJuYXZpZ2F0ZWRBdCIsIkRhdGUiLCJub3ciLCJ0aGVuIiwiZmxpZ2h0RGF0YSIsInJlZGlyZWN0SHJlZiIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImNyZWF0ZUhyZWZGcm9tVXJsIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJhY3Rpb25SZXZhbGlkYXRlZCIsImxlbmd0aCIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwidHJlZVBhdGNoIiwic2VlZERhdGEiLCJjYWNoZU5vZGVTZWVkRGF0YSIsImhlYWQiLCJpc1Jvb3RSZW5kZXIiLCJjb25zb2xlIiwibG9nIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsInJzYyIsImNhY2hlIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJwcmVmZXRjaFJzYyIsImxvYWRpbmciLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsInJldmFsaWRhdGVFbnRpcmVDYWNoZSIsInByZWZldGNoQ2FjaGUiLCJNYXAiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwidXBkYXRlZFRyZWUiLCJ1cGRhdGVkQ2FjaGUiLCJpbmNsdWRlTmV4dFVybCIsIkJvb2xlYW4iLCJwYXRjaGVkVHJlZSIsImNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSIsInVybCIsImRhdGEiLCJjb3VsZEJlSW50ZXJjZXB0ZWQiLCJwcmVyZW5kZXJlZCIsInBvc3Rwb25lZCIsInN0YWxlVGltZSIsImtpbmQiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiQVVUTyIsImdldFJlZGlyZWN0RXJyb3IiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiaGFuZGxlTXV0YWJsZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"serverPatchReducer\", ({\n    enumerable: true,\n    get: function() {\n        return serverPatchReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nfunction serverPatchReducer(state, action) {\n    const { serverResponse: { flightData, canonicalUrl: canonicalUrlOverride }, navigatedAt } = action;\n    const mutable = {};\n    mutable.preserveCustomHistoryState = false;\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === 'string') {\n        return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    let currentTree = state.tree;\n    let currentCache = state.cache;\n    for (const normalizedFlightData of flightData){\n        const { segmentPath: flightSegmentPath, tree: treePatch } = normalizedFlightData;\n        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n            '',\n            ...flightSegmentPath\n        ], currentTree, treePatch, state.canonicalUrl);\n        // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n        // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n        // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n        // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n        // the entire page to reload.\n        if (newTree === null) {\n            return state;\n        }\n        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);\n        }\n        const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n        if (canonicalUrlOverrideHref) {\n            mutable.canonicalUrl = canonicalUrlOverrideHref;\n        }\n        const cache = (0, _approuter.createEmptyCacheNode)();\n        (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);\n        mutable.patchedTree = newTree;\n        mutable.cache = cache;\n        currentCache = cache;\n        currentTree = newTree;\n    }\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-patch-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvc2VydmVyLXBhdGNoLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztzREFlZ0JBOzs7ZUFBQUE7OzsrQ0Fma0I7eURBQ1U7eURBQ0E7NkNBT1Y7NkNBQ0Y7MkNBQ0Y7dUNBRU87QUFFOUIsU0FBU0EsbUJBQ2RDLEtBQTJCLEVBQzNCQyxNQUF5QjtJQUV6QixNQUFNLEVBQ0pDLGdCQUFnQixFQUFFQyxVQUFVLEVBQUVDLGNBQWNDLG9CQUFvQixFQUFFLEVBQ2xFQyxXQUFXLEVBQ1osR0FBR0w7SUFFSixNQUFNTSxVQUFtQixDQUFDO0lBRTFCQSxRQUFRQywwQkFBMEIsR0FBRztJQUVyQyw0REFBNEQ7SUFDNUQsSUFBSSxPQUFPTCxlQUFlLFVBQVU7UUFDbEMsT0FBT00sQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFBQSxFQUNMVCxPQUNBTyxTQUNBSixZQUNBSCxNQUFNVSxPQUFPLENBQUNDLFdBQVc7SUFFN0I7SUFFQSxJQUFJQyxjQUFjWixNQUFNYSxJQUFJO0lBQzVCLElBQUlDLGVBQWVkLE1BQU1lLEtBQUs7SUFFOUIsS0FBSyxNQUFNQyx3QkFBd0JiLFdBQVk7UUFDN0MsTUFBTSxFQUFFYyxhQUFhQyxpQkFBaUIsRUFBRUwsTUFBTU0sU0FBUyxFQUFFLEdBQ3ZESDtRQUVGLE1BQU1JLFVBQVVDLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBQUEsRUFDZDtZQUNDO2VBQU9IO1NBQWtCLEVBQzFCTixhQUNBTyxXQUNBbkIsTUFBTUksWUFBWTtRQUdwQixrSUFBa0k7UUFDbEksOEdBQThHO1FBQzlHLG9JQUFvSTtRQUNwSSxtSUFBbUk7UUFDbkksNkJBQTZCO1FBQzdCLElBQUlnQixZQUFZLE1BQU07WUFDcEIsT0FBT3BCO1FBQ1Q7UUFFQSxJQUFJc0IsQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUFBQSxFQUE0QlYsYUFBYVEsVUFBVTtZQUNyRCxPQUFPWCxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQ0xULE9BQ0FPLFNBQ0FQLE1BQU1JLFlBQVksRUFDbEJKLE1BQU1VLE9BQU8sQ0FBQ0MsV0FBVztRQUU3QjtRQUVBLE1BQU1ZLDJCQUEyQmxCLHVCQUM3Qm1CLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JuQix3QkFDbEJvQjtRQUVKLElBQUlGLDBCQUEwQjtZQUM1QmhCLFFBQVFILFlBQVksR0FBR21CO1FBQ3pCO1FBRUEsTUFBTVIsUUFBbUJXLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFBQTtRQUN6QkMsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQUFBLEVBQWdCckIsYUFBYVEsY0FBY0MsT0FBT0M7UUFFbERULFFBQVFxQixXQUFXLEdBQUdSO1FBQ3RCYixRQUFRUSxLQUFLLEdBQUdBO1FBRWhCRCxlQUFlQztRQUNmSCxjQUFjUTtJQUNoQjtJQUVBLE9BQU9TLENBQUFBLEdBQUFBLGVBQUFBLGFBQUFBLEVBQWM3QixPQUFPTztBQUM5QiIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccmVkdWNlcnNcXHNlcnZlci1wYXRjaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi4vY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQgeyBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgfSBmcm9tICcuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSdcbmltcG9ydCB7IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCB9IGZyb20gJy4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0J1xuaW1wb3J0IHR5cGUge1xuICBTZXJ2ZXJQYXRjaEFjdGlvbixcbiAgUmVkdWNlclN0YXRlLFxuICBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgTXV0YWJsZSxcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBoYW5kbGVFeHRlcm5hbFVybCB9IGZyb20gJy4vbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IGFwcGx5RmxpZ2h0RGF0YSB9IGZyb20gJy4uL2FwcGx5LWZsaWdodC1kYXRhJ1xuaW1wb3J0IHsgaGFuZGxlTXV0YWJsZSB9IGZyb20gJy4uL2hhbmRsZS1tdXRhYmxlJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlcidcblxuZXhwb3J0IGZ1bmN0aW9uIHNlcnZlclBhdGNoUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFNlcnZlclBhdGNoQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBjb25zdCB7XG4gICAgc2VydmVyUmVzcG9uc2U6IHsgZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZSB9LFxuICAgIG5hdmlnYXRlZEF0LFxuICB9ID0gYWN0aW9uXG5cbiAgY29uc3QgbXV0YWJsZTogTXV0YWJsZSA9IHt9XG5cbiAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlXG5cbiAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICBzdGF0ZSxcbiAgICAgIG11dGFibGUsXG4gICAgICBmbGlnaHREYXRhLFxuICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgIClcbiAgfVxuXG4gIGxldCBjdXJyZW50VHJlZSA9IHN0YXRlLnRyZWVcbiAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlXG5cbiAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgY29uc3QgeyBzZWdtZW50UGF0aDogZmxpZ2h0U2VnbWVudFBhdGgsIHRyZWU6IHRyZWVQYXRjaCB9ID1cbiAgICAgIG5vcm1hbGl6ZWRGbGlnaHREYXRhXG5cbiAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgWycnLCAuLi5mbGlnaHRTZWdtZW50UGF0aF0sXG4gICAgICBjdXJyZW50VHJlZSxcbiAgICAgIHRyZWVQYXRjaCxcbiAgICAgIHN0YXRlLmNhbm9uaWNhbFVybFxuICAgIClcblxuICAgIC8vIGBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWVgIHJldHVybnMgYG51bGxgIHdoZW4gaXQgZGV0ZXJtaW5lZCB0aGF0IHRoZSBzZXJ2ZXIgcmVzcG9uc2UgaXMgbm90IGFwcGxpY2FibGUgdG8gdGhlIGN1cnJlbnQgdHJlZS5cbiAgICAvLyBJbiBvdGhlciB3b3JkcywgdGhlIHNlcnZlciByZXNwb25kZWQgd2l0aCBhIHRyZWUgdGhhdCBkb2Vzbid0IG1hdGNoIHdoYXQgdGhlIGNsaWVudCBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLlxuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgc2VydmVyIHBhdGNoIGFjdGlvbiB0b29rIGxvbmdlciB0byByZXNvbHZlIHRoYW4gYSBzdWJzZXF1ZW50IG5hdmlnYXRpb24gd2hpY2ggd291bGQgaGF2ZSBjaGFuZ2VkIHRoZSB0cmVlLlxuICAgIC8vIFByZXZpb3VzbHkgdGhpcyBjYXNlIHRyaWdnZXJlZCBhbiBNUEEgbmF2aWdhdGlvbiBidXQgaXQgc2hvdWxkIGJlIHNhZmUgdG8gc2ltcGx5IGRpc2NhcmQgdGhlIHNlcnZlciByZXNwb25zZSByYXRoZXIgdGhhbiBmb3JjaW5nXG4gICAgLy8gdGhlIGVudGlyZSBwYWdlIHRvIHJlbG9hZC5cbiAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfVxuXG4gICAgaWYgKGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIG11dGFibGUsXG4gICAgICAgIHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlXG4gICAgICA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKVxuICAgICAgOiB1bmRlZmluZWRcblxuICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmXG4gICAgfVxuXG4gICAgY29uc3QgY2FjaGU6IENhY2hlTm9kZSA9IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKClcbiAgICBhcHBseUZsaWdodERhdGEobmF2aWdhdGVkQXQsIGN1cnJlbnRDYWNoZSwgY2FjaGUsIG5vcm1hbGl6ZWRGbGlnaHREYXRhKVxuXG4gICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWVcbiAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGVcblxuICAgIGN1cnJlbnRDYWNoZSA9IGNhY2hlXG4gICAgY3VycmVudFRyZWUgPSBuZXdUcmVlXG4gIH1cblxuICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbn1cbiJdLCJuYW1lcyI6WyJzZXJ2ZXJQYXRjaFJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInNlcnZlclJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsImNhbm9uaWNhbFVybCIsImNhbm9uaWNhbFVybE92ZXJyaWRlIiwibmF2aWdhdGVkQXQiLCJtdXRhYmxlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImN1cnJlbnRUcmVlIiwidHJlZSIsImN1cnJlbnRDYWNoZSIsImNhY2hlIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJzZWdtZW50UGF0aCIsImZsaWdodFNlZ21lbnRQYXRoIiwidHJlZVBhdGNoIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJhcHBseUZsaWdodERhdGEiLCJwYXRjaGVkVHJlZSIsImhhbmRsZU11dGFibGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    addRefreshMarkerToActiveParallelSegments: function() {\n        return addRefreshMarkerToActiveParallelSegments;\n    },\n    refreshInactiveParallelSegments: function() {\n        return refreshInactiveParallelSegments;\n    }\n});\nconst _applyflightdata = __webpack_require__(/*! ./apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nasync function refreshInactiveParallelSegments(options) {\n    const fetchedSegments = new Set();\n    await refreshInactiveParallelSegmentsImpl({\n        ...options,\n        rootTree: options.updatedTree,\n        fetchedSegments\n    });\n}\nasync function refreshInactiveParallelSegmentsImpl(param) {\n    let { navigatedAt, state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;\n    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;\n    const fetchPromises = [];\n    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === 'refresh' && // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)) {\n        fetchedSegments.add(refetchPath) // Mark this URL as fetched\n        ;\n        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n        const fetchPromise = (0, _fetchserverresponse.fetchServerResponse)(new URL(refetchPath, location.origin), {\n            // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n            // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n            flightRouterState: [\n                rootTree[0],\n                rootTree[1],\n                rootTree[2],\n                'refetch'\n            ],\n            nextUrl: includeNextUrl ? state.nextUrl : null\n        }).then((param)=>{\n            let { flightData } = param;\n            if (typeof flightData !== 'string') {\n                for (const flightDataPath of flightData){\n                    // we only pass the new cache as this function is called after clearing the router cache\n                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n                    // just been created & has been written to, but hasn't been \"committed\" yet.\n                    (0, _applyflightdata.applyFlightData)(navigatedAt, updatedCache, updatedCache, flightDataPath);\n                }\n            } else {\n            // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n            // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n            // when refreshing on-screen data, so handling this has been ommitted.\n            }\n        });\n        fetchPromises.push(fetchPromise);\n    }\n    for(const key in parallelRoutes){\n        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n            navigatedAt,\n            state,\n            updatedTree: parallelRoutes[key],\n            updatedCache,\n            includeNextUrl,\n            fetchedSegments,\n            rootTree,\n            canonicalUrl\n        });\n        fetchPromises.push(parallelFetchPromise);\n    }\n    await Promise.all(fetchPromises);\n}\nfunction addRefreshMarkerToActiveParallelSegments(tree, path) {\n    const [segment, parallelRoutes, , refetchMarker] = tree;\n    // a page segment might also contain concatenated search params, so we do a partial match on the key\n    if (segment.includes(_segment.PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n        tree[2] = path;\n        tree[3] = 'refresh';\n    }\n    for(const key in parallelRoutes){\n        addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refetch-inactive-parallel-segments.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUF5SGdCQSx3Q0FBd0M7ZUFBeENBOztJQTlGTUMsK0JBQStCO2VBQS9CQTs7OzZDQXhCVTtpREFDSTtxQ0FDSDtBQXNCMUIsZUFBZUEsZ0NBQ3BCQyxPQUF3QztJQUV4QyxNQUFNQyxrQkFBa0IsSUFBSUM7SUFDNUIsTUFBTUMsb0NBQW9DO1FBQ3hDLEdBQUdILE9BQU87UUFDVkksVUFBVUosUUFBUUssV0FBVztRQUM3Qko7SUFDRjtBQUNGO0FBRUEsZUFBZUUsb0NBQW9DLEtBWWxEO0lBWmtELE1BQ2pERyxXQUFXLEVBQ1hDLEtBQUssRUFDTEYsV0FBVyxFQUNYRyxZQUFZLEVBQ1pDLGNBQWMsRUFDZFIsZUFBZSxFQUNmRyxXQUFXQyxXQUFXLEVBQ3RCSyxZQUFZLEVBSWIsR0Faa0Q7SUFhakQsTUFBTSxHQUFHQyxnQkFBZ0JDLGFBQWFDLGNBQWMsR0FBR1I7SUFDdkQsTUFBTVMsZ0JBQWdCLEVBQUU7SUFFeEIsSUFDRUYsZUFDQUEsZ0JBQWdCRixnQkFDaEJHLGtCQUFrQixhQUNsQiw0RkFBNEY7SUFDNUYsc0RBQXNEO0lBQ3RELENBQUNaLGdCQUFnQmMsR0FBRyxDQUFDSCxjQUNyQjtRQUNBWCxnQkFBZ0JlLEdBQUcsQ0FBQ0osYUFBYSwyQkFBMkI7O1FBRTVELHdIQUF3SDtRQUN4SCxrSUFBa0k7UUFDbEksTUFBTUssZUFBZUMsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFBQSxFQUNuQixJQUFJQyxJQUFJUCxhQUFhUSxTQUFTQyxNQUFNLEdBQ3BDO1lBQ0UsZ0dBQWdHO1lBQ2hHLDhIQUE4SDtZQUM5SEMsbUJBQW1CO2dCQUFDbEIsUUFBUSxDQUFDLEVBQUU7Z0JBQUVBLFFBQVEsQ0FBQyxFQUFFO2dCQUFFQSxRQUFRLENBQUMsRUFBRTtnQkFBRTthQUFVO1lBQ3JFbUIsU0FBU2QsaUJBQWlCRixNQUFNZ0IsT0FBTyxHQUFHO1FBQzVDLEdBQ0FDLElBQUksQ0FBQztnQkFBQyxFQUFFQyxVQUFVLEVBQUU7WUFDcEIsSUFBSSxPQUFPQSxlQUFlLFVBQVU7Z0JBQ2xDLEtBQUssTUFBTUMsa0JBQWtCRCxXQUFZO29CQUN2Qyx3RkFBd0Y7b0JBQ3hGLDRHQUE0RztvQkFDNUcsNEVBQTRFO29CQUM1RUUsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQUFBLEVBQ0VyQixhQUNBRSxjQUNBQSxjQUNBa0I7Z0JBRUo7WUFDRixPQUFPO1lBQ0wsNEdBQTRHO1lBQzVHLCtHQUErRztZQUMvRyxzRUFBc0U7WUFDeEU7UUFDRjtRQUVBWixjQUFjYyxJQUFJLENBQUNYO0lBQ3JCO0lBRUEsSUFBSyxNQUFNWSxPQUFPbEIsZUFBZ0I7UUFDaEMsTUFBTW1CLHVCQUF1QjNCLG9DQUFvQztZQUMvREc7WUFDQUM7WUFDQUYsYUFBYU0sY0FBYyxDQUFDa0IsSUFBSTtZQUNoQ3JCO1lBQ0FDO1lBQ0FSO1lBQ0FHO1lBQ0FNO1FBQ0Y7UUFFQUksY0FBY2MsSUFBSSxDQUFDRTtJQUNyQjtJQUVBLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ2xCO0FBQ3BCO0FBUU8sU0FBU2hCLHlDQUNkbUMsSUFBdUIsRUFDdkJDLElBQVk7SUFFWixNQUFNLENBQUNDLFNBQVN4QixrQkFBa0JFLGNBQWMsR0FBR29CO0lBQ25ELG9HQUFvRztJQUNwRyxJQUFJRSxRQUFRQyxRQUFRLENBQUNDLFNBQUFBLGdCQUFnQixLQUFLeEIsa0JBQWtCLFdBQVc7UUFDckVvQixJQUFJLENBQUMsRUFBRSxHQUFHQztRQUNWRCxJQUFJLENBQUMsRUFBRSxHQUFHO0lBQ1o7SUFFQSxJQUFLLE1BQU1KLE9BQU9sQixlQUFnQjtRQUNoQ2IseUNBQXlDYSxjQUFjLENBQUNrQixJQUFJLEVBQUVLO0lBQ2hFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxyZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IEFwcFJvdXRlclN0YXRlIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGFwcGx5RmxpZ2h0RGF0YSB9IGZyb20gJy4vYXBwbHktZmxpZ2h0LWRhdGEnXG5pbXBvcnQgeyBmZXRjaFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQgeyBQQUdFX1NFR01FTlRfS0VZIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuXG5pbnRlcmZhY2UgUmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyB7XG4gIG5hdmlnYXRlZEF0OiBudW1iZXJcbiAgc3RhdGU6IEFwcFJvdXRlclN0YXRlXG4gIHVwZGF0ZWRUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuICB1cGRhdGVkQ2FjaGU6IENhY2hlTm9kZVxuICBpbmNsdWRlTmV4dFVybDogYm9vbGVhblxuICBjYW5vbmljYWxVcmw6IHN0cmluZ1xufVxuXG4vKipcbiAqIFJlZnJlc2hlcyBpbmFjdGl2ZSBzZWdtZW50cyB0aGF0IGFyZSBzdGlsbCBpbiB0aGUgY3VycmVudCBGbGlnaHRSb3V0ZXJTdGF0ZS5cbiAqIEEgc2VnbWVudCBpcyBjb25zaWRlcmVkIFwiaW5hY3RpdmVcIiB3aGVuIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgaW5kaWNhdGVzIGl0IGRpZG4ndCBtYXRjaCB0byBhIHBhZ2UgY29tcG9uZW50LlxuICogVGhpcyBoYXBwZW5zIGR1cmluZyBhIHNvZnQtbmF2aWdhdGlvbiwgd2hlcmUgdGhlIHNlcnZlciB3aWxsIHdhbnQgdG8gcGF0Y2ggaW4gdGhlIHNlZ21lbnRcbiAqIHdpdGggdGhlIFwiZGVmYXVsdFwiIGNvbXBvbmVudCwgYnV0IHdlIGV4cGxpY2l0bHkgaWdub3JlIHRoZSBzZXJ2ZXIgaW4gdGhpcyBjYXNlXG4gKiBhbmQga2VlcCB0aGUgZXhpc3Rpbmcgc3RhdGUgZm9yIHRoYXQgc2VnbWVudC4gTmV3IGRhdGEgZm9yIGluYWN0aXZlIHNlZ21lbnRzIGFyZSBpbmhlcmVudGx5XG4gKiBub3QgcGFydCBvZiB0aGUgc2VydmVyIHJlc3BvbnNlIHdoZW4gd2UgcGF0Y2ggdGhlIHRyZWUsIGJlY2F1c2UgdGhleSB3ZXJlIGFzc29jaWF0ZWQgd2l0aCBhIHJlc3BvbnNlXG4gKiBmcm9tIGFuIGVhcmxpZXIgbmF2aWdhdGlvbi9yZXF1ZXN0LiBGb3IgZWFjaCBzZWdtZW50LCBvbmNlIGl0IGJlY29tZXMgXCJhY3RpdmVcIiwgd2UgZW5jb2RlIHRoZSBVUkwgdGhhdCBwcm92aWRlZFxuICogdGhlIGRhdGEgZm9yIGl0LiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyBwYXJhbGxlbCByb3V0ZXMgbG9va2luZyBmb3IgdGhlc2UgbWFya2VycyBzbyB0aGF0IGl0IGNhbiByZS1mZXRjaFxuICogYW5kIHBhdGNoIHRoZSBuZXcgZGF0YSBpbnRvIHRoZSB0cmVlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyhcbiAgb3B0aW9uczogUmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50c1xuKSB7XG4gIGNvbnN0IGZldGNoZWRTZWdtZW50cyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGF3YWl0IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHJvb3RUcmVlOiBvcHRpb25zLnVwZGF0ZWRUcmVlLFxuICAgIGZldGNoZWRTZWdtZW50cyxcbiAgfSlcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50c0ltcGwoe1xuICBuYXZpZ2F0ZWRBdCxcbiAgc3RhdGUsXG4gIHVwZGF0ZWRUcmVlLFxuICB1cGRhdGVkQ2FjaGUsXG4gIGluY2x1ZGVOZXh0VXJsLFxuICBmZXRjaGVkU2VnbWVudHMsXG4gIHJvb3RUcmVlID0gdXBkYXRlZFRyZWUsXG4gIGNhbm9uaWNhbFVybCxcbn06IFJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMgJiB7XG4gIGZldGNoZWRTZWdtZW50czogU2V0PHN0cmluZz5cbiAgcm9vdFRyZWU6IEZsaWdodFJvdXRlclN0YXRlXG59KSB7XG4gIGNvbnN0IFssIHBhcmFsbGVsUm91dGVzLCByZWZldGNoUGF0aCwgcmVmZXRjaE1hcmtlcl0gPSB1cGRhdGVkVHJlZVxuICBjb25zdCBmZXRjaFByb21pc2VzID0gW11cblxuICBpZiAoXG4gICAgcmVmZXRjaFBhdGggJiZcbiAgICByZWZldGNoUGF0aCAhPT0gY2Fub25pY2FsVXJsICYmXG4gICAgcmVmZXRjaE1hcmtlciA9PT0gJ3JlZnJlc2gnICYmXG4gICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgdGhlIHRyZWUgdG8gY29udGFpbiBtdWx0aXBsZSBzZWdtZW50cyB0aGF0IGNvbnRhaW4gZGF0YSBhdCB0aGUgc2FtZSBVUkxcbiAgICAvLyB3ZSBrZWVwIHRyYWNrIG9mIHRoZW0gc28gd2UgY2FuIGRlZHVwZSB0aGUgcmVxdWVzdHNcbiAgICAhZmV0Y2hlZFNlZ21lbnRzLmhhcyhyZWZldGNoUGF0aClcbiAgKSB7XG4gICAgZmV0Y2hlZFNlZ21lbnRzLmFkZChyZWZldGNoUGF0aCkgLy8gTWFyayB0aGlzIFVSTCBhcyBmZXRjaGVkXG5cbiAgICAvLyBFYWdlcmx5IGtpY2sgb2ZmIHRoZSBmZXRjaCBmb3IgdGhlIHJlZmV0Y2ggcGF0aCAmIHRoZSBwYXJhbGxlbCByb3V0ZXMuIFRoaXMgc2hvdWxkIGJlIGZpbmUgdG8gZG8gYXMgdGhleSBlYWNoIG9wZXJhdGVcbiAgICAvLyBpbmRlcGVuZGVudGx5IG9uIHRoZWlyIG93biBjYWNoZSBub2RlcywgYW5kIGBhcHBseUZsaWdodERhdGFgIHdpbGwgY29weSBhbnl0aGluZyBpdCBkb2Vzbid0IGNhcmUgYWJvdXQgZnJvbSB0aGUgZXhpc3RpbmcgY2FjaGUuXG4gICAgY29uc3QgZmV0Y2hQcm9taXNlID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZShcbiAgICAgIG5ldyBVUkwocmVmZXRjaFBhdGgsIGxvY2F0aW9uLm9yaWdpbiksXG4gICAgICB7XG4gICAgICAgIC8vIHJlZmV0Y2ggZnJvbSB0aGUgcm9vdCBvZiB0aGUgdXBkYXRlZCB0cmVlLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBzY29wZWQgdG8gdGhlIGN1cnJlbnQgc2VnbWVudFxuICAgICAgICAvLyBhbmQgbWlnaHQgbm90IGNvbnRhaW4gdGhlIGRhdGEgd2UgbmVlZCB0byBwYXRjaCBpbiBpbnRlcmNlcHRpb24gcm91dGUgZGF0YSAoc3VjaCBhcyBkeW5hbWljIHBhcmFtcyBmcm9tIGEgcHJldmlvdXMgc2VnbWVudClcbiAgICAgICAgZmxpZ2h0Um91dGVyU3RhdGU6IFtyb290VHJlZVswXSwgcm9vdFRyZWVbMV0sIHJvb3RUcmVlWzJdLCAncmVmZXRjaCddLFxuICAgICAgICBuZXh0VXJsOiBpbmNsdWRlTmV4dFVybCA/IHN0YXRlLm5leHRVcmwgOiBudWxsLFxuICAgICAgfVxuICAgICkudGhlbigoeyBmbGlnaHREYXRhIH0pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yIChjb25zdCBmbGlnaHREYXRhUGF0aCBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgICAgLy8gd2Ugb25seSBwYXNzIHRoZSBuZXcgY2FjaGUgYXMgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgY2xlYXJpbmcgdGhlIHJvdXRlciBjYWNoZVxuICAgICAgICAgIC8vIGFuZCBmaWxsaW5nIGluIHRoZSBuZXcgcGFnZSBkYXRhIGZyb20gdGhlIHNlcnZlci4gTWVhbmluZyB0aGUgZXhpc3RpbmcgY2FjaGUgaXMgYWN0dWFsbHkgdGhlIGNhY2hlIHRoYXQnc1xuICAgICAgICAgIC8vIGp1c3QgYmVlbiBjcmVhdGVkICYgaGFzIGJlZW4gd3JpdHRlbiB0bywgYnV0IGhhc24ndCBiZWVuIFwiY29tbWl0dGVkXCIgeWV0LlxuICAgICAgICAgIGFwcGx5RmxpZ2h0RGF0YShcbiAgICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgICAgdXBkYXRlZENhY2hlLFxuICAgICAgICAgICAgdXBkYXRlZENhY2hlLFxuICAgICAgICAgICAgZmxpZ2h0RGF0YVBhdGhcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdoZW4gZmxpZ2h0RGF0YSBpcyBhIHN0cmluZywgaXQgc3VnZ2VzdHMgdGhhdCB0aGUgc2VydmVyIHJlc3BvbnNlIHNob3VsZCBoYXZlIHRyaWdnZXJlZCBhbiBNUEEgbmF2aWdhdGlvblxuICAgICAgICAvLyBJJ20gbm90IDEwMCUgc3VyZSBvZiB0aGlzIGRlY2lzaW9uLCBidXQgaXQgc2VlbXMgdW5saWtlbHkgdGhhdCB3ZSdkIHdhbnQgdG8gaW50cm9kdWNlIGEgcmVkaXJlY3Qgc2lkZSBlZmZlY3RcbiAgICAgICAgLy8gd2hlbiByZWZyZXNoaW5nIG9uLXNjcmVlbiBkYXRhLCBzbyBoYW5kbGluZyB0aGlzIGhhcyBiZWVuIG9tbWl0dGVkLlxuICAgICAgfVxuICAgIH0pXG5cbiAgICBmZXRjaFByb21pc2VzLnB1c2goZmV0Y2hQcm9taXNlKVxuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBjb25zdCBwYXJhbGxlbEZldGNoUHJvbWlzZSA9IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsKHtcbiAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgc3RhdGUsXG4gICAgICB1cGRhdGVkVHJlZTogcGFyYWxsZWxSb3V0ZXNba2V5XSxcbiAgICAgIHVwZGF0ZWRDYWNoZSxcbiAgICAgIGluY2x1ZGVOZXh0VXJsLFxuICAgICAgZmV0Y2hlZFNlZ21lbnRzLFxuICAgICAgcm9vdFRyZWUsXG4gICAgICBjYW5vbmljYWxVcmwsXG4gICAgfSlcblxuICAgIGZldGNoUHJvbWlzZXMucHVzaChwYXJhbGxlbEZldGNoUHJvbWlzZSlcbiAgfVxuXG4gIGF3YWl0IFByb21pc2UuYWxsKGZldGNoUHJvbWlzZXMpXG59XG5cbi8qKlxuICogV2Fsa3MgdGhlIGN1cnJlbnQgcGFyYWxsZWwgc2VnbWVudHMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIFwiYWN0aXZlXCIuXG4gKiBBbiBhY3RpdmUgcGFyYWxsZWwgcm91dGUgd2lsbCBoYXZlIGEgYF9fUEFHRV9fYCBzZWdtZW50IGluIHRoZSBGbGlnaHRSb3V0ZXJTdGF0ZS5cbiAqIEFzIG9wcG9zZWQgdG8gYSBgX19ERUZBVUxUX19gIHNlZ21lbnQsIHdoaWNoIG1lYW5zIHRoZXJlIHdhcyBubyBtYXRjaCBmb3IgdGhhdCBwYXJhbGxlbCByb3V0ZS5cbiAqIFdlIGFkZCBhIHNwZWNpYWwgbWFya2VyIGhlcmUgc28gdGhhdCB3ZSBrbm93IGhvdyB0byByZWZyZXNoIGl0cyBkYXRhIHdoZW4gdGhlIHJvdXRlciBpcyByZXZhbGlkYXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMoXG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBwYXRoOiBzdHJpbmdcbikge1xuICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXMsICwgcmVmZXRjaE1hcmtlcl0gPSB0cmVlXG4gIC8vIGEgcGFnZSBzZWdtZW50IG1pZ2h0IGFsc28gY29udGFpbiBjb25jYXRlbmF0ZWQgc2VhcmNoIHBhcmFtcywgc28gd2UgZG8gYSBwYXJ0aWFsIG1hdGNoIG9uIHRoZSBrZXlcbiAgaWYgKHNlZ21lbnQuaW5jbHVkZXMoUEFHRV9TRUdNRU5UX0tFWSkgJiYgcmVmZXRjaE1hcmtlciAhPT0gJ3JlZnJlc2gnKSB7XG4gICAgdHJlZVsyXSA9IHBhdGhcbiAgICB0cmVlWzNdID0gJ3JlZnJlc2gnXG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcykge1xuICAgIGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMocGFyYWxsZWxSb3V0ZXNba2V5XSwgcGF0aClcbiAgfVxufVxuIl0sIm5hbWVzIjpbImFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwib3B0aW9ucyIsImZldGNoZWRTZWdtZW50cyIsIlNldCIsInJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsIiwicm9vdFRyZWUiLCJ1cGRhdGVkVHJlZSIsIm5hdmlnYXRlZEF0Iiwic3RhdGUiLCJ1cGRhdGVkQ2FjaGUiLCJpbmNsdWRlTmV4dFVybCIsImNhbm9uaWNhbFVybCIsInBhcmFsbGVsUm91dGVzIiwicmVmZXRjaFBhdGgiLCJyZWZldGNoTWFya2VyIiwiZmV0Y2hQcm9taXNlcyIsImhhcyIsImFkZCIsImZldGNoUHJvbWlzZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsInRoZW4iLCJmbGlnaHREYXRhIiwiZmxpZ2h0RGF0YVBhdGgiLCJhcHBseUZsaWdodERhdGEiLCJwdXNoIiwia2V5IiwicGFyYWxsZWxGZXRjaFByb21pc2UiLCJQcm9taXNlIiwiYWxsIiwidHJlZSIsInBhdGgiLCJzZWdtZW50IiwiaW5jbHVkZXMiLCJQQUdFX1NFR01FTlRfS0VZIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_HMR_REFRESH: function() {\n        return ACTION_HMR_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_PREFETCH: function() {\n        return ACTION_PREFETCH;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    PrefetchCacheEntryStatus: function() {\n        return PrefetchCacheEntryStatus;\n    },\n    PrefetchKind: function() {\n        return PrefetchKind;\n    }\n});\nconst ACTION_REFRESH = 'refresh';\nconst ACTION_NAVIGATE = 'navigate';\nconst ACTION_RESTORE = 'restore';\nconst ACTION_SERVER_PATCH = 'server-patch';\nconst ACTION_PREFETCH = 'prefetch';\nconst ACTION_HMR_REFRESH = 'hmr-refresh';\nconst ACTION_SERVER_ACTION = 'server-action';\nvar PrefetchKind = /*#__PURE__*/ function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\n    return PrefetchKind;\n}({});\nvar PrefetchCacheEntryStatus = /*#__PURE__*/ function(PrefetchCacheEntryStatus) {\n    PrefetchCacheEntryStatus[\"fresh\"] = \"fresh\";\n    PrefetchCacheEntryStatus[\"reusable\"] = \"reusable\";\n    PrefetchCacheEntryStatus[\"expired\"] = \"expired\";\n    PrefetchCacheEntryStatus[\"stale\"] = \"stale\";\n    return PrefetchCacheEntryStatus;\n}({});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer-types.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBWWFBLGtCQUFrQjtlQUFsQkE7O0lBSkFDLGVBQWU7ZUFBZkE7O0lBR0FDLGVBQWU7ZUFBZkE7O0lBSkFDLGNBQWM7ZUFBZEE7O0lBRUFDLGNBQWM7ZUFBZEE7O0lBSUFDLG9CQUFvQjtlQUFwQkE7O0lBSEFDLG1CQUFtQjtlQUFuQkE7O0lBeU1EQyx3QkFBd0I7ZUFBeEJBOztJQWhFQUMsWUFBWTtlQUFaQTs7O0FBNUlMLE1BQU1MLGlCQUFpQjtBQUN2QixNQUFNRixrQkFBa0I7QUFDeEIsTUFBTUcsaUJBQWlCO0FBQ3ZCLE1BQU1FLHNCQUFzQjtBQUM1QixNQUFNSixrQkFBa0I7QUFDeEIsTUFBTUYscUJBQXFCO0FBQzNCLE1BQU1LLHVCQUF1QjtBQXNJN0IsSUFBS0csZUFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsWUFBQUE7Ozs7V0FBQUE7O0FBZ0VMLElBQUtELDJCQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSx3QkFBQUE7Ozs7O1dBQUFBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccm91dGVyLXJlZHVjZXItdHlwZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHtcbiAgRmxpZ2h0Um91dGVyU3RhdGUsXG4gIEZsaWdodFNlZ21lbnRQYXRoLFxufSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB0eXBlIHsgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCB9IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuXG5leHBvcnQgY29uc3QgQUNUSU9OX1JFRlJFU0ggPSAncmVmcmVzaCdcbmV4cG9ydCBjb25zdCBBQ1RJT05fTkFWSUdBVEUgPSAnbmF2aWdhdGUnXG5leHBvcnQgY29uc3QgQUNUSU9OX1JFU1RPUkUgPSAncmVzdG9yZSdcbmV4cG9ydCBjb25zdCBBQ1RJT05fU0VSVkVSX1BBVENIID0gJ3NlcnZlci1wYXRjaCdcbmV4cG9ydCBjb25zdCBBQ1RJT05fUFJFRkVUQ0ggPSAncHJlZmV0Y2gnXG5leHBvcnQgY29uc3QgQUNUSU9OX0hNUl9SRUZSRVNIID0gJ2htci1yZWZyZXNoJ1xuZXhwb3J0IGNvbnN0IEFDVElPTl9TRVJWRVJfQUNUSU9OID0gJ3NlcnZlci1hY3Rpb24nXG5cbmV4cG9ydCB0eXBlIFJvdXRlckNoYW5nZUJ5U2VydmVyUmVzcG9uc2UgPSAoe1xuICBuYXZpZ2F0ZWRBdCxcbiAgcHJldmlvdXNUcmVlLFxuICBzZXJ2ZXJSZXNwb25zZSxcbn06IHtcbiAgbmF2aWdhdGVkQXQ6IG51bWJlclxuICBwcmV2aW91c1RyZWU6IEZsaWdodFJvdXRlclN0YXRlXG4gIHNlcnZlclJlc3BvbnNlOiBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0XG59KSA9PiB2b2lkXG5cbmV4cG9ydCBpbnRlcmZhY2UgTXV0YWJsZSB7XG4gIG1wYU5hdmlnYXRpb24/OiBib29sZWFuXG4gIHBhdGNoZWRUcmVlPzogRmxpZ2h0Um91dGVyU3RhdGVcbiAgY2Fub25pY2FsVXJsPzogc3RyaW5nXG4gIHNjcm9sbGFibGVTZWdtZW50cz86IEZsaWdodFNlZ21lbnRQYXRoW11cbiAgcGVuZGluZ1B1c2g/OiBib29sZWFuXG4gIGNhY2hlPzogQ2FjaGVOb2RlXG4gIHByZWZldGNoQ2FjaGU/OiBBcHBSb3V0ZXJTdGF0ZVsncHJlZmV0Y2hDYWNoZSddXG4gIGhhc2hGcmFnbWVudD86IHN0cmluZ1xuICBzaG91bGRTY3JvbGw/OiBib29sZWFuXG4gIHByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlPzogYm9vbGVhblxuICBvbmx5SGFzaENoYW5nZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXJ2ZXJBY3Rpb25NdXRhYmxlIGV4dGVuZHMgTXV0YWJsZSB7XG4gIGluRmxpZ2h0U2VydmVyQWN0aW9uPzogUHJvbWlzZTxhbnk+IHwgbnVsbFxufVxuXG4vKipcbiAqIFJlZnJlc2ggdHJpZ2dlcnMgYSByZWZyZXNoIG9mIHRoZSBmdWxsIHBhZ2UgZGF0YS5cbiAqIC0gZmV0Y2hlcyB0aGUgRmxpZ2h0IGRhdGEgYW5kIGZpbGxzIHJzYyBhdCB0aGUgcm9vdCBvZiB0aGUgY2FjaGUuXG4gKiAtIFRoZSByb3V0ZXIgc3RhdGUgaXMgdXBkYXRlZCBhdCB0aGUgcm9vdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWZyZXNoQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9SRUZSRVNIXG4gIG9yaWdpbjogTG9jYXRpb25bJ29yaWdpbiddXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSG1yUmVmcmVzaEFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fSE1SX1JFRlJFU0hcbiAgb3JpZ2luOiBMb2NhdGlvblsnb3JpZ2luJ11cbn1cblxuZXhwb3J0IHR5cGUgU2VydmVyQWN0aW9uRGlzcGF0Y2hlciA9IChcbiAgYXJnczogT21pdDxcbiAgICBTZXJ2ZXJBY3Rpb25BY3Rpb24sXG4gICAgJ3R5cGUnIHwgJ211dGFibGUnIHwgJ25hdmlnYXRlJyB8ICdjaGFuZ2VCeVNlcnZlclJlc3BvbnNlJyB8ICdjYWNoZSdcbiAgPlxuKSA9PiB2b2lkXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmVyQWN0aW9uQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9TRVJWRVJfQUNUSU9OXG4gIGFjdGlvbklkOiBzdHJpbmdcbiAgYWN0aW9uQXJnczogYW55W11cbiAgcmVzb2x2ZTogKHZhbHVlOiBhbnkpID0+IHZvaWRcbiAgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkXG59XG5cbi8qKlxuICogTmF2aWdhdGUgdHJpZ2dlcnMgYSBuYXZpZ2F0aW9uIHRvIHRoZSBwcm92aWRlZCB1cmwuIEl0IHN1cHBvcnRzIHR3byB0eXBlczogYHB1c2hgIGFuZCBgcmVwbGFjZWAuXG4gKlxuICogYG5hdmlnYXRlVHlwZWA6XG4gKiAtIGBwdXNoYCAtIHB1c2hlcyBhIG5ldyBoaXN0b3J5IGVudHJ5IGluIHRoZSBicm93c2VyIGhpc3RvcnlcbiAqIC0gYHJlcGxhY2VgIC0gcmVwbGFjZXMgdGhlIGN1cnJlbnQgaGlzdG9yeSBlbnRyeSBpbiB0aGUgYnJvd3NlciBoaXN0b3J5XG4gKlxuICogTmF2aWdhdGUgaGFzIG11bHRpcGxlIGNhY2hlIGhldXJpc3RpY3M6XG4gKiAtIHBhZ2Ugd2FzIHByZWZldGNoZWRcbiAqICAtIEFwcGx5IHJvdXRlciBzdGF0ZSB0cmVlIGZyb20gcHJlZmV0Y2hcbiAqICAtIEFwcGx5IEZsaWdodCBkYXRhIGZyb20gcHJlZmV0Y2ggdG8gdGhlIGNhY2hlXG4gKiAgLSBJZiBGbGlnaHQgZGF0YSBpcyBhIHN0cmluZywgaXQncyBhIHJlZGlyZWN0IGFuZCB0aGUgc3RhdGUgaXMgdXBkYXRlZCB0byB0cmlnZ2VyIGEgcmVkaXJlY3RcbiAqICAtIENoZWNrIGlmIGhhcmQgbmF2aWdhdGlvbiBpcyBuZWVkZWRcbiAqICAgIC0gSGFyZCBuYXZpZ2F0aW9uIGhhcHBlbnMgd2hlbiBhIGR5bmFtaWMgcGFyYW1ldGVyIGJlbG93IHRoZSBjb21tb24gbGF5b3V0IGNoYW5nZWRcbiAqICAgIC0gV2hlbiBoYXJkIG5hdmlnYXRpb24gaXMgbmVlZGVkIHRoZSBjYWNoZSBpcyBpbnZhbGlkYXRlZCBiZWxvdyB0aGUgZmxpZ2h0U2VnbWVudFBhdGhcbiAqICAgIC0gVGhlIG1pc3NpbmcgY2FjaGUgbm9kZXMgb2YgdGhlIHBhZ2Ugd2lsbCBiZSBmZXRjaGVkIGluIGxheW91dC1yb3V0ZXIgYW5kIHRyaWdnZXIgdGhlIFNFUlZFUl9QQVRDSCBhY3Rpb25cbiAqICAtIElmIGhhcmQgbmF2aWdhdGlvbiBpcyBub3QgbmVlZGVkXG4gKiAgICAtIFRoZSBjYWNoZSBpcyByZXVzZWRcbiAqICAgIC0gSWYgYW55IGNhY2hlIG5vZGVzIGFyZSBtaXNzaW5nIHRoZXknbGwgYmUgZmV0Y2hlZCBpbiBsYXlvdXQtcm91dGVyIGFuZCB0cmlnZ2VyIHRoZSBTRVJWRVJfUEFUQ0ggYWN0aW9uXG4gKiAtIHBhZ2Ugd2FzIG5vdCBwcmVmZXRjaGVkXG4gKiAgLSBUaGUgbmF2aWdhdGUgd2FzIGNhbGxlZCBmcm9tIGBuZXh0L3JvdXRlcmAgKGByb3V0ZXIucHVzaCgpYCAvIGByb3V0ZXIucmVwbGFjZSgpYCkgLyBgbmV4dC9saW5rYCB3aXRob3V0IHByZWZldGNoZWQgZGF0YSBhdmFpbGFibGUgKGUuZy4gdGhlIHByZWZldGNoIGRpZG4ndCBjb21lIGJhY2sgZnJvbSB0aGUgc2VydmVyIGJlZm9yZSBjbGlja2luZyB0aGUgbGluaylcbiAqICAgIC0gRmxpZ2h0IGRhdGEgaXMgZmV0Y2hlZCBpbiB0aGUgcmVkdWNlciAoc3VzcGVuZHMgdGhlIHJlZHVjZXIpXG4gKiAgICAtIFJvdXRlciBzdGF0ZSB0cmVlIGlzIGNyZWF0ZWQgYmFzZWQgb24gRmxpZ2h0IGRhdGFcbiAqICAgIC0gQ2FjaGUgaXMgZmlsbGVkIGJhc2VkIG9uIHRoZSBGbGlnaHQgZGF0YVxuICpcbiAqIEFib3ZlIHN0ZXBzIGV4cGxhaW4gMyBjYXNlczpcbiAqIC0gYHNvZnRgIC0gUmV1c2VzIHRoZSBleGlzdGluZyBjYWNoZSBhbmQgZmV0Y2hlcyBtaXNzaW5nIG5vZGVzIGluIGxheW91dC1yb3V0ZXIuXG4gKiAtIGBoYXJkYCAtIENyZWF0ZXMgYSBuZXcgY2FjaGUgd2hlcmUgY2FjaGUgbm9kZXMgYXJlIHJlbW92ZWQgYmVsb3cgdGhlIGNvbW1vbiBsYXlvdXQgYW5kIGZldGNoZXMgbWlzc2luZyBub2RlcyBpbiBsYXlvdXQtcm91dGVyLlxuICogLSBgb3B0aW1pc3RpY2AgKGV4cGxpY2l0IG5vIHByZWZldGNoKSAtIENyZWF0ZXMgYSBuZXcgY2FjaGUgYW5kIGtpY2tzIG9mZiB0aGUgZGF0YSBmZXRjaCBpbiB0aGUgcmVkdWNlci4gVGhlIGRhdGEgZmV0Y2ggaXMgYXdhaXRlZCBpbiB0aGUgbGF5b3V0LXJvdXRlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0ZUFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fTkFWSUdBVEVcbiAgdXJsOiBVUkxcbiAgaXNFeHRlcm5hbFVybDogYm9vbGVhblxuICBsb2NhdGlvblNlYXJjaDogTG9jYXRpb25bJ3NlYXJjaCddXG4gIG5hdmlnYXRlVHlwZTogJ3B1c2gnIHwgJ3JlcGxhY2UnXG4gIHNob3VsZFNjcm9sbDogYm9vbGVhblxuICBhbGxvd0FsaWFzaW5nOiBib29sZWFuXG59XG5cbi8qKlxuICogUmVzdG9yZSBhcHBsaWVzIHRoZSBwcm92aWRlZCByb3V0ZXIgc3RhdGUuXG4gKiAtIFVzZWQgZm9yIGBwb3BzdGF0ZWAgKGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9uKSB3aGVyZSBhIGtub3duIHJvdXRlciBzdGF0ZSBoYXMgdG8gYmUgYXBwbGllZC5cbiAqIC0gQWxzbyB1c2VkIHdoZW4gc3luY2luZyB0aGUgcm91dGVyIHN0YXRlIHdpdGggYHB1c2hTdGF0ZWAvYHJlcGxhY2VTdGF0ZWAgY2FsbHMuXG4gKiAtIFJvdXRlciBzdGF0ZSBpcyBhcHBsaWVkIGFzLWlzIGZyb20gdGhlIGhpc3Rvcnkgc3RhdGUsIGlmIGF2YWlsYWJsZS5cbiAqIC0gSWYgdGhlIGhpc3Rvcnkgc3RhdGUgZG9lcyBub3QgY29udGFpbiB0aGUgcm91dGVyIHN0YXRlLCB0aGUgZXhpc3Rpbmcgcm91dGVyIHN0YXRlIGlzIHVzZWQuXG4gKiAtIElmIGFueSBjYWNoZSBub2RlIGlzIG1pc3NpbmcgaXQgd2lsbCBiZSBmZXRjaGVkIGluIGxheW91dC1yb3V0ZXIgZHVyaW5nIHJlbmRlcmluZyBhbmQgdGhlIHNlcnZlci1wYXRjaCBjYXNlLlxuICogLSBJZiBleGlzdGluZyBjYWNoZSBub2RlcyBtYXRjaCB0aGVzZSBhcmUgdXNlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXN0b3JlQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9SRVNUT1JFXG4gIHVybDogVVJMXG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlIHwgdW5kZWZpbmVkXG59XG5cbi8qKlxuICogU2VydmVyLXBhdGNoIGFwcGxpZXMgdGhlIHByb3ZpZGVkIEZsaWdodCBkYXRhIHRvIHRoZSBjYWNoZSBhbmQgcm91dGVyIHRyZWUuXG4gKiAtIE9ubHkgdHJpZ2dlcmVkIGluIGxheW91dC1yb3V0ZXIuXG4gKiAtIENyZWF0ZXMgYSBuZXcgY2FjaGUgYW5kIHJvdXRlciBzdGF0ZSB3aXRoIHRoZSBGbGlnaHQgZGF0YSBhcHBsaWVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZlclBhdGNoQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9TRVJWRVJfUEFUQ0hcbiAgbmF2aWdhdGVkQXQ6IG51bWJlclxuICBzZXJ2ZXJSZXNwb25zZTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdFxuICBwcmV2aW91c1RyZWU6IEZsaWdodFJvdXRlclN0YXRlXG59XG5cbi8qKlxuICogUHJlZmV0Y2hLaW5kIGRlZmluZXMgdGhlIHR5cGUgb2YgcHJlZmV0Y2hpbmcgdGhhdCBzaG91bGQgYmUgZG9uZS5cbiAqIC0gYGF1dG9gIC0gaWYgdGhlIHBhZ2UgaXMgZHluYW1pYywgcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBwYXJ0aWFsbHksIGlmIHN0YXRpYyBwcmVmZXRjaCB0aGUgcGFnZSBkYXRhIGZ1bGx5LlxuICogLSBgZnVsbGAgLSBwcmVmZXRjaCB0aGUgcGFnZSBkYXRhIGZ1bGx5LlxuICogLSBgdGVtcG9yYXJ5YCAtIGEgdGVtcG9yYXJ5IHByZWZldGNoIGVudHJ5IGlzIGFkZGVkIHRvIHRoZSBjYWNoZSwgdGhpcyBpcyB1c2VkIHdoZW4gcHJlZmV0Y2g9e2ZhbHNlfSBpcyB1c2VkIGluIG5leHQvbGluayBvciB3aGVuIHlvdSBwdXNoIGEgcm91dGUgcHJvZ3JhbW1hdGljYWxseS5cbiAqL1xuXG5leHBvcnQgZW51bSBQcmVmZXRjaEtpbmQge1xuICBBVVRPID0gJ2F1dG8nLFxuICBGVUxMID0gJ2Z1bGwnLFxuICBURU1QT1JBUlkgPSAndGVtcG9yYXJ5Jyxcbn1cblxuLyoqXG4gKiBQcmVmZXRjaCBhZGRzIHRoZSBwcm92aWRlZCBGbGlnaHREYXRhIHRvIHRoZSBwcmVmZXRjaCBjYWNoZVxuICogLSBDcmVhdGVzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBiYXNlZCBvbiB0aGUgcGF0Y2ggaW4gRmxpZ2h0RGF0YVxuICogLSBBZGRzIHRoZSBGbGlnaHREYXRhIHRvIHRoZSBwcmVmZXRjaCBjYWNoZVxuICogLSBJbiBBQ1RJT05fTkFWSUdBVEUgdGhlIHByZWZldGNoIGNhY2hlIGlzIGNoZWNrZWQgYW5kIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBhbmQgRmxpZ2h0RGF0YSBhcmUgYXBwbGllZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVmZXRjaEFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fUFJFRkVUQ0hcbiAgdXJsOiBVUkxcbiAga2luZDogUHJlZmV0Y2hLaW5kXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHVzaFJlZiB7XG4gIC8qKlxuICAgKiBJZiB0aGUgYXBwLXJvdXRlciBzaG91bGQgcHVzaCBhIG5ldyBoaXN0b3J5IGVudHJ5IGluIGFwcC1yb3V0ZXIncyB1c2VFZmZlY3QoKVxuICAgKi9cbiAgcGVuZGluZ1B1c2g6IGJvb2xlYW5cbiAgLyoqXG4gICAqIE11bHRpLXBhZ2UgbmF2aWdhdGlvbiB0aHJvdWdoIGxvY2F0aW9uLmhyZWYuXG4gICAqL1xuICBtcGFOYXZpZ2F0aW9uOiBib29sZWFuXG4gIC8qKlxuICAgKiBTa2lwIGFwcGx5aW5nIHRoZSByb3V0ZXIgc3RhdGUgdG8gdGhlIGJyb3dzZXIgaGlzdG9yeSBzdGF0ZS5cbiAgICovXG4gIHByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlOiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIEZvY3VzQW5kU2Nyb2xsUmVmID0ge1xuICAvKipcbiAgICogSWYgZm9jdXMgYW5kIHNjcm9sbCBzaG91bGQgYmUgc2V0IGluIHRoZSBsYXlvdXQtcm91dGVyJ3MgdXNlRWZmZWN0KClcbiAgICovXG4gIGFwcGx5OiBib29sZWFuXG4gIC8qKlxuICAgKiBUaGUgaGFzaCBmcmFnbWVudCB0aGF0IHNob3VsZCBiZSBzY3JvbGxlZCB0by5cbiAgICovXG4gIGhhc2hGcmFnbWVudDogc3RyaW5nIHwgbnVsbFxuICAvKipcbiAgICogVGhlIHBhdGhzIG9mIHRoZSBzZWdtZW50cyB0aGF0IHNob3VsZCBiZSBmb2N1c2VkLlxuICAgKi9cbiAgc2VnbWVudFBhdGhzOiBGbGlnaHRTZWdtZW50UGF0aFtdXG4gIC8qKlxuICAgKiBJZiBvbmx5IHRoZSBVUkxzIGhhc2ggZnJhZ21lbnQgY2hhbmdlZFxuICAgKi9cbiAgb25seUhhc2hDaGFuZ2U6IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5ID0ge1xuICB0cmVlQXRUaW1lT2ZQcmVmZXRjaDogRmxpZ2h0Um91dGVyU3RhdGVcbiAgZGF0YTogUHJvbWlzZTxGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0PlxuICBraW5kOiBQcmVmZXRjaEtpbmRcbiAgcHJlZmV0Y2hUaW1lOiBudW1iZXJcbiAgc3RhbGVUaW1lOiBudW1iZXJcbiAgbGFzdFVzZWRUaW1lOiBudW1iZXIgfCBudWxsXG4gIGtleTogc3RyaW5nXG4gIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzXG4gIHVybDogVVJMXG59XG5cbmV4cG9ydCBlbnVtIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyB7XG4gIGZyZXNoID0gJ2ZyZXNoJyxcbiAgcmV1c2FibGUgPSAncmV1c2FibGUnLFxuICBleHBpcmVkID0gJ2V4cGlyZWQnLFxuICBzdGFsZSA9ICdzdGFsZScsXG59XG5cbi8qKlxuICogSGFuZGxlcyBrZWVwaW5nIHRoZSBzdGF0ZSBvZiBhcHAtcm91dGVyLlxuICovXG5leHBvcnQgdHlwZSBBcHBSb3V0ZXJTdGF0ZSA9IHtcbiAgLyoqXG4gICAqIFRoZSByb3V0ZXIgc3RhdGUsIHRoaXMgaXMgd3JpdHRlbiBpbnRvIHRoZSBoaXN0b3J5IHN0YXRlIGluIGFwcC1yb3V0ZXIgdXNpbmcgcmVwbGFjZVN0YXRlL3B1c2hTdGF0ZS5cbiAgICogLSBIYXMgdG8gYmUgc2VyaWFsaXphYmxlIGFzIGl0IGlzIHdyaXR0ZW4gaW50byB0aGUgaGlzdG9yeSBzdGF0ZS5cbiAgICogLSBIb2xkcyB3aGljaCBzZWdtZW50cyBhbmQgcGFyYWxsZWwgcm91dGVzIGFyZSBzaG93biBvbiB0aGUgc2NyZWVuLlxuICAgKi9cbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgLyoqXG4gICAqIFRoZSBjYWNoZSBob2xkcyBSZWFjdCBub2RlcyBmb3IgZXZlcnkgc2VnbWVudCB0aGF0IGlzIHNob3duIG9uIHNjcmVlbiBhcyB3ZWxsIGFzIHByZXZpb3VzbHkgc2hvd24gc2VnbWVudHMuXG4gICAqIEl0IGFsc28gaG9sZHMgaW4tcHJvZ3Jlc3MgZGF0YSByZXF1ZXN0cy5cbiAgICogUHJlZmV0Y2hlZCBkYXRhIGlzIHN0b3JlZCBzZXBhcmF0ZWx5IGluIGBwcmVmZXRjaENhY2hlYCwgdGhhdCBpcyBhcHBsaWVkIGR1cmluZyBBQ1RJT05fTkFWSUdBVEUuXG4gICAqL1xuICBjYWNoZTogQ2FjaGVOb2RlXG4gIC8qKlxuICAgKiBDYWNoZSB0aGF0IGhvbGRzIHByZWZldGNoZWQgRmxpZ2h0IHJlc3BvbnNlcyBrZXllZCBieSB1cmwuXG4gICAqL1xuICBwcmVmZXRjaENhY2hlOiBNYXA8c3RyaW5nLCBQcmVmZXRjaENhY2hlRW50cnk+XG4gIC8qKlxuICAgKiBEZWNpZGVzIGlmIHRoZSB1cGRhdGUgc2hvdWxkIGNyZWF0ZSBhIG5ldyBoaXN0b3J5IGVudHJ5IGFuZCBpZiB0aGUgbmF2aWdhdGlvbiBoYXMgdG8gdHJpZ2dlciBhIGJyb3dzZXIgbmF2aWdhdGlvbi5cbiAgICovXG4gIHB1c2hSZWY6IFB1c2hSZWZcbiAgLyoqXG4gICAqIERlY2lkZXMgaWYgdGhlIHVwZGF0ZSBzaG91bGQgYXBwbHkgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50LlxuICAgKi9cbiAgZm9jdXNBbmRTY3JvbGxSZWY6IEZvY3VzQW5kU2Nyb2xsUmVmXG4gIC8qKlxuICAgKiBUaGUgY2Fub25pY2FsIHVybCB0aGF0IGlzIHB1c2hlZC9yZXBsYWNlZC5cbiAgICogLSBUaGlzIGlzIHRoZSB1cmwgeW91IHNlZSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGNhbm9uaWNhbFVybDogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgdW5kZXJseWluZyBcInVybFwiIHJlcHJlc2VudGluZyB0aGUgVUkgc3RhdGUsIHdoaWNoIGlzIHVzZWQgZm9yIGludGVyY2VwdGluZyByb3V0ZXMuXG4gICAqL1xuICBuZXh0VXJsOiBzdHJpbmcgfCBudWxsXG59XG5cbmV4cG9ydCB0eXBlIFJlYWRvbmx5UmVkdWNlclN0YXRlID0gUmVhZG9ubHk8QXBwUm91dGVyU3RhdGU+XG5leHBvcnQgdHlwZSBSZWR1Y2VyU3RhdGUgPSBQcm9taXNlPEFwcFJvdXRlclN0YXRlPiB8IEFwcFJvdXRlclN0YXRlXG5leHBvcnQgdHlwZSBSZWR1Y2VyQWN0aW9ucyA9IFJlYWRvbmx5PFxuICB8IFJlZnJlc2hBY3Rpb25cbiAgfCBOYXZpZ2F0ZUFjdGlvblxuICB8IFJlc3RvcmVBY3Rpb25cbiAgfCBTZXJ2ZXJQYXRjaEFjdGlvblxuICB8IFByZWZldGNoQWN0aW9uXG4gIHwgSG1yUmVmcmVzaEFjdGlvblxuICB8IFNlcnZlckFjdGlvbkFjdGlvblxuPlxuIl0sIm5hbWVzIjpbIkFDVElPTl9ITVJfUkVGUkVTSCIsIkFDVElPTl9OQVZJR0FURSIsIkFDVElPTl9QUkVGRVRDSCIsIkFDVElPTl9SRUZSRVNIIiwiQUNUSU9OX1JFU1RPUkUiLCJBQ1RJT05fU0VSVkVSX0FDVElPTiIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJQcmVmZXRjaEtpbmQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "reducer", ({\n    enumerable: true,\n    get: function() {\n        return reducer;\n    }\n}));\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js");\nconst _navigatereducer = __webpack_require__(/*! ./reducers/navigate-reducer */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js");\nconst _serverpatchreducer = __webpack_require__(/*! ./reducers/server-patch-reducer */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js");\nconst _restorereducer = __webpack_require__(/*! ./reducers/restore-reducer */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js");\nconst _refreshreducer = __webpack_require__(/*! ./reducers/refresh-reducer */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js");\nconst _hmrrefreshreducer = __webpack_require__(/*! ./reducers/hmr-refresh-reducer */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js");\nconst _serveractionreducer = __webpack_require__(/*! ./reducers/server-action-reducer */ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js");\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case _routerreducertypes.ACTION_NAVIGATE:\n            {\n                return (0, _navigatereducer.navigateReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_PATCH:\n            {\n                return (0, _serverpatchreducer.serverPatchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_RESTORE:\n            {\n                return (0, _restorereducer.restoreReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_REFRESH:\n            {\n                return (0, _refreshreducer.refreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_HMR_REFRESH:\n            {\n                return (0, _hmrrefreshreducer.hmrRefreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_PREFETCH:\n            {\n                return (0, _prefetchreducer.prefetchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_ACTION:\n            {\n                return (0, _serveractionreducer.serverActionReducer)(state, action);\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw Object.defineProperty(new Error(\'Unknown action\'), "__NEXT_ERROR_CODE", {\n                value: "E295",\n                enumerable: false,\n                configurable: true\n            });\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer =  false ? 0 : clientReducer;\nif ((typeof exports.default === \'function\' || typeof exports.default === \'object\' && exports.default !== null) && typeof exports.default.__esModule === \'undefined\') {\n    Object.defineProperty(exports.default, \'__esModule\', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0FpRWFBOzs7ZUFBQUE7OztnREF6RE47NkNBTXlCO2dEQUNHOzRDQUNKOzRDQUNBOzZDQUNDOytDQUNFO2lEQUNFO0FBRXBDOztDQUVDLEdBQ0QsU0FBU0MsY0FDUEMsS0FBMkIsRUFDM0JDLE1BQXNCO0lBRXRCLE9BQVFBLE9BQU9DLElBQUk7UUFDakIsS0FBS0Msb0JBQUFBLGVBQWU7WUFBRTtnQkFDcEIsT0FBT0MsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQUFBLEVBQWdCSixPQUFPQztZQUNoQztRQUNBLEtBQUtJLG9CQUFBQSxtQkFBbUI7WUFBRTtnQkFDeEIsT0FBT0MsQ0FBQUEsR0FBQUEsb0JBQUFBLGtCQUFBQSxFQUFtQk4sT0FBT0M7WUFDbkM7UUFDQSxLQUFLTSxvQkFBQUEsY0FBYztZQUFFO2dCQUNuQixPQUFPQyxDQUFBQSxHQUFBQSxnQkFBQUEsY0FBQUEsRUFBZVIsT0FBT0M7WUFDL0I7UUFDQSxLQUFLUSxvQkFBQUEsY0FBYztZQUFFO2dCQUNuQixPQUFPQyxDQUFBQSxHQUFBQSxnQkFBQUEsY0FBQUEsRUFBZVYsT0FBT0M7WUFDL0I7UUFDQSxLQUFLVSxvQkFBQUEsa0JBQWtCO1lBQUU7Z0JBQ3ZCLE9BQU9DLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JaLE9BQU9DO1lBQ2xDO1FBQ0EsS0FBS1ksb0JBQUFBLGVBQWU7WUFBRTtnQkFDcEIsT0FBT0MsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQUFBLEVBQWdCZCxPQUFPQztZQUNoQztRQUNBLEtBQUtjLG9CQUFBQSxvQkFBb0I7WUFBRTtnQkFDekIsT0FBT0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFBQSxFQUFvQmhCLE9BQU9DO1lBQ3BDO1FBQ0EsK0RBQStEO1FBQy9EO1lBQ0UsTUFBTSxxQkFBMkIsQ0FBM0IsSUFBSWdCLE1BQU0sbUJBQVY7dUJBQUE7NEJBQUE7OEJBQUE7WUFBMEI7SUFDcEM7QUFDRjtBQUVBLFNBQVNDLGNBQ1BsQixLQUEyQixFQUMzQm1CLE9BQXVCO0lBRXZCLE9BQU9uQjtBQUNUO0FBR08sTUFBTUYsVUFDWCxNQUE2QixHQUFHb0IsQ0FBYUEsR0FBR25CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccm91dGVyLXJlZHVjZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQUNUSU9OX05BVklHQVRFLFxuICBBQ1RJT05fU0VSVkVSX1BBVENILFxuICBBQ1RJT05fUkVTVE9SRSxcbiAgQUNUSU9OX1JFRlJFU0gsXG4gIEFDVElPTl9QUkVGRVRDSCxcbiAgQUNUSU9OX0hNUl9SRUZSRVNILFxuICBBQ1RJT05fU0VSVkVSX0FDVElPTixcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB0eXBlIHtcbiAgUmVkdWNlckFjdGlvbnMsXG4gIFJlZHVjZXJTdGF0ZSxcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBuYXZpZ2F0ZVJlZHVjZXIgfSBmcm9tICcuL3JlZHVjZXJzL25hdmlnYXRlLXJlZHVjZXInXG5pbXBvcnQgeyBzZXJ2ZXJQYXRjaFJlZHVjZXIgfSBmcm9tICcuL3JlZHVjZXJzL3NlcnZlci1wYXRjaC1yZWR1Y2VyJ1xuaW1wb3J0IHsgcmVzdG9yZVJlZHVjZXIgfSBmcm9tICcuL3JlZHVjZXJzL3Jlc3RvcmUtcmVkdWNlcidcbmltcG9ydCB7IHJlZnJlc2hSZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9yZWZyZXNoLXJlZHVjZXInXG5pbXBvcnQgeyBwcmVmZXRjaFJlZHVjZXIgfSBmcm9tICcuL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXInXG5pbXBvcnQgeyBobXJSZWZyZXNoUmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcnMvaG1yLXJlZnJlc2gtcmVkdWNlcidcbmltcG9ydCB7IHNlcnZlckFjdGlvblJlZHVjZXIgfSBmcm9tICcuL3JlZHVjZXJzL3NlcnZlci1hY3Rpb24tcmVkdWNlcidcblxuLyoqXG4gKiBSZWR1Y2VyIHRoYXQgaGFuZGxlcyB0aGUgYXBwLXJvdXRlciBzdGF0ZSB1cGRhdGVzLlxuICovXG5mdW5jdGlvbiBjbGllbnRSZWR1Y2VyKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogUmVkdWNlckFjdGlvbnNcbik6IFJlZHVjZXJTdGF0ZSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIEFDVElPTl9OQVZJR0FURToge1xuICAgICAgcmV0dXJuIG5hdmlnYXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKVxuICAgIH1cbiAgICBjYXNlIEFDVElPTl9TRVJWRVJfUEFUQ0g6IHtcbiAgICAgIHJldHVybiBzZXJ2ZXJQYXRjaFJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICB9XG4gICAgY2FzZSBBQ1RJT05fUkVTVE9SRToge1xuICAgICAgcmV0dXJuIHJlc3RvcmVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pXG4gICAgfVxuICAgIGNhc2UgQUNUSU9OX1JFRlJFU0g6IHtcbiAgICAgIHJldHVybiByZWZyZXNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKVxuICAgIH1cbiAgICBjYXNlIEFDVElPTl9ITVJfUkVGUkVTSDoge1xuICAgICAgcmV0dXJuIGhtclJlZnJlc2hSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pXG4gICAgfVxuICAgIGNhc2UgQUNUSU9OX1BSRUZFVENIOiB7XG4gICAgICByZXR1cm4gcHJlZmV0Y2hSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pXG4gICAgfVxuICAgIGNhc2UgQUNUSU9OX1NFUlZFUl9BQ1RJT046IHtcbiAgICAgIHJldHVybiBzZXJ2ZXJBY3Rpb25SZWR1Y2VyKHN0YXRlLCBhY3Rpb24pXG4gICAgfVxuICAgIC8vIFRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgYmUgaGl0IGFzIGRpc3BhdGNoIGlzIHN0cm9uZ2x5IHR5cGVkLlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYWN0aW9uJylcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXJ2ZXJSZWR1Y2VyKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIF9hY3Rpb246IFJlZHVjZXJBY3Rpb25zXG4pOiBSZWR1Y2VyU3RhdGUge1xuICByZXR1cm4gc3RhdGVcbn1cblxuLy8gd2UgZG9uJ3QgcnVuIHRoZSBjbGllbnQgcmVkdWNlciBvbiB0aGUgc2VydmVyLCBzbyB3ZSB1c2UgYSBub29wIGZ1bmN0aW9uIGZvciBiZXR0ZXIgdHJlZSBzaGFraW5nXG5leHBvcnQgY29uc3QgcmVkdWNlciA9XG4gIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gc2VydmVyUmVkdWNlciA6IGNsaWVudFJlZHVjZXJcbiJdLCJuYW1lcyI6WyJyZWR1Y2VyIiwiY2xpZW50UmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidHlwZSIsIkFDVElPTl9OQVZJR0FURSIsIm5hdmlnYXRlUmVkdWNlciIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJzZXJ2ZXJQYXRjaFJlZHVjZXIiLCJBQ1RJT05fUkVTVE9SRSIsInJlc3RvcmVSZWR1Y2VyIiwiQUNUSU9OX1JFRlJFU0giLCJyZWZyZXNoUmVkdWNlciIsIkFDVElPTl9ITVJfUkVGUkVTSCIsImhtclJlZnJlc2hSZWR1Y2VyIiwiQUNUSU9OX1BSRUZFVENIIiwicHJlZmV0Y2hSZWR1Y2VyIiwiQUNUSU9OX1NFUlZFUl9BQ1RJT04iLCJzZXJ2ZXJBY3Rpb25SZWR1Y2VyIiwiRXJyb3IiLCJzZXJ2ZXJSZWR1Y2VyIiwiX2FjdGlvbiIsIndpbmRvdyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js\n'))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"setCacheBustingSearchParam\", ({\n    enumerable: true,\n    get: function() {\n        return setCacheBustingSearchParam;\n    }\n}));\nconst _hash = __webpack_require__(/*! ../../../shared/lib/hash */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/hash.js\");\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst setCacheBustingSearchParam = (url, headers)=>{\n    const uniqueCacheKey = (0, _hash.hexHash)([\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] || '0',\n        headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] || '0',\n        headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER],\n        headers[_approuterheaders.NEXT_URL]\n    ].join(','));\n    /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */ const existingSearch = url.search;\n    const rawQuery = existingSearch.startsWith('?') ? existingSearch.slice(1) : existingSearch;\n    const pairs = rawQuery.split('&').filter(Boolean);\n    pairs.push(_approuterheaders.NEXT_RSC_UNION_QUERY + \"=\" + uniqueCacheKey);\n    url.search = pairs.length ? \"?\" + pairs.join('&') : '';\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=set-cache-busting-search-param.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvc2V0LWNhY2hlLWJ1c3Rpbmctc2VhcmNoLXBhcmFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OERBMkJhQTs7O2VBQUFBOzs7a0NBMUJXOzhDQU9qQjtBQW1CQSxNQUFNQSw2QkFBNkIsQ0FDeENDLEtBQ0FDO0lBRUEsTUFBTUMsaUJBQWlCQyxDQUFBQSxHQUFBQSxNQUFBQSxPQUFBQSxFQUNyQjtRQUNFRixPQUFPLENBQUNHLGtCQUFBQSwyQkFBMkIsQ0FBQyxJQUFJO1FBQ3hDSCxPQUFPLENBQUNJLGtCQUFBQSxtQ0FBbUMsQ0FBQyxJQUFJO1FBQ2hESixPQUFPLENBQUNLLGtCQUFBQSw2QkFBNkIsQ0FBQztRQUN0Q0wsT0FBTyxDQUFDTSxrQkFBQUEsUUFBUSxDQUFDO0tBQ2xCLENBQUNDLElBQUksQ0FBQztJQUdUOzs7Ozs7Ozs7O0dBVUMsR0FDRCxNQUFNQyxpQkFBaUJULElBQUlVLE1BQU07SUFDakMsTUFBTUMsV0FBV0YsZUFBZUcsVUFBVSxDQUFDLE9BQ3ZDSCxlQUFlSSxLQUFLLENBQUMsS0FDckJKO0lBQ0osTUFBTUssUUFBUUgsU0FBU0ksS0FBSyxDQUFDLEtBQUtDLE1BQU0sQ0FBQ0M7SUFDekNILE1BQU1JLElBQUksQ0FBSUMsa0JBQUFBLG9CQUFvQixHQUFDLE1BQUdqQjtJQUN0Q0YsSUFBSVUsTUFBTSxHQUFHSSxNQUFNTSxNQUFNLEdBQUksTUFBR04sTUFBTU4sSUFBSSxDQUFDLE9BQVM7QUFDdEQiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxzZXQtY2FjaGUtYnVzdGluZy1zZWFyY2gtcGFyYW0udHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgeyBoZXhIYXNoIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9oYXNoJ1xuaW1wb3J0IHtcbiAgTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIsXG4gIE5FWFRfVVJMLFxuICBORVhUX1JTQ19VTklPTl9RVUVSWSxcbn0gZnJvbSAnLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHR5cGUgeyBSZXF1ZXN0SGVhZGVycyB9IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuXG4vKipcbiAqIE11dGF0ZXMgdGhlIHByb3ZpZGVkIFVSTCBieSBhZGRpbmcgYSBjYWNoZS1idXN0aW5nIHNlYXJjaCBwYXJhbWV0ZXIgZm9yIENETnMgdGhhdCBkb24ndFxuICogc3VwcG9ydCBjdXN0b20gaGVhZGVycy4gVGhpcyBoZWxwcyBhdm9pZCBjYWNoaW5nIGNvbmZsaWN0cyBieSBtYWtpbmcgZWFjaCByZXF1ZXN0IHVuaXF1ZS5cbiAqXG4gKiBSYXRoZXIgdGhhbiByZWx5aW5nIG9uIHRoZSBWYXJ5IGhlYWRlciB3aGljaCBzb21lIENETnMgaWdub3JlLCB3ZSBhcHBlbmQgYSBzZWFyY2ggcGFyYW1cbiAqIHRvIGNyZWF0ZSBhIHVuaXF1ZSBVUkwgdGhhdCBmb3JjZXMgYSBmcmVzaCByZXF1ZXN0LlxuICpcbiAqIEV4YW1wbGU6XG4gKiBVUkwgYmVmb3JlOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MVxuICogVVJMIGFmdGVyOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MSZfcnNjPWFiYzEyM1xuICpcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGUgaW5wdXQgVVJMIGRpcmVjdGx5IGFuZCBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcuXG4gKlxuICogVE9ETzogU2luY2Ugd2UgbmVlZCB0byB1c2UgYSBzZWFyY2ggcGFyYW0gYW55d2F5LCB3ZSBjb3VsZCBzaW1wbGlmeSBieSByZW1vdmluZyB0aGUgY3VzdG9tXG4gKiBoZWFkZXJzIGFwcHJvYWNoIGVudGlyZWx5IGFuZCBqdXN0IHVzZSBzZWFyY2ggcGFyYW1zLlxuICovXG5leHBvcnQgY29uc3Qgc2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0gPSAoXG4gIHVybDogVVJMLFxuICBoZWFkZXJzOiBSZXF1ZXN0SGVhZGVyc1xuKTogdm9pZCA9PiB7XG4gIGNvbnN0IHVuaXF1ZUNhY2hlS2V5ID0gaGV4SGFzaChcbiAgICBbXG4gICAgICBoZWFkZXJzW05FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl0gfHwgJzAnLFxuICAgICAgaGVhZGVyc1tORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUl0gfHwgJzAnLFxuICAgICAgaGVhZGVyc1tORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUl0sXG4gICAgICBoZWFkZXJzW05FWFRfVVJMXSxcbiAgICBdLmpvaW4oJywnKVxuICApXG5cbiAgLyoqXG4gICAqIE5vdGUgdGhhdCB3ZSBpbnRlbnRpb25hbGx5IGRvIG5vdCB1c2UgYHVybC5zZWFyY2hQYXJhbXMuc2V0YCBoZXJlOlxuICAgKlxuICAgKiBjb25zdCB1cmwgPSBuZXcgVVJMKCdodHRwczovL2V4YW1wbGUuY29tL3NlYXJjaD9xPWN1c3RvbSUyMHNwYWNpbmcnKTtcbiAgICogdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19yc2MnLCAnYWJjMTIzJyk7XG4gICAqIGNvbnNvbGUubG9nKHVybC50b1N0cmluZygpKTsgLy8gT3V0cHV0czogaHR0cHM6Ly9leGFtcGxlLmNvbS9zZWFyY2g/cT1jdXN0b20rc3BhY2luZyZfcnNjPWFiYzEyM1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXiA8LS0tIHRoaXMgaXMgY2F1c2luZyBjb25mdXNpb25cbiAgICogVGhpcyBpcyBpbiBmYWN0IGludGVuZGVkIGJhc2VkIG9uIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLXVybHNlYXJjaHBhcmFtcywgYnV0XG4gICAqIHdlIHdhbnQgdG8gcHJlc2VydmUgdGhlICUyMCBhcyAlMjAgaWYgdGhhdCdzIHdoYXQgdGhlIHVzZXIgcGFzc2VkIGluLCBoZW5jZSB0aGUgY3VzdG9tXG4gICAqIGxvZ2ljIGJlbG93LlxuICAgKi9cbiAgY29uc3QgZXhpc3RpbmdTZWFyY2ggPSB1cmwuc2VhcmNoXG4gIGNvbnN0IHJhd1F1ZXJ5ID0gZXhpc3RpbmdTZWFyY2guc3RhcnRzV2l0aCgnPycpXG4gICAgPyBleGlzdGluZ1NlYXJjaC5zbGljZSgxKVxuICAgIDogZXhpc3RpbmdTZWFyY2hcbiAgY29uc3QgcGFpcnMgPSByYXdRdWVyeS5zcGxpdCgnJicpLmZpbHRlcihCb29sZWFuKVxuICBwYWlycy5wdXNoKGAke05FWFRfUlNDX1VOSU9OX1FVRVJZfT0ke3VuaXF1ZUNhY2hlS2V5fWApXG4gIHVybC5zZWFyY2ggPSBwYWlycy5sZW5ndGggPyBgPyR7cGFpcnMuam9pbignJicpfWAgOiAnJ1xufVxuIl0sIm5hbWVzIjpbInNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtIiwidXJsIiwiaGVhZGVycyIsInVuaXF1ZUNhY2hlS2V5IiwiaGV4SGFzaCIsIk5FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUiIsIk5FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIiLCJORVhUX1VSTCIsImpvaW4iLCJleGlzdGluZ1NlYXJjaCIsInNlYXJjaCIsInJhd1F1ZXJ5Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwicGFpcnMiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJwdXNoIiwiTkVYVF9SU0NfVU5JT05fUVVFUlkiLCJsZW5ndGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"shouldHardNavigate\", ({\n    enumerable: true,\n    get: function() {\n        return shouldHardNavigate;\n    }\n}));\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js\");\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState) {\n    const [segment, parallelRoutes] = flightRouterState;\n    // TODO-APP: Check if `as` can be replaced.\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Check if current segment matches the existing segment.\n    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    const lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate((0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath), parallelRoutes[parallelRouteKey]);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=should-hard-navigate.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvc2hvdWxkLWhhcmQtbmF2aWdhdGUuanMiLCJtYXBwaW5ncyI6Ijs7OztzREFTZ0JBOzs7ZUFBQUE7OzsrQ0FKeUI7MkNBQ1o7QUFHdEIsU0FBU0EsbUJBQ2RDLGlCQUFpQyxFQUNqQ0MsaUJBQW9DO0lBRXBDLE1BQU0sQ0FBQ0MsU0FBU0MsZUFBZSxHQUFHRjtJQUNsQywyQ0FBMkM7SUFDM0MsTUFBTSxDQUFDRyxnQkFBZ0JDLGlCQUFpQixHQUFHTDtJQUszQyx5REFBeUQ7SUFDekQsSUFBSSxDQUFDTSxDQUFBQSxHQUFBQSxlQUFBQSxZQUFBQSxFQUFhRixnQkFBZ0JGLFVBQVU7UUFDMUMsa0dBQWtHO1FBQ2xHLElBQUlLLE1BQU1DLE9BQU8sQ0FBQ0osaUJBQWlCO1lBQ2pDLE9BQU87UUFDVDtRQUVBLHNFQUFzRTtRQUN0RSxPQUFPO0lBQ1Q7SUFDQSxNQUFNSyxjQUFjVCxrQkFBa0JVLE1BQU0sSUFBSTtJQUVoRCxJQUFJRCxhQUFhO1FBQ2YsT0FBTztJQUNUO0lBRUEsT0FBT1YsbUJBQ0xZLENBQUFBLEdBQUFBLG1CQUFBQSx3QkFBQUEsRUFBeUJYLG9CQUN6QkcsY0FBYyxDQUFDRSxpQkFBaUI7QUFFcEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxzaG91bGQtaGFyZC1uYXZpZ2F0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHREYXRhUGF0aCxcbiAgU2VnbWVudCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGggfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuaW1wb3J0IHsgbWF0Y2hTZWdtZW50IH0gZnJvbSAnLi4vbWF0Y2gtc2VnbWVudHMnXG5cbi8vIFRPRE8tQVBQOiBmbGlnaHRTZWdtZW50UGF0aCB3aWxsIGJlIGVtcHR5IGluIGNhc2Ugb2Ygc3RhdGljIHJlc3BvbnNlLCBuZWVkcyB0byBiZSBoYW5kbGVkLlxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZEhhcmROYXZpZ2F0ZShcbiAgZmxpZ2h0U2VnbWVudFBhdGg6IEZsaWdodERhdGFQYXRoLFxuICBmbGlnaHRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGVcbik6IGJvb2xlYW4ge1xuICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXNdID0gZmxpZ2h0Um91dGVyU3RhdGVcbiAgLy8gVE9ETy1BUFA6IENoZWNrIGlmIGBhc2AgY2FuIGJlIHJlcGxhY2VkLlxuICBjb25zdCBbY3VycmVudFNlZ21lbnQsIHBhcmFsbGVsUm91dGVLZXldID0gZmxpZ2h0U2VnbWVudFBhdGggYXMgW1xuICAgIFNlZ21lbnQsXG4gICAgc3RyaW5nLFxuICBdXG5cbiAgLy8gQ2hlY2sgaWYgY3VycmVudCBzZWdtZW50IG1hdGNoZXMgdGhlIGV4aXN0aW5nIHNlZ21lbnQuXG4gIGlmICghbWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgIC8vIElmIGR5bmFtaWMgcGFyYW1ldGVyIGluIHRyZWUgZG9lc24ndCBtYXRjaCB1cCB3aXRoIHNlZ21lbnQgcGF0aCBhIGhhcmQgbmF2aWdhdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFNlZ21lbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBleGlzdGluZyBzZWdtZW50IGRpZCBub3QgbWF0Y2ggc29mdCBuYXZpZ2F0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBjb25zdCBsYXN0U2VnbWVudCA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyXG5cbiAgaWYgKGxhc3RTZWdtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gc2hvdWxkSGFyZE5hdmlnYXRlKFxuICAgIGdldE5leHRGbGlnaHRTZWdtZW50UGF0aChmbGlnaHRTZWdtZW50UGF0aCksXG4gICAgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV1cbiAgKVxufVxuIl0sIm5hbWVzIjpbInNob3VsZEhhcmROYXZpZ2F0ZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJjdXJyZW50U2VnbWVudCIsInBhcmFsbGVsUm91dGVLZXkiLCJtYXRjaFNlZ21lbnQiLCJBcnJheSIsImlzQXJyYXkiLCJsYXN0U2VnbWVudCIsImxlbmd0aCIsImdldE5leHRGbGlnaHRTZWdtZW50UGF0aCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\n"))},"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts('/**\n * Entry point to the Segment Cache implementation.\n *\n * All code related to the Segment Cache lives `segment-cache-impl` directory.\n * Callers access it through this indirection.\n *\n * This is to ensure the code is dead code eliminated from the bundle if the\n * flag is disabled.\n *\n * TODO: This is super tedious. Since experimental flags are an essential part\n * of our workflow, we should establish a better pattern for dead code\n * elimination. Ideally it would be done at the bundler level, like how React\'s\n * build process works. In the React repo, you don\'t even need to add any extra\n * configuration per experiment — if the code is not reachable, it gets stripped\n * from the build automatically by Rollup. Or, shorter term, we could stub out\n * experimental modules at build time by updating the build config, i.e. a more\n * automated version of what I\'m doing manually in this file.\n */ \nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    NavigationResultTag: function() {\n        return NavigationResultTag;\n    },\n    PrefetchPriority: function() {\n        return PrefetchPriority;\n    },\n    cancelPrefetchTask: function() {\n        return cancelPrefetchTask;\n    },\n    createCacheKey: function() {\n        return createCacheKey;\n    },\n    getCurrentCacheVersion: function() {\n        return getCurrentCacheVersion;\n    },\n    navigate: function() {\n        return navigate;\n    },\n    prefetch: function() {\n        return prefetch;\n    },\n    reschedulePrefetchTask: function() {\n        return reschedulePrefetchTask;\n    },\n    revalidateEntireCache: function() {\n        return revalidateEntireCache;\n    },\n    schedulePrefetchTask: function() {\n        return schedulePrefetchTask;\n    }\n});\nconst notEnabled = ()=>{\n    throw Object.defineProperty(new Error(\'Segment Cache experiment is not enabled. This is a bug in Next.js.\'), "__NEXT_ERROR_CODE", {\n        value: "E654",\n        enumerable: false,\n        configurable: true\n    });\n};\nconst prefetch =  false ? 0 : notEnabled;\nconst navigate =  false ? 0 : notEnabled;\nconst revalidateEntireCache =  false ? 0 : notEnabled;\nconst getCurrentCacheVersion =  false ? 0 : notEnabled;\nconst schedulePrefetchTask =  false ? 0 : notEnabled;\nconst cancelPrefetchTask =  false ? 0 : notEnabled;\nconst reschedulePrefetchTask =  false ? 0 : notEnabled;\nconst createCacheKey =  false ? 0 : notEnabled;\nvar NavigationResultTag = /*#__PURE__*/ function(NavigationResultTag) {\n    NavigationResultTag[NavigationResultTag["MPA"] = 0] = "MPA";\n    NavigationResultTag[NavigationResultTag["Success"] = 1] = "Success";\n    NavigationResultTag[NavigationResultTag["NoOp"] = 2] = "NoOp";\n    NavigationResultTag[NavigationResultTag["Async"] = 3] = "Async";\n    return NavigationResultTag;\n}({});\nvar PrefetchPriority = /*#__PURE__*/ function(PrefetchPriority) {\n    /**\n   * Assigned to any visible link that was hovered/touched at some point. This\n   * is not removed on mouse exit, because a link that was momentarily\n   * hovered is more likely to to be interacted with than one that was not.\n   */ PrefetchPriority[PrefetchPriority["Intent"] = 2] = "Intent";\n    /**\n   * The default priority for prefetch tasks.\n   */ PrefetchPriority[PrefetchPriority["Default"] = 1] = "Default";\n    /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */ PrefetchPriority[PrefetchPriority["Background"] = 0] = "Background";\n    return PrefetchPriority;\n}({});\nif ((typeof exports.default === \'function\' || typeof exports.default === \'object\' && exports.default !== null) && typeof exports.default.__esModule === \'undefined\') {\n    Object.defineProperty(exports.default, \'__esModule\', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=segment-cache.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvc2VnbWVudC1jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkM7Ozs7Ozs7Ozs7OztJQWtGaUJBLG1CQUFtQjtlQUFuQkE7O0lBVUFDLGdCQUFnQjtlQUFoQkE7O0lBeENMQyxrQkFBa0I7ZUFBbEJBOztJQWtCQUMsY0FBYztlQUFkQTs7SUFwQ0FDLHNCQUFzQjtlQUF0QkE7O0lBaEJBQyxRQUFRO2VBQVJBOztJQVBBQyxRQUFRO2VBQVJBOztJQWtEQUMsc0JBQXNCO2VBQXRCQTs7SUFwQ0FDLHFCQUFxQjtlQUFyQkE7O0lBa0JBQyxvQkFBb0I7ZUFBcEJBOzs7QUF0Q2IsTUFBTUMsYUFBa0I7SUFDdEIsTUFBTSxxQkFFTCxDQUZLLElBQUlDLE1BQ1IsdUVBREk7ZUFBQTtvQkFBQTtzQkFBQTtJQUVOO0FBQ0Y7QUFFTyxNQUFNTCxXQUNYTSxNQUF1QyxHQUNuQyxDQUVDLEdBQ0RGO0FBRUMsTUFBTUwsV0FDWE8sTUFBdUMsR0FDbkMsQ0FFQyxHQUNERjtBQUVDLE1BQU1GLHdCQUNYSSxNQUF1QyxHQUNuQyxDQUlDLEdBQ0RGO0FBRUMsTUFBTU4seUJBQ1hRLE1BQXVDLEdBQ25DLENBSUMsR0FDREY7QUFFQyxNQUFNRCx1QkFDWEcsTUFBdUMsR0FDbkMsQ0FJQyxHQUNERjtBQUVDLE1BQU1SLHFCQUNYVSxNQUF1QyxHQUNuQyxDQUlDLEdBQ0RGO0FBRUMsTUFBTUgseUJBQ1hLLE1BQXVDLEdBQ25DLENBSUMsR0FDREY7QUFFQyxNQUFNUCxpQkFDWFMsTUFBdUMsR0FDbkMsQ0FFQyxHQUNERjtBQU9DLElBQVdWLHNCQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxtQkFBQUE7Ozs7O1dBQUFBOztBQVVYLElBQVdDLG1CQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxnQkFBQUE7SUFDaEI7Ozs7R0FJQztJQUVEOztHQUVDO0lBRUQ7OztHQUdDO1dBZGVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxzZWdtZW50LWNhY2hlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRW50cnkgcG9pbnQgdG8gdGhlIFNlZ21lbnQgQ2FjaGUgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQWxsIGNvZGUgcmVsYXRlZCB0byB0aGUgU2VnbWVudCBDYWNoZSBsaXZlcyBgc2VnbWVudC1jYWNoZS1pbXBsYCBkaXJlY3RvcnkuXG4gKiBDYWxsZXJzIGFjY2VzcyBpdCB0aHJvdWdoIHRoaXMgaW5kaXJlY3Rpb24uXG4gKlxuICogVGhpcyBpcyB0byBlbnN1cmUgdGhlIGNvZGUgaXMgZGVhZCBjb2RlIGVsaW1pbmF0ZWQgZnJvbSB0aGUgYnVuZGxlIGlmIHRoZVxuICogZmxhZyBpcyBkaXNhYmxlZC5cbiAqXG4gKiBUT0RPOiBUaGlzIGlzIHN1cGVyIHRlZGlvdXMuIFNpbmNlIGV4cGVyaW1lbnRhbCBmbGFncyBhcmUgYW4gZXNzZW50aWFsIHBhcnRcbiAqIG9mIG91ciB3b3JrZmxvdywgd2Ugc2hvdWxkIGVzdGFibGlzaCBhIGJldHRlciBwYXR0ZXJuIGZvciBkZWFkIGNvZGVcbiAqIGVsaW1pbmF0aW9uLiBJZGVhbGx5IGl0IHdvdWxkIGJlIGRvbmUgYXQgdGhlIGJ1bmRsZXIgbGV2ZWwsIGxpa2UgaG93IFJlYWN0J3NcbiAqIGJ1aWxkIHByb2Nlc3Mgd29ya3MuIEluIHRoZSBSZWFjdCByZXBvLCB5b3UgZG9uJ3QgZXZlbiBuZWVkIHRvIGFkZCBhbnkgZXh0cmFcbiAqIGNvbmZpZ3VyYXRpb24gcGVyIGV4cGVyaW1lbnQg4oCUIGlmIHRoZSBjb2RlIGlzIG5vdCByZWFjaGFibGUsIGl0IGdldHMgc3RyaXBwZWRcbiAqIGZyb20gdGhlIGJ1aWxkIGF1dG9tYXRpY2FsbHkgYnkgUm9sbHVwLiBPciwgc2hvcnRlciB0ZXJtLCB3ZSBjb3VsZCBzdHViIG91dFxuICogZXhwZXJpbWVudGFsIG1vZHVsZXMgYXQgYnVpbGQgdGltZSBieSB1cGRhdGluZyB0aGUgYnVpbGQgY29uZmlnLCBpLmUuIGEgbW9yZVxuICogYXV0b21hdGVkIHZlcnNpb24gb2Ygd2hhdCBJJ20gZG9pbmcgbWFudWFsbHkgaW4gdGhpcyBmaWxlLlxuICovXG5cbmV4cG9ydCB0eXBlIHsgTmF2aWdhdGlvblJlc3VsdCB9IGZyb20gJy4vc2VnbWVudC1jYWNoZS1pbXBsL25hdmlnYXRpb24nXG5leHBvcnQgdHlwZSB7IFByZWZldGNoVGFzayB9IGZyb20gJy4vc2VnbWVudC1jYWNoZS1pbXBsL3NjaGVkdWxlcidcblxuY29uc3Qgbm90RW5hYmxlZDogYW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ1NlZ21lbnQgQ2FjaGUgZXhwZXJpbWVudCBpcyBub3QgZW5hYmxlZC4gVGhpcyBpcyBhIGJ1ZyBpbiBOZXh0LmpzLidcbiAgKVxufVxuXG5leHBvcnQgY29uc3QgcHJlZmV0Y2g6IHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL3ByZWZldGNoJykucHJlZmV0Y2ggPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9wcmVmZXRjaCcpLnByZWZldGNoKC4uLmFyZ3MpXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCBuYXZpZ2F0ZTogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvbmF2aWdhdGlvbicpLm5hdmlnYXRlID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgPyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvbmF2aWdhdGlvbicpLm5hdmlnYXRlKC4uLmFyZ3MpXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCByZXZhbGlkYXRlRW50aXJlQ2FjaGU6IHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL2NhY2hlJykucmV2YWxpZGF0ZUVudGlyZUNhY2hlID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgPyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvY2FjaGUnKS5yZXZhbGlkYXRlRW50aXJlQ2FjaGUoXG4gICAgICAgICAgLi4uYXJnc1xuICAgICAgICApXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCBnZXRDdXJyZW50Q2FjaGVWZXJzaW9uOiB0eXBlb2YgaW1wb3J0KCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9jYWNoZScpLmdldEN1cnJlbnRDYWNoZVZlcnNpb24gPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9jYWNoZScpLmdldEN1cnJlbnRDYWNoZVZlcnNpb24oXG4gICAgICAgICAgLi4uYXJnc1xuICAgICAgICApXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCBzY2hlZHVsZVByZWZldGNoVGFzazogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykuc2NoZWR1bGVQcmVmZXRjaFRhc2sgPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9zY2hlZHVsZXInKS5zY2hlZHVsZVByZWZldGNoVGFzayhcbiAgICAgICAgICAuLi5hcmdzXG4gICAgICAgIClcbiAgICAgIH1cbiAgICA6IG5vdEVuYWJsZWRcblxuZXhwb3J0IGNvbnN0IGNhbmNlbFByZWZldGNoVGFzazogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykuY2FuY2VsUHJlZmV0Y2hUYXNrID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgPyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykuY2FuY2VsUHJlZmV0Y2hUYXNrKFxuICAgICAgICAgIC4uLmFyZ3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIDogbm90RW5hYmxlZFxuXG5leHBvcnQgY29uc3QgcmVzY2hlZHVsZVByZWZldGNoVGFzazogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykucmVzY2hlZHVsZVByZWZldGNoVGFzayA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRVxuICAgID8gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJy4vc2VnbWVudC1jYWNoZS1pbXBsL3NjaGVkdWxlcicpLnJlc2NoZWR1bGVQcmVmZXRjaFRhc2soXG4gICAgICAgICAgLi4uYXJnc1xuICAgICAgICApXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDYWNoZUtleTogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvY2FjaGUta2V5JykuY3JlYXRlQ2FjaGVLZXkgPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9jYWNoZS1rZXknKS5jcmVhdGVDYWNoZUtleSguLi5hcmdzKVxuICAgICAgfVxuICAgIDogbm90RW5hYmxlZFxuXG4vKipcbiAqIEJlbG93IGFyZSBwdWJsaWMgY29uc3RhbnRzLiBUaGV5J3JlIHNtYWxsIGVub3VnaCB0aGF0IHdlIGRvbid0IG5lZWQgdG9cbiAqIERDRSB0aGVtLlxuICovXG5cbmV4cG9ydCBjb25zdCBlbnVtIE5hdmlnYXRpb25SZXN1bHRUYWcge1xuICBNUEEsXG4gIFN1Y2Nlc3MsXG4gIE5vT3AsXG4gIEFzeW5jLFxufVxuXG4vKipcbiAqIFRoZSBwcmlvcml0eSBvZiB0aGUgcHJlZmV0Y2ggdGFzay4gSGlnaGVyIG51bWJlcnMgYXJlIGhpZ2hlciBwcmlvcml0eS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gUHJlZmV0Y2hQcmlvcml0eSB7XG4gIC8qKlxuICAgKiBBc3NpZ25lZCB0byBhbnkgdmlzaWJsZSBsaW5rIHRoYXQgd2FzIGhvdmVyZWQvdG91Y2hlZCBhdCBzb21lIHBvaW50LiBUaGlzXG4gICAqIGlzIG5vdCByZW1vdmVkIG9uIG1vdXNlIGV4aXQsIGJlY2F1c2UgYSBsaW5rIHRoYXQgd2FzIG1vbWVudGFyaWx5XG4gICAqIGhvdmVyZWQgaXMgbW9yZSBsaWtlbHkgdG8gdG8gYmUgaW50ZXJhY3RlZCB3aXRoIHRoYW4gb25lIHRoYXQgd2FzIG5vdC5cbiAgICovXG4gIEludGVudCA9IDIsXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBwcmlvcml0eSBmb3IgcHJlZmV0Y2ggdGFza3MuXG4gICAqL1xuICBEZWZhdWx0ID0gMSxcbiAgLyoqXG4gICAqIEFzc2lnbmVkIHRvIHRhc2tzIHdoZW4gdGhleSBzcGF3biBub24tYmxvY2tpbmcgYmFja2dyb3VuZCB3b3JrLCBsaWtlXG4gICAqIHJldmFsaWRhdGluZyBhIHBhcnRpYWxseSBjYWNoZWQgZW50cnkgdG8gc2VlIGlmIG1vcmUgZGF0YSBpcyBhdmFpbGFibGUuXG4gICAqL1xuICBCYWNrZ3JvdW5kID0gMCxcbn1cbiJdLCJuYW1lcyI6WyJOYXZpZ2F0aW9uUmVzdWx0VGFnIiwiUHJlZmV0Y2hQcmlvcml0eSIsImNhbmNlbFByZWZldGNoVGFzayIsImNyZWF0ZUNhY2hlS2V5IiwiZ2V0Q3VycmVudENhY2hlVmVyc2lvbiIsIm5hdmlnYXRlIiwicHJlZmV0Y2giLCJyZXNjaGVkdWxlUHJlZmV0Y2hUYXNrIiwicmV2YWxpZGF0ZUVudGlyZUNhY2hlIiwic2NoZWR1bGVQcmVmZXRjaFRhc2siLCJub3RFbmFibGVkIiwiRXJyb3IiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwiYXJncyIsInJlcXVpcmUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\n'))},"(app-pages-browser)/./node_modules/next/dist/client/components/unauthorized.js":(module,exports,__webpack_require__)=>{eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "unauthorized", ({\n    enumerable: true,\n    get: function() {\n        return unauthorized;\n    }\n}));\nconst _httpaccessfallback = __webpack_require__(/*! ./http-access-fallback/http-access-fallback */ "(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js");\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */ const DIGEST = "" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ";401";\nfunction unauthorized() {\n    if (true) {\n        throw Object.defineProperty(new Error("`unauthorized()` is experimental and only allowed to be used when `experimental.authInterrupts` is enabled."), "__NEXT_ERROR_CODE", {\n            value: "E411",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // eslint-disable-next-line no-throw-literal\n    const error = Object.defineProperty(new Error(DIGEST), "__NEXT_ERROR_CODE", {\n        value: "E394",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = DIGEST;\n    throw error;\n}\nif ((typeof exports.default === \'function\' || typeof exports.default === \'object\' && exports.default !== null) && typeof exports.default.__esModule === \'undefined\') {\n    Object.defineProperty(exports.default, \'__esModule\', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unauthorized.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvdW5hdXRob3JpemVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Z0RBc0JnQkE7OztlQUFBQTs7O2dEQW5CVDtBQUVQLGdDQUFnQztBQUNoQzs7Ozs7Ozs7Ozs7O0NBWUMsR0FFRCxNQUFNQyxTQUFVLEtBQUVDLG9CQUFBQSw4QkFBOEIsR0FBQztBQUUxQyxTQUFTRjtJQUNkLElBQUksSUFBZ0QsRUFBRTtRQUNwRCxNQUFNLHFCQUVMLENBRkssSUFBSU0sTUFDUCxnSEFERzttQkFBQTt3QkFBQTswQkFBQTtRQUVOO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsTUFBTUMsUUFBUSxxQkFBaUIsQ0FBakIsSUFBSUQsTUFBTUwsU0FBVjtlQUFBO29CQUFBO3NCQUFBO0lBQWdCO0lBQzVCTSxNQUFrQ0MsTUFBTSxHQUFHUDtJQUM3QyxNQUFNTTtBQUNSIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDFcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFx1bmF1dGhvcml6ZWQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSFRUUF9FUlJPUl9GQUxMQkFDS19FUlJPUl9DT0RFLFxuICB0eXBlIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yLFxufSBmcm9tICcuL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2h0dHAtYWNjZXNzLWZhbGxiYWNrJ1xuXG4vLyBUT0RPOiBBZGQgYHVuYXV0aG9yaXplZGAgZG9jc1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gcmVuZGVyIHRoZSBbdW5hdXRob3JpemVkLmpzIGZpbGVdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2ZpbGUtY29udmVudGlvbnMvdW5hdXRob3JpemVkKVxuICogd2l0aGluIGEgcm91dGUgc2VnbWVudCBhcyB3ZWxsIGFzIGluamVjdCBhIHRhZy5cbiAqXG4gKiBgdW5hdXRob3JpemVkKClgIGNhbiBiZSB1c2VkIGluXG4gKiBbU2VydmVyIENvbXBvbmVudHNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zZXJ2ZXItY29tcG9uZW50cyksXG4gKiBbUm91dGUgSGFuZGxlcnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvcm91dGUtaGFuZGxlcnMpLCBhbmRcbiAqIFtTZXJ2ZXIgQWN0aW9uc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vZGF0YS1mZXRjaGluZy9zZXJ2ZXItYWN0aW9ucy1hbmQtbXV0YXRpb25zKS5cbiAqXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBEb2NzOiBgdW5hdXRob3JpemVkYF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3VuYXV0aG9yaXplZClcbiAqL1xuXG5jb25zdCBESUdFU1QgPSBgJHtIVFRQX0VSUk9SX0ZBTExCQUNLX0VSUk9SX0NPREV9OzQwMWBcblxuZXhwb3J0IGZ1bmN0aW9uIHVuYXV0aG9yaXplZCgpOiBuZXZlciB7XG4gIGlmICghcHJvY2Vzcy5lbnYuX19ORVhUX0VYUEVSSU1FTlRBTF9BVVRIX0lOVEVSUlVQVFMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgXFxgdW5hdXRob3JpemVkKClcXGAgaXMgZXhwZXJpbWVudGFsIGFuZCBvbmx5IGFsbG93ZWQgdG8gYmUgdXNlZCB3aGVuIFxcYGV4cGVyaW1lbnRhbC5hdXRoSW50ZXJydXB0c1xcYCBpcyBlbmFibGVkLmBcbiAgICApXG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihESUdFU1QpIGFzIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yXG4gIDsoZXJyb3IgYXMgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3IpLmRpZ2VzdCA9IERJR0VTVFxuICB0aHJvdyBlcnJvclxufVxuIl0sIm5hbWVzIjpbInVuYXV0aG9yaXplZCIsIkRJR0VTVCIsIkhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfRVhQRVJJTUVOVEFMX0FVVEhfSU5URVJSVVBUUyIsIkVycm9yIiwiZXJyb3IiLCJkaWdlc3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/unauthorized.js\n'))}}]);